// RcBridgeRebar.cpp: implementation of the CRcBridgeRebar class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ARcBridgeData.h"


#define MAKE_RATE m_nTypeAddRate==0 ? ((pRB->m_dDia>m_dAddRateDiaOrg) ? 1+m_dAddRateUpper/100 : 1+m_dAddRateLower/100) : (pRB->m_bMainRebar ? 1+m_dAddRateLower/100 : 1+m_dAddRateUpper/100)
#define MAKE_RATE1 (pRB->m_dDia>=22) ? 1.06 : 1.03


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
////////////////////////////////////////////////////////////////////// 
CRcBridgeRebar::CRcBridgeRebar()
{
	long stt(0), left(0);


	m_nFlag	= 0;
	m_bRoundAtEdgeRebar					= TRUE;
	m_nIdxCTC_MainRebar					= 1;
	m_dCTC_MainRebar					= 250;	// index방식에서 double형으로 변경 index는 사용하지 않음(2005.04.25)
	for(left = 0; left < 2; left++)
		m_nCountWrapShearRebar_StirrupRebar_ConnectSection[left]	= 0;

	m_nIdxCTC_SupportAndShearRebar		= 1;
	m_dCTC_SupportRebar[iUPPER]			= 300;		// index에서 double로 변경(2005.04.25)
	m_dCTC_SupportRebar[iLOWER]			= 300;
	m_dCTC_ShearRebar[iUPPER]			= 600;
	m_dCTC_ShearRebar[iLOWER]			= 600;
	m_dCTC_SupportRebarOutWall[0]		= 300;
	m_dCTC_SupportRebarOutWall[1]		= 300;
	m_dCTC_ShearRebarOutWall[0]			= 600;
	m_dCTC_ShearRebarOutWall[1]			= 600;
	m_dCTC_ShearRebarBracket			= 250;
	for(stt = 0; stt < 2; stt++)
	{
		for(left = 0; left < 2; left++)
		{
			m_dDistGirderRebarJong[left][stt]	= 0;					// 좌우측 종거더 설치위치([iLEFT][iSTT])
		}
	}
	m_bSameOffsetPlaceTAndCBlock		= FALSE;	// 인장 압축구간을 동일 간격으로 배치

	long upper = 0; for(upper = 0; upper < 2; upper++)
	{
		long i = 0; for(i = 0; i < MAX_JIJUM_COUNT_RC; i++)
		{
			long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
			{
				m_nCountJointMainRebar_UpperSlab_Cycle1[i][upper][dan]	= 2;
				m_nCountJointMainRebar_UpperSlab_Cycle2[i][upper][dan]	= 2;
				m_nCountJointMainRebar_LowerSlab_Cycle1[i][upper][dan]	= 2;
				m_nCountJointMainRebar_LowerSlab_Cycle2[i][upper][dan]	= 2;
			}
		}
	}

	for(stt = 0; stt < 2; stt++)
	{
		for(long inner = 0; inner < 2; inner++)
		{
			long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
			{
				m_nCountJointMainRebar_OutWall_Cycle1[stt][inner][dan]	= 2;
				m_nCountJointMainRebar_OutWall_Cycle2[stt][inner][dan]	= 2;
			}
		}
	}

	for(upper = 0; upper < 2; upper++)
	{
		long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
		{
			m_nCountJointMainRebar_ArchRib_Cycle1[upper][dan]	= 2;	// 리브 상하면,1~3단 이음 개수(리브만 특별히 각 단에 대해서 이음을 입력받음)
			m_nCountJointMainRebar_ArchRib_Cycle2[upper][dan]	= 2;	// 리브 상하면,1~3단 이음 개수(리브만 특별히 각 단에 대해서 이음을 입력받음)
		}
	}

	// 철근배치 옵션
	m_bDetailInput23DanMainRebar				= FALSE;		// 2,3단 주철근을 2Cycle 1단 입력하듯이 세부적으로 조정해서 입력 할 수 잇게 한다.
	m_bExtendShearRebarToHunchRebar		= FALSE;		// 상부슬래브 전단철근을 헌치철근까지 연장할지?(기존값:TRUE -> FALSE 변경)
	m_bExtendShearRebarBoHunchRebar		= FALSE;		// 하부슬래브 전단철근 헌치철근까지 연장(기본 FALSE) ARCBRIDGE-2789
	m_bPlacingOutWallInnerRebar[iSTT]			= TRUE;		// 시 종점외측벽체 내측철근 배치
	m_bPlacingOutWallInnerRebar[iEND]			= TRUE;		// 시 종점외측벽체 내측철근 배치
	m_bPlacingInWallRebarOfCycle24				= TRUE;		// 중간벽체 철근 배치
	m_bBendingDanBuRebar						= FALSE;		// 단 절점부 철근 구부려서 배치
	m_bPlacingStirrupAtDanBuRebar				= TRUE;		// 단 절점부 ROUND부에 스트럽 배치
	m_bPlacingSupportAtHunchRebar			= TRUE;		// 헌치철근위에 배력철근 배치
	m_bPlacingSupportAtDanBuRebar			= TRUE;		// 단 절점부 ROUND부에 배력철근 배치
	m_bPlacing23DanByStandardOffset			= FALSE;		// 2,3단 철근을 표준배치간격으로 배치
	m_nCountWrapMainRebarUpperSlab		= 4;			// 주철근을 감싸는 개수
	m_nCountWrapMainRebarLowerSlab			= 4;
	m_nCountWrapMainRebarForOutWall[0]		= 4;			// 시종점 외측벽체 전단철근이 주철근 구간 감싸는 개수
	m_nCountWrapMainRebarForOutWall[1]		= 4;			// 시종점 외측벽체 전단철근이 주철근 구간 감싸는 개수
	m_nCountWrapMainRebarForInWall			= 4;			// 중간벽체 전단철근이 주철근을 감싸는 개수
	m_nCountWrapMainRebarForBracket[0]		= 4;			// 브라켓 전단철근이 주철근 구간 감싸는 개수
	m_nCountWrapMainRebarForBracket[1]		= 4;			// 브라켓 전단철근이 주철근 구간 감싸는 개수
	m_nCountWrapMainRebarForArchRib		= 4;			// 리브 전단철근이 주철근 구간 감싸는 개수
	m_nCountWrapMainRebarForFootingLean	= 4;
	m_nCountWrapMainRebarForFootingPile	= 4;


	m_nTypeDefaultCycle3_OutRebar				= 2;			// 주철근 cycle3 권고안 방법(외측철근 : 상부슬래브 상면, 외측철근 외측면)
	m_nTypeDefaultCycle3_UpperSlabLower		= 2;			// 주철근 cycle3 권고안 방법(상 부슬래브 하면)
	m_nTypeDefaultCycle3_OutWallInner			= 2;			// 주철근 cycle3 권고안 방법(외측벽체 내측면)
	m_nTypeDefaultCycle3_ArchRib				= 2;
	m_nTypeCurveOfWallVertRebar				= 0;			// 벽체 수직철근 절곡부 타입(0 : 자동, 1 : 곡선, 2 : 직각)
	m_nTypeStandardCTCRebarMain				= 0;			// 주철근 ctc 기준(0 : 상부슬래브, 1 : 시점벽체)
	m_bRemoveShearRebarAtSlabYundan		= FALSE;		// 슬래브 연단 전단철근 제거
	m_nTypeCouplerColumnMainRebar			= 0;			// 기둥 주철근 커플러? 겹이음. 
	m_bApplySameSupportRebar					= TRUE;
	m_bApplySameMainRebar						= TRUE;		// 상하행 주철근관련 입력 동일 적용


	// 단부 스터럽 철근 직경
	for(long iUD=iUPPER; iUD<=iLOWER; iUD++)
	{
		for(stt = 0; stt < 2; stt++)
		{
			m_dDiaStirrupAtDanBuRebar[iUD][stt]	= 19;		// 단부 스터럽 철근 직경 (시종점)
			m_nCountStirrupAtDanBuRebar[iUD][stt] = 2;		// 단부 스터럽 철근 개수 (시종점)
			m_nCountStirrupCtcMainRebar[iUD][stt] = 4;		//
		}
	}


	// 가각부 배근
	for(stt = 0; stt < 2; stt++)
	{
		for(left = 0; left < 2; left++)
		{
			m_nTypeRebarMainRebarOfExp[stt][left]	= 0;
			m_nTypeOrgMainRebarOfExp[stt][left]	= 1;
			m_dLenMainRebarOfExp[stt][left]		= 1;				// 가각부 배근시 가각부와 좌우측라인과의 교차점에서 주철근이 뻗어 나가는 거리

			m_bLineDirRebarOfExp[stt][left]	= FALSE;				// 가각 철근이 선형방향으로 배치될지?
			m_nCountSupportRebarOfExpAtLineDirRebar[stt][left]	= 1;	// 가각 철근이 선형방향으로 배치될때 기존 보강철근은 몇개가 배치될지
		}
	}

	// 사보강배치일때 사방향배치가 적용되는 구간 거리
	m_dDistSttJijumDirPlacing[0]			= 0;			// 시점각도방향으로 배치되는 배력철근의 배치구간거리(시점에서부터의 거리)
	m_dDistEndJijumDirPlacing[0]			= 0;			// 종점각도방향으로 배치된는 배력철근의 배치구간거리(종점에서부터의 거리)
	m_dDistSttJijumDirPlacing[1]			= 0;			// 시점각도방향으로 배치되는 배력철근의 배치구간거리(시점에서부터의 거리)
	m_dDistEndJijumDirPlacing[1]			= 0;			// 종점각도방향으로 배치된는 배력철근의 배치구간거리(종점에서부터의 거리)
	// 주철근
	m_dDistLeftDirPlacing				= 0;			// 좌측면 각도 방향으로 배치되는 주철근의 배치구간거리(시점에서부터의 거리)
	m_dDistRightDirPlacing				= 0;			// 우측면 각도 방향으로 배치되는 주철근의 배치구간거리(종점에서부터의 거리)

	for(long iUD=iUPPER; iUD<=iLOWER; iUD++)
	{
		for(stt = 0; stt < 2; stt++)
		{
			// 단절점부 철근
			m_bIsDanbuRebar_Cycle1[iUD][stt]	= FALSE;					// 2 : 시종점(시점상단, 종점상단)	- 설치여부.
			m_bIsDanbuRebar_Cycle2[iUD][stt]	= FALSE;					// 2 : 시종점(시점상단, 종점상단) - 설치여부.
			long dan = 0; for(dan = 0; dan < 3; dan++)
			{
				m_dDia_DanbuRebar_Cycle1[iUD][stt][dan]	= 25;	// 2 : 시종점(시점상단, 종점상단) - 지름
				m_dDia_DanbuRebar_Cycle2[iUD][stt][dan]	= 25;			// 2 : 시종점(시점상단, 종점상단) - 지름
			}
		}
	}
	
	m_dDanCorner_UpperSlab[0] = 0.4;			// 단절점부 상부슬래브
	m_dDanCorner_LowerSlab[0] = 0.4;			// 단절점부 하부슬래브
	m_dDanCorner_UpperSlab[1] = 0.5;			// 단절점부 상부슬래브
	m_dDanCorner_LowerSlab[1] = 0.5;			// 단절점부 하부슬래브
	m_dDanCorner_UpperSlab[2] = 0.6;			// 단절점부 상부슬래브
	m_dDanCorner_LowerSlab[2] = 0.6;			// 단절점부 하부슬래브

	m_dDanCorner_UpperVert = 0.3; 
	m_dDanCorner_LowerVert = 0.3; 
	m_bUpperSlab_CornerCurve = TRUE;
	m_bLowerSlab_CornerCurve = TRUE;

	m_nType_DanbuRebar = 0;

	m_nTypePlacingSupportRebar_UpperSlab	= 2;
	m_nTypePlacingMainRebar_UpperSlab		= 0;
	m_nTypePlacingMainRebar_Footing			= 1;		// 기초 주철근 배치 타입(0 : 선형방향, 1 : 사보강, 2 : 사보강(구간추가)
	for(stt = 0; stt < 2 ; stt++)
	{
		m_dRangeSupportRebarForSameUpperSlab[stt]	= 0;
		m_placeByBlock_SupportRebarAddSameUpperSlab[stt].m_xyArr.RemoveAll();	// 상부슬래브 처럼 꺽을 배력근이 추가될 범위
		m_placeByBlock_SupportRebarAddSameUpperSlab[stt].m_xyArr.Add(CDPoint(0, 0));
		m_placeByBlock_SupportRebarAddSameUpperSlab[stt].m_nCountBlock	= 1;
		for(left = 0; left < 2; left++)
			m_dDistAddSupportRebarForSameUpperSlab[stt][left]	= 0;	// 상부슬래브 처럼 꺽을 추가되는 배력근의 좌우측 거리
	}
	m_nTypeSideRebarMain_UpperSlabSabogang	= 1;		// 사보강 배치시 좌우측 주철근 타입(0 : 직선, 1 : 선형따라)
	m_bFixOutSideMainRebarBy1Cyle			= FALSE;			// 최외측 주철근 1cycle로 고정(2, 4사이클일 경우 적용) - 벽체 기초, 슬래브 모두 적용

	// 아치리브 하면 배력근 치수 정밀도.
	m_dAccuracyArchRibLowerSupportDim	= 0;

	// 브라켓철근
	for(stt = 0; stt < 2; stt++)
	{
		m_dDiaRebarMain_Bracket_Cycle1[stt]	= 19;
		m_dDiaRebarMain_Bracket_Cycle2[stt]	= 19;
		m_dDiaRebarSupport_Bracket[stt]	= 19;
		// m_dDiaRebarShear_Bracket_XXX[stt]	= 19;
		m_RebarShearDetail_Bracket[stt].m_dDia = 19;
		m_RebarShearDetail_Bracket[stt].m_nType = TYPE_SHEAR_DIGUT_BEND;
	}

	// 상부슬래브 둔각부 보강
	for(stt = 0; stt < 2; stt++)
	{
		for(left = 0; left < 2; left++)
		{
			m_bIsObtuseAngle_UpperSlab[stt][left]	= FALSE;	// 시종점, 좌우측
			for(upper = 0; upper < 2; upper++)
			{
				m_dCoverObtuseAngle_UpperSlab_Plane[stt][left][upper]	= 200;	// 시종점, 좌우측, 0:종방향,1:횡방향
				m_dCoverObtuseAngle_UpperSlab[stt][left][upper]			= 200;	// 시종점, 좌우측, 상하면피복
				m_dLenObtuseAngle_UpperSlab[stt][left][upper]			= 1000;	// 시종점, 좌우측, 상하면 철근 길이
			}
			m_dLenObtuseAngle_OutWall[stt][left]			=1000;			// 시종점, 좌우측 상면 철근 벽체방향 길이
			m_dDiaObtuseAngle_UpperSlabLower_XXX			= 0;		// 선형방향 하면 보강철근 직경
			m_dDiaObtuseAngle_UpperSlabLower[stt][left]		= 19;		// 선형방향 하면 보강철근 직경
			for(upper = 0; upper < 2; upper++)
			{
				m_rebarInfoCycle_ObtuseAngle_Upperslab[stt][left][upper].InitInfoCycle();		// 시종점, 좌우측, 상하면 
			}
		}
	}

	// 하부슬래브 둔각부 보강
	for(stt = 0; stt < 2; stt++)
	{
		for(left = 0; left < 2; left++)
		{
			m_bIsObtuseAngle_LowerSlab[stt][left]	= FALSE;	// 시종점, 좌우측
			for(upper = 0; upper < 2; upper++)
			{
				m_dCoverObtuseAngle_LowerSlab_Plane[stt][left][upper]	= 200;	// 시종점, 좌우측, 0:종방향,1:횡방향
				m_dCoverObtuseAngle_LowerSlab[stt][left][upper]			= 200;	// 시종점, 좌우측, 상하면피복
				m_dLenObtuseAngle_LowerSlab[stt][left][upper]			= 1000;	// 시종점, 좌우측, 상하면 철근 길이
			}
			m_dLenObtuseAngle_LowerOutWall[stt][left]			=1000;			// 시종점, 좌우측 상면 철근 벽체방향 길이
			for(upper = 0; upper < 2; upper++)
			{
				m_rebarInfoCycle_ObtuseAngle_Lowerslab[stt][left][upper].InitInfoCycle();		// 시종점, 좌우측, 상하면 
			}
		}
	}

	// 시종점벽체 예각부
	for(stt = 0; stt < 2; stt++)
	{
		for(left = 0; left < 2; left++)
		{
			m_bIsAcuteAngle_OutWall[stt][left]				= FALSE;;	// 시종점 좌우측 벽체 예각부 설치 여부
			for(upper = 0; upper < 2; upper++)
			{
				m_dCoverAcuteAngle_OutWall[stt][left][upper]	= 200;	// 벽체 예각부 피복(시종점,좌우측,상하면)
			}
			m_rebarInfoCycle_AcuteAngle_OutWall[stt][left].InitInfoCycle();	// 벽체 예각부 철근
			m_dLenAcuteangle_OutWall[stt][left]		= 1000;	// 벽체 예각부 철근길이(시종점,좌우측,상하면)
			m_dRange_AcuteAngle_OutWall[stt][left]	= 3000;
		}
	}



	// 교명주 받침 철근 제원
	AhTPADelete(&m_pArrRebarMonument, (CRebar*)0);
	AhTPAMake(MO_REBAR_COUNT, &m_pArrRebarMonument, (CRebar*)0);

	m_Util.SetRebarType();

	// 평면 주철근, 배력근을 모두 미리 구해놓자.(철근마크할때 또 쓰기 때문에)
	m_bCaledRebarMain_Plane		= FALSE;
	m_bCaledRebarSupport_Plane	= FALSE;

	for(stt = 0; stt < 2; stt++)
	{
		for(left = 0; left < 2; left++)
		{
			m_bIsObtuseAngle_UpperSlab[stt][left]	= FALSE;	// 시종점, 좌우측
		}
	}


	m_dGapJoint	= -36;

	m_Util.m_pRcBridgeApp	= dynamic_cast<CRcBridgeApp*>(this);
}

CRcBridgeRebar::~CRcBridgeRebar()
{
	long dan(0), upper(0), stt(0), inner(0), cycle(0);
	// CYCLE1~4 ///////////////////////////////////////////////////////////////
	// CRebarInfoCycle
	for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
	{
		for(dan = 0; dan < 3; dan++)
		{
			for(upper = 0; upper < 2; upper++)
			{
				AhTPADelete(&m_pArrRCMainUpperSlab[cycle][upper][dan], (CRebarInfoCycle*)0);
				AhTPADelete(&m_pArrRCMainLowerSlab[cycle][upper][dan], (CRebarInfoCycle*)0);
				AhTPADelete(&m_pArrRCMainRib[cycle][upper][dan], (CRebarInfoCycle*)0);
			}

			for(stt = 0; stt < 2; stt++)
			{
				for(inner = 0; inner < 2; inner++)
				{
					AhTPADelete(&m_pArrRCMainOutWall[cycle][stt][inner][dan], (CRebarInfoCycle*)0);
				}	
			}
		}
		AhTPADelete(&m_pArrRCMainUpperSlabHunch[cycle], (CRebarInfoCycle*)0);
		AhTPADelete(&m_pArrRCMainLowerSlabHunch[cycle], (CRebarInfoCycle*)0);
	}

	for(stt = 0; stt < 2; stt++)
	{
		AhTPADelete(&m_pArrRCMainOutWallBracket_Cycle1[stt], (CRebarInfoCycle*)0);
		AhTPADelete(&m_pArrRCMainOutWallBracket_Cycle2[stt], (CRebarInfoCycle*)0);
		AhTPADelete(&m_pArrRCMainBoxLowerPRF_Cycle1[stt], (CRebarInfoCycle*)0);
		AhTPADelete(&m_pArrRCMainBoxLowerPRF_Cycle2[stt], (CRebarInfoCycle*)0);
	}


	// 이음 간격, 철근 지름
	for(upper = 0; upper < 2; upper++)
	{
		for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
		{
			for(dan = 0; dan < MAX_REBAR_DAN; dan++)
			{
				AhTPADelete(&m_pArrDistUpperSlab[cycle][upper][dan], (CDoubleArray*)0);
				AhTPADelete(&m_pArrDistLowerSlab[cycle][upper][dan], (CDoubleArray*)0);

				AhTPADelete(&m_pArrDiaUpperSlab[cycle][upper][dan], (CDoubleArray*)0);
				AhTPADelete(&m_pArrDiaLowerSlab[cycle][upper][dan], (CDoubleArray*)0);

				AhTPADelete(&m_pArrExistUpperSlab[cycle][upper][dan], (CDoubleArray*)0);
				AhTPADelete(&m_pArrExistLowerSlab[cycle][upper][dan], (CDoubleArray*)0);
			}
		}
	}
	/////////////////////////////////////////////////////////////// CYCLE1~4 //

	// 이음연결
	for(upper = 0; upper < 2; upper++)
	{
		AhTPADelete(&m_pArrSetRebarJointUpperSlab[upper], (CSetRebarJoint*)0);
		AhTPADelete(&m_pArrSetRebarJointLowerSlab[upper], (CSetRebarJoint*)0);
	}
	/////////////////////////////////////////////////////////////// CYCLE1 //

	// CSetRebarDan
	for(upper = 0; upper < 2; upper++)
	{
		AhTPADelete(&m_pArrSetRebarDanUpperSlab[upper], (CSetRebarDan*)0);
		AhTPADelete(&m_pArrSetRebarDanLowerSlab[upper], (CSetRebarDan*)0);
	}


	// 철근 집계용
	AhTPADelete(&m_pArrRebarMain, (CRebar*)0);	
	AhTPADelete(&m_pArrRebarSupport, (CRebar*)0);	
	AhTPADelete(&m_pArrRebarShear, (CRebar*)0);	
	AhTPADelete(&m_pArrRebarEtc, (CRebar*)0);
	AhTPADelete(&m_pArrRebarGirder, (CRebar*)0);
	AhTPADelete(&m_pArrRebarMonument, (CRebar*)0);
	AhTPADelete(&m_pArrRebarMain_User, (CRebar*)0);
	AhTPADelete(&m_pArrRebarGirder_User, (CRebar*)0);

	// 속도개선용 변수들
	for(upper = 0; upper < 2; upper++)
	{
		for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
		{
			for(dan = 0; dan < MAX_REBAR_DAN; dan++)
			{
				AhTPADelete(&m_tvArr_RebarMain_Plane[cycle][dan][upper], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrAngLeft_RebarMain_Plane[cycle][dan][upper], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrAngRight_RebarMain_Plane[cycle][dan][upper], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrJoint_RebarMain_Plane[cycle][dan][upper], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrHidden_RebarMain_Plane[cycle][dan][upper], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrHiddenLeft_RebarMain_Plane[cycle][dan][upper], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrHiddenRight_RebarMain_Plane[cycle][dan][upper], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrAngLeftHalf_RebarMain_Plane[cycle][dan][upper], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrAngRightHalf_RebarMain_Plane[cycle][dan][upper], (CTwinVectorArray*)0);

				AhTPADelete(&m_tvArr_RebarMain_LowerPlane[cycle][dan][upper], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrAngLeft_RebarMain_LowerPlane[cycle][dan][upper], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrAngRight_RebarMain_LowerPlane[cycle][dan][upper], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrJoint_RebarMain_LowerPlane[cycle][dan][upper], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrHidden_RebarMain_LowerPlane[cycle][dan][upper], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrHiddenLeft_RebarMain_LowerPlane[cycle][dan][upper], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrHiddenRight_RebarMain_LowerPlane[cycle][dan][upper], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrAngLeftHalf_RebarMain_LowerPlane[cycle][dan][upper], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrAngRightHalf_RebarMain_LowerPlane[cycle][dan][upper], (CTwinVectorArray*)0);
			}

			AhTPADelete(&m_tvArr_RebarMain_PlaneHunch[cycle], (CTwinVectorArray*)0);
			AhTPADelete(&m_tvArrAngLeft_RebarMain_PlaneHunch[cycle], (CTwinVectorArray*)0);
			AhTPADelete(&m_tvArrAngRight_RebarMain_PlaneHunch[cycle], (CTwinVectorArray*)0);
			AhTPADelete(&m_tvArrJoint_RebarMain_PlaneHunch[cycle], (CTwinVectorArray*)0);
			AhTPADelete(&m_tvArrHidden_RebarMain_PlaneHunch[cycle], (CTwinVectorArray*)0);
			AhTPADelete(&m_tvArrHiddenLeft_RebarMain_PlaneHunch[cycle], (CTwinVectorArray*)0);
			AhTPADelete(&m_tvArrHiddenRight_RebarMain_PlaneHunch[cycle], (CTwinVectorArray*)0);
			AhTPADelete(&m_tvArrAngLeftHalf_RebarMain_PlaneHunch[cycle], (CTwinVectorArray*)0);
			AhTPADelete(&m_tvArrAngRightHalf_RebarMain_PlaneHunch[cycle], (CTwinVectorArray*)0);

			AhTPADelete(&m_tvArr_RebarMain_LowerPlaneHunch[cycle], (CTwinVectorArray*)0);
			AhTPADelete(&m_tvArrAngLeft_RebarMain_LowerPlaneHunch[cycle], (CTwinVectorArray*)0);
			AhTPADelete(&m_tvArrAngRight_RebarMain_LowerPlaneHunch[cycle], (CTwinVectorArray*)0);
			AhTPADelete(&m_tvArrJoint_RebarMain_LowerPlaneHunch[cycle], (CTwinVectorArray*)0);
			AhTPADelete(&m_tvArrHidden_RebarMain_LowerPlaneHunch[cycle], (CTwinVectorArray*)0);
			AhTPADelete(&m_tvArrHiddenLeft_RebarMain_LowerPlaneHunch[cycle], (CTwinVectorArray*)0);
			AhTPADelete(&m_tvArrHiddenRight_RebarMain_LowerPlaneHunch[cycle], (CTwinVectorArray*)0);
			AhTPADelete(&m_tvArrAngLeftHalf_RebarMain_LowerPlaneHunch[cycle], (CTwinVectorArray*)0);
			AhTPADelete(&m_tvArrAngRightHalf_RebarMain_LowerPlaneHunch[cycle], (CTwinVectorArray*)0);
		}
	}
}

CRcBridgeRebar& CRcBridgeRebar::operator=(const CRcBridgeRebar& Obj)
{
	CRcBridgeApp::operator=(Obj);

	long stt(0), left(0);

	/// 가각부 배근
	for(stt = 0; stt < 2; stt++)
	{
		for(left = 0; left < 2; left++)
		{
			m_nTypeRebarMainRebarOfExp[stt][left]	= Obj.m_nTypeRebarMainRebarOfExp[stt][left];
			m_nTypeOrgMainRebarOfExp[stt][left]	= Obj.m_nTypeOrgMainRebarOfExp[stt][left];
			m_dLenMainRebarOfExp[stt][left]		= Obj.m_dLenMainRebarOfExp[stt][left];				// 가각부 배근시 가각부와 좌우측라인과의 교차점에서 주철근이 뻗어 나가는 거리

			m_bLineDirRebarOfExp[stt][left]		= Obj.m_bLineDirRebarOfExp[stt][left];			// 가각 철근이 선형방향으로 배치될지?
			m_nCountSupportRebarOfExpAtLineDirRebar[stt][left]	= Obj.m_nCountSupportRebarOfExpAtLineDirRebar[stt][left];	// 가각 철근이 선형방향으로 배치될때 기존 보강철근은 몇개가 배치될지
		}
	}

	// 철근 집계
	AhTPACopy(&m_pArrRebarMain, &Obj.m_pArrRebarMain, (CRebar*)0);
	AhTPACopy(&m_pArrRebarSupport, &Obj.m_pArrRebarSupport, (CRebar*)0);
	AhTPACopy(&m_pArrRebarShear, &Obj.m_pArrRebarShear, (CRebar*)0);
	AhTPACopy(&m_pArrRebarEtc, &Obj.m_pArrRebarEtc, (CRebar*)0);
	AhTPACopy(&m_pArrRebarGirder, &Obj.m_pArrRebarGirder, (CRebar*)0);
	AhTPACopy(&m_pArrRebarMonument, &Obj.m_pArrRebarMonument, (CRebar*)0);
	AhTPACopy(&m_pArrRebarMain_User, &Obj.m_pArrRebarMain_User, (CRebar*)0);
	AhTPACopy(&m_pArrRebarGirder_User, &Obj.m_pArrRebarGirder_User, (CRebar*)0);
	// ******************* SerializeRebar 함수 사용하는 변수들 표시선  ***************************


	return *this;
}

void CRcBridgeRebar::Serialize(CArchive &ar)
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	// 38 : 단 절점부 타입 추가시 인덱스를 중간에 추가해서 생긴 flag
	// 40 : m_nTypeCouplerColumnMainRebar;				// 기둥 주철근 커플러? 겹이음. 
	// 41 : m_bApplySameSupportRebar;		// 상하행 배력철근 간격 동일 적용
	// 42 : m_bApplySameMainRebar;					// 상하행 주철근관련 입력 동일 적용
	// 43 : BOX타입 추가
	// 44 : 단절점부 철근위치 추가
	// 45 : 사용자철근
	// 46 : m_nCountWrapMainRebarLowerSlab
	// 47 : m_RebarShearDetail_LowerSlab
	// 48 : m_dCTC_SupportRebar[iLOWER], m_dCTC_ShearRebar[iLOWER] 추가
	// 49 : m_dCTC_ShearRebarBracket
	// 50 : m_bExtendShearRebarBoHunchRebar
	// 51 : m_bIsObtuseAngle_LowerSlab 등 하부슬래브 둔각부 변수들 추가
	// 52 : m_RebarShearDetail_Bracket 
	// 53 : 절곡부 구부림 반지름 적용 입력값
	
	m_nFlag		= 53;
	long upper	= 0;
	CDoubleArray dArr;
	CRcBridgeApp::Serialize(ar);

	if(ar.IsStoring()) 
	{
		ar << m_nFlag;

		// 주철근 배치 ///////////////////////////////////////////////////////////////////////////////////////////////////
		// 철근 배치 옵션 관련
		ar << m_bRoundAtEdgeRebar;		// 헌치부 철근을 라운드 적용할지?

		// 철근 배치 간격
		ar << m_nIdxCTC_MainRebar;
		ar << m_dCTC_MainRebar;	// index방식에서 double형으로 변경 index는 사용하지 않음(2005.04.25)
		ar << m_bSameOffsetPlaceTAndCBlock;	// 인장 압축구간을 동일 간격으로 배치

		// 이음 개수
		for(long jijum = 0; jijum < MAX_JIJUM_COUNT_RC; jijum++)
		{
			long upper = 0; for(upper = 0; upper < 2; upper++)
			{
				long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
				{
					ar << m_nCountJointMainRebar_UpperSlab_Cycle1[jijum][upper][dan];	// 상부슬래브 상,하면 각 지간별 이음 개수
					ar << m_nCountJointMainRebar_UpperSlab_Cycle2[jijum][upper][dan];	// 상부슬래브 상,하면 각 지간별 이음 개수
				}
			}
		}
		long stt = 0; for(stt = 0; stt < 2; stt++)
		{
			long left = 0; for(left = 0; left < 2; left++)
			{
				long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
				{
					ar << m_nCountJointMainRebar_OutWall_Cycle1[stt][left][dan];	// 외측벽체 시종점,좌우측 이음 개수
					ar << m_nCountJointMainRebar_OutWall_Cycle2[stt][left][dan];	// 외측벽체 시종점,좌우측 이음 개수
				}
			}
		}

		for(upper = 0; upper < 2; upper++)
		{
			long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
			{
				ar << m_nCountJointMainRebar_ArchRib_Cycle1[upper][dan];	// 리브 상하면,1~3단 이음 개수(리브만 특별히 각 단에 대해서 이음을 입력받음)
				ar << m_nCountJointMainRebar_ArchRib_Cycle2[upper][dan];	// 리브 상하면,1~3단 이음 개수(리브만 특별히 각 단에 대해서 이음을 입력받음)
			}
		}

		// 전단철근 타입 설정
		m_RebarShearDetail_UpperSlab.Serialize(ar);		// 상부슬래브
		m_RebarShearDetail_LowerSlab.Serialize(ar);
		m_RebarShearDetail_OutWall[iSTT].Serialize(ar);	// 시종점 외측벽체
		m_RebarShearDetail_OutWall[iEND].Serialize(ar);	// 시종점 외측벽체
		m_RebarShearDetail_InWall.Serialize(ar);		// 중간벽체
		m_RebarShearDetail_FootingLean.Serialize(ar);	// 직접기초
		m_RebarShearDetail_FootingPile.Serialize(ar);	// 말뚝기초
		m_RebarShearDetail_ArchRib.Serialize(ar);
		m_RebarShearDetail_Bracket[0].Serialize(ar);
		m_RebarShearDetail_Bracket[1].Serialize(ar);

		// 주철근 배근 저장(일괄저장함수)
		SerializeRebar(ar);
		// Box형식 추가
		SerializeRebarBox(ar);
	}
	else
	{
		ar >> m_nFlag;

		// 주철근 배치 ///////////////////////////////////////////////////////////////////////////////////////////////////
		// 철근 배치 옵션 관련
		ar >> m_bRoundAtEdgeRebar;		// 헌치부 철근을 라운드 적용할지?

		// 철근 배치 간격
		ar >> m_nIdxCTC_MainRebar;
		if(m_nFlag > 0)
			ar >> m_dCTC_MainRebar;	// index방식에서 double형으로 변경 index는 사용하지 않음(2005.04.25)
		ar >> m_bSameOffsetPlaceTAndCBlock;	// 인장 압축구간을 동일 간격으로 배치

		// 이음 개수
		for(long jijum = 0; jijum < MAX_JIJUM_COUNT_RC; jijum++)
		{
			long upper = 0; for(upper = 0; upper < 2; upper++)
			{
				long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
				{
					if(m_nFlag > 37 || dan == 0)
					{
						ar >> m_nCountJointMainRebar_UpperSlab_Cycle1[jijum][upper][dan];	// 상부슬래브 상,하면 각 지간별 이음 개수
						if(m_nFlag > 12)
							ar >> m_nCountJointMainRebar_UpperSlab_Cycle2[jijum][upper][dan];	// 상부슬래브 상,하면 각 지간별 이음 개수

						if(m_nFlag < 43)
						{
							// long m_nCountJointMainRebar_LowerSlab[MAX_JIJUM_COUNT_RC][2][MAX_REBAR_DAN] 변수 삭제
							long nDelete;
							ar >> nDelete;
						}
					}
				}
			}
		}
		long stt = 0; for(stt = 0; stt < 2; stt++)
		{
			long left = 0; for(left = 0; left < 2; left++)
			{
				long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
				{
					if(m_nFlag > 37 || dan == 0)
					{
						ar >> m_nCountJointMainRebar_OutWall_Cycle1[stt][left][dan];	// 외측벽체 시종점,좌우측 이음 개수
						if(m_nFlag > 12)
							ar >> m_nCountJointMainRebar_OutWall_Cycle2[stt][left][dan];	// 외측벽체 시종점,좌우측 이음 개수
					}
				}
			}
		}

		if(m_nFlag > 22)
		{
			for(upper = 0; upper < 2; upper++)
			{
				long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
				{
					ar >> m_nCountJointMainRebar_ArchRib_Cycle1[upper][dan];	// 리브 상하면,1~3단 이음 개수(리브만 특별히 각 단에 대해서 이음을 입력받음)
					ar >> m_nCountJointMainRebar_ArchRib_Cycle2[upper][dan];	// 리브 상하면,1~3단 이음 개수(리브만 특별히 각 단에 대해서 이음을 입력받음)
				}
			}
		}

		if(m_nFlag > 10)
		{
			// 전단철근 타입 설정
			m_RebarShearDetail_UpperSlab.Serialize(ar);		// 상부슬래브
			if(m_nFlag > 46)
				m_RebarShearDetail_LowerSlab.Serialize(ar);
			m_RebarShearDetail_OutWall[iSTT].Serialize(ar);	// 시종점 외측벽체
			m_RebarShearDetail_OutWall[iEND].Serialize(ar);	// 시종점 외측벽체
			m_RebarShearDetail_InWall.Serialize(ar);		// 중간벽체
			m_RebarShearDetail_FootingLean.Serialize(ar);	// 직접기초
			m_RebarShearDetail_FootingPile.Serialize(ar);	// 말뚝기초
			if(m_nFlag > 26)
				m_RebarShearDetail_ArchRib.Serialize(ar);		// 리브
			if(m_nFlag > 51)
			{
				m_RebarShearDetail_Bracket[0].Serialize(ar);
				m_RebarShearDetail_Bracket[1].Serialize(ar);
			}
		}
		else
		{
			CWallApp *pWall	= GetInWall(0);
			CFootingApp *pFooting					= GetFooting(0);
			m_RebarShearDetail_UpperSlab.m_dDia		= m_placeByBlock_ShearRebar_UpperSlab.m_dDia;		// 상부슬래브
			m_RebarShearDetail_OutWall[iSTT].m_dDia	= m_placeByBlock_ShearRebar_OutWall[iSTT].m_dDia;	// 시종점 외측벽체
			m_RebarShearDetail_OutWall[iEND].m_dDia	= m_placeByBlock_ShearRebar_OutWall[iEND].m_dDia;	// 시종점 외측벽체
			m_RebarShearDetail_InWall.m_dDia		= pWall ? pWall->m_placeByBlock_ShearRebar.m_dDia : 19;
			m_RebarShearDetail_FootingLean.m_dDia	= pFooting ? pFooting->m_placeByBlock_Shear_Front.m_dDia : 19;	// 직접기초
			m_RebarShearDetail_FootingPile.m_dDia	= pFooting ? pFooting->m_placeByBlock_Shear_Front.m_dDia : 19;	// 말뚝기초
		}

		// 주철근 배근 저장(일괄저장함수)
		SerializeRebar(ar);
		// Box형식 추가
		SerializeRebarBox(ar);
	}

	if(ar.IsLoading() && m_nFlag<6)
	{
		if(GetWingWall(TRUE,TRUE)->m_bExist)  SetDataDefaultRebarJewonWingWall(TRUE,TRUE);
		if(GetWingWall(TRUE,FALSE)->m_bExist) SetDataDefaultRebarJewonWingWall(TRUE,FALSE);
		if(GetWingWall(FALSE,TRUE)->m_bExist) SetDataDefaultRebarJewonWingWall(FALSE,TRUE);
		if(GetWingWall(FALSE,FALSE)->m_bExist)SetDataDefaultRebarJewonWingWall(FALSE,FALSE);
	}
	if(ar.IsLoading() && m_nFlag<7)
	{
		if(GetWingWall(TRUE,TRUE)->m_bExist)
		{
			SetConvertWingWallHorRebarDim(TRUE, TRUE, 0, 0, TRUE);
			SetConvertWingWallHorRebarDim(TRUE, TRUE, 0, 0, FALSE);
			SetConvertWingWallHorRebarDim(TRUE, TRUE, 1, 0, TRUE);
			SetConvertWingWallHorRebarDim(TRUE, TRUE, 1, 0, FALSE);
		}
		if(GetWingWall(TRUE,FALSE)->m_bExist)
		{
			SetConvertWingWallHorRebarDim(TRUE, FALSE, 0, 0, TRUE);
			SetConvertWingWallHorRebarDim(TRUE, FALSE, 0, 0, FALSE);
			SetConvertWingWallHorRebarDim(TRUE, FALSE, 1, 0, TRUE);
			SetConvertWingWallHorRebarDim(TRUE, FALSE, 1, 0, FALSE);
		}
		if(GetWingWall(FALSE,TRUE)->m_bExist) 
		{
			SetConvertWingWallHorRebarDim(FALSE, TRUE, 0, 0, TRUE);
			SetConvertWingWallHorRebarDim(FALSE, TRUE, 0, 0, FALSE);
			SetConvertWingWallHorRebarDim(FALSE, TRUE, 1, 0, TRUE);
			SetConvertWingWallHorRebarDim(FALSE, TRUE, 1, 0, FALSE);
		}
		if(GetWingWall(FALSE,FALSE)->m_bExist)
		{
			SetConvertWingWallHorRebarDim(FALSE, FALSE, 0, 0, TRUE);
			SetConvertWingWallHorRebarDim(FALSE, FALSE, 0, 0, FALSE);
			SetConvertWingWallHorRebarDim(FALSE, FALSE, 1, 0, TRUE);
			SetConvertWingWallHorRebarDim(FALSE, FALSE, 1, 0, FALSE);
		}
	}
	if(ar.IsLoading() && m_nFlag<8)
	{
		CLineInfoApp *pLine = NULL;
		pLine = pStd->GetLineApp();	
		double dStaStt = GetStationBridgeStt(FALSE);
		double dStaEnd = dStaStt + GetLengthBridge(FALSE);
		double dElStt = 0;
		double dElEnd = 0;
		
		pLine->GetLine(0)->GetElevationErathOnStation(dStaStt, dElStt);
		pLine->GetLine(0)->GetElevationErathOnStation(dStaEnd, dElEnd);
		
		CWingWall *pWing = NULL;
		pWing = GetWingWall(TRUE, TRUE);
		if(pWing->m_bExist)  pWing->m_dElSodanBottom = toM(dElStt);

		pWing = GetWingWall(TRUE, FALSE);
		if(pWing->m_bExist)  pWing->m_dElSodanBottom = toM(dElStt);

		pWing = GetWingWall(FALSE, TRUE);
		if(pWing->m_bExist)  pWing->m_dElSodanBottom = toM(dElEnd);

		pWing = GetWingWall(FALSE, FALSE);
		if(pWing->m_bExist)  pWing->m_dElSodanBottom = toM(dElEnd);
	}

	CheckSerialize();

	if(ar.IsLoading())
	{
		SetSearchIP();
	}

	if(ar.IsLoading() && m_nFlag < 13)
	{
		//SyncBridge(0, !IsVertDir(), FALSE, FALSE);
		//SyncRebar2CycleMainRebarOldAndNew();
	}
}

// 입력된 정보로 상부슬래브 철근 생성(1, 2, 3, 4cycle) 1~3단..
void CRcBridgeRebar::MakeRebarInfoCycle_UpperSlab(long nCycle, long nDan, BOOL bInput, long nVertDir)
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar() - 1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar() - 1) return;

	BOOL bVertDir	= IsVertDir();
	if(nVertDir!=0)
		bVertDir	= nVertDir == -1 ? TRUE : FALSE;
	m_bMakedRebarInfoCycleByVert = m_bMakedRebarInfoCycleByVertUpperSlab	= bVertDir;

	// 사용할 변수들.. 
	CSafetyTypedPtrArray <CObArray, CDoubleArray*> *pArrDistUpper	= &m_pArrDistUpperSlab[nCycle][iUPPER][0];
	CSafetyTypedPtrArray <CObArray, CDoubleArray*> *pArrDistLower	= &m_pArrDistUpperSlab[nCycle][iLOWER][0];

	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRCUpper	= &m_pArrRCMainUpperSlab[nCycle][iUPPER][nDan];
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRCLower	= &m_pArrRCMainUpperSlab[nCycle][iLOWER][nDan];

	long nCycleReal	= nCycle;
	if(!m_bDetailInput23DanMainRebar)
	{
		if(nDan > 0)
			nCycle = 1;
	}

	
	AhTPADelete(pArrRCUpper, (CRebarInfoCycle*)0);
	AhTPADelete(pArrRCLower, (CRebarInfoCycle*)0);
	
	CRebarPlacing rbPlacing;
	CTwinVector tv;
	CTwinVectorArray tvArr, tvArrTmp;

	CRebarInfoCycle *pRC = NULL;

	// 공통사용 변수
	CTwinVector tvRebar;		// 상부슬래브 좌표
	double dOffset		= 0;	// 상단슬래브 상면에서 철근까지의 거리
	double dNextStt		= -1;	// 다음 철근의 시작위치(이음길이 고려한 위치)
	long nSize			= 0;	
	double dLenRound	= 0;	// 가장자리 철근의 모따리나 라운드 크기
	double dLenRoundDnabu	= 0;	// 단부철근 꺽임옵션 적용된 길이
	double dDia			= 0;	// 철근 지름
	double dDiaNext		= 0;	// 다음 철근의 지름
	double dDiaReal		= 0;
	BOOL bExist			= TRUE;
	long nCountJoint	= 0;	// 이음개수
	long nIdx			= 0;
	CDPoint vAng		= CDPoint(0, 1);
	double dCoverSide	= GetCoverSide_UpperSlab(0);
	double dLenJoint	= 0;
	double dLenJointLast	= 0;

	BOOL b2CycleBending	= ((nCycleReal == 1 || nCycleReal == 3) && m_bBendingDanBuRebar)? TRUE : FALSE;

	// description 정보 /////
	CString sCycle	= m_pARcBridgeDataStd->GetStringCircleNum(1);
	CString sUpper	= "상";
	///////////////////////////

	// 상부 슬래브 주철근 1단 1사이클
	tvRebar		= GetTvOffset_UpperSlab(nDan, TRUE, -1, -1, bVertDir);	
	dOffset		= m_dCoverUpper_UpperSlab[nDan];
//	dNextStt	= -1;	
	nSize		= pArrDistUpper->GetSize();
	long i = 0; for(i = 0; i < m_nQtyJigan; i++)
	{
		if(nSize <= i) continue;
		if(m_bDetailInput23DanMainRebar && nDan > 0)
		{
			if(nDan >= GetDanMainRebarUpperSlab(nCycleReal, TRUE, 0))
				break;

		}
		nCountJoint = GetCountJointMainRebarUpperSlab(nCycle, nDan, TRUE, i);
		nCountJoint	= nCountJoint > 0 ? nCountJoint : 1;
		nIdx		= 0;
		vAng		= bVertDir ? CDPoint(0, 1) : GetAngleJijum(i+1);
		dLenJointLast	= 0;
		dLenJoint		= 0;
		
		long j = 0; for(j = 0; j <  nCountJoint; j++)
		{
			dLenJointLast	= dLenJoint;
			double dist = GetDistMainRebarUpperSlab(nCycle, nDan, TRUE, i, j, FALSE, nVertDir);

			// 철근 지름과 가장자리철근 모따기밑 라운드 크기 ////////////
			dDia		= GetDiaMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, i, nIdx);
			dDiaReal	= GetDiaMainRebarUpperSlab(nCycleReal, nDan, TRUE, i, nIdx);
			bExist		= IsExistMainRebarUpperSlab(nCycleReal, nDan, TRUE, i, nIdx++);
			dDiaNext	= GetDiaMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, i, nIdx);
			if(nIdx == nCountJoint && i < m_nQtyJigan-1)
				dDiaNext	= GetDiaMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, i+1, 0);

			dLenRound	= GetLenRebarAtEdge(dDiaReal, FALSE, nVertDir, TRUE);
			dLenRoundDnabu	= GetLenRebarAtEdge(dDiaReal, FALSE, nVertDir, TRUE, b2CycleBending);
			if(i == 0 && !IsOutWall(TRUE)) 
			{
				dLenRound	= 0;
				dLenRoundDnabu	= 0;
			}
			if(i == m_nQtyJigan-1 && !IsOutWall(FALSE))
			{
				dLenRound	= 0;
				dLenRoundDnabu	= 0;
			}
			/////////////////////////////////////////////////////////////////
				

			// 철근 하나 추가
			pArrRCUpper->Add(new CRebarInfoCycle);
			pRC		= pArrRCUpper->GetAt(pArrRCUpper->GetSize()-1);

			// 공통속성
			pRC->m_nTypeRebar	= REBAR_TYPE_MAIN;
 			pRC->m_nRebarDan	= 0;
			pRC->m_Dia			= dDia;
			pRC->m_bExist		= bExist;
			
			// 첫번째 지간에 첫번째 이음까지의 철근 
			if(i == 0 && j == 0)
			{
				double dLen		= GetLenRebarBeforeEdge_UpperSlab_Cycle13(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, FALSE, nVertDir);
				pRC->m_nPosStt	= REBARINFO_POS_STTWALL_OUTTER;
				pRC->m_nPosEnd	= REBARINFO_POS_UPPERSLAB_UPPER;
				dLenJoint		= GetValueJoint(pRC, dDiaNext, NULL, nVertDir);
				pRC->m_Dia		= dDiaReal;
				pRC->m_xyStt	= CDPoint(tvRebar.m_v1.x, tvRebar.m_v1.y - (dLen + dLenRound)); //dLen에 dLenRoundDanbu가 포함되어 있다. ARCBRIDGE-2921
				//  => (ARCBRIDGE-2921) 아닌데~~ 절곡길이 포함 안됬는데~~ GetLenRebarBeforeEdge_UpperSlab_Cycle13() 함수에 오류가 있어서 수정.

				GetXyTanOfArc(tvRebar.m_v1, tvRebar.GetXyDir(), CDPoint(0, -1), dLenRoundDnabu, pRC->m_xyCen, pRC->m_xyMid2, pRC->m_xyMid1);
				//pRC->m_xyEnd	= GetXyToDistFromSlabUpper(pRC->m_xyMid2.x, dist + dLenJoint/2, 0, dOffset, bVertDir);
				GetXyMatchLineAndLine(pRC->m_xyMid2+CDPoint(dist+dLenJoint/2, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyEnd);
				pRC->m_R_Mid	= (b2CycleBending) ? 0 : dLenRoundDnabu;
				pRC->m_bRevArc	= TRUE;
				dNextStt		= pRC->m_xyEnd.x - dLenJoint;
			}
			else
			{
				// 첫번째 지간 이후의 첫번째 철근
				if(j == 0)
				{
					// 신축이음인경우 첫번째 철근을 꺽어 줘야 된다.
					if(m_bExpJoint[i])
					{
						// 슬래브가 경사진 경우. xyMid2가 경사따라 그려져야됨.
						CDPoint xyDir	= (GetXyToDistFromSlabUpper(dNextStt+dLenRound, 0, 0, dOffset, bVertDir)-GetXyToDistFromSlabUpper(dNextStt, 0, 0, dOffset, bVertDir)).Unit();

						pRC->m_nPosStt	= REBARINFO_POS_UPPERSLAB_SIDE;
						pRC->m_nPosEnd	= REBARINFO_POS_UPPERSLAB_UPPER;
						dLenJoint		= GetValueJoint(pRC, dDiaNext, NULL, nVertDir);
						pRC->m_Dia		= dDiaReal;
						//pRC->m_xyMid1	= GetXyToDistFromSlabUpper(dNextStt, 0, 0, dOffset, bVertDir) + CDPoint(0, -dLenRound);
						GetXyMatchLineAndLine(CDPoint(dNextStt, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyMid1);
						pRC->m_xyMid1.y -= dLenRound;
						pRC->m_xyStt	= CDPoint(pRC->m_xyMid1.x, pRC->m_xyMid1.y - (m_dTS - dLenRound - m_dCoverUpper_UpperSlab[0] - m_dCoverLower_UpperSlab[0]));
						//pRC->m_xyMid2	= GetXyToDistFromSlabUpper(dNextStt, 0, 0, dOffset, bVertDir) + xyDir * dLenRound;
						GetXyMatchLineAndLine(CDPoint(dNextStt, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyMid2);
						pRC->m_xyMid2 += xyDir * dLenRound;
						//pRC->m_xyEnd	= GetXyToDistFromSlabUpper(GetStationOnJijum(i, 0, bVertDir), dist + dLenJoint/2, 0, dOffset, bVertDir);
						GetXyMatchLineAndLine(CDPoint(GetStationOnJijum(i, 0, bVertDir)+dist+dLenJoint/2, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyEnd);
						pRC->m_xyCen	= CDPoint(pRC->m_xyStt.x + dLenRound, pRC->m_xyStt.y);
						pRC->m_R_Mid	= dLenRound;
						dNextStt		= pRC->m_xyEnd.x - dLenJoint;
					}
					else
					{
						pRC->m_nPosStt	= REBARINFO_POS_UPPERSLAB_UPPER;
						pRC->m_nPosEnd	= REBARINFO_POS_UPPERSLAB_UPPER;
						dLenJoint		= GetValueJoint(pRC, dDiaNext, NULL, nVertDir);
						pRC->m_Dia		= dDiaReal;
						//pRC->m_xyStt	= GetXyToDistFromSlabUpper(dNextStt, 0, 0, dOffset, bVertDir);
						GetXyMatchLineAndLine(CDPoint(dNextStt, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyStt);
						//pRC->m_xyMid1	= GetXyToDistFromSlabUpper(GetStationOnJijum(i, 0, bVertDir), dist + dLenJoint/2, 0, dOffset, bVertDir);
						GetXyMatchLineAndLine(CDPoint(GetStationOnJijum(i, 0, bVertDir)+dist+dLenJoint/2, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyMid1);
						pRC->m_xyMid2	= pRC->m_xyMid1;
						pRC->m_xyEnd	= pRC->m_xyMid1;
						pRC->m_R_Mid	= 0;
						pRC->m_nPosStt	= REBARINFO_POS_UPPERSLAB_UPPER;
						pRC->m_nPosEnd	= REBARINFO_POS_UPPERSLAB_UPPER;
						dNextStt		= pRC->m_xyMid1.x - dLenJoint;

						// 첫번째 지간 이후의 첫번째 철근은 이전 철근과 합쳐 져야 한다.
						long nCount		= pArrRCUpper->GetSize();
						m_Util.MergeRebarInfoCycle(pArrRCUpper, nCount-2, nCount-1);

						// 각 지점에 걸리는 철근이다.
						// 2,3단일 경우 1단철근과 길이를 일치 시켜 준다.
						if(nDan > 0 && !m_bDetailInput23DanMainRebar)
						{
							pRC	= pArrRCUpper->GetAt(pArrRCUpper->GetSize()-1);
							CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRCUpper1Dan	= 
								&m_pArrRCMainUpperSlab[nCycle][iUPPER][0];
							double dSta	= GetStationOnJijum(i, 0, bVertDir);

							for(long k = 0; k < pArrRCUpper1Dan->GetSize(); k++)
							{
								CRebarInfoCycle *pRC1Dan	= pArrRCUpper1Dan->GetAt(k);
								if(pRC1Dan->m_xyStt.x <= dSta && pRC1Dan->m_xyMid1.x >= dSta)
								{
									pRC->m_xyStt.x	= pRC1Dan->m_xyStt.x;
									pRC->m_xyMid1.x	= pRC1Dan->m_xyMid1.x;
								}
							}
						}
					}
				}
				// 첫번째 이음 이후의 철근, 마지막 철근은 아님.
				else if(j > 0 && j < nCountJoint)
				{
					pRC->m_nPosStt	= REBARINFO_POS_UPPERSLAB_UPPER;
					pRC->m_nPosEnd	= REBARINFO_POS_UPPERSLAB_UPPER;
					dLenJoint		= GetValueJoint(pRC, dDiaNext, NULL, nVertDir);
					pRC->m_Dia		= dDiaReal;
					//pRC->m_xyStt	= GetXyToDistFromSlabUpper(dNextStt, 0, 0, dOffset, bVertDir);
					GetXyMatchLineAndLine(CDPoint(dNextStt, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyStt);
					//pRC->m_xyMid1	= GetXyToDistFromSlabUpper(dNextStt, dist + dLenJointLast/2 + dLenJoint/2, 0, dOffset, bVertDir);
					GetXyMatchLineAndLine(CDPoint(dNextStt + dist + dLenJointLast/2 + dLenJoint/2, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyMid1);
					pRC->m_xyMid2	= pRC->m_xyMid1;
					pRC->m_xyEnd	= pRC->m_xyMid1;
					pRC->m_R_Mid	= 0;
					dNextStt		= pRC->m_xyMid1.x - dLenJoint;

					if(nDan > 0 && !m_bDetailInput23DanMainRebar)
					{
						delete pRC;
						pArrRCUpper->RemoveAt(pArrRCUpper->GetSize()-1);
					}
				}
			}

			// 현재 지간의 마지막 철근을 구해야 되면..
			if(j == nCountJoint-1)
			{
				pArrRCUpper->Add(new CRebarInfoCycle);
				pRC = pArrRCUpper->GetAt(pArrRCUpper->GetSize()-1);

				// 마지막 지간이면
				if(i == m_nQtyJigan-1)
				{
					dDia			= GetDiaMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, i, -1);
					dDiaReal		= GetDiaMainRebarUpperSlab(nCycleReal, nDan, TRUE, i, -1);
					bExist			= IsExistMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, i, -1);
					pRC->m_Dia		= dDiaReal;
					pRC->m_bExist	= bExist;
					pRC->m_nPosStt	= REBARINFO_POS_UPPERSLAB_UPPER;
					pRC->m_nPosEnd	= REBARINFO_POS_ENDWALL_OUTTER;

					double dLen		= GetLenRebarBeforeEdge_UpperSlab_Cycle13(nCycle, nDan, FALSE, FALSE, nVertDir);
					dLenRound		= GetLenRebarAtEdge(dDiaReal, FALSE, nVertDir, TRUE);
					dLenRoundDnabu	= GetLenRebarAtEdge(dDiaReal, FALSE, nVertDir, TRUE, b2CycleBending);
					if(i == 0 && !IsOutWall(TRUE))
					{
						dLenRound	= 0;
						dLenRoundDnabu	= 0;
					}
					if(i == m_nQtyJigan-1 && !IsOutWall(FALSE))
					{
						dLenRound	= 0;
						dLenRoundDnabu	= 0;
					}
					//pRC->m_xyStt	= GetXyToDistFromSlabUpper(dNextStt, 0, 0, dOffset, bVertDir);
					GetXyMatchLineAndLine(CDPoint(dNextStt, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyStt);
					GetXyTanOfArc(tvRebar.m_v2, CDPoint(0, -1), tvRebar.GetXyDir(TRUE), dLenRoundDnabu, pRC->m_xyCen, pRC->m_xyMid2, pRC->m_xyMid1);
					pRC->m_xyEnd	= pRC->m_xyMid2 + CDPoint(0, -dLen);
					pRC->m_R_Mid	= (b2CycleBending) ? 0 : dLenRoundDnabu;
					pRC->m_bRevArc	= TRUE;
					dNextStt		= pRC->m_xyEnd.x;
				}
				// 마지막 지간이 아니면
				else
				{
					
					// 신축이음인 경우 지점에서 한번 끊어 준다.
					CJijum *pJ	= GetJijum(i+1);
					if(m_bExpJoint[i+1] && pJ)
					{
						dDia			= GetDiaMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, i, -1);
						dDiaReal		= GetDiaMainRebarUpperSlab(nCycleReal, nDan, TRUE, i, -1);
						bExist			= IsExistMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, i, -1);
						pRC->m_Dia		= dDiaReal;
						pRC->m_bExist	= bExist;
						dLenRound		= GetLenRebarAtEdge(dDiaReal, FALSE, nVertDir, TRUE);
						if(i == 0 && !IsOutWall(TRUE)) dLenRound	= 0;
						if(i == m_nQtyJigan-1 && !IsOutWall(FALSE)) dLenRound	= 0;
						double dUganP	= pJ->m_dLengthUgan[0];
						double dUganN	= pJ->m_dLengthUgan[1];
						//pRC->m_xyStt	= GetXyToDistFromSlabUpper(dNextStt, 0, 0, dOffset, bVertDir);
						GetXyMatchLineAndLine(CDPoint(dNextStt, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyStt);
						//pRC->m_xyMid1	= GetXyToDistFromSlabUpper(GetStationOnJijum(i+1, 0, bVertDir)-dUganP-dCoverSide/vAng.y-dLenRound, 0, 0 ,dOffset, bVertDir);
						GetXyMatchLineAndLine(CDPoint(GetStationOnJijum(i+1, 0, bVertDir)-dUganP-dCoverSide/vAng.y-dLenRound, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyMid1);
						//pRC->m_xyMid2	= GetXyToDistFromSlabUpper(GetStationOnJijum(i+1, 0, bVertDir)-dUganP-dCoverSide/vAng.y, 0, 0, dOffset, bVertDir)+CDPoint(0, -dLenRound);
						GetXyMatchLineAndLine(CDPoint(GetStationOnJijum(i+1, 0, bVertDir)-dUganP-dCoverSide/vAng.y, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyMid2);
						pRC->m_xyMid2 += CDPoint(0,-dLenRound);
						pRC->m_xyEnd	= CDPoint(pRC->m_xyMid2.x, pRC->m_xyMid2.y - (m_dTS - dLenRound - m_dCoverUpper_UpperSlab[0] - m_dCoverLower_UpperSlab[0]));
						pRC->m_xyCen	= CDPoint(pRC->m_xyEnd.x-dLenRound, pRC->m_xyEnd.y);
						pRC->m_R_Mid	= dLenRound;
						pRC->m_nPosStt	= REBARINFO_POS_UPPERSLAB_UPPER;
						pRC->m_nPosEnd	= REBARINFO_POS_UPPERSLAB_SIDE;
						dNextStt		= pRC->m_xyEnd.x + dUganP + dUganN + (dCoverSide*2/vAng.y);
					}
					else
					{
						dDia			= GetDiaMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, i+1, 0);
						dDiaReal		= GetDiaMainRebarUpperSlab(nCycleReal, nDan, TRUE, i+1, 0);
						bExist			= IsExistMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, i+1, 0);
						dDiaNext		= GetDiaMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, i+2, 0);

						pRC->m_Dia		= dDia;
						pRC->m_bExist	= bExist;
						pRC->m_nPosStt	= REBARINFO_POS_UPPERSLAB_UPPER;
						pRC->m_nPosEnd	= REBARINFO_POS_UPPERSLAB_UPPER;
						dLenJoint		= GetValueJoint(pRC, dDiaNext, NULL, nVertDir);
						pRC->m_Dia		= dDiaReal;

						//pRC->m_xyStt	= GetXyToDistFromSlabUpper(dNextStt, 0, 0, dOffset, bVertDir);
						GetXyMatchLineAndLine(CDPoint(dNextStt, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyStt);
						///pRC->m_xyMid1	= GetXyToDistFromSlabUpper(GetStationOnJijum(i+1, 0), 0, 0, dOffset, bVertDir);
						GetXyMatchLineAndLine(CDPoint(GetStationOnJijum(i+1, 0), 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyMid1);
						pRC->m_xyMid2	= pRC->m_xyMid1;
						pRC->m_xyEnd	= pRC->m_xyMid1;
						pRC->m_R_Mid	= 0;
						dNextStt		= pRC->m_xyMid1.x - dLenJoint;
					}
				}
			}

			// 두번째 지간부터는 이전 지간에 이음이 있는지 없는지 검사를 해야 되며
			// 마지막 지간의 경우 현재 지간에 이음이 있는지 없는지 검사를 해야 된다.
			if(j == 0)
			{
				if(i > 0)
				{
					if(GetCountJointMainRebarUpperSlab(nCycle, nDan, TRUE, i-1) == 0)
					{
						long nSize	= pArrRCUpper->GetSize();
						if(nSize > 1)
						{
							if(nCountJoint == 1)
								m_Util.MergeRebarInfoCycle(pArrRCUpper, nSize-3, nSize-2);
							else
								m_Util.MergeRebarInfoCycle(pArrRCUpper, nSize-2, nSize-1);
						}
					}
				}

				if(i == m_nQtyJigan-1)
				{
					if(GetCountJointMainRebarUpperSlab(nCycle, nDan, TRUE, i) == 0)
					{
						long nSize	= pArrRCUpper->GetSize();
						if(nSize > 1)
							m_Util.MergeRebarInfoCycle(pArrRCUpper, nSize-2, nSize-1);
					}
				}
			}
		}
	}

	if(nDan > 0 && !m_bDetailInput23DanMainRebar)
	{
		// 상부철근 2,3단에서 시작철근이 끝좌표와 마지막철근의 시작좌표는 2cycle1단철근의 끝과시작좌표와 맞춰줘야 한다.
		// 그리고 벽체가 있는 경우 y좌표를 맞춰줘야 된다.
		if(pArrRCUpper->GetSize() > 0)
		{
			const long cycle2	= 1;
			long i = 0; for(i = 0; i < 2; i++)
			{
				CRebarInfoCycle *pRC	= pArrRCUpper->GetAt(i == 0 ? 0 : pArrRCUpper->GetSize()-1);
				CRebarInfoCycle *pRC2Cycle	= GetRebarInfoCycleUpperSlab(cycle2, 0, TRUE, i==0 ? 0 : -1);

				if(pRC2Cycle)
				{
					if(i == 0)
					{
						// 상부 슬래브쪽 조정
						double dSta		= pRC2Cycle->m_xyEnd.x;
						//pRC->m_xyEnd	= GetXyToDistFromSlabUpper(dSta, 0, 0, dOffset, bVertDir);
						GetXyMatchLineAndLine(CDPoint(dSta, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyEnd);

						// 벽체쪽 조정
						pRC->m_xyStt.y	= pRC2Cycle->m_xyStt.y;
					}
					else
					{
						// 상부 슬래브쪽 조정
						double dSta		= pRC2Cycle->m_xyStt.x;
						//pRC->m_xyStt	= GetXyToDistFromSlabUpper(dSta, 0, 0, dOffset, bVertDir);	
						GetXyMatchLineAndLine(CDPoint(dSta, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyStt);

						// 벽체쪽 조정
						pRC->m_xyEnd.y	= pRC2Cycle->m_xyEnd.y;
					}
				}
			}
		}

		// 2단 이상일 경우 옵션에 의해서 설치되는 철근만 남기고 모두 제거 한다.
		// 각 지점에 하나씩 옵션이 지정됨
		long nIdx	= 0;
		for(i = 0; i < pArrRCUpper->GetSize(); i++)
		{
			CRebarInfoCycle *pRC	= pArrRCUpper->GetAt(i);
			pRC->m_Dia	= GetDiaMainRebarUpperSlab(nCycleReal, nDan, TRUE, 0, nIdx);
			ApplyExtLength23DanMainRebar_UpperSlab(pRC, GetLengthExt23DanRebarUpperSlab(TRUE, nIdx));
			if(nDan >= GetDanMainRebarUpperSlab(nCycleReal, TRUE, nIdx++))
			{
				delete pRC;
				pArrRCUpper->RemoveAt(i);
				i--;
			}
		}
	}


	// Not Exist인 rc 제거
	/*
	if(!bInput)
		RemoveNotExistRebarInfoCycle(pArrRCUpper);
		*/

	// szMark 설정
	SetStringMarkToRebarInfoCycle(pArrRCUpper, MARK_UPPERSLAB_UPPER, nCycleReal, bInput, bInput || (nCycleReal==0 && nDan==0), nDan);
	// sDescription 설정
	SetStringDescriptionRebarInfoCycle_UpperSlab(pArrRCUpper, nCycleReal, TRUE, nDan);

	SettingAngleInfoAtRebarInfoCycle_UpperSlab(pArrRCUpper, 0, -1, -1, bVertDir);


	// 상부슬래브 하면 
	double dLenVerStt	= 100;	// 시종점 하면 철근 위로 올라가는 길이
	double dLenVerEnd	= 100;	// 시종점 하면 철근 위로 올라가는 길이
	double dTP			= GetThickPave(FALSE);

	// 벽체가 있으면 하면철근 꺽이는거 없음
	if(IsOutWall(TRUE))
		dLenVerStt	= 0;
	if(IsOutWall(FALSE))
		dLenVerEnd	= 0;

	if(IsBlockOut(TRUE))
	{
		dLenVerStt	= m_dTS - m_fxJointStt.m_dHeight - m_dCoverUpper_UpperSlab[nDan] - m_dCoverLower_UpperSlab[nDan] + dTP;
	}

	if(IsBlockOut(FALSE))
	{
		dLenVerEnd	= m_dTS - m_fxJointEnd.m_dHeight - m_dCoverUpper_UpperSlab[nDan] - m_dCoverLower_UpperSlab[nDan] + dTP;
	}

	nSize		= pArrDistLower->GetSize();
	tvRebar		= GetTvOffset_UpperSlab(nDan, FALSE, -1, -1, bVertDir);	// 하부슬래브 좌표
	dNextStt	= tvRebar.m_v1.x;
	dLenJointLast	= 0;

	long nCountJointTot	= 0;
	for(i = 0; i < m_nQtyJigan; i++)
		nCountJointTot += GetCountJointMainRebarUpperSlab(nCycle, nDan, FALSE, i);

	if(nCountJointTot == 0)
	{
		if(nDan < GetDanMainRebarUpperSlab(nCycleReal, FALSE, 0))
		{
			dDiaReal	= GetDiaMainRebarUpperSlab(nCycleReal, nDan, FALSE, 0, 0);
			bExist		= IsExistMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, FALSE, 0, 0);
			pArrRCLower->Add(new CRebarInfoCycle);
			pRC = pArrRCLower->GetAt(pArrRCLower->GetSize()-1);

			

			// 공통속성
			pRC->m_nTypeRebar	= REBAR_TYPE_MAIN;
			pRC->m_nRebarDan	= 0;
			pRC->m_nPosStt		= REBARINFO_POS_UPPERSLAB_LOWER;
			pRC->m_nPosEnd		= REBARINFO_POS_UPPERSLAB_LOWER;
			pRC->m_Dia			= dDiaReal;
			pRC->m_bExist		= bExist;		

			pRC->m_xyStt		= tvRebar.m_v1;
			pRC->m_xyMid1		= tvRebar.m_v2;
			pRC->m_xyMid2		= tvRebar.m_v2;
			pRC->m_xyEnd		= tvRebar.m_v2;
		}
	}
	else
	{
		for(i = 0; i < m_nQtyJigan; i++)
		{
			if(i >= nSize) continue;
			if(m_bDetailInput23DanMainRebar && nDan > 0)
			{
				if(nDan >= GetDanMainRebarUpperSlab(nCycleReal, FALSE, 0))
					break;
			}
		
			nCountJoint	= GetCountJointMainRebarUpperSlab(nCycle, nDan, FALSE, i);
			nCountJoint	= nCountJoint > 0 ? nCountJoint : 1;
			nIdx		= 0;
			long j = 0; for(j = 0; j < nCountJoint; j++)
			{
				dLenJointLast	= dLenJoint;
				double dist = GetDistMainRebarUpperSlab(nCycle, nDan, FALSE, i, j, FALSE, nVertDir);
				dDia		= GetDiaMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, FALSE, i, nIdx);
				dDiaReal	= GetDiaMainRebarUpperSlab(nCycleReal, nDan, FALSE, i, nIdx);
				bExist		= IsExistMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, FALSE, i, nIdx++);
				dDiaNext	= GetDiaMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, FALSE, i, nIdx);
				if(nIdx-1 == nCountJoint-1 && i < m_nQtyJigan-1)
				{
					dDiaNext	= GetDiaMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, FALSE, i+1, 0);
				}

				// 철근 하나 추가
				pArrRCLower->Add(new CRebarInfoCycle);
				pRC = pArrRCLower->GetAt(pArrRCLower->GetSize()-1);

				// 공통속성
				pRC->m_nTypeRebar	= REBAR_TYPE_MAIN;
				pRC->m_nRebarDan	= 0;
				pRC->m_nPosStt		= REBARINFO_POS_UPPERSLAB_LOWER;
				pRC->m_nPosEnd		= REBARINFO_POS_UPPERSLAB_LOWER;
				pRC->m_Dia			= dDia;
				pRC->m_bExist		= bExist;


				// 첫번째 지간에 첫번째 이음까지의 철근 
				if(i == 0 && j == 0)
				{
					pRC->m_nPosStt	= REBARINFO_POS_UPPERSLAB_SIDE;
					dLenJoint		= GetValueJoint(pRC, dDiaNext, NULL, nVertDir);
					pRC->m_Dia		= dDiaReal;

					//pRC->m_xyMid1	= GetXyToDistFromSlabUpper(tvRebar.m_v1.x, 0, 0, dOffset, bVertDir);
					pRC->m_xyMid1	= tvRebar.m_v1;
					pRC->m_xyStt	= pRC->m_xyMid1 + CDPoint(0, 1) * dLenVerStt;
					pRC->m_xyMid2	= pRC->m_xyMid1;
					//pRC->m_xyEnd	= GetXyToDistFromSlabUpper(pRC->m_xyMid1.x, dist+dLenJoint/2, 0, dOffset, bVertDir);
					GetXyMatchLineAndLine(CDPoint(pRC->m_xyMid1.x+dist+dLenJoint/2, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyEnd);
					pRC->m_R_Mid	= 0;
					dNextStt		= pRC->m_xyEnd.x - dLenJoint;

					if(IsBlockOut(TRUE))
					{
						pRC->m_xyMid1	= pRC->m_xyStt;
						GetXyMatchLineAndLine(pRC->m_xyStt, tvRebar.GetXyDir(), pRC->m_xyStt+CDPoint(m_fxJointStt.m_dLenHorRebar[nCycleReal][nDan], 0), CDPoint(0, 1), pRC->m_xyStt);
					}
				}
				else
				{
					// 첫번째 지간 이후의 첫번째 철근
					if(j == 0)
					{
						if(m_bExpJoint[i])
						{
							pRC->m_nPosStt	= REBARINFO_POS_UPPERSLAB_SIDE;
							dLenJoint		= GetValueJoint(pRC, dDiaNext, NULL, nVertDir);
							pRC->m_Dia		= dDiaReal;

							//pRC->m_xyMid2	= GetXyToDistFromSlabUpper(dNextStt, 0, 0, dOffset, bVertDir);
							GetXyMatchLineAndLine(CDPoint(dNextStt, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyMid2);
							//pRC->m_xyEnd	= GetXyToDistFromSlabUpper(GetStationOnJijum(i, 0, bVertDir), dist + dLenJoint/2, 0, dOffset, bVertDir);
							GetXyMatchLineAndLine(CDPoint(GetStationOnJijum(i, 0, bVertDir) + dist + dLenJoint/2, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyEnd);
							pRC->m_xyStt	= pRC->m_xyMid2;
							pRC->m_xyMid1	= pRC->m_xyMid2;
							pRC->m_R_Mid	= 0;
							dNextStt		= pRC->m_xyEnd.x - dLenJoint;
						}
						else
						{
							dLenJoint		= GetValueJoint(pRC, dDiaNext, NULL, nVertDir);
							pRC->m_Dia		= dDiaReal;

							//pRC->m_xyStt	= GetXyToDistFromSlabUpper(dNextStt, 0, 0, dOffset, bVertDir);
							GetXyMatchLineAndLine(CDPoint(dNextStt, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyStt);
							//pRC->m_xyMid1	= GetXyToDistFromSlabUpper(GetStationOnJijum(i, 0, bVertDir), dist + dLenJoint/2, 0, dOffset, bVertDir);
							GetXyMatchLineAndLine(CDPoint(GetStationOnJijum(i, 0, bVertDir) + dist + dLenJoint/2, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyMid1);
							pRC->m_xyMid2	= pRC->m_xyMid1;
							pRC->m_xyEnd	= pRC->m_xyMid1;
							pRC->m_R_Mid	= 0;
							dNextStt		= pRC->m_xyMid1.x - dLenJoint;
							// 첫번째 지간 이후의 첫번째 철근은 이전 철근과 합쳐 져야 한다.
							long nCount		= pArrRCLower->GetSize();
							m_Util.MergeRebarInfoCycle(pArrRCLower, nCount-2, nCount-1);
						}
						
					}
					// 첫번째 이음 이후의 철근, 마지막 철근은 아님.
					else if(j > 0 && j < nCountJoint)
					{
						dLenJoint		= GetValueJoint(pRC, dDiaNext, NULL, nVertDir);
						pRC->m_Dia		= dDiaReal;

						//pRC->m_xyStt	= GetXyToDistFromSlabUpper(dNextStt, 0, 0, dOffset, bVertDir);
						GetXyMatchLineAndLine(CDPoint(dNextStt, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyStt);
						//pRC->m_xyMid1	= GetXyToDistFromSlabUpper(dNextStt, dist + dLenJointLast/2 + dLenJoint/2, 0, dOffset, bVertDir);
						GetXyMatchLineAndLine(CDPoint(dNextStt + dist + dLenJointLast/2 + dLenJoint/2, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyMid1);
						pRC->m_xyMid2	= pRC->m_xyMid1;
						pRC->m_xyEnd	= pRC->m_xyMid1;
						pRC->m_R_Mid	= 0;
						dNextStt		= pRC->m_xyMid1.x - dLenJoint;
					}
				}

				// 현재 지간의 마지막 철근을 구해야 되면..
				if(j == nCountJoint-1)
				{
					pArrRCLower->Add(new CRebarInfoCycle);
					pRC = pArrRCLower->GetAt(pArrRCLower->GetSize()-1);

					// 공통 속성
					pRC->m_nPosStt		= REBARINFO_POS_UPPERSLAB_LOWER;
					pRC->m_nPosEnd		= REBARINFO_POS_UPPERSLAB_LOWER;

					// 마지막 지간이면
					if(i == m_nQtyJigan-1)
					{
						dDia			= GetDiaMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, FALSE, i, nIdx);
						dDiaReal		= GetDiaMainRebarUpperSlab(nCycleReal, nDan, FALSE, i, nIdx);
						bExist			= IsExistMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, FALSE, i, nIdx++);
						pRC->m_Dia		= dDiaReal;
						pRC->m_bExist	= bExist;

						pRC->m_nPosEnd	= REBARINFO_POS_UPPERSLAB_SIDE;
						//pRC->m_xyStt	= GetXyToDistFromSlabUpper(dNextStt, 0, 0, dOffset, bVertDir);
						GetXyMatchLineAndLine(CDPoint(dNextStt, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyStt);
						//pRC->m_xyMid1	= GetXyToDistFromSlabUpper(tvRebar.m_v2.x, 0, 0, dOffset, bVertDir);
						pRC->m_xyMid1	= tvRebar.m_v2;
						pRC->m_xyMid2	= pRC->m_xyMid1;
						pRC->m_xyEnd	= pRC->m_xyMid2 + CDPoint(0, 1) * dLenVerEnd;
						pRC->m_R_Mid	= 0;
						dNextStt		= pRC->m_xyMid1.x;

						if(IsBlockOut(FALSE))
						{
							pRC->m_xyMid2	= pRC->m_xyEnd;
							GetXyMatchLineAndLine(pRC->m_xyEnd, tvRebar.GetXyDir(), pRC->m_xyEnd+CDPoint(-m_fxJointEnd.m_dLenHorRebar[nCycleReal][nDan], 0), CDPoint(0, 1), pRC->m_xyEnd);
						}
					}
					// 마지막 지간이 아니면
					else
					{
						// 신축이음인 경우 지점에서 끊어 줘야 된다.
						CJijum *pJ	= GetJijum(i+1);
						if(m_bExpJoint[i+1] && pJ)
						{
							dDia			= GetDiaMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, FALSE, i, 0);
							dDiaReal		= GetDiaMainRebarUpperSlab(nCycleReal, nDan, FALSE, i, 0);
							bExist			= IsExistMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, FALSE, i, 0);
							pRC->m_Dia		= dDiaReal;
							pRC->m_bExist	= bExist;
							double dUganP	= pJ->m_dLengthUgan[0];
							double dUganN	= pJ->m_dLengthUgan[1];
							//pRC->m_xyStt	= GetXyToDistFromSlabUpper(dNextStt, 0, 0, dOffset, bVertDir);
							GetXyMatchLineAndLine(CDPoint(dNextStt, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyStt);
							//pRC->m_xyMid1	= GetXyToDistFromSlabUpper(GetStationOnJijum(i+1, 0, bVertDir)-dUganP-dCoverSide/vAng.y, 0, 0 ,dOffset, bVertDir);
							GetXyMatchLineAndLine(CDPoint(GetStationOnJijum(i+1, 0, bVertDir)-dUganP-dCoverSide/vAng.y, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyMid1);
							pRC->m_xyMid2	= pRC->m_xyMid1;
							pRC->m_xyEnd	= pRC->m_xyMid2;
							pRC->m_xyCen	= pRC->m_xyMid1;
							pRC->m_R_Mid	= 0;
							pRC->m_nPosEnd	= REBARINFO_POS_UPPERSLAB_SIDE;
							dNextStt		= pRC->m_xyMid1.x + dCoverSide*2/vAng.y + dUganP + dUganN;
						}
						else
						{
							dDia			= GetDiaMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, FALSE, i+1, 0);
							dDiaReal		= GetDiaMainRebarUpperSlab(nCycleReal, nDan, FALSE, i+1, 0);
							bExist			= IsExistMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, FALSE, i+1, 0);
							dDiaNext		= GetDiaMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, FALSE, i+2, 0);
							pRC->m_Dia		= dDia;
							pRC->m_bExist	= bExist;
							dLenJoint		= GetValueJoint(pRC, dDiaNext, NULL, nVertDir);
							pRC->m_Dia		= dDiaReal;

							//pRC->m_xyStt	= GetXyToDistFromSlabUpper(dNextStt, 0, 0, dOffset, bVertDir);
							GetXyMatchLineAndLine(CDPoint(dNextStt, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyStt);
							//pRC->m_xyMid1	= GetXyToDistFromSlabUpper(GetStationOnJijum(i+1, 0), 0, 0, dOffset, bVertDir);
							GetXyMatchLineAndLine(CDPoint(GetStationOnJijum(i+1, 0), 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyMid1);
							pRC->m_xyMid2	= pRC->m_xyMid1;
							pRC->m_xyEnd	= pRC->m_xyMid1;
							pRC->m_xyCen	= pRC->m_xyMid1;
							pRC->m_R_Mid	= 0;
							dNextStt		= pRC->m_xyMid1.x - dLenJoint/2;
						}
					}
				}

				// 두번째 지간부터는 이전 지간에 이음이 있는지 없는지 검사를 해야 되며
				// 마지막 지간의 경우 현재 지간에 이음이 있는지 없는지 검사를 해야 된다.
				if(j == 0)
				{
					if(i > 0)
					{
						if(GetCountJointMainRebarUpperSlab(nCycle, nDan, FALSE, i-1) == 0)
						{
							long nSize	= pArrRCLower->GetSize();
							if(nSize > 1)
							{
								if(nCountJoint == 1)
									m_Util.MergeRebarInfoCycle(pArrRCLower, nSize-3, nSize-2);
								else
									m_Util.MergeRebarInfoCycle(pArrRCLower, nSize-2, nSize-1);
							}
						}
					}

					if(i == m_nQtyJigan-1)
					{
						if(GetCountJointMainRebarUpperSlab(nCycle, nDan, FALSE, i) == 0)
						{
							long nSize	= pArrRCLower->GetSize();
							if(nSize > 1)
								m_Util.MergeRebarInfoCycle(pArrRCLower, nSize-2, nSize-1);
						}
					}
				}
			}

			// 두번째 지간부터는 이전 지간의 이음이 0개인지 검사해서 0개이면 합쳐 버린다.
			if(i > 0)
			{
				if(GetCountJointMainRebarUpperSlab(nCycle, nDan, FALSE, i-1) == 0)
				{
					long nSize	= pArrRCLower->GetSize();
					if(nSize > 1)
					{
						m_Util.MergeRebarInfoCycle(pArrRCLower, nSize-2, nSize-1);
					}
				}
			}
		}
	}


	// 하면은 2,3에 대해서 모두 만든 뒤에 각 지각의 중앙에 있는 철근에 대해서만 설치여부를 결정한다.
	// 그리고 철근 위치를 1단 철근과 같게 만들어 준다.
	if(nDan > 0 && !m_bDetailInput23DanMainRebar)
	{
		CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRCLower1Dan	= &m_pArrRCMainUpperSlab[nCycle][iLOWER][0];

		long i = 0; for(i = 0; i < pArrRCLower->GetSize(); i++)
		{
			CRebarInfoCycle *pRC	= pArrRCLower->GetAt(i);
			pRC->m_xyMid1	= pRC->m_xyEnd;
			pRC->m_xyMid2	= pRC->m_xyEnd;
			long j = 0; for(j = 0; j < pArrRCLower1Dan->GetSize(); j++)
			{
				CRebarInfoCycle *pRC1	= pArrRCLower1Dan->GetAt(j);
				double dMidX	= (pRC->m_xyStt.x+pRC->m_xyMid1.x)/2;
				if(pRC1->m_xyStt.x < dMidX && pRC1->m_xyMid1.x > dMidX)
				{
					pRC->m_xyStt.x	= pRC1->m_xyStt.x;
					pRC->m_xyMid1.x	= pRC1->m_xyEnd.x;
					pRC->m_xyMid2.x	= pRC1->m_xyEnd.x;
					pRC->m_xyEnd.x	= pRC1->m_xyEnd.x;
				}
			}

			BOOL bIs	= FALSE;
			for(long jigan = 0; jigan < m_nQtyJigan; jigan++)
			{
				double dXMid	= GetStationOnJijum(jigan, 0, bVertDir) + (GetStationOnJijum(jigan+1, 0, bVertDir) - GetStationOnJijum(jigan, 0, bVertDir))/2;

				if(pRC->m_xyStt.x < dXMid && pRC->m_xyMid1.x > dXMid)
				{
					bIs	= TRUE;
					if(nCountJointTot > 0)
					{
						pRC->m_Dia	= GetDiaMainRebarUpperSlab(nCycleReal, nDan, FALSE, 0, jigan);
						ApplyExtLength23DanMainRebar_UpperSlab(pRC, GetLengthExt23DanRebarUpperSlab(FALSE, jigan));
						if(nDan >= GetDanMainRebarUpperSlab(nCycleReal, FALSE, jigan)) 
							bIs	= FALSE;
					}
				}
			}


			if(!bIs)
			{
				delete pRC;
				pArrRCLower->RemoveAt(i);
				i--;
			}
		}
	}

	// 외측벽체 이음이 0개인 경우 상부슬래브와 연결되서 편입된다.
	long stt = 0; for(stt = 0; stt < 2; stt++)
	{
		BOOL bStt	= stt == iSTT;
		if(GetCountJointMainRebarOutWall(nCycle, nDan, bStt, FALSE) == 0 && IsEnableJointMainRebar_OutWallOutterAndUpperSlabUpper(bStt, nCycle==0||nCycle==2))
		{
			CRebarInfoCycle *pRCUpperSlab	= GetRebarInfoCycleUpperSlab(nCycle, nDan, TRUE, bStt?0:-1);
			CRebarInfoCycle *pRCOutWall		= GetRebarInfoCycleOutWall(nCycle, nDan, bStt, FALSE, bStt?0:-1);
			if(pRCUpperSlab && pRCOutWall)
			{
				if(bStt)
				{
					pRCUpperSlab->m_xyEndExt	= pRCUpperSlab->m_xyEnd;
					pRCUpperSlab->m_xyMidExt	= pRCUpperSlab->m_xyMid2;
					pRCUpperSlab->m_xyEnd		= pRCUpperSlab->m_xyMid1;
					pRCUpperSlab->m_xyCenExt	= pRCUpperSlab->m_xyCen;
					pRCUpperSlab->m_R_MidExt	= pRCUpperSlab->m_R_Mid;
					pRCUpperSlab->m_bUseCenExt	= TRUE;
					pRCUpperSlab->m_bUseMidExt	= TRUE;
					pRCUpperSlab->m_bUseEndExt	= TRUE;
					pRCUpperSlab->m_xyMid2		= pRCOutWall->m_xyMid2;
					pRCUpperSlab->m_xyMid1		= pRCOutWall->m_xyMid1;
					pRCUpperSlab->m_xyStt		= pRCOutWall->m_xyStt;
					pRCUpperSlab->m_xyCen		= pRCOutWall->m_xyCen;
					pRCUpperSlab->m_R_Mid		= pRCOutWall->m_R_Mid;

					pRCUpperSlab->m_nPosStt		= pRCOutWall->m_nPosStt;
					AhTPADelete(&m_pArrRCMainOutWall[nCycleReal][stt][iOUTTER][nDan], (CRebarInfoCycle*)0);
				}
				else
				{
					pRCUpperSlab->m_xyEnd		= pRCOutWall->m_xyMid2;
					pRCUpperSlab->m_xyMidExt	= pRCOutWall->m_xyMid1;
					pRCUpperSlab->m_xyEndExt	= pRCOutWall->m_xyStt;
					pRCUpperSlab->m_xyCenExt	= pRCOutWall->m_xyCen;
					pRCUpperSlab->m_R_MidExt	= pRCOutWall->m_R_Mid;
					pRCUpperSlab->m_bUseMidExt	= TRUE;
					pRCUpperSlab->m_bUseEndExt	= TRUE;
					pRCUpperSlab->m_bUseCenExt	= TRUE;

					pRCUpperSlab->m_nPosEnd		= pRCOutWall->m_nPosStt;
					AhTPADelete(&m_pArrRCMainOutWall[nCycleReal][stt][iOUTTER][nDan], (CRebarInfoCycle*)0);
				}
			}
		}
	}

	// Not Exist인 rc 제거
	/*
	if(!bInput)
		RemoveNotExistRebarInfoCycle(pArrRCLower);
		*/

	// szMark 설정
	SetStringMarkToRebarInfoCycle(pArrRCLower, MARK_UPPERSLAB_LOWER, nCycleReal, bInput, bInput, nDan);
	// sDescription 설정
	SetStringDescriptionRebarInfoCycle_UpperSlab(pArrRCLower, nCycleReal, FALSE, nDan);

	SettingAngleInfoAtRebarInfoCycle_UpperSlab(pArrRCLower, 0, -1, -1, bVertDir);
}


// 종단면에서 nDan만큼 옵셋한 tvArr 리턴(상부슬래브)
// BOOL bApplyFlexibleJoint : 상면 구할때 신축이음 고려해서 구할지?
CTwinVector CRcBridgeRebar::GetTvOffset_UpperSlab(long nDan, BOOL bUpper, double dSttSta, double dEndSta, BOOL bVertDir, BOOL bApplyFlexibleJoint)
{
	CTwinVector tv;
	CDPoint vAngStt	= bVertDir ? CDPoint(0, 1) : GetAngleJijum(0);
	CDPoint vAngEnd	= bVertDir ? CDPoint(0, 1) : GetAngleJijum(m_nQtyJigan);
	
	// dSttSta와 dEndSta가 모두 -1이면 벽체 시작부터 끝까지로 인식...
	double dCoverSideStt	= nDan > -1 ? m_dCoverWallOut[nDan] : 0;//IsOutWall(TRUE) ? m_dCoverWallOut[nDan] : GetCoverSide_UpperSlab(nDan);
	double dCoverSideEnd	= nDan > -1 ? m_dCoverWallOut[nDan] : 0;//IsOutWall(FALSE) ? m_dCoverWallOut[nDan] : GetCoverSide_UpperSlab(nDan);

	CTwinVectorArray *pTvArrVertSection	= bVertDir ? &m_tvArrVertSection_Vert_Center[m_nTypeJongdanForRebar] : &m_tvArrVertSection_Ang_Center[m_nTypeJongdanForRebar][0];;

	if(Compare(dSttSta, -1.0, "=") && Compare(dEndSta, -1.0, "="))
	{
		CTwinVector tvUpper;
		CTwinVector tvStt, tvEnd;
		CString str	= IsOutWall(TRUE) ? "시점브라켓상부측면" : "시점슬래브측면";
		pTvArrVertSection->GetTvByInfo(str, tvStt);
		dSttSta = tvStt.m_v2.x;


		str	= IsOutWall(FALSE) ? "종점브라켓상부측면" : "종점슬래브측면";
		pTvArrVertSection->GetTvByInfo(str, tvEnd);
		dEndSta = tvEnd.m_v1.x;
		
		dSttSta += dCoverSideStt / vAngStt.y;
		dEndSta -= dCoverSideEnd / vAngEnd.y;

		tv.m_v1	= tvStt.m_v2;
		tv.m_v2	= tvEnd.m_v1;
	}

	// 상부슬래브에서 구하고자하는 tv까지의 거리
	double dOffset = bUpper ? (nDan > -1 ? m_dCoverUpper_UpperSlab[nDan] : 0) : 
							(nDan > -1 ? m_dTS - m_dCoverLower_UpperSlab[nDan] : m_dTS);
	if(nDan == -1)
		dOffset	= bUpper ? 0 : m_dTS;
	
	GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), CDPoint(dSttSta, 0), CDPoint(0, 1), tv.m_v1);
	GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), CDPoint(dEndSta, 0), CDPoint(0, 1), tv.m_v2);
	tv.m_v1.y -= dOffset;
	tv.m_v2.y -= dOffset;

	// 신축이음 적용하자
	if(bUpper && bApplyFlexibleJoint)
	{
		if(IsBlockOut(TRUE))
		{
			GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), tv.m_v1+CDPoint(m_fxJointStt.m_dWidth, 0), CDPoint(0, 1), tv.m_v1);
		}

		if(IsBlockOut(FALSE))
		{
			GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), tv.m_v2+CDPoint(-m_fxJointEnd.m_dWidth, 0), CDPoint(0, 1), tv.m_v2);
		}
	}

	return tv;
}

// 종단면에서 nDan만큼 옵셋한 tvArr리턴(외측벽체) 
// bStt : 시점측 벽체 
// 브라켓상부측면 상단에서 기초위 까지 리턴
// 철근배근을 위해서..
// 방향 : 기초에서 상부슬래브 방향
CTwinVector CRcBridgeRebar::GetTvOffset_OutWall(long nDan, BOOL bStt, BOOL bInner, BOOL bVertDir)
{
	CTwinVector tvStt, tvEnd;
	CTwinVector tv;
	CRebarPlacing rb;
	double dOffset	= 0;
	CTwinVector tvUpper, tvLower;	// 상부슬래브 상면 철근과 기초하면의 철근...
	CDPoint vAng	= bVertDir ? CDPoint(0, 1) : (bStt ? GetAngleJijum(0) : GetAngleJijum(m_nQtyJigan));
	double dCoverWallIn		= IsOutWall(bStt) ? m_dCoverWallIn[nDan]/vAng.y : m_dCoverSide_UpperSlab[nDan]/vAng.y;
	double dCoverWallOut	= IsOutWall(bStt) ? m_dCoverWallOut[nDan]/vAng.y : m_dCoverSide_UpperSlab[nDan]/vAng.y;

	// 이렇게 쓰면 현재 상태가 vertDir TRUE면 bVertDir과 상관없이 같은게 나오겠지..
	// CTwinVectorArray *pTvArrVertSection	= bVertDir ? &m_tvArrVertSection_Vert_Center[m_nTypeJongdanForRebar] : &m_tvArrVertSection;
	CTwinVectorArray *pTvArrVertSection	= bVertDir ? &m_tvArrVertSection_Vert_Center[m_nTypeJongdanForRebar] : &m_tvArrVertSection_Ang_Center[m_nTypeJongdanForRebar][0];
	
	if(!IsOutWall(bStt)) 
	{
		// 벽체가 없는 경우 슬래브 측면을 대신 리턴
		CString str		= bStt ? "시점슬래브측면" : "종점슬래브측면";
		pTvArrVertSection->GetTvByInfo(str, tv);
		if(!bStt) GetSwap(tv.m_v1, tv.m_v2);
		rb.Offset(tv.m_v1, tv.m_v2, dCoverWallOut);

		CDPoint xyDir	= tv.GetXyDir();
		tv.m_v1			= tv.m_v1 + (xyDir * m_dCoverLower_UpperSlab[nDan]);
		tv.m_v2			= tv.m_v2 + (-xyDir * m_dCoverUpper_UpperSlab[nDan]);
		return tv;
	}

	// 상부와 하부 기준이 되는 선을 찾음
	tvUpper	= GetTvOffset_UpperSlab(nDan, TRUE, -1, -1, bVertDir);
	if(IsBoxType())
	{
		CString str	= bStt ? "하부슬래브하면(시점벽체아래)" : "하부슬래브하면(종점벽체아래)";
		m_tvArrVertSection.GetTvByInfo(str, tvLower);
		if(bStt==FALSE) GetSwap(tvUpper.m_v1, tvUpper.m_v2);
		tvLower.m_v1.y += m_dCoverLower_LowerSlab[nDan];
		tvLower.m_v2.y += m_dCoverLower_LowerSlab[nDan];
	}
	else
	{
		CFootingApp *pFooting = bStt ? &m_footingStt : &m_footingEnd;
		pFooting->m_tvArrFront.GetTvByInfo("기초하면", tvLower);
		tvLower.m_v1.y += pFooting->m_dCoverLower[nDan];
		tvLower.m_v2.y += pFooting->m_dCoverLower[nDan];
	}

	// 시점측
	if(bStt)
	{
		if(bInner)
		{
			pTvArrVertSection->GetTvByInfo("시점벽체우측면", tv);
			GetSwap(tv.m_v1, tv.m_v2);
			dOffset = -dCoverWallIn;
			rb.Offset(tv.m_v1, tv.m_v2, dOffset);

			GetXyMatchSegAndLine(tvLower.m_v1, tvLower.m_v2, tv.m_v1, tv.GetXyDir(), tv.m_v1);
			GetXyMatchSegAndLine(tvUpper.m_v1, tvUpper.m_v2, tv.m_v1, tv.GetXyDir(), tv.m_v2);
		}
		else
		{
			pTvArrVertSection->GetTvByInfo("시점브라켓상부측면", tvEnd);
			pTvArrVertSection->GetTvByInfo("시점벽체좌측면", tvStt);
			tv.m_v1 = CVector(tvEnd.m_v1.x, tvStt.m_v1.y, 0);
			tv.m_v2 = tvEnd.m_v2;
			dOffset	= dCoverWallOut;
			rb.Offset(tv.m_v1, tv.m_v2, dOffset);

			GetXyMatchSegAndSeg(tv.m_v1, tv.m_v2, tvLower.m_v1, tvLower.m_v2, tv.m_v1);
			GetXyMatchSegAndSeg(tv.m_v1, tv.m_v2, tvUpper.m_v1, tvUpper.m_v2, tv.m_v2);
		}
	}
	else
	{
		if(bInner)
		{
			pTvArrVertSection->GetTvByInfo("종점벽체좌측면", tv);
			dOffset	= dCoverWallIn;
			rb.Offset(tv.m_v1, tv.m_v2, dOffset);

			GetXyMatchSegAndSeg(tv.m_v1, tv.m_v2, tvLower.m_v1, tvLower.m_v2, tv.m_v1);
			GetXyMatchSegAndSeg(tv.m_v1, tv.m_v2, tvUpper.m_v1, tvUpper.m_v2, tv.m_v2);
		}
		else
		{
			pTvArrVertSection->GetTvByInfo("종점브라켓상부측면", tvEnd);
			pTvArrVertSection->GetTvByInfo("종점벽체우측면", tvStt);
			tv.m_v1 = CVector(tvEnd.m_v1.x, tvStt.m_v2.y, 0);
			tv.m_v2 = tvEnd.m_v2;
			dOffset	= -dCoverWallOut;
			rb.Offset(tv.m_v1, tv.m_v2, dOffset);
			GetXyMatchSegAndSeg(tv.m_v1, tv.m_v2, tvLower.m_v1, tvLower.m_v2, tv.m_v1);
			GetXyMatchSegAndSeg(tv.m_v1, tv.m_v2, tvUpper.m_v1, tvUpper.m_v2, tv.m_v2);
		}
	}


	// 외측벽체 X좌표는 상부슬래브 X좌표와 같아야 된다.
	// 그래야 이음이 정확하게구해짐
	if(!bInner)
	{
		CTwinVector tvUpper	= GetTvOffset_UpperSlab(nDan, TRUE, -1, -1, bVertDir);

		if(bStt)
			tv.m_v1.x	= tvUpper.m_v1.x;
		else
			tv.m_v2.x	= tvUpper.m_v2.x;
	}
	


	return tv;
}


// 2단이상 철근의 단수 설정 기본값 
// nType 0 : 상부슬래브
// nType 1 : 외측벽체
// nType 2 : 내측벽체
// nType 3 : 기초
// nType 4 : 리브
// nType 5 : 하부슬래브
// nType -1 : 모두
void CRcBridgeRebar::SetDataDefaultSetRebarDan(long nType)
{
	// 상부철근
	if(nType == 0 || nType == -1)
	{
		long upper = 0; for(upper = 0; upper < 2; upper++)
		{
			BOOL bUpper	= upper == iUPPER;
			long nCountNeedSetRebarDan = (bUpper) ? m_nQtyJigan+1 : m_nQtyJigan;
			AhTPAMake(nCountNeedSetRebarDan, &m_pArrSetRebarDanUpperSlab[upper], (CSetRebarDan*)0);
			long nCount = m_pArrSetRebarDanUpperSlab[upper].GetSize();
			long i = 0; for(i = 0; i < nCount; i++)
			{
				CSetRebarDan *pSetRebarDan = m_pArrSetRebarDanUpperSlab[upper].GetAt(i);
				pSetRebarDan->Init();

				// 벽체가 없는 경우 하면 철근의 2,3단 연장길이는 권고안을 0으로 한다.
				if(!bUpper && (!IsOutWall(TRUE) || !IsOutWall(FALSE)))
					pSetRebarDan->m_dLengthExt23DanRebar	= 0;
			}
		}
	}

	// 외측벽체
	if(nType == 1 || nType == -1)
	{
		long stt = 0; for(stt = 0; stt < 2; stt++)
		{
			for(long inner = 0; inner < 2; inner++)
			{
				m_pArrSetRebarDanOutWall[stt][inner].Init();
			}
		}
	}

	if(nType == 2 || nType == -1)
	{
		long nCountInWall	= GetCountInWall();
		for(long wall = 0; wall < nCountInWall; wall++)
		{
			CWallApp *pWall	= GetInWall(wall);
			if(pWall)
			{
				pWall->m_setRebarDan[iLEFT].Init();	
				pWall->m_setRebarDan[iRIGHT].Init();
			}
		}
	}

	if(nType == 3 || nType == -1)
	{
		long nCountFooting	= GetCountFooting();
		for(long footing = 0; footing < nCountFooting; footing++)
		{
			CFootingApp *pFooting	= GetFooting(footing);
			if(pFooting)
			{
				pFooting->m_setRebarDan[iUPPER].Init();
				pFooting->m_setRebarDan[iLOWER].Init();
				
			}
		}
	}

	if(nType == 4 || nType == -1)
	{
		long cycle = 0; for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
		{
			long upper = 0; for(upper = 0; upper < 2; upper++)
			{
				m_nCountDanMainRebarRib[cycle][upper]	= 1;
			}
		}
	}

	// 하부철근
	if(nType == 5 || (nType == -1 && m_nTypeBridge == BRIDGE_TYPE_BOX))
	{
		long upper = 0; for(upper = 0; upper < 2; upper++)
		{
			BOOL bUpper	= upper == iUPPER;
			long nCountNeedSetRebarDan = (!bUpper) ? m_nQtyJigan+1 : m_nQtyJigan;
			AhTPAMake(nCountNeedSetRebarDan, &m_pArrSetRebarDanLowerSlab[upper], (CSetRebarDan*)0);
			long nCount = m_pArrSetRebarDanLowerSlab[upper].GetSize();
			long i = 0; for(i = 0; i < nCount; i++)
			{
				CSetRebarDan *pSetRebarDan = m_pArrSetRebarDanLowerSlab[upper].GetAt(i);
				pSetRebarDan->Init();

				// 벽체가 없는 경우 하면 철근의 2,3단 연장길이는 권고안을 0으로 한다.
				if(!bUpper && (!IsOutWall(TRUE) || !IsOutWall(FALSE)))
					pSetRebarDan->m_dLengthExt23DanRebar	= 0;
			}
		}
	}
}


// 입력된 정보로 외측벽체 철근 생성(cycle1,2,3,4)
// 외측벽체는 이음이 없을 수가 없다. (캬캬 그래서 이음 0개에 대해서 고려할게 별로 없음)
void CRcBridgeRebar::MakeRebarInfoCycle_OutWall(long nCycle, long nDan, BOOL bInput, long nVertDir)
{
	if(IsBoxType())
	{
		// Box타입 일때는 따로 만들어준다.
		MakeRebarInfoCycle_OutWallBoxType(nCycle, nDan, bInput, nVertDir);
		return;
	}
	if(nCycle == -1) nCycle = GetCountCycleMainRebar() - 1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar() - 1) return;
	BOOL bVertDir	= IsVertDir();
	if(nVertDir != 0)
		bVertDir	= nVertDir == -1 ? TRUE : FALSE;

	AhTPADelete(&m_pArrRCMainOutWall[nCycle][iSTT][iINNER][nDan], (CRebarInfoCycle*)0);
	AhTPADelete(&m_pArrRCMainOutWall[nCycle][iSTT][iOUTTER][nDan], (CRebarInfoCycle*)0);
	AhTPADelete(&m_pArrRCMainOutWall[nCycle][iEND][iINNER][nDan], (CRebarInfoCycle*)0);
	AhTPADelete(&m_pArrRCMainOutWall[nCycle][iEND][iOUTTER][nDan], (CRebarInfoCycle*)0);
	
	long nCycleReal	= nCycle;
	if(!m_bDetailInput23DanMainRebar)
	{
 		if(nDan > 0)
			nCycle	= 1;
	}
	CRebarPlacing rbPlacing;
	CTwinVector tv;
	CTwinVectorArray tvArr, tvArrTmp;

	// 공통사용 변수
	CTwinVector tvRebar;	// 외측벽체 외측 좌표
	CDPoint xyStt(0, 0);
	double dNextStt		= -1;	// 다음 철근의 시작위치(이음길이 고려한 위치)
	long nSize			= 0;	
	double dist			= 0;
	double dLenRound	= 0;	// 가장자리 철근의 모따리나 라운드 크기
	double dDia			= 0;	// 철근 지름
	double dDiaReal		= 0;
	BOOL bExist			= FALSE;
	double dDiaNext		= 0;	// 이음 길이를 구하기 위한 다음 철근 지름
	BOOL bStt			= TRUE;
	BOOL bInner			= TRUE;
	long nCountJoint	= 0;
	long nCountRealJoint	= 0;
	CDPoint vAng	= CDPoint(0, 1);
	const double dSettleOfFooting	= 500;
	double dLenJoint	= 0;
	double dLenJointLast	= 0;

	
	BOOL bCheckDist	= TRUE;	// 벽체 내측의 경우 이음이 없어도 생성이 될 수 있으므로 실제 이음 거리를 체크하지 않아야 할 때가 있다.
	BOOL bIsMainRebarUpperSlab	= FALSE;	// 상부슬래브와 연결되서 실제 지름이 상부슬래브 철근이 적용되어야 하는지??
	
	// 시,종점측 외측벽체 외측면 주철근 1단 1사이클
	long stt = 0; for(stt = 0; stt < 2; stt++)
	{
		bStt	= (stt == iSTT);
		vAng	= bVertDir ? CDPoint(0, 1) : GetAngleJijum(bStt ? 0 : m_nQtyJigan);
		if(IsOutWall(bStt))
		{
			CTwinVector tv;
			CFootingApp *pFooting = (bStt) ? &m_footingStt : &m_footingEnd;
			pFooting->m_tvArrFront.GetTvByInfo("기초하면", tv);

			// 내측, 외측 
			for(long inner = 0; inner < 2; inner++)
			{ 
				bInner		= (inner == iINNER);
				tvRebar		= GetTvOffset_OutWall(nDan, bStt, bInner, bVertDir);
				xyStt		= CDPoint(tvRebar.m_v1.x, tv.m_v1.y + pFooting->m_dCoverLower[0]);	// 시작위치
				dNextStt	= xyStt.y;
				nCountJoint	= GetCountJointMainRebarOutWall(nCycle, nDan, bStt, bInner);
				nCountRealJoint	= nCountJoint;
				bCheckDist	= TRUE;
				bIsMainRebarUpperSlab	= FALSE;

				if(nDan >= GetDanMainRebarOutWall(nCycleReal, bStt, bInner)) continue;

			
				if(nCountJoint == 0)
				{
					nCountJoint	= 1;	// 외측벽체는 이음이 무조건 1개이상이다.(상부슬래브와 항상 연결되면서 이음이 생김)
					// 내측벽체의 경우 계산 실제 변수까지 속여야 됨.
					if(bInner)
					{
						if(nCycle == 0 || nCycle == 2)
							m_nCountJointMainRebar_OutWall_Cycle1[stt][inner][0]	= 1;
						else
							m_nCountJointMainRebar_OutWall_Cycle2[stt][inner][0]	= 1;
						bCheckDist	= FALSE;
					}
					else
					{
						if(nDan == 0 && IsEnableJointMainRebar_OutWallOutterAndUpperSlabUpper(bStt, nCycle==0||nCycle==2))
						{
							bCheckDist	= FALSE;
							bIsMainRebarUpperSlab	= TRUE;
						}

						//#0029461
						//m_bDetailInput23DanMainRebar의 값이 FALSE면서 nDan이 0보다 큰경우 기본값을 설정하지 않게된다... 때문에 dDist와 bExist가 0값이 되어 철근을 그리지 못하게 된다.
						if(m_bDetailInput23DanMainRebar == FALSE && nDan > 0)
							bCheckDist = FALSE;
					}

					
				}


				for(long joint = 0; joint < nCountJoint; joint++)
				{
					dLenJointLast	= dLenJoint;
					dist = GetDistMainRebarOutWall(nCycle, nDan, bStt, bInner, joint, FALSE);
					
					if(Compare(dist, 0.0, "=") && bCheckDist) continue;

					// 철근 지름과 가장자리철근 모따기밑 라운드 크기 ////////////
					dDia	= !bIsMainRebarUpperSlab ? GetDiaMainRebarOutWall(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, bStt, bInner, joint) : GetDiaMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, 0, 0);
					dDiaReal	= !bIsMainRebarUpperSlab ? GetDiaMainRebarOutWall(nCycleReal, nDan, bStt, bInner, joint) : GetDiaMainRebarUpperSlab(nCycleReal, nDan, TRUE, 0, 0);
					bExist	= !bIsMainRebarUpperSlab ? IsExistMainRebarOutWall(nCycleReal, nDan, bStt, bInner, joint) : IsExistMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, 0, 0);
					dDiaNext	= GetDiaMainRebarOutWall(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, bStt, bInner, joint+1);

					
					//#0029461
					//m_bDetailInput23DanMainRebar의 값이 FALSE이고 nDan이 0보다 큰경우 기본값을 설정하지 않게된다... 때문에 dDist와 bExist가 0값이 되어 철근을 그리지 못하게 된다.
					if(bCheckDist == FALSE && m_bDetailInput23DanMainRebar == FALSE && nDan > 0)
						bExist = TRUE;

					dLenRound	= (joint == 0) ? GetLenRebarAtEdge(dDiaReal, TRUE) : GetLenRebarAtEdge(dDiaReal);
					/////////////////////////////////////////////////////////////////

					// 외측벽체 철근 마지막이면 상부슬래브 첫번째나 마지막 철근과 비교해서 이음장 구함.
					if(Compare(dDiaNext, 0.0, "=") && !bInner && joint == nCountJoint-1)
					{
						dDiaNext	= GetDiaMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, bStt ? 0 : m_nQtyJigan-1, bStt ? 0 : -1);
					}


					m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan].Add(new CRebarInfoCycle);
					CRebarInfoCycle *pRC	= m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan].GetAt(m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan].GetSize()-1);

					// 공통속성
					pRC->m_nTypeRebar	= REBAR_TYPE_MAIN;
					pRC->m_nPosStt		= bStt ? (bInner ? REBARINFO_POS_STTWALL_INNER : REBARINFO_POS_STTWALL_OUTTER) 
												: (bInner ? REBARINFO_POS_ENDWALL_INNER : REBARINFO_POS_ENDWALL_OUTTER);
					pRC->m_nPosEnd		= pRC->m_nPosStt;
					pRC->m_Dia			= dDiaReal;
					pRC->m_bExist		= bExist;
					pRC->m_nRebarDan	= 0;
					

					// 시작위치는 항상 기초에서 시작한다.
					if(joint == 0)
					{
						pRC->m_nPosStt	= REBARINFO_POS_FOOTING_LOWER;
						pRC->m_Dia		= dDia;
						dLenJoint		= GetValueJoint(pRC, dDiaNext);
						pRC->m_Dia		= dDiaReal;

						double sw		= bStt ? -1 : 1;
						sw				= bInner ? sw*-1 : sw;
						// 앞굽이 너무 작으면 sw를 다시 반대로 함
						if(bInner)
						{
							if((bStt && m_footingStt.m_dFWR < dLenRound+dSettleOfFooting) || (!bStt && m_footingEnd.m_dFWL < dLenRound+dSettleOfFooting))
							{
								sw	= sw * -1;
							}
						}
						pRC->m_xyStt	= CDPoint(xyStt.x + (dLenRound+dSettleOfFooting)*sw, dNextStt);
						pRC->m_xyMid1	= CDPoint(pRC->m_xyStt.x + (dSettleOfFooting*sw*-1), pRC->m_xyStt.y);
						pRC->m_xyMid2	= CDPoint(pRC->m_xyMid1.x + (dLenRound*sw*-1), pRC->m_xyMid1.y + dLenRound);
						pRC->m_xyEnd	= CDPoint(pRC->m_xyMid2.x, pRC->m_xyMid2.y + dist + dLenJoint/2);
						pRC->m_xyCen	= CDPoint(pRC->m_xyMid1.x, pRC->m_xyMid2.y);
						pRC->m_R_Mid	= dLenRound;
						pRC->m_bRevArc	= bStt ? (bInner ? TRUE : FALSE) : (bInner ? FALSE : TRUE);
						dNextStt		= pRC->m_xyEnd.y - dLenJoint;
					}
					else
					{
						pRC->m_Dia		= dDia;
						dLenJoint	= GetValueJoint(pRC, dDiaNext);
						pRC->m_Dia		= dDiaReal;

						pRC->m_xyStt	= CDPoint(xyStt.x, dNextStt);
						pRC->m_xyMid1	= CDPoint(pRC->m_xyStt.x, pRC->m_xyStt.y + dist + dLenJoint/2 + dLenJointLast/2);
						pRC->m_xyMid2	= pRC->m_xyMid1;
						pRC->m_xyEnd	= pRC->m_xyMid1;
						pRC->m_xyCen	= pRC->m_xyMid1;
						pRC->m_R_Mid	= 0;
						dNextStt		= pRC->m_xyMid1.y - dLenJoint;
					}

					// 내측벽체이고 마지막 이음이면 상부슬래브와 연결되는 철근을 하나 더 만들어 뿐다.
					if(bInner && joint == nCountJoint-1)
					{
						m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan].Add(new CRebarInfoCycle);
						CRebarInfoCycle *pRC	= m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan].GetAt(m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan].GetSize()-1);
						dDia				= GetDiaMainRebarOutWall(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, bStt, bInner, -1);
						dDiaReal			= GetDiaMainRebarOutWall(nCycleReal, nDan, bStt, bInner, -1);
						bExist				= IsExistMainRebarOutWall(nCycleReal, nDan, bStt, bInner, -1);
						
						// 공통속성
						pRC->m_nTypeRebar	= REBAR_TYPE_MAIN;
						pRC->m_nPosStt		= bStt ? REBARINFO_POS_STTWALL_INNER : REBARINFO_POS_ENDWALL_INNER;
						pRC->m_nPosEnd		= pRC->m_nPosStt;
						pRC->m_Dia			= dDiaReal;
						pRC->m_bExist		= bExist;
						pRC->m_nRebarDan	= 0;
						
						// 내측철근 마지막 이음 끝부터 상부슬래브 1단철근까지의 거리
						double dLen		= GetLenRebarBeforeEdge_UpperSlab_Cycle13(nCycle, nDan, bStt, bInner, nVertDir) - dLenJoint/2;	
						pRC->m_xyStt	= CDPoint(xyStt.x, dNextStt);
						pRC->m_xyMid1	= CDPoint(pRC->m_xyStt.x, pRC->m_xyStt.y + dLen + dLenJoint/2);
						pRC->m_xyMid2	= pRC->m_xyMid1;
						pRC->m_xyEnd	= pRC->m_xyMid1;
						pRC->m_xyCen	= pRC->m_xyMid1;
						pRC->m_R_Mid	= 0;
						dNextStt		= pRC->m_xyMid1.y - dLenJoint;
					}
				}

				// 내측일 경우 이음이 없으면 앞뒤로 합쳐준다.
				if(bInner && nCountRealJoint == 0)
				{
					nSize = m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan].GetSize();
					if(nSize > 1)
					{
						m_Util.MergeRebarInfoCycle(&m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan], nSize-2, nSize-1);
					}
					if(nCycle == 0 || nCycle == 2)
						m_nCountJointMainRebar_OutWall_Cycle1[stt][inner][0]	= 0;
					else
						m_nCountJointMainRebar_OutWall_Cycle2[stt][inner][0]	= 0;
				}

				/*
				// 외측벽체 이음이 0개인 경우 상부슬래브와 연결되서 편입된다.
				if(!bInner && GetCountJointMainRebarOutWall(nCycle, nDan, bStt, bInner) == 0 && IsEnableJointMainRebar_OutWallOutterAndUpperSlabUpper(bStt, nCycle==0||nCycle==2))
				{
					CRebarInfoCycle *pRCUpperSlab	= GetRebarInfoCycleUpperSlab(nCycle, nDan, TRUE, bStt?0:-1);
					CRebarInfoCycle *pRCOutWall		= GetRebarInfoCycleOutWall(nCycle, nDan, bStt, bInner, bStt?0:-1);
					if(pRCUpperSlab && pRCOutWall)
					{
						if(bStt)
						{
							pRCUpperSlab->m_xyEndExt	= pRCUpperSlab->m_xyEnd;
							pRCUpperSlab->m_xyMidExt	= pRCUpperSlab->m_xyMid2;
							pRCUpperSlab->m_xyEnd		= pRCUpperSlab->m_xyMid1;
							pRCUpperSlab->m_xyCenExt	= pRCUpperSlab->m_xyCen;
							pRCUpperSlab->m_R_MidExt	= pRCUpperSlab->m_R_Mid;
							pRCUpperSlab->m_bUseCenExt	= TRUE;
							pRCUpperSlab->m_bUseMidExt	= TRUE;
							pRCUpperSlab->m_bUseEndExt	= TRUE;
							pRCUpperSlab->m_xyMid2		= pRCOutWall->m_xyMid2;
							pRCUpperSlab->m_xyMid1		= pRCOutWall->m_xyMid1;
							pRCUpperSlab->m_xyStt		= pRCOutWall->m_xyStt;
							pRCUpperSlab->m_xyCen		= pRCOutWall->m_xyCen;
							pRCUpperSlab->m_R_Mid		= pRCOutWall->m_R_Mid;

							pRCUpperSlab->m_nPosStt		= pRCOutWall->m_nPosStt;
							AhTPADelete(&m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan], (CRebarInfoCycle*)0);
						}
						else
						{
							pRCUpperSlab->m_xyEnd		= pRCOutWall->m_xyMid2;
							pRCUpperSlab->m_xyMidExt	= pRCOutWall->m_xyMid1;
							pRCUpperSlab->m_xyEndExt	= pRCOutWall->m_xyStt;
							pRCUpperSlab->m_xyCenExt	= pRCOutWall->m_xyCen;
							pRCUpperSlab->m_R_MidExt	= pRCOutWall->m_R_Mid;
							pRCUpperSlab->m_bUseMidExt	= TRUE;
							pRCUpperSlab->m_bUseEndExt	= TRUE;
							pRCUpperSlab->m_bUseCenExt	= TRUE;

							pRCUpperSlab->m_nPosEnd		= pRCOutWall->m_nPosStt;
							AhTPADelete(&m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan], (CRebarInfoCycle*)0);
						}
					}
				}
				*/


				// 2,3단은 확장길이 적용
				if(nDan > 0 && !m_bDetailInput23DanMainRebar)
				{ 
					ApplyExtLength23DanMainRebar_OutWall(&m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan], GetLengthExt23DanRebarOutWall(bStt, bInner));
				}

				// Not Exist인 rc 제거
				/*
				if(!bInput)
					RemoveNotExistRebarInfoCycle(&m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan]);
					*/

				// szMark 설정
				long nType	= bStt ? (bInner ? MARK_STTWALL_INNER : MARK_STTWALL_OUTTER) : (bInner ? MARK_ENDWALL_INNER : MARK_ENDWALL_OUTTER);
				SetStringMarkToRebarInfoCycle(&m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan], nType, nCycleReal, bInput, bInput || (stt==0&&inner==0&&nCycleReal==0&&nDan==0), nDan);

				// sDescription 설정
				SetStringDescriptionRebarInfoCycle_OutWall(&m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan], bStt, bInner, nDan, nCycleReal);

				// 내측이든 외측이던 마지막 철근을 길이 변화가능 철근으로 지정한다. ///
				long nSize	= m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan].GetSize();
				if(nSize > 0)
				{
					CRebarInfoCycle *pRC	= m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan].GetAt(nSize-1);
					pRC->m_bVariableLength	= TRUE;
					pRC->m_bVariablePos		= FALSE;
				}
				/////////////////////////////////////////////////////////////////////////
			}
		}
	}
}

// 헌치부 철근의 길이
// 라운드인지 모따기인지와 철근 지름에 따라 달라짐.
double CRcBridgeRebar::GetLenRebarAtEdge(double dDia, BOOL bInFooting, long nVertDir, BOOL bUpperSlab, BOOL bBending)
{
	double dLen	= 0;
	
	if(bInFooting) 
	{
		if(m_nTypeCurveOfWallVertRebar == 0)		// 자동
			dLen	= m_pARcBridgeDataStd->m_pBasicConcInfo->GetRebarInfo(dDia, BASIC_RADIUS);
		else if(m_nTypeCurveOfWallVertRebar == 1)	// 곡선
			dLen	= m_pARcBridgeDataStd->m_pBasicConcInfo->GetRebarInfo(dDia, BASIC_RADIUS);
		else									// 직선
			dLen	= 0;	

		if(m_nTypeCurveOfWallVertRebar == 0) 
		{
			if(Compare(dDia, 22.0, "<")) dLen	= 0;
		}
	}
	else
	{
		if(bBending && ((bUpperSlab && !m_bUpperSlab_CornerCurve) || (!bUpperSlab && !m_bLowerSlab_CornerCurve)))
		{
			double dTs = bUpperSlab ? m_dTS : m_dTS_Lower;
			double dTw = MIN(m_dWS, m_dWE);
			double dTh = bUpperSlab ? MIN(m_dHHS, m_dHHE) : MIN(m_dWSHH, m_dWEHH);
			double dLenTot = dTs + dTw + dTh - m_dCoverWallOut[0] - (bUpperSlab ? m_dCoverUpper_UpperSlab[0] : m_dCoverLower_LowerSlab[0]);

			dLen = dLenTot * (bUpperSlab ? m_dDanCorner_UpperVert : m_dDanCorner_LowerVert);
		}
		else
		{
			dLen	= m_pARcBridgeDataStd->m_pBasicConcInfo->GetRebarInfo(dDia, (!bBending && m_bRoundAtEdgeRebar)?BASIC_RADIUS:BASIC_CHAMFER);
		}
	}

	if(bUpperSlab)
		dLen	= GetLengthBynVertDir(dLen, nVertDir);

	return dLen;
}

// 상부슬래브 가장자리 이전 철근의 길이
// 예를 들어 벽체와 슬래브연결시 모따기(라운드)이전 직선 철근의 길이.(1cycle전용함수)
// 슬래브교이거나 벽체가 없는 경우에는 슬래브 두께로 결정함..
// 1,3 cycle
double CRcBridgeRebar::GetLenRebarBeforeEdge_UpperSlab_Cycle13(long nCycle, long nDan, BOOL bStt, BOOL bInner, long nVertDir)
{
	BOOL bVertDir	= IsVertDir();
	if(nVertDir!=0)
		bVertDir	= nVertDir == -1 ? TRUE : FALSE;

	BOOL b2CycleBending	= ((nCycle == 1 || nCycle == 3) && m_bBendingDanBuRebar)? TRUE : FALSE;

	CTwinVector tvUpper;		// 상부슬래브 상면 철근
	CTwinVector tvOutWallRebar;	// 외측벽체철근
	CTwinVector tvLower;		// 기초하면
	CRebarPlacing rb;

	long nCount			= GetCountJointMainRebarOutWall(nCycle, nDan, bStt, bInner);				// 외측벽체철근 이음 개수
	double dTot			= GetDistMainRebarOutWall(nCycle, nDan, bStt, bInner, nCount-1, TRUE);	// 외측벽체철근이 배근된 총 길이.
	long nJigan			= bStt ? 0 : m_nQtyJigan-1;
	double dDiaWall		= GetDiaMainRebarOutWall(nCycle, nDan, bStt, bInner, 0);
	double dDiaSlab		= GetDiaMainRebarUpperSlab(nCycle, nDan, TRUE, nJigan, bStt ? 0 : -1);
	double dRWall		= GetLenRebarAtEdge(dDiaWall, TRUE, 0, TRUE, b2CycleBending);
	double dRSlab		= bInner ? 0 : IsOutWall(TRUE) ? GetLenRebarAtEdge(dDiaSlab, FALSE, 0, TRUE, b2CycleBending) : 0;
	double dLengthJoint	= 0;

	double dAng	= 0;
	double dDiff = 0;
	// 외측 벽체의 경우 경사에 의해서 R 높이가 달라 지는 경우가 있음 
	if(!bInner && m_nTypeJongdanForRebar == 1)
	{
		dAng	= GetTvOffset_UpperSlab(0, TRUE, -1, -1, bVertDir, FALSE).GetXyDir().GetAngleDegree();
		
		CDPoint xyMatch1(0, 0), xyMatch2(0, 0), xyCen(0, 0);
		GetXyTanOfArc(CDPoint(0, 0), ToDPointFrDegree(dAng+180), CDPoint(0, -1), dRSlab, xyCen, xyMatch1, xyMatch2);
		dDiff	= fabs(dRSlab - fabs(xyMatch2.y));
		// 이전 위치를 구할때 GetXyTanOfArc()를 사용하는 경우에는 경사에대한 R값이 반영되어야 한다.
		// 하지만 하단은 무조건 반영이 되어하므로 dDiff값은 무조건 구하고 반영만 Stt가 아닐때
		if(!bStt)
		{
			if(dAng > 0 && dAng < 180)
			{
				dRSlab += bStt? -dDiff : dDiff;
			}
			else
			{
				dRSlab -= bStt? - dDiff : dDiff;
			}
		}
	}
	
	// 이음 길이 구함 /////////////////////
	// Box형일때 외측벽체 이음이 1개일때 외측벽체 철근이 없기 때문에 하부슬래브 철근을...
	CRebarInfoCycle *pRCPrev	= bInner ? GetRebarInfoCycleOutWall(nCycle, nDan, bStt, bInner, GetCountJointMainRebarOutWall(nCycle, nDan, bStt, bInner)-1) : GetRebarInfoCycleOutWall(nCycle, nDan, bStt, bInner, -1);
	CRebarInfoCycle *pRCNext	= bInner ? GetRebarInfoCycleOutWall(nCycle, nDan, bStt, bInner, -1) : GetRebarInfoCycleUpperSlab(nCycle, nDan, TRUE, bStt ? 0 : -1);
	if(pRCPrev == NULL && !bInner && IsBoxType())
	{
		pRCPrev  =GetRebarInfoCycleLowerSlab(nCycle, nDan, FALSE, bStt? 0:-1);
	}
	if(pRCPrev && pRCNext)
		dLengthJoint	= GetValueJoint(pRCPrev, pRCNext->m_Dia, NULL, 0, bStt)/2;
	else if(pRCPrev && !pRCNext)
		dLengthJoint	= GetValueJoint(pRCPrev, 0)/2;
	// 이음 길이 구함 /////////////////////

	CFootingApp *pFooting = bStt ? &m_footingStt : &m_footingEnd;
	if(pFooting->m_bIs)
	{
		pFooting->m_tvArrFront.GetTvByInfo("기초하면", tvLower);
		tvLower.m_v1.y = tvLower.m_v2.y += pFooting->m_dCoverLower[0];
	}
	else if(m_nTypeBridge == BRIDGE_TYPE_BOX)
	{	
	}
	else
	{
		CString str	= bStt ? "시점슬래브측면" : "종점슬래브측면";
		m_tvArrVertSection.GetTvByInfo(str, tvLower);
		if(bStt) GetSwap(tvLower.m_v1, tvLower.m_v2);
		dLengthJoint	= 0;	// 슬래브일땐 측면에 이음 없음.
		dRWall			= 0;
		tvLower.m_v1.y = tvLower.m_v2.y += m_dCoverLower_UpperSlab[0];
	}
	
	tvOutWallRebar	= GetTvOffset_OutWall(nDan, bStt, bInner, bVertDir);
	CDPoint xyTopUpperSlab = GetXyMatchLineAndSlabUpper(tvOutWallRebar.m_v1, CDPoint(0, 1), 0, m_dCoverUpper_UpperSlab[nDan], bVertDir);
	if(m_nTypeBridge == BRIDGE_TYPE_BOX)
	{
		tvLower.m_v1 = GetXyMatchLineAndLowerSlab(tvOutWallRebar.m_v1, CDPoint(0, 1), 0, m_dCoverLower_LowerSlab[nDan], bVertDir);
		if(bInner)
			dRWall = 0;
		else
		{
			double dDiaLSlab		= GetDiaMainRebarLowerSlab(nCycle, nDan, FALSE, nJigan, bStt ? 0 : -1);
			dRWall		= GetLenRebarAtEdge(dDiaLSlab, FALSE, 0, TRUE, b2CycleBending);

			// 하부슬래브 경사가 있다면 
			if(m_nTypeJongdanForRebar == 1 && m_bSlopeLowerSlab)
			{
				if(dAng > 0 && dAng < 180)
				{
					dRWall += bStt? dDiff : -dDiff;
				}
				else
				{
					dRWall += bStt? -dDiff : dDiff;
				}
			}
		}
	}
	double dLenTot	= xyTopUpperSlab.y - tvLower.m_v1.y;


	// (34613) 길이가 최소한 이음길이보다는 길어야 한다. 즉 외측벽체배근이 길게 되었다고 해도 -값이 나오면 안된다.
//	double dLen		= dLenTot - (dRSlab) - (dRWall+dTot) + dLengthJoint;
	double dLen		= MAX(0, dLenTot - (dRSlab) - (dRWall+dTot)) + dLengthJoint;
	return dLen;
}


// 시종점 외측벽체 내외측 주철근 철근 지름 가져오는 함수
// 철근 지름이나 이음의 길이를 직접 가져와도 되지만, 만해하나라도 배열이 원하는 만큼 덜 생성 됐을 경우나
// 이상한 값이 들어간 경우를 대비해서 이 함수를 통해서 직접 지름을 가져 오도록 한다.
double CRcBridgeRebar::GetDiaMainRebarOutWall(long nCycle, long nDan, BOOL bStt, BOOL bInner, long nIdx)
{
	double dDia	= 0;
	long stt	= bStt ? iSTT : iEND;
	long inner	= bInner ? iINNER : iOUTTER;

	if(nDan == 0 || m_bDetailInput23DanMainRebar)
	{
		long nSize	= 0;
		nSize	= m_pArrDiaOutWall[nCycle][stt][inner][nDan].GetSize();
		if(nIdx == -1) nIdx = nSize-1;
		if(nIdx < 0 || nIdx > nSize-1) return 0;

		if(nIdx < nSize)
			dDia	= m_pArrDiaOutWall[nCycle][stt][inner][nDan].GetAt(nIdx);
		else 
			dDia	= 0;
	}
	// 2단부터는 다른 변수에 저장되어 있다
	// 2단이상은 그냥 내측 외측으로 지름이 구분되어 있음.
	// 2단이 index 0이고 3단이 1이다.
	else if(nDan > 0)
	{
		if(nDan == -1) nDan = MAX_REBAR_DAN-1;
		if(nDan < 0) return 0;
		if(nDan > MAX_REBAR_DAN-1) return 0;
		if(nCycle == -1) nCycle = MAX_REBAR_CYCLE-1;
		if(nCycle < 0) return 0;
		if(nCycle > MAX_REBAR_CYCLE-1) return 0;

		CSetRebarDan *pRD	= &m_pArrSetRebarDanOutWall[stt][inner];
		if(pRD->m_nCountDan > nDan && GetCountCycleMainRebar() > nCycle)
		{
			dDia	= pRD->m_dDia[nCycle][nDan];
		}
		else 
			dDia	= 0;
	}

	return dDia;
}

double CRcBridgeRebar::GetDiaLsdExposure_Main(EPartOfBridge ePos, BOOL bUpperFront)
{
	if(m_pARcBridgeDataStd->IsLsdDesign() == FALSE)
		return 0;

	double dDiaMax =0, dDiaCurr = 0;	
	CRebarInfoCycle *pRb;

	long dan = 0;
	for(long cycle = 0; cycle < MAX_REBAR_CYCLE; cycle ++)
	{
		
		if( ePos == ePartUpperSlab )		// 상부 슬래브
		{					
			for(long i = 0; i < m_pArrRCMainUpperSlab[cycle][bUpperFront==TRUE ? 0 : 1][dan].GetSize(); i++)
			{
				pRb = m_pArrRCMainUpperSlab[cycle][bUpperFront==TRUE ? 0 : 1][dan].GetAt(i); 
				if(pRb && pRb->m_bExist) 
					dDiaCurr = pRb->m_Dia;

				dDiaMax = max(dDiaMax, dDiaCurr);
			}
		}
		else if( ePos == ePartLowerSlab )		// 하부 슬래브
		{
			for(long i = 0; i < m_pArrRCMainLowerSlab[cycle][bUpperFront==TRUE ? 0 : 1][dan].GetSize(); i++)
			{
				pRb = m_pArrRCMainLowerSlab[cycle][bUpperFront==TRUE ? 0 : 1][dan].GetAt(i); 
				if(pRb && pRb->m_bExist) 
					dDiaCurr = pRb->m_Dia;

				dDiaMax = max(dDiaMax, dDiaCurr);
			}
		}
		else if( ePos == ePartOutWallStt || ePos == ePartOutWallEnd )		// 시종점 외측
		{
			// 전면이 내측 배면이 외측
			for(long i = 0; i < m_pArrRCMainOutWall[cycle][ePos == ePartOutWallStt ? 0 : 1][bUpperFront==TRUE ? iINNER : iOUTTER][dan].GetSize(); i++)
			{
				pRb = m_pArrRCMainOutWall[cycle][ePos == ePartOutWallStt ? 0 : 1][bUpperFront==TRUE ? iINNER : iOUTTER][dan].GetAt(i); 
				if(pRb && pRb->m_bExist) 
					dDiaCurr = pRb->m_Dia;

				dDiaMax = max(dDiaMax, dDiaCurr);
			}

			if(bUpperFront == FALSE)
			{
				double dDiaMaxSlab = 0, dDiaCurrSlab = 0;
				for (long nSlab =0; nSlab < 2; nSlab++)
				{
					BOOL bUpperSlab = nSlab == 0? TRUE : FALSE;
					if(IsBoxType()==FALSE && bUpperSlab == FALSE)
						continue;

					long nSize	= bUpperSlab?  m_pArrRCMainUpperSlab[cycle][iUPPER][dan].GetSize() : m_pArrRCMainLowerSlab[cycle][iLOWER][dan].GetSize();
					if(nSize ==0)	continue;


					long nIdx		= ePos == ePartOutWallStt?  0 : nSize-1;
					if(bUpperSlab)	pRb = m_pArrRCMainUpperSlab[cycle][iUPPER][dan].GetAt(nIdx); 
					else				pRb = m_pArrRCMainLowerSlab[cycle][iLOWER][dan].GetAt(nIdx); 
					
					if(cycle > 0 && pRb->m_bExist == FALSE)
						continue;

					if(pRb && pRb->m_bExist) 
						dDiaCurrSlab = pRb->m_Dia;

					dDiaMaxSlab = max(dDiaMaxSlab, dDiaCurrSlab);
				}

				if(dDiaMaxSlab > 0 && dDiaMaxSlab >dDiaMax )
					dDiaMax = dDiaMaxSlab;

			}
		}
		else if( ePos == ePartInWall )		// 내측 벽체
		{
			for(long ix=0; ix<GetCountInWall(); ++ix)
			{
				CWallApp *pWall = GetInWall(ix);
				if( pWall == NULL ) continue;

				dDiaMax = max(dDiaMax, max(pWall->GetDiaMainRebar(cycle, dan, TRUE, 0), pWall->GetDiaMainRebar(cycle, dan, FALSE, 0)));
			}
		}
		else if( ePos == ePartFootStt || ePos == ePartFootEnd || ePos == ePartInFoot )				// 시종점 / 중간 기초
		{				
			CFootingApp *pFooting = GetFooting(ePos == ePartFootStt ? 0 : (ePos == ePartInFoot ? 1 : (GetCountFooting() - 1)));
			if(pFooting == NULL) continue;

			dDiaCurr = pFooting->GetDiaMainRebar(cycle, bUpperFront, 0);

			dDiaMax = max(dDiaCurr, dDiaMax);
		}
		else if( ePos == ePartWingWallStt || ePos == ePartWingWallEnd )		// 날개벽
		{
			for (long nLeft=0; nLeft<2; ++nLeft)
			{
				CWingWall* pWing = GetWingWall(ePos == ePartWingWallStt ? TRUE : FALSE, nLeft==0 ? TRUE : FALSE);

				dDiaCurr = MAX(MAX(pWing->m_dDiaMainA[bUpperFront==TRUE ? 0 : 1][dan], pWing->m_dDiaMainB[bUpperFront==TRUE ? 0 : 1][dan]), 
					MAX(pWing->m_dDiaMainC[bUpperFront==TRUE ? 0 : 1][dan], pWing->m_dDiaMainD[bUpperFront==TRUE ? 0 : 1][dan]));

				dDiaMax = max(dDiaCurr, dDiaMax);
			}

			break;
		}
		else if( ePos == ePartApsStt || ePos == ePartApsEnd )			// 접속슬래브
		{
			for (long nLeft=0; nLeft<2; ++nLeft)
			{
				CApsApp *pAps	= ePos == ePartApsStt ? &m_apsStt[nLeft] : &m_apsEnd[nLeft];
				if(pAps == NULL) continue;
				if(IsAps(ePos == ePartApsStt, nLeft==0) == FALSE)
					continue;

				dDiaCurr = pAps->m_dDiaMain1[bUpperFront==TRUE ? 0 : 1];

				dDiaMax = max(dDiaMax, dDiaCurr);
			}

			break;
		}		
	}

	return dDiaMax;
}

//간격재가 적용될경우 0 ARCBRIDGE-2668
double CRcBridgeRebar::GetDiaLsdExposure_Shear( EPartOfBridge ePos )
{
	if(m_pARcBridgeDataStd->IsLsdDesign() == FALSE)
		return 0;

	if(m_nSelectExposureCoverCheck == 1) 
		return 0;

	long dan = 0;
	long nType = 0;
	double dDia = 0;
	
	if( ePos == ePartUpperSlab )		// 상부 슬래브
	{
		nType = m_RebarShearDetail_UpperSlab.m_nType;
		dDia = (nType != TYPE_SHEAR_SPACER) ? m_RebarShearDetail_UpperSlab.m_dDia : 0;
	}
	else if( ePos == ePartLowerSlab )		// 하부 슬래브
	{
		nType = m_RebarShearDetail_LowerSlab.m_nType;
		dDia = (nType != TYPE_SHEAR_SPACER) ? m_RebarShearDetail_LowerSlab.m_dDia : 0;
	
	}
	else if( ePos == ePartOutWallStt || ePos == ePartOutWallEnd )		// 시종점 벽체
	{
		long iSE = (ePos == ePartOutWallStt) ? iSTT : iEND;
	
		nType = m_RebarShearDetail_OutWall[iSE].m_nType;
		dDia = (nType != TYPE_SHEAR_SPACER) ? m_RebarShearDetail_OutWall[iSE].m_dDia : 0;
	}
	else if( ePos == ePartInWall )		// 내측 벽체
	{
		CWallApp *pWall	= GetInWall(0);
		if(pWall)
		{
			if(pWall->m_bTopIsColumn) //기둥일경우 띠철근직경 사용
			{
				CColumnApp *pColumn = pWall->GetColumn(0);
				if(pColumn)
				{
					CPlaceRebarByBlock *pPlace	= &pColumn->m_placeRebarRound[iOUTTER][dan];
					dDia = pPlace ? pPlace->m_dDia : 0;
				}
			}
			else
			{
				nType = pWall->m_rebarShearDetail.m_nType;
				dDia = (nType != TYPE_SHEAR_SPACER) ? pWall->m_rebarShearDetail.m_dDia : 0;
			}
		}
	}
	else if( ePos == ePartFootStt || ePos == ePartFootEnd || ePos == ePartInFoot )				// 시종점 / 중간 기초
	{
		CFootingApp *pFooting = GetFooting(ePos == ePartFootStt ? 0 : (ePos == ePartInFoot ? -1 : (GetCountFooting() - 1)));
		if(pFooting == NULL) return 0;
	
		nType = pFooting->m_rebarShearDetail.m_nType;
		dDia = (nType != TYPE_SHEAR_SPACER) ? pFooting->m_rebarShearDetail.m_dDia : 0;
	
	}
	else if( ePos == ePartWingWallStt || ePos == ePartWingWallEnd )		// 날개벽
	{
		double dDiaMax = 0;
		for(long nLeft = 0; nLeft < 2; ++nLeft)
		{
			CWingWall* pWing = GetWingWall((ePos == ePartWingWallStt) ? TRUE : FALSE, nLeft==0 ? TRUE : FALSE);
			if(pWing)
			{
				double dDiaA = (pWing->m_RebarShearDetailA.m_nType != TYPE_SHEAR_SPACER) ? pWing->m_RebarShearDetailA.m_dDia : 0;
				double dDiaB = (pWing->m_RebarShearDetailB.m_nType != TYPE_SHEAR_SPACER) ? pWing->m_RebarShearDetailB.m_dDia : 0;
				double dDiaC = (pWing->m_RebarShearDetailC.m_nType != TYPE_SHEAR_SPACER) ? pWing->m_RebarShearDetailC.m_dDia : 0;
				double dDiaD = (pWing->m_RebarShearDetailD.m_nType != TYPE_SHEAR_SPACER) ? pWing->m_RebarShearDetailD.m_dDia : 0;

				if(pWing->m_nTypeShearBC == 1)
					dDiaB = 0;
				if(pWing->m_nTypeShearBC == 0)
					dDiaC = 0;
	
				dDiaMax = MAX(MAX(dDiaA, dDiaB), MAX(dDiaC, dDiaD));
			}
			dDia = MAX(dDia, dDiaMax);
		}
	}
	else if( ePos == ePartApsStt || ePos == ePartApsEnd )			// 접속슬래브
	{
		for (long nLeft=0; nLeft<2; ++nLeft)
		{
			CApsApp *pAps	= ePos == ePartApsStt ? &m_apsStt[nLeft] : &m_apsEnd[nLeft];
			if(pAps == NULL) continue;
			if(IsAps(ePos == ePartApsStt, nLeft==0) == FALSE) continue;
			if(pAps->m_rebarShearDetail.m_nType == TYPE_SHEAR_SPACER) continue;

			double dDiaCurr = pAps->m_rebarShearDetail.m_dDia;

			dDia = max(dDia, dDiaCurr);
		}
	}

	return dDia;
}

// 시종점 외측벽체 내외측 주철근 존재 여부
BOOL CRcBridgeRebar::IsExistMainRebarOutWall(long nCycle, long nDan, BOOL bStt, BOOL bInner, long nIdx)
{
	if((nCycle == 0 || nCycle == 2) && nDan == 0) return TRUE;

	BOOL bExist	= FALSE;
	long nSize	= 0;
	long stt	= bStt ? iSTT : iEND;
	long inner	= bInner ? iINNER : iOUTTER;
	
	// 4cycle은 입력받지 않으므로 2cycle껄로 사용
	if(nCycle == 3) 
		nCycle = 1;
	if(!m_bDetailInput23DanMainRebar)
	{
		if(nDan > 1) nDan = 1;
	}

	nSize	= m_pArrExistOutWall[nCycle][stt][inner][nDan].GetSize();
	if(nIdx == -1) nIdx = nSize-1;
	if(nIdx < 0 || nIdx > nSize-1) 
	{
		long i = 0; for(i = nSize; i <= nIdx; i++)
			m_pArrExistOutWall[nCycle][stt][inner][nDan].Add((double)TRUE);

		return TRUE;
	}

	bExist	= (BOOL)(m_pArrExistOutWall[nCycle][stt][inner][nDan].GetAt(nIdx));

	return bExist;
}

// 시종점 외측벽체 내외측면 이음길이 가져오는 함수
// 철근 지름이나 이음의 길이를 직접 가져와도 되지만, 만해하나라도 배열이 원하는 만큼 덜 생성 됐을 경우나
// 이상한 값이 들어간 경우를 대비해서 이 함수를 통해서 직접 이음길이를 가져 오도록 한다.
// bAccumulation : index까지의 이음길이를 축적해서 가져옴.
double CRcBridgeRebar::GetDistMainRebarOutWall(long nCycle, long nDan, BOOL bStt, BOOL bInner, long nIdx, BOOL bAccumulation)
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return 0;

	double dDist	= 0;
	long nSize		= 0;
	long stt		= bStt ? iSTT : iEND;
	long inner		= bInner ? iINNER : iOUTTER;

	if(!IsOutWall(bStt)) return 0;
	if(!m_bDetailInput23DanMainRebar)
		nDan	= 0;

	nSize	= m_pArrDistOutWall[nCycle][stt][inner][nDan].GetSize();
	if(nIdx == -1) nIdx = nSize-1;
	if(nIdx < 0) return dDist;

	if(bAccumulation)
	{
		long i = 0; for(i = 0; i <= nIdx; i++)
		{
			if(i >= nSize) break;
			dDist	+= m_pArrDistOutWall[nCycle][stt][inner][nDan].GetAt(i);
		}
	}
	else
	{
		if(nIdx < nSize)
			dDist	= m_pArrDistOutWall[nCycle][stt][inner][nDan].GetAt(nIdx);
		else
			dDist	= 0;
	}

	return dDist;
}

// 상부슬래브 상하면 주철근 지름 가져오는 함수
// 철근 지름이나 이음의 길이를 직접 가져와도 되지만, 만해하나라도 배열이 원하는 만큼 덜 생성 됐을 경우나
// 이상한 값이 들어간 경우를 대비해서 이 함수를 통해서 직접 지름을 가져 오도록 한다.
double CRcBridgeRebar::GetDiaMainRebarUpperSlab(long nCycle, long nDan, BOOL bUpper, long nJigan, long nIdx)
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return 0;
	if(nJigan == -1) nJigan = m_nQtyJigan-1;
	if(nJigan < 0 || nJigan > m_nQtyJigan-1) return 0;
	double dDia	= 0;
	long nSize	= 0;
	long nSizeJigan = 0;
	long upper	= bUpper ? iUPPER : iLOWER;

	if(nDan == 0 || m_bDetailInput23DanMainRebar)
	{
		nSizeJigan	= m_pArrDiaUpperSlab[nCycle][upper][nDan].GetSize();
		if(nJigan < nSizeJigan)
		{
			nSize	= m_pArrDiaUpperSlab[nCycle][upper][nDan][nJigan]->GetSize();
			if(nIdx == -1) nIdx = nSize-1;

			if(nIdx < nSize && nIdx > -1)
				dDia	= m_pArrDiaUpperSlab[nCycle][upper][nDan][nJigan]->GetAt(nIdx);
			else 
			{
				// 개수가 없는 경우 상부슬래브 철근에 이음이 한개도 없어서 마지막 지간에만 직경이 하나 들어 가 있을 수 있다.
				// (ARCBRIDGE-2553) 마지막 지간을 직접가져오지 말고 배열의 마지막 값을 가져온다.
				nSize	= m_pArrDiaUpperSlab[nCycle][upper][nDan][nSizeJigan-1]->GetSize();
				if(nIdx == -1)
					nIdx = nSize - 1;
				
				if(nIdx < nSize && nIdx > -1)
					dDia	= m_pArrDiaUpperSlab[nCycle][upper][nDan][nSizeJigan-1]->GetAt(nIdx);
				else
					dDia	= 0;
			}
		}
	}
	// 2단부터는 다른 변수에 저장되어 있다
	// 2단이상은 그냥 내측 외측으로 지름이 구분되어 있음.
	// 2단이 index 0이고 3단이 1이다.
	else if(nDan > 0)
	{
		if(nDan == -1) nDan = MAX_REBAR_DAN-1;
		if(nDan < 0) return 0;
		if(nDan > MAX_REBAR_DAN-1) return 0;
		if(nCycle == -1) nCycle = MAX_REBAR_CYCLE-1;
		if(nCycle < 0) return 0;
		if(nCycle > MAX_REBAR_CYCLE-1) return 0;
		
		nSize	=  m_pArrSetRebarDanUpperSlab[upper].GetSize();
		if(nSize == 1 && !bUpper)
			nIdx	= 0;

		if(nIdx == -1) nIdx	= nSize-1;
		if(nIdx < 0 || nIdx > nSize-1) return 0;

		CSetRebarDan *pRD	= m_pArrSetRebarDanUpperSlab[upper].GetAt(nIdx);
		if(pRD->m_nCountDan > nDan && GetCountCycleMainRebar() > nCycle)
		{
			dDia	= pRD->m_dDia[nCycle][nDan];
		}
		else 
			dDia	= 0;
	}

	return dDia;
}

// 상부슬래브 상하면 주철근 지름 가져오는 함수
// 철근 지름이나 이음의 길이를 직접 가져와도 되지만, 만해하나라도 배열이 원하는 만큼 덜 생성 됐을 경우나
// 이상한 값이 들어간 경우를 대비해서 이 함수를 통해서 직접 지름을 가져 오도록 한다.
BOOL CRcBridgeRebar::IsExistMainRebarUpperSlab(long nCycle, long nDan, BOOL bUpper, long nJigan, long nIdx)
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return FALSE;
	if(nJigan == -1) nJigan = m_nQtyJigan-1;
	if(nJigan < 0 || nJigan > m_nQtyJigan-1) return FALSE;
	if(!m_bDetailInput23DanMainRebar && (nCycle == 0 || nCycle == 2)) return TRUE;	// 1, 3사이클은 무조건 존재함.

	// 외측벽체는 2,3단에 대해서도 사용자 입력을 받지만, 옵션이 선택 되었을 때만 적용함.
	if(!m_bDetailInput23DanMainRebar)
		nDan	= 0;

	// 4cycle은 입력받지 않으므로 2cycle껄로 사용
	if(nCycle == 3) 
		nCycle = 1;

	BOOL bExist	= FALSE;
	long nSize	= 0;
	long nSizeJigan = 0;
	long upper	= bUpper ? iUPPER : iLOWER;
	nSizeJigan	= m_pArrExistUpperSlab[nCycle][upper][nDan].GetSize();
	if(nJigan < nSizeJigan)
	{
		nSize	= m_pArrExistUpperSlab[nCycle][upper][nDan][nJigan]->GetSize();
		if(nIdx == -1) nIdx = nSize-1;

		if(nIdx < nSize && nIdx > -1)
			bExist	= (BOOL)m_pArrExistUpperSlab[nCycle][upper][nDan][nJigan]->GetAt(nIdx);
		else 
		{
			nSize	= m_pArrExistUpperSlab[nCycle][upper][nDan][nSizeJigan-1]->GetSize();
			if(nIdx == -1) nIdx = nSize - 1;
			if(nIdx < nSize && nIdx > -1)
				bExist	= (BOOL)m_pArrExistUpperSlab[nCycle][upper][nDan][nSizeJigan-1]->GetAt(nIdx);
			else
				bExist	= FALSE;
		}
	}


	return bExist;
}

BOOL CRcBridgeRebar::IsExistMainRebarLowerSlab(long nCycle, long nDan, BOOL bUpper, long nJigan, long nIdx)
{
	if(m_nTypeBridge != BRIDGE_TYPE_BOX) return FALSE;
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return FALSE;
	if(nJigan == -1) nJigan = m_nQtyJigan-1;
	if(nJigan < 0 || nJigan > m_nQtyJigan-1) return FALSE;
	if(!m_bDetailInput23DanMainRebar && (nCycle == 0 || nCycle == 2)) return TRUE;	// 1, 3사이클은 무조건 존재함.

	// 외측벽체는 2,3단에 대해서도 사용자 입력을 받지만, 옵션이 선택 되었을 때만 적용함.
	if(!m_bDetailInput23DanMainRebar)
		nDan	= 0;

	// 4cycle은 입력받지 않으므로 2cycle껄로 사용
	if(nCycle == 3) 
		nCycle = 1;

	BOOL bExist	= FALSE;
	long nSize	= 0;
	long nSizeJigan = 0;
	long upper	= bUpper ? iUPPER : iLOWER;
	nSizeJigan	= m_pArrExistLowerSlab[nCycle][upper][nDan].GetSize();
	if(nJigan < nSizeJigan)
	{
		nSize	= m_pArrExistLowerSlab[nCycle][upper][nDan][nJigan]->GetSize();
		if(nIdx == -1) nIdx = nSize-1;

		if(nIdx < nSize && nIdx > -1)
			bExist	= (BOOL)m_pArrExistLowerSlab[nCycle][upper][nDan][nJigan]->GetAt(nIdx);
		else 
		{
			nSize	= m_pArrExistLowerSlab[nCycle][upper][nDan][nSizeJigan-1]->GetSize();
			if(nIdx == -1) nIdx = nSize - 1;
			if(nIdx < nSize && nIdx > -1)
				bExist	= (BOOL)m_pArrExistLowerSlab[nCycle][upper][nDan][nSizeJigan-1]->GetAt(nIdx);
			else
				bExist	= FALSE;
		}
	}


	return bExist;
}


// 상부슬래브 상하면 이음길이 가져오는 함수
// 철근 지름이나 이음의 길이를 직접 가져와도 되지만, 만해하나라도 배열이 원하는 만큼 덜 생성 됐을 경우나
// 이상한 값이 들어간 경우를 대비해서 이 함수를 통해서 직접 이음길이를 가져 오도록 한다.
// bAccumulation : index까지의 이음길이를 축적해서 가져옴.
double CRcBridgeRebar::GetDistMainRebarUpperSlab(long nCycle, long nDan, BOOL bUpper, long nJigan, long nIdx, BOOL bAccumulation, long nVertDir)
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return 0;
	if(nJigan == -1) nJigan = m_nQtyJigan-1;
	if(nJigan < 0 || nJigan > m_nQtyJigan-1) return 0;
	if(!m_bDetailInput23DanMainRebar)
		nDan	= 0;

	double dDist	= 0;
	long nSize		= 0;
	long upper		= bUpper ? iUPPER : iLOWER;

	nSize	= m_pArrDistUpperSlab[nCycle][upper][nDan].GetSize();
	if(nJigan < nSize)
	{
		nSize	= m_pArrDistUpperSlab[nCycle][upper][nDan][nJigan]->GetSize();
		if(nIdx == -1) nIdx = nSize-1;

		if(bAccumulation)
		{
			long i = 0; for(i = 0; i <= nIdx; i++)
			{
				if(i >= nSize) break;
				dDist	+= m_pArrDistUpperSlab[nCycle][upper][nDan][nJigan]->GetAt(i);
			}
		}
		else
		{
			if(nIdx < nSize)
				dDist	= m_pArrDistUpperSlab[nCycle][upper][nDan][nJigan]->GetAt(nIdx);
			else
				dDist	= 0;
		}
	}

	dDist	= GetLengthBynVertDir(dDist, nVertDir);

	return dDist;
}

double CRcBridgeRebar::GetDistMainRebarLowerSlab(long nCycle, long nDan, BOOL bUpper, long nJigan, long nIdx, BOOL bAccumulation, long nVertDir)
{
	if(m_nTypeBridge != BRIDGE_TYPE_BOX) return FALSE;

	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return 0;
	if(nJigan == -1) nJigan = m_nQtyJigan-1;
	if(nJigan < 0 || nJigan > m_nQtyJigan-1) return 0;
	if(!m_bDetailInput23DanMainRebar)
		nDan	= 0;

	double dDist	= 0;
	long nSize		= 0;
	long upper		= bUpper ? iUPPER : iLOWER;

	nSize	= m_pArrDistLowerSlab[nCycle][upper][nDan].GetSize();
	if(nJigan < nSize)
	{
		nSize	= m_pArrDistLowerSlab[nCycle][upper][nDan][nJigan]->GetSize();
		if(nIdx == -1) nIdx = nSize-1;

		if(bAccumulation)
		{
			long i = 0; for(i = 0; i <= nIdx; i++)
			{
				if(i >= nSize) break;
				dDist	+= m_pArrDistLowerSlab[nCycle][upper][nDan][nJigan]->GetAt(i);
			}
		}
		else
		{
			if(nIdx < nSize)
				dDist	= m_pArrDistLowerSlab[nCycle][upper][nDan][nJigan]->GetAt(nIdx);
			else
				dDist	= 0;
		}
	}

	dDist	= GetLengthBynVertDir(dDist, nVertDir);

	return dDist;
}

// 외측벽체 이음 개수
long CRcBridgeRebar::GetCountJointMainRebarOutWall(long nCycle, long nDan, BOOL bStt, BOOL bInner)
{
	if(!m_bDetailInput23DanMainRebar)
		nDan	= 0;
	long nCount = 0;
	long stt	= bStt ? iSTT : iEND;
	long inner	= bInner ? iINNER : iOUTTER;
	nCount = nCycle == 0 || nCycle == 2 ? m_nCountJointMainRebar_OutWall_Cycle1[stt][inner][nDan] : m_nCountJointMainRebar_OutWall_Cycle2[stt][inner][nDan];

	if(nCount < 0) nCount = 0;

	return nCount;
}

// 상부슬래브 이음 개수
long CRcBridgeRebar::GetCountJointMainRebarUpperSlab(long nCycle, long nDan, BOOL bUpper, long nJigan)
{
	if(!m_bDetailInput23DanMainRebar)
		nDan	= 0;


	long nCount = 0;
	long upper	= bUpper ? iUPPER : iLOWER;

	long nJStt = MAX(0, nJigan);
	long nJEnd = nJigan<0? m_nQtyJigan : MIN(m_nQtyJigan, nJigan+1);
	for(long nJ=nJStt; nJ<nJEnd; ++nJ)
	{
		nCount += nCycle == 0 || nCycle == 2 ? m_nCountJointMainRebar_UpperSlab_Cycle1[nJ][upper][nDan] : m_nCountJointMainRebar_UpperSlab_Cycle2[nJ][upper][nDan];
	}

	if(nCount < 0) nCount = 0;

	return nCount;
}



// 상부슬래브 상면 2사이클 철근연결인지 파악.
BOOL CRcBridgeRebar::IsJointMainRebarUpperSlab_Upper_Cycle2(long nJigan)
{
	long nSize = m_pArrSetRebarJointUpperSlab[iUPPER].GetSize();
	if(nJigan == -1) nJigan = nSize-1;
	if(nJigan >= nSize) return FALSE;
	if(nJigan < 0) return FALSE;

// 	BOOL bJoint = FALSE;

	CSetRebarJoint *pRJ	= m_pArrSetRebarJointUpperSlab[iUPPER].GetAt(nJigan);
	BOOL bJoint = pRJ->m_bJoint;

	return bJoint;
}

// 상부슬래브 하면 2사이클 철근연결인지 파악.
BOOL CRcBridgeRebar::IsJointMainRebarUpperSlab_Lower_Cycle2(long nJijum)
{
	long nSize = m_pArrSetRebarJointUpperSlab[iLOWER].GetSize();
	if(nJijum == -1) nJijum = nSize-1;
	if(nJijum >= nSize) return FALSE;
	if(nJijum < 0) return FALSE;

// 	BOOL bJoint = FALSE;

	CSetRebarJoint *pRJ	= m_pArrSetRebarJointUpperSlab[iLOWER].GetAt(nJijum);
	BOOL bJoint = pRJ->m_bJoint;

	return bJoint;
}

void CRcBridgeRebar::SerializeRebar(CArchive &ar)
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	long upper(0), stt(0), left(0), inner(0), cycle(0), dan(0), nJ(0);

	// ******************* 여기서부터 아래 표시선 까지는 반드시 SerializeRebar함수에서 파일에 저장함. ***************************
	// CDoubleArray나 CDoubleArray*만 와야 된다.
	// 파일 저장시 복잡한 변수명과 개수로 인한 혼선을 방지하기 위해 하나의 함수에서 일괄적으로 처리하기 때문에..
	
	// CYCLE1~4 ///////////////////////////////////////////////////////////////////
	for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
	{
		// 이음 간격
		for(upper = 0; upper < 2; upper++)
		{
			for(dan = 0; dan < MAX_REBAR_DAN; dan++)
			{
				if(m_nFlag > 37 || ar.IsStoring() || dan == 0)
				{
					pStd->SerializeArrayOfDoubleArray(ar, &m_pArrDistUpperSlab[cycle][upper][dan]);	// 상부슬래브 상하면 1사이클
					pStd->SerializeArrayOfDoubleArray(ar, &m_pArrDistLowerSlab[cycle][upper][dan]);	// 하부슬래브 상하면 1사이클
				}
			}
		}
		for(stt = 0; stt < 2; stt++)
		{
			for(left = 0; left < 2; left++)
			{
				for(dan = 0; dan < MAX_REBAR_DAN; dan++)
				{
					if(m_nFlag > 37 || ar.IsStoring() || dan == 0)
					{
						pStd->SerializeDoubleArray(ar, &m_pArrDistOutWall[cycle][stt][left][dan]);	// 시좀점, 좌우측 외측벽체 1사이클 이음 간격
					}
				}
			}
		}

		if(m_nFlag > 22 || ar.IsStoring())
		{
			for(upper = 0; upper < 2; upper++)
			{
				for(dan = 0; dan < MAX_REBAR_DAN; dan++)
					pStd->SerializeDoubleArray(ar, &m_dArrDistRib[cycle][upper][dan]);
			}
		}


		// 철근 지름
		for(upper = 0; upper < 2; upper++)
		{
			for(dan = 0; dan < MAX_REBAR_DAN; dan++)
			{
				if(m_nFlag > 37 || ar.IsStoring() || dan == 0)
				{
					pStd->SerializeArrayOfDoubleArray(ar, &m_pArrDiaUpperSlab[cycle][upper][dan]);	// 상부슬래브 상하면 1사이클 철근 지름
					pStd->SerializeArrayOfDoubleArray(ar, &m_pArrDiaLowerSlab[cycle][upper][dan]);	// 하부슬래브 상하면 1사이클 철근 지름
				}
			}
		}
		for(stt = 0; stt < 2; stt++)
		{
			for(left = 0; left < 2; left++)
			{
				for(dan = 0; dan < MAX_REBAR_DAN; dan++)
				{
					if(m_nFlag > 37 || ar.IsStoring() || dan == 0)
					{
						pStd->SerializeDoubleArray(ar, &m_pArrDiaOutWall[cycle][stt][left][dan]);	// 시종점, 좌우측 외측벽체 1사이클 철근 지름
					}
				}
			}
		}
		pStd->SerializeDoubleArray(ar, &m_dArrDiaUpperSlabHunch[cycle]);				// 상부 슬래브 헌치부 철근

		if(m_nFlag > 22 || ar.IsStoring())
		{
			for(upper = 0; upper < 2; upper++)
			{
				for(dan = 0; dan < MAX_REBAR_DAN; dan++)
					pStd->SerializeDoubleArray(ar, &m_dArrDiaRib[cycle][upper][dan]);
			}
		}

		// 철근 존재 뺄껀지 선택(2cycle에 대해서만 지원하지만 차후 업그레이드를 위해 4cycle 모두 변수 생성함)
		if(m_nFlag > 12)
		{
			for(upper = 0; upper < 2; upper++)
			{
				for(dan = 0; dan < MAX_REBAR_DAN; dan++)
				{
					if(ar.IsStoring() || m_nFlag > 34 || dan == 0)
						pStd->SerializeArrayOfDoubleArray(ar, &m_pArrExistUpperSlab[cycle][upper][dan]);
				}
			}
			for(stt = 0; stt < 2; stt++)
			{
				for(left = 0; left < 2; left++)
				{
					for(dan = 0; dan < MAX_REBAR_DAN; dan++)
					{
						if(ar.IsStoring() || m_nFlag > 34 || dan == 0)
							pStd->SerializeDoubleArray(ar, &m_pArrExistOutWall[cycle][stt][left][dan]);
					}
				}
			}
		}
		else
		{
			if(cycle == 0 || cycle == 2)
			{
				for(upper = 0; upper < 2; upper++)
				{
					long nSize	= m_pArrDiaUpperSlab[cycle][upper][0].GetSize();
					long i = 0; for(i = 0; i < nSize; i++)
					{
						CDoubleArray *pDArr	= m_pArrDiaUpperSlab[cycle][upper][0].GetAt(i);
						CDoubleArray *pDArrExist	= new CDoubleArray;
						long j = 0; for(j = 0; j < pDArr->GetSize(); j++)
							pDArrExist->Add((double)TRUE);
						m_pArrExistUpperSlab[cycle][upper][0].Add(pDArrExist);
					}
				}
				for(stt = 0; stt < 2; stt++)
				{
					for(left = 0; left < 2; left++)
					{
						long i = 0; for(i = 0; i < m_pArrDiaOutWall[cycle][stt][left][0].GetSize(); i++)
							m_pArrExistOutWall[cycle][stt][left][0].Add((double)TRUE);
					}
				}
			}
		}

		if(m_nFlag > 23)
		{
			for(upper = 0; upper < 2; upper++)
			{
				for(dan = 0; dan < MAX_REBAR_DAN; dan++)
				{
					pStd->SerializeDoubleArray(ar, &m_dArrExistRib[cycle][upper][dan]);
				}
			}
		}
	}

	if(m_nFlag < 35)
	{
		for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
		{
			for(upper = 0; upper < 2; upper++)
			{
				for(dan = 1; dan < MAX_REBAR_DAN; dan++)
				{
					pStd->CopyArrayOfDoubleArray(&m_pArrExistUpperSlab[cycle][upper][dan], &m_pArrExistUpperSlab[1][upper][0]);
				}
			}
			for(stt = 0; stt < 2; stt++)
			{
				for(left = 0; left < 2; left++)
				{
					for(dan = 1; dan < MAX_REBAR_DAN; dan++)
					{
						pStd->CopyDoubleArray(&m_pArrExistOutWall[cycle][stt][left][dan], &m_pArrExistOutWall[1][stt][left][0]);
					}
				}
			}
		}
	}
	pStd->SerializeDoubleArray(ar, &m_dArrTypeUpperSlabHunch);
	/////////////////////////////////////////////////////////////////// CYCLE1~4 //

	// 철근연결및 이음수 설정
	for(upper = 0; upper < 2; upper++)
	{
		AhTPASerial(ar, &m_pArrSetRebarJointUpperSlab[upper], (CSetRebarJoint*)0);	// 상부슬래브 상하면 2사이클 철근 연결 및 이음개수
		AhTPASerial(ar, &m_pArrSetRebarJointLowerSlab[upper], (CSetRebarJoint*)0);	// 하부슬래브 상하면 2사이클 철근 연결 및 이음개수
	}

	for(stt = 0; stt < 2; stt++)
		m_pArrSetRebarJointOutWall_Outter[stt].Serialize(ar);	// 시종점, 외측, 외측벽체 2사이클 철근 연결 및 이음개수
	for(stt = 0; stt < 2; stt++)
		for(upper = 0; upper < 2; upper++)
			m_pArrSetRebarJointOutWall_Inner[stt][upper].Serialize(ar);	// 시종점, 내측, 위아래 외측벽체  2사이클 철근 연결 및 이음개수

	// 철근배치 옵션
	SerializeValue(ar, &m_bDetailInput23DanMainRebar, m_nFlag > 37);			// 2,3단 주철근을 2Cycle 1단 입력하듯이 세부적으로 조정해서 입력 할 수 잇게 한다.
	SerializeValue(ar, &m_bExtendShearRebarToHunchRebar);	// 상부슬래브 전단철근을 헌치철근까지 연장할지?(기본 FALSE)
	SerializeValue(ar, &m_bExtendShearRebarBoHunchRebar, m_nFlag > 49);	// 상부슬래브 전단철근을 헌치철근까지 연장할지?(기본 FALSE)
	for(stt = 0; stt < 2; stt++)
		SerializeValue(ar, &m_bPlacingOutWallInnerRebar[stt]);	// 시종점 외측벽체 내측철근 배치
	SerializeValue(ar, &m_bPlacingInWallRebarOfCycle24);	// 중간벽체 철근 배치 시리얼추가
	SerializeValue(ar, &m_bBendingDanBuRebar);				// 단 절점부 철근 구부려서 배치
	SerializeValue(ar, &m_bPlacingStirrupAtDanBuRebar);		// 단 절점부 ROUND부에 스트럽 배치
	SerializeValue(ar, &m_bPlacingSupportAtHunchRebar);		// 헌치철근위에 배력철근 배치
	SerializeValue(ar, &m_bPlacingSupportAtDanBuRebar);		// 단 절점부 ROUND부에 배력철근 배치
	SerializeValue(ar, &m_bPlacing23DanByStandardOffset);	// 2,3단 철근을 표준배치간격으로 배치
	SerializeValue(ar, &m_nCountWrapMainRebarUpperSlab);	// 주철근을 감싸는 개수
	SerializeValue(ar, &m_nCountWrapMainRebarLowerSlab, m_nFlag > 45);	// 주철근을 감싸는 개수
	SerializeValue(ar, &m_nCountWrapMainRebarForOutWall[0], m_nFlag > 36);	// 시종점 외측벽체 전단철근이 주철근 구간 감싸는 개수
	SerializeValue(ar, &m_nCountWrapMainRebarForOutWall[1], m_nFlag > 36);	// 시종점 외측벽체 전단철근이 주철근 구간 감싸는 개수
	SerializeValue(ar, &m_nCountWrapMainRebarForInWall, m_nFlag > 36);	// 중간벽체 전단철근이 주철근을 감싸는 개수
	SerializeValue(ar, &m_nCountWrapMainRebarForBracket[0], m_nFlag > 36);	// 브라켓 전단철근이 주철근 구간 감싸는 개수
	SerializeValue(ar, &m_nCountWrapMainRebarForBracket[1], m_nFlag > 36);	// 브라켓 전단철근이 주철근 구간 감싸는 개수
	SerializeValue(ar, &m_nCountWrapMainRebarForFootingLean, m_nFlag > 36);	// 직접기초 전단철근이 주철근 구간 감싸는 개수
	SerializeValue(ar, &m_nCountWrapMainRebarForFootingPile, m_nFlag > 36);	// 말뚝기초 전단철근이 주철근 구간 감싸는 개수
	SerializeValue(ar, &m_nCountWrapMainRebarForArchRib, m_nFlag > 36);		// 리브 전단철근이 주철근 구간 감싸는 개수
	SerializeValue(ar, &m_nCountWrapMainRebarForDanbuStirrup_XXX, m_nFlag > 36);	// 단부 스터럽 철근집계시 주철근을 감싸는 개수
	if(ar.IsLoading() && m_nFlag < 37)
	{
		m_nCountWrapMainRebarForArchRib	= m_nCountWrapMainRebarUpperSlab;
		m_nCountWrapMainRebarForBracket[0]	= m_nCountWrapMainRebarUpperSlab;
		m_nCountWrapMainRebarForBracket[1]	= m_nCountWrapMainRebarUpperSlab;
		m_nCountWrapMainRebarForOutWall[0]	= m_nCountWrapMainRebarUpperSlab;
		m_nCountWrapMainRebarForOutWall[1]	= m_nCountWrapMainRebarUpperSlab;
		m_nCountWrapMainRebarForDanbuStirrup_XXX	= m_nCountWrapMainRebarUpperSlab;
		m_nCountWrapMainRebarForFootingLean	= m_nCountWrapMainRebarUpperSlab;
		m_nCountWrapMainRebarForFootingPile	= m_nCountWrapMainRebarUpperSlab;
	}
	if(ar.IsLoading() && m_nFlag < 46)
	{
		m_nCountWrapMainRebarLowerSlab = m_nCountWrapMainRebarUpperSlab;
	}

	SerializeValue(ar, &m_nTypeDefaultCycle3_OutRebar);		// 주철근 cycle3 권고안 방법(외측철근 : 상부슬래브 상면, 외측철근 외측면)
	SerializeValue(ar, &m_nTypeDefaultCycle3_UpperSlabLower);	// 주철근 cycle3 권고안 방법(상 부슬래브 하면)
	SerializeValue(ar, &m_nTypeDefaultCycle3_OutWallInner);	// 주철근 cycle3 권고안 방법(외측벽체 내측면)
	SerializeValue(ar, &m_nTypeDefaultCycle3_ArchRib, m_nFlag > 27);
	SerializeValue(ar, &m_nTypeCurveOfWallVertRebar);			// 벽체 수직철근 절곡부 타입(0 : 자동, 1 : 곡선, 2 : 직각)
	SerializeValue(ar, &m_nTypeStandardCTCRebarMain, m_nFlag > 15);			// 주철근 ctc 기준(0 : 상부슬래브, 1 : 시점벽체)
	SerializeValue(ar, &m_bRemoveShearRebarAtSlabYundan, m_nFlag > 35);		// 슬래브 연단 전단철근 제거
	SerializeValue(ar, &m_nTypeCouplerColumnMainRebar, m_nFlag > 39);				// 기둥 주철근 커플러? 겹이음. 
	SerializeValue(ar, &m_bApplySameSupportRebar, m_nFlag > 40);
	SerializeValue(ar, &m_bApplySameMainRebar, m_nFlag > 41);					// 상하행 주철근관련 입력 동일 적용
	

	// 단부 스터럽 철근 직경
	for(long iUD=iUPPER; iUD<=iLOWER; iUD++)
	{
		long nFlagCheck = iUD==iUPPER ? 14 : 42;
		for(stt = 0; stt < 2; stt++)
		{
			SerializeValue(ar, &m_dDiaStirrupAtDanBuRebar[iUD][stt], m_nFlag > nFlagCheck);		// 단부 스터럽 철근 직경 (시종점)
			SerializeValue(ar, &m_nCountStirrupAtDanBuRebar[iUD][stt], m_nFlag > nFlagCheck);		// 단부 스터럽 철근 개수 (시종점)
			if(m_nFlag < nFlagCheck + 1)
			{
				if(m_bPlacingStirrupAtDanBuRebar)
				{
					m_dDiaStirrupAtDanBuRebar[iUD][stt]	= m_placeByBlock_ShearRebar_UpperSlab.m_dDia;
				}
				else
				{
					m_dDiaStirrupAtDanBuRebar[iUD][stt]	= 0;
				}
			}
		}
	}
	
	// 가각부 배근
	for(stt = 0; stt < 2; stt++)
	{
		for(left = 0; left < 2; left++)
		{
			SerializeValue(ar, &m_nTypeRebarMainRebarOfExp[stt][left], m_nFlag > 17);
			SerializeValue(ar, &m_nTypeOrgMainRebarOfExp[stt][left], m_nFlag > 4);
		}
	}
	SerializeValue(ar, &m_dLenMainRebarOfExp[iSTT][iLEFT], m_nFlag > 1);				// 가각부 배근시 가각부와 좌우측라인과의 교차점에서 주철근이 뻗어 나가는 거리
	SerializeValue(ar, &m_dLenMainRebarOfExp[iSTT][iRIGHT], m_nFlag > 4);				// 가각부 배근시 가각부와 좌우측라인과의 교차점에서 주철근이 뻗어 나가는 거리
	SerializeValue(ar, &m_dLenMainRebarOfExp[iEND][iLEFT], m_nFlag > 4);				// 가각부 배근시 가각부와 좌우측라인과의 교차점에서 주철근이 뻗어 나가는 거리
	SerializeValue(ar, &m_dLenMainRebarOfExp[iEND][iRIGHT], m_nFlag > 4);				// 가각부 배근시 가각부와 좌우측라인과의 교차점에서 주철근이 뻗어 나가는 거리
	if(m_nFlag < 5)
	{
		m_dLenMainRebarOfExp[iSTT][iRIGHT]	= m_dLenMainRebarOfExp[iSTT][iRIGHT];
		m_dLenMainRebarOfExp[iEND][iLEFT]	= m_dLenMainRebarOfExp[iSTT][iRIGHT];
		m_dLenMainRebarOfExp[iEND][iRIGHT]	= m_dLenMainRebarOfExp[iSTT][iRIGHT];
	}
	for(stt = 0; stt < 2; stt++)
	{
		for(left = 0; left < 2; left++)
		{
			SerializeValue(ar, &m_bLineDirRebarOfExp[stt][left], m_nFlag > 38);			// 가각 철근이 선형방향으로 배치될지?
			SerializeValue(ar, &m_nCountSupportRebarOfExpAtLineDirRebar[stt][left], m_nFlag > 38);	// 가각 철근이 선형방향으로 배치될때 기존 보강철근은 몇개가 배치될지
		}
	}
	
	

	// 사보강배치일때 사방향배치가 적용되는 구간 거리
	SerializeValue(ar, &m_dDistSttJijumDirPlacing[0]);			// 시점각도방향으로 배치되는 배력철근의 배치구간거리(시점에서부터의 거리)
	SerializeValue(ar, &m_dDistEndJijumDirPlacing[0]);			// 종점각도방향으로 배치된는 배력철근의 배치구간거리(종점에서부터의 거리)

	SerializeValue(ar, &m_dDistSttJijumDirPlacing[1], m_nFlag > 33);			// 시점각도방향으로 배치되는 배력철근의 배치구간거리(시점에서부터의 거리)
	SerializeValue(ar, &m_dDistEndJijumDirPlacing[1], m_nFlag > 33);			// 종점각도방향으로 배치된는 배력철근의 배치구간거리(종점에서부터의 거리)
	if(m_nFlag < 34)
	{
		m_dDistSttJijumDirPlacing[1]	= m_dDistSttJijumDirPlacing[0];
		m_dDistEndJijumDirPlacing[1]	= m_dDistEndJijumDirPlacing[0];
	}

	// 주철근
	SerializeValue(ar, &m_dDistLeftDirPlacing);				// 좌측면 각도 방향으로 배치되는 주철근의 배치구간거리(시점에서부터의 거리)
	SerializeValue(ar, &m_dDistRightDirPlacing);				// 우측면 각도 방향으로 배치되는 주철근의 배치구간거리(종점에서부터의 거리)



	// 철근 단수 설정
	for(upper = 0; upper < 2; upper++)
	{
		AhTPASerial(ar, &m_pArrSetRebarDanUpperSlab[upper], (CSetRebarDan*)0);		// 상부슬래브 상하면, 2단이상 철근의 철근지름 설정
		AhTPASerial(ar, &m_pArrSetRebarDanLowerSlab[upper], (CSetRebarDan*)0);		// 하부슬래브 상하면, 2단이상 철근의 철근지름 설정
	}
	
	for(stt = 0; stt < 2; stt++)
	{
		for(inner = 0; inner < 2; inner++)
			m_pArrSetRebarDanOutWall[stt][inner].Serialize(ar);						// 시종점, 내측 외측벽체 2단이상 철근의 철근지름 설정
	}
	
	for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
	{
		for(upper = 0; upper < 2; upper++)
		{
			SerializeValue(ar, &m_nCountDanMainRebarRib[cycle][upper], m_nFlag > 23);
		}
	}
	/////////////////////////////////////////////////////////////////////////////////////////////////////// 주철근 배치 //

	// 표준단면 철근 배치 관련 변수들 (배력철근, 전단철근)
	// 배력철근
	for(upper = 0; upper < 2; upper++)
	{
		for(dan = 0; dan < MAX_REBAR_DAN; dan++)
			m_placeByBlock_SupportRebar_UpperSlab[upper][dan].Serialize(ar);											// 상부슬래브 상하면
	}
	for(stt = 0; stt < 2; stt++)
	{
		for(inner = 0; inner < 2; inner++)
		{
			for(dan = 0; dan < MAX_REBAR_DAN; dan++)
			{
				m_placeByBlock_SupportRebar_OutWall[stt][inner][dan].Serialize(ar);										// 외측벽체 시종점, 내외측
			}
		}
	}
	if(ar.IsStoring() || m_nFlag > 25)
	{
		for(upper = 0; upper < 2; upper++)
		{
			for(dan = 0; dan < MAX_REBAR_DAN; dan++)
			{
				m_placeByBlock_SupportRebar_ArchRib[upper][dan][iLEFT].Serialize(ar);
				if(ar.IsStoring() || m_nFlag > 26)
					m_placeByBlock_SupportRebar_ArchRib[upper][dan][iRIGHT].Serialize(ar);
			}
		}
	}

	// 아치리브 하면 배력근 치수 정밀도.
	SerializeValue(ar, &m_dAccuracyArchRibLowerSupportDim, m_nFlag > 29);

	// 전단철근
	m_placeByBlock_ShearRebar_UpperSlab.Serialize(ar);		// 상부슬래브 전단철근 
	for(stt = 0; stt < 2; stt++)
		m_placeByBlock_ShearRebar_OutWall[stt].Serialize(ar);	// 측벽체 시종점 전단철근
	if(m_nFlag > 11)
	{
		for(stt = 0; stt < 2; stt++)
			m_placeByBlock_ShearRebar_Bracket[stt].Serialize(ar);	// 브라켓 시종점 전단철근
	}
	if(ar.IsStoring() || m_nFlag > 25)
	{
		m_placeByBlock_ShearRebar_ArchRib[iLEFT].Serialize(ar);
	}
	if(ar.IsStoring() || m_nFlag > 26)
	{
		m_placeByBlock_ShearRebar_ArchRib[iRIGHT].Serialize(ar);
	}

	if(ar.IsStoring() || m_nFlag > 28)
	{
		for(left = 0; left < 2; left++)
		{
			m_placeByBlock_StirrupRebar_ConnectSection[left].Serialize(ar);
			SerializeValue(ar, &m_nCountWrapShearRebar_StirrupRebar_ConnectSection[left], m_nFlag > 28);
		}
	}

	SerializeValue(ar, &m_nIdxCTC_SupportAndShearRebar);				// 전단철근 표준 배치 간격
	SerializeValue(ar, &m_dCTC_SupportRebar[iUPPER], m_nFlag > 0);		// index에서 double로 변경(2005.04.25)
	SerializeValue(ar, &m_dCTC_SupportRebar[iLOWER], m_nFlag > 47);
	SerializeValue(ar, &m_dCTC_ShearRebar[iUPPER], m_nFlag > 24);
	SerializeValue(ar, &m_dCTC_ShearRebar[iLOWER], m_nFlag > 47);
	for(stt = 0; stt < 2; stt++)
	{
		SerializeValue(ar, &m_dCTC_SupportRebarOutWall[stt], m_nFlag > 24);
		SerializeValue(ar, &m_dCTC_ShearRebarOutWall[stt], m_nFlag > 24);
	}
	SerializeValue(ar, &m_dCTC_ShearRebarBracket, m_nFlag > 48);

	if(m_nFlag < 24)
	{
		m_dCTC_ShearRebar[iUPPER]	= m_dCTC_SupportRebar[iUPPER];
		for(stt = 0; stt < 2; stt++)
		{
			m_dCTC_SupportRebarOutWall[stt]	= m_dCTC_SupportRebar[iUPPER];
			m_dCTC_ShearRebarOutWall[stt]	= m_dCTC_ShearRebar[iUPPER];
		}
	}

	if (m_nFlag < 48)
	{
		m_dCTC_SupportRebar[iLOWER] = m_dCTC_SupportRebar[iUPPER];
		m_dCTC_ShearRebar[iLOWER] = m_dCTC_ShearRebar[iUPPER];
	}

	// 스터럽 철근
	for(nJ = 0; nJ < MAX_JIJUM_COUNT_RC; nJ++)
		m_SlabGirderRebar[iUPPER][nJ].Serialize(ar);

	if(ar.IsLoading())
	{
		if(m_nFlag > 16)
		{
			for(left = 0; left < 2; left++)
			{
				m_girderRebarJong[left].Serialize(ar);
				for(stt = 0; stt < 2; stt++)
					m_girderRebarJongGagak[stt][left].Serialize(ar);
			}
		}

	}
	else
	{
		for(left = 0; left < 2; left++)
		{
			m_girderRebarJong[left].Serialize(ar);
			for(stt = 0; stt < 2; stt++)
				m_girderRebarJongGagak[stt][left].Serialize(ar);
		}
	}

	for(left = 0; left < 2; left++)
	{
		for(stt = 0; stt < 2; stt++)
		{
			SerializeValue(ar, &m_dDistGirderRebarJong[left][stt], m_nFlag > 16);
		}
	}


	// 시리얼 추가
	// 단절점부 철근 1cycle
	for(stt = 0; stt < 2; stt++)
	{
		SerializeValue(ar, &m_bIsDanbuRebar_Cycle1[iUPPER][stt]);					// 2 : 시종점(시점상단, 종점상단)	- 설치여부.
		long dan = 0; for(dan = 0; dan < 3; dan++)
		{
			SerializeValue(ar, &m_dDia_DanbuRebar_Cycle1[iUPPER][stt][dan]);			// 2 : 시종점(시점상단, 종점상단) - 지름
			SerializeValue(ar, &m_nType_DanbuRebar_Cycle1_XXX[stt][dan], m_nFlag > 9);				// 종류 0 : ㄷ, 1 : 갈고리
			if(m_nFlag < 38)
			{
				if(m_nType_DanbuRebar_Cycle1_XXX[stt][dan] == 1)
					m_nType_DanbuRebar_Cycle1_XXX[stt][dan] = 2;
			}
			SerializeValue(ar, &m_nIdxCTC_DanbuRebar_XXX[stt][dan]);  		// 2 : 시종점(시점상단, 종점상단) - CTC
			SerializeValue(ar, &m_dCTC_DanbuRebar_XXX[stt][dan], m_nFlag > 0);			// index에서  double로 변경 (2005.04.25)
		}
	}
	// 단절점부 철근 2cycle
	for(stt = 0; stt < 2; stt++)
	{
		SerializeValue(ar, &m_bIsDanbuRebar_Cycle2[iUPPER][stt], m_nFlag > 2);					// 2 : 시종점(시점상단, 종점상단)	- 설치여부.
		long dan = 0; for(dan = 0; dan < 3; dan++)
		{
			SerializeValue(ar, &m_dDia_DanbuRebar_Cycle2[iUPPER][stt][dan], m_nFlag > 2);			// 2 : 시종점(시점상단, 종점상단) - 지름
			SerializeValue(ar, &m_nType_DanbuRebar_Cycle2_XXX[stt][dan], m_nFlag > 9);				// 종류 0 : ㄷ, 1 : 갈고리
		}
	}

	// 하부 단절점부
	for(stt = 0; stt < 2; stt++)
	{
		SerializeValue(ar, &m_bIsDanbuRebar_Cycle1[iLOWER][stt], m_nFlag > 42);
		long dan = 0; for(dan = 0; dan < 3; dan++)
		{
			SerializeValue(ar, &m_dDia_DanbuRebar_Cycle1[iLOWER][stt][dan], m_nFlag > 42);
		}
	}
	for(stt = 0; stt < 2; stt++)
	{
		SerializeValue(ar, &m_bIsDanbuRebar_Cycle2[iLOWER][stt], m_nFlag > 42);
		long dan = 0; for(dan = 0; dan < 3; dan++)
		{
			SerializeValue(ar, &m_dDia_DanbuRebar_Cycle2[iLOWER][stt][dan], m_nFlag > 42);
		}
	}
	if(ar.IsLoading() && m_nFlag < 43)
	{
		m_nType_DanbuRebar = m_nType_DanbuRebar_Cycle1_XXX[0][0];
	}


	// 브라켓 철근 설치 여부
	for(cycle = 0; cycle < 2; cycle++)
	{
		for(stt = 0; stt < 2; stt++)
		{
			SerializeValue(ar, &m_bIsBracketRebar[cycle][stt], m_nFlag > 3);					// 1,2사이클, 시종점
		}
	}

	// 상부슬래브 둔각부 보강
	for(stt = 0; stt < 2; stt++)
	{
		for(left = 0; left < 2; left++)
		{
			SerializeValue(ar, &m_bIsObtuseAngle_UpperSlab[stt][left], m_nFlag > 18) ;	// 시종점, 좌우측
			SerializeValue(ar, &m_dCoverObtuseAngle_UpperSlab_Plane[stt][left][0], m_nFlag > 19);	// 시종점, 좌우측, 0:종방향,1:횡방향
			SerializeValue(ar, &m_dCoverObtuseAngle_UpperSlab_Plane[stt][left][1], m_nFlag > 19);	// 시종점, 좌우측, 0:종방향,1:횡방향
			for(upper = 0; upper < 2; upper++)
			{
				SerializeValue(ar, &m_dCoverObtuseAngle_UpperSlab[stt][left][upper], m_nFlag > 18);	// 시종점, 좌우측, 상하면피복
				SerializeValue(ar, &m_dLenObtuseAngle_UpperSlab[stt][left][upper], m_nFlag > 18);	// 시종점, 좌우측, 상하면 철근 길이
			}
			SerializeValue(ar, &m_dLenObtuseAngle_OutWall[stt][left], m_nFlag > 18);			// 시종점, 좌우측 상면 철근 벽체방향 길이
			
			if(ar.IsStoring() || m_nFlag > 18)
			{
				m_placeByBlock_ObtuseAngle_Support_UpperSlab[stt][left][iUPPER].Serialize(ar);	// 시종점 좌우측 선형방향 간격
				m_placeByBlock_ObtuseAngle_Main_UpperSlab[stt][left][iUPPER].Serialize(ar);	// 시종점 좌우측 횡방향 간격
			}

			if(ar.IsStoring() || m_nFlag > 20)
			{
				m_placeByBlock_ObtuseAngle_Support_UpperSlab[stt][left][iLOWER].Serialize(ar);	// 시종점 좌우측 선형방향 간격
				m_placeByBlock_ObtuseAngle_Main_UpperSlab[stt][left][iLOWER].Serialize(ar);	// 시종점 좌우측 횡방향 간격
				m_placeByBlock_ObtuseAngle_Support_OutWall[stt][left].Serialize(ar);		// 시종점 좌우측 벽체 선형방향 간격
			}

			SerializeValue(ar, &m_dDiaObtuseAngle_UpperSlabLower[stt][left], m_nFlag > 19);
		}
	}
	SerializeValue(ar, &m_dDiaObtuseAngle_UpperSlabLower_XXX, m_nFlag > 18);		// 선형방향 하면 보강철근 직경

	// 하부슬래브 둔각부 보강
	for(stt = 0; stt < 2; stt++)
	{
		for(left = 0; left < 2; left++)
		{
			SerializeValue(ar, &m_bIsObtuseAngle_LowerSlab[stt][left], m_nFlag > 50) ;					// 시종점, 좌우측
			SerializeValue(ar, &m_dCoverObtuseAngle_LowerSlab_Plane[stt][left][0], m_nFlag > 50);			// 시종점, 좌우측, 0:종방향,1:횡방향
			SerializeValue(ar, &m_dCoverObtuseAngle_LowerSlab_Plane[stt][left][1], m_nFlag > 50);		// 시종점, 좌우측, 0:종방향,1:횡방향
			for(upper = 0; upper < 2; upper++)
			{
				SerializeValue(ar, &m_dCoverObtuseAngle_LowerSlab[stt][left][upper], m_nFlag > 50);	// 시종점, 좌우측, 상하면피복
				SerializeValue(ar, &m_dLenObtuseAngle_LowerSlab[stt][left][upper], m_nFlag > 50);		// 시종점, 좌우측, 상하면 철근 길이
			}
			SerializeValue(ar, &m_dLenObtuseAngle_LowerOutWall[stt][left], m_nFlag > 50);				// 시종점, 좌우측 상면 철근 벽체방향 길이

			if(ar.IsStoring() || m_nFlag > 50)
			{
				m_placeByBlock_ObtuseAngle_Support_LowerSlab[stt][left][iUPPER].Serialize(ar);			// 시종점 좌우측 선형방향 간격
				m_placeByBlock_ObtuseAngle_Main_LowerSlab[stt][left][iUPPER].Serialize(ar);				// 시종점 좌우측 횡방향 간격
			}

			if(ar.IsStoring() || m_nFlag > 50)
			{
				m_placeByBlock_ObtuseAngle_Support_LowerSlab[stt][left][iLOWER].Serialize(ar);			// 시종점 좌우측 선형방향 간격
				m_placeByBlock_ObtuseAngle_Main_LowerSlab[stt][left][iLOWER].Serialize(ar);				// 시종점 좌우측 횡방향 간격
				m_placeByBlock_ObtuseAngle_Support_LowerOutWall[stt][left].Serialize(ar);				// 시종점 좌우측 벽체 선형방향 간격
			}			
		}
	}

	// 시종점벽체 예각부
	for(stt = 0; stt < 2; stt++)
	{
		for(left = 0; left < 2; left++)
		{
			SerializeValue(ar, &m_bIsAcuteAngle_OutWall[stt][left], m_nFlag > 21);	// 시종점 좌우측 벽체 예각부 설치 여부
			for(upper = 0; upper < 2; upper++)
			{
				SerializeValue(ar, &m_dCoverAcuteAngle_OutWall[stt][left][upper], m_nFlag > 21);	// 벽체 예각부 피복(시종점,좌우측,상하면)
			}
			SerializeValue(ar, &m_dLenAcuteangle_OutWall[stt][left], m_nFlag > 21);	// 벽체 예각부 철근길이(시종점,좌우측,상하면)
			if(ar.IsStoring() || m_nFlag > 21)
			{
				m_placeByBlock_AcuteAngle_MainRebar_OutWall[stt][left].Serialize(ar);	// 벽체 예각부 철근 배치 간격
				m_placeByBlock_AcuteAngle_SupportRebar_OutWall[stt][left].Serialize(ar);
				m_rebarInfoCycle_AcuteAngle_OutWall[stt][left].Serialize(ar);	// 벽체 예각부 철근
				SerializeValue(ar, &m_dRange_AcuteAngle_OutWall[stt][left], m_nFlag > 21);
			}
		}
	}




	SerializeValue(ar, &m_nTypePlacingSupportRebar_UpperSlab);
	SerializeValue(ar, &m_nTypePlacingMainRebar_UpperSlab);
	SerializeValue(ar, &m_nTypePlacingMainRebar_Footing);		// 기초 주철근 배치 타입(0 : 선형방향, 1 : 사보강, 2 : 사보강(구간추가)
	SerializeValue(ar, &m_dRangeSupportRebarForSameUpperSlab[iSTT], m_nFlag > 13);
	SerializeValue(ar, &m_dRangeSupportRebarForSameUpperSlab[iEND], m_nFlag > 13);

	if(ar.IsStoring() || m_nFlag > 30)
	{
		for(stt = 0; stt < 2; stt++)
		{
			m_placeByBlock_SupportRebarAddSameUpperSlab[stt].Serialize(ar);	// 상부슬래브 처럼 꺽을 배력근이 추가될 범위
			for(left = 0; left < 2; left++)
				SerializeValue(ar, &m_dDistAddSupportRebarForSameUpperSlab[stt][left], m_nFlag > 30);	// 상부슬래브 처럼 꺽을 추가되는 배력근의 좌우측 거리
		}
	}

	if(ar.IsStoring() || m_nFlag > 31)
	{
		SerializeValue(ar, &m_nTypeSideRebarMain_UpperSlabSabogang);		// 사보강 배치시 좌우측 주철근 타입(0 : 직선, 1 : 선형따라)
	}
	if(ar.IsStoring() || m_nFlag > 32)
	{
		SerializeValue(ar, &m_bFixOutSideMainRebarBy1Cyle);					// 최외측 주철근 1cycle로 고정(2, 4사이클일 경우 적용) - 벽체 기초, 슬래브 모두 적용
	}
		


	// 브라켓철근
	for(stt = 0; stt < 2; stt++)
	{
		SerializeValue(ar, &m_dDiaRebarMain_Bracket_Cycle1[stt]);
		SerializeValue(ar, &m_dDiaRebarMain_Bracket_Cycle2[stt], m_nFlag > 3);
		SerializeValue(ar, &m_dDiaRebarSupport_Bracket[stt]);
		if(ar.IsLoading())
		{
			if(m_nFlag < 52)
			{
				SerializeValue(ar, &m_dDiaRebarShear_Bracket_XXX[stt]);
				m_RebarShearDetail_Bracket[stt].m_dDia = m_dDiaRebarShear_Bracket_XXX[stt];
			}
		}
	}

	// 철근 집계
	AhTPASerial(ar, &m_pArrRebarMain, (CRebar*)0);		// 주철근
	AhTPASerial(ar, &m_pArrRebarSupport, (CRebar*)0);	// 배력철근
	AhTPASerial(ar, &m_pArrRebarShear, (CRebar*)0);		// 전단철근
	AhTPASerial(ar, &m_pArrRebarEtc, (CRebar*)0);		// 기타철근
	if(ar.IsStoring())
	{
		AhTPASerial(ar, &m_pArrRebarGirder, (CRebar*)0);		// 기타철근
	}
	else
	{
		if(m_nFlag>8)
			AhTPASerial(ar, &m_pArrRebarGirder, (CRebar*)0);		// 기타철근
	}
	AhTPASerial(ar, &m_pArrRebarMonument, (CRebar*)0);	// 교명주 받침 철근
	if(ar.IsStoring())
	{
		AhTPASerial(ar, &m_pArrRebarMain_User, (CRebar*)0);
		AhTPASerial(ar, &m_pArrRebarGirder_User, (CRebar*)0);
	}
	else
	{
		if(m_nFlag>44)
		{
			AhTPASerial(ar, &m_pArrRebarMain_User, (CRebar*)0);
			AhTPASerial(ar, &m_pArrRebarGirder_User, (CRebar*)0);
		}
	}
	// ******************* SerializeRebar 함수 사용하는 변수들 표시선  ***************************
}

void CRcBridgeRebar::SerializeRebarBox( CArchive &ar )
{
	// Box형식 철근 추가
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;

	if(ar.IsStoring())
	{
		for(long jijum = 0; jijum < MAX_JIJUM_COUNT_RC; jijum++)
		{
			long upper = 0; for(upper = 0; upper < 2; upper++)
			{
				long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
				{
					ar << m_nCountJointMainRebar_LowerSlab_Cycle1[jijum][upper][dan];	// 상부슬래브 상,하면 각 지간별 이음 개수
					ar << m_nCountJointMainRebar_LowerSlab_Cycle2[jijum][upper][dan];	// 상부슬래브 상,하면 각 지간별 이음 개수
				}
			}
		}

		for(long upper = 0; upper < 2; upper++)
		{
			for(long cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
			{
				for(long dan = 0; dan < MAX_REBAR_DAN; dan++)
				{
					pStd->SerializeArrayOfDoubleArray(ar, &m_pArrExistLowerSlab[cycle][upper][dan]);
				}
			}
		}

		for(long cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
		{
			m_dArrDiaLowerSlabHunch[cycle].Serialize(ar);
		}
		m_dArrTypeLowerSlabHunch.Serialize(ar);

		for(long nJ = 0; nJ < MAX_JIJUM_COUNT_RC; nJ++)
			m_SlabGirderRebar[iLOWER][nJ].Serialize(ar);

		for(long upper = 0; upper < 2; upper++)
		{
			for(long dan = 0; dan < MAX_REBAR_DAN; dan++)
				m_placeByBlock_SupportRebar_LowerSlab[upper][dan].Serialize(ar);											// 상부슬래브 상하면
		}

		m_RebarShearDetail_UpperSlab.Serialize(ar);		// 하부슬래브
		m_placeByBlock_ShearRebar_LowerSlab.Serialize(ar);		// 하부슬래브 전단철근 

		for(long iUD=iUPPER; iUD<=iLOWER; iUD++)
		{
			for(long stt = 0; stt < 2; stt++)
			{
				ar << m_nCountStirrupCtcMainRebar[iUD][stt]; //단부 스터럽 철근 주철근 간격
			}
		}

		for(long nDan = 0; nDan < MAX_REBAR_DAN; nDan++)
		{
			ar << m_dDanCorner_UpperSlab[nDan];
			ar << m_dDanCorner_LowerSlab[nDan];
		}
		ar << m_dDanCorner_UpperVert;
		ar << m_dDanCorner_LowerVert;
		ar << m_bUpperSlab_CornerCurve;
		ar << m_bLowerSlab_CornerCurve;
	}
	else
	{
		if(m_nFlag > 42)
		{
			for(long jijum = 0; jijum < MAX_JIJUM_COUNT_RC; jijum++)
			{
				long upper = 0; for(upper = 0; upper < 2; upper++)
				{
					long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
					{
						ar >> m_nCountJointMainRebar_LowerSlab_Cycle1[jijum][upper][dan];	// 상부슬래브 상,하면 각 지간별 이음 개수
						ar >> m_nCountJointMainRebar_LowerSlab_Cycle2[jijum][upper][dan];	// 상부슬래브 상,하면 각 지간별 이음 개수
					}
				}
			}

			for(long upper = 0; upper < 2; upper++)
			{
				for(long cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
				{
					for(long dan = 0; dan < MAX_REBAR_DAN; dan++)
					{
						pStd->SerializeArrayOfDoubleArray(ar, &m_pArrExistLowerSlab[cycle][upper][dan]);
					}
				}
			}

			for(long cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
			{
				m_dArrDiaLowerSlabHunch[cycle].Serialize(ar);
			}
			m_dArrTypeLowerSlabHunch.Serialize(ar);

			for(long nJ = 0; nJ < MAX_JIJUM_COUNT_RC; nJ++)
				m_SlabGirderRebar[iLOWER][nJ].Serialize(ar);

			for(long upper = 0; upper < 2; upper++)
			{
				for(long dan = 0; dan < MAX_REBAR_DAN; dan++)
					m_placeByBlock_SupportRebar_LowerSlab[upper][dan].Serialize(ar);											// 상부슬래브 상하면
			}

			m_RebarShearDetail_UpperSlab.Serialize(ar);		// 하부슬래브
			m_placeByBlock_ShearRebar_LowerSlab.Serialize(ar);		// 하부슬래브 전단철근 

			for(long iUD=iUPPER; iUD<=iLOWER; iUD++)
			{
				for(long stt = 0; stt < 2; stt++)
				{
					ar >> m_nCountStirrupCtcMainRebar[iUD][stt]; //단부 스터럽 철근 주철근 간격
				}
			}
		}

		if(m_nFlag > 43)
		{
			for(long nDan = 0; nDan < MAX_REBAR_DAN; nDan++)
			{
				ar >> m_dDanCorner_UpperSlab[nDan];
				ar >> m_dDanCorner_LowerSlab[nDan];
			}
		}
		if(m_nFlag > 52)
		{
			ar >> m_dDanCorner_UpperVert;
			ar >> m_dDanCorner_LowerVert;		
			ar >> m_bUpperSlab_CornerCurve;		
			ar >> m_bLowerSlab_CornerCurve;	
		}
	}
}

// sta으로 지점번호를 찾아서 연결되었는지 체크함.
// 가장 가까운 곳을 찾음
BOOL CRcBridgeRebar::IsJointMainRebarUpperSlab_Lower_Cycle2(double dSta)
{
	long nJijum		= 0;
	double dNearest	= fabs(dSta - GetStationOnJijum(0, 0));
	for(long jijum = 1; jijum < m_nQtyJigan+1; jijum++)
	{
		if(fabs(dSta-GetStationOnJijum(jijum, 0)) < dNearest)
		{
			dNearest	= fabs(dSta - (dSta-GetStationOnJijum(jijum, 0)));
			nJijum		= jijum;
		}
	}

	return IsJointMainRebarUpperSlab_Lower_Cycle2((long)nJijum);
}

// 존재하는 철근에서 사용되는 철근중의 nIdx에 해당하는 철근을 리턴한다. 
CRebarInfoCycle *CRcBridgeRebar::GetRebarInfoCycleUpperSlabCheckExist(long nCycle, long nDan, BOOL bUpper, long nIdx)
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return FALSE;
	if(nDan == -1) nDan = MAX_REBAR_DAN-1;
	if(nDan < 0 || nDan > MAX_REBAR_DAN-1) return FALSE;

	// 필요한 RebarInfoCycle 배열을 찾음
	long upper	= bUpper ? iUPPER : iLOWER;
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = &m_pArrRCMainUpperSlab[nCycle][upper][nDan];
	if(!pArrRC) return FALSE;

	long nSize	= pArrRC->GetSize();
	if(nIdx == -1)
	{		
		long i = 0; for(i = nSize-1; i >= 0; --i)
		{
			CRebarInfoCycle *pRc = pArrRC->GetAt(i);
			if(!pRc)	continue;

			if(pRc->m_bExist && pRc->m_Dia > 0)
			{
				nIdx = i;
				break;
			}
		}
	}
	else
	{
		long nRealIdx = -1;
		long i = 0; for(i = 0; i < nSize; i++)
		{
			CRebarInfoCycle *pRc = pArrRC->GetAt(i);
			if(!pRc)	continue;

			if(pRc->m_bExist && pRc->m_Dia > 0)
				nRealIdx++;

			if(nIdx == nRealIdx)
			{
				nIdx = i;
				break;
			}
		}
	}

	if(nIdx >= nSize) return FALSE;
	if(nIdx < 0) return FALSE;

	return pArrRC->GetAt(nIdx);
}

// RebarInfoCycle 하나를 찾아서 리턴한다.
CRebarInfoCycle *CRcBridgeRebar::GetRebarInfoCycleUpperSlab(long nCycle, long nDan, BOOL bUpper, long nIdx)
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return FALSE;
	if(nDan == -1) nDan = MAX_REBAR_DAN-1;
	if(nDan < 0 || nDan > MAX_REBAR_DAN-1) return FALSE;

	// 필요한 RebarInfoCycle 배열을 찾음
	long upper	= bUpper ? iUPPER : iLOWER;
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = &m_pArrRCMainUpperSlab[nCycle][upper][nDan];
	if(!pArrRC) return FALSE;

	long nSize	= pArrRC->GetSize();
	if(nIdx == -1) nIdx = nSize-1;
	if(nIdx >= nSize) return FALSE;
	if(nIdx < 0) return FALSE;

	return pArrRC->GetAt(nIdx);
	/*
	// 포인터를 넘겨도 되지만 별개로 관리해야 메모리 관리가 어지럽지 않을꺼 같아서 이렇게 함.
	*pRC	= *pArrRC->GetAt(nIdx);
	*/
}

// 시종점 내외측 벽체의 이음 정보 가져오는 함수(주철근용)
void CRcBridgeRebar::MakeJointMainRebarOutWall(CJointArray &arrJoint, long nCycle, long nDan, BOOL bStt, BOOL bInner)
{
	arrJoint.RemoveAll();
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return;

	// 필요한 RebarInfoCycle를 찾음
	long stt	= bStt ? iSTT : iEND;
	long inner	= bInner ? iINNER : iOUTTER;
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = &m_pArrRCMainOutWall[nCycle][stt][inner][nDan];
	if(!pArrRC) return;

	// 1단이면서 외측벽체 외측의 경우 상부슬래브와 연결되는 형태이므로 체크할때 상부슬래브 첫번째나 끝에있는 철근도 추가해서 검사해야 된다.
	BOOL bAddUpperSlabRebarInfoCycle = FALSE;
	BOOL bAddLowerSlabRebarInfoCycle = FALSE;
	if(!bInner && (nDan == 0 || m_bDetailInput23DanMainRebar))
	{
		bAddUpperSlabRebarInfoCycle	= TRUE;
		if(IsBoxType())
			bAddLowerSlabRebarInfoCycle = TRUE;
	}

	if(bAddUpperSlabRebarInfoCycle)
	{
		if(bStt)
		{
			CRebarInfoCycle *pRCTmp	= GetRebarInfoCycleUpperSlab(nCycle, nDan, TRUE, 0);
			if(pRCTmp)
			{
				CRebarInfoCycle *pRC	= new CRebarInfoCycle;
				*pRC	= *pRCTmp;
				pArrRC->Add(pRC);
			}
			else
				bAddUpperSlabRebarInfoCycle	= FALSE;
		}
		else
		{
			CRebarInfoCycle *pRCTmp	= GetRebarInfoCycleUpperSlab(nCycle, nDan, TRUE, -1);
			if(pRCTmp)
			{
				CRebarInfoCycle *pRC	= new CRebarInfoCycle;
				*pRC	= *pRCTmp;
				m_Util.InvertRebarInfoCycle(pRC);
				pArrRC->Add(pRC);
			}
			else
				bAddUpperSlabRebarInfoCycle	= FALSE;
		}
	}
	if(bAddLowerSlabRebarInfoCycle)
	{
		if(bStt)
		{
			CRebarInfoCycle *pRCTmp	= GetRebarInfoCycleLowerSlab(nCycle, nDan, FALSE, 0);
			if(pRCTmp)
			{
				CRebarInfoCycle *pRC	= new CRebarInfoCycle;
				*pRC	= *pRCTmp;
				m_Util.InvertRebarInfoCycle(pRC);
				pArrRC->InsertAt(0, pRC);
			}
			else
				bAddLowerSlabRebarInfoCycle	= FALSE;
		}
		else
		{
			CRebarInfoCycle *pRCTmp	= GetRebarInfoCycleLowerSlab(nCycle, nDan, FALSE, -1);
			if(pRCTmp)
			{
				CRebarInfoCycle *pRC	= new CRebarInfoCycle;
				*pRC	= *pRCTmp;
				pArrRC->InsertAt(0, pRC);
			}
			else
				bAddLowerSlabRebarInfoCycle	= FALSE;
		}
	}

	// 정보분석
	m_Util.GetJointAtRebarInfoCycleArray(arrJoint, pArrRC);

	if(bAddUpperSlabRebarInfoCycle)
	{
		long nSize	= pArrRC->GetSize();
		if(nSize > 0)
		{
			delete pArrRC->GetAt(nSize-1);
			pArrRC->RemoveAt(nSize-1);
		}
	}
	if(bAddLowerSlabRebarInfoCycle)
	{
		if(pArrRC->GetSize() > 0)
		{
			delete pArrRC->GetAt(0);
			pArrRC->RemoveAt(0);
		}
	}
}

void CRcBridgeRebar::MakeJointMainRebarUpperSlab(CJointArray &arrJoint, long nCycle, long nDan, BOOL bUpper)
{
	arrJoint.RemoveAll();
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return;

	// 필요한 RebarInfoCycle를 찾음
	long upper	= bUpper ? iUPPER : iLOWER;
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = &m_pArrRCMainUpperSlab[nCycle][upper][nDan];
	if(!pArrRC) return;

	// 정보분석
	m_Util.GetJointAtRebarInfoCycleArray(arrJoint, pArrRC);
}

void CRcBridgeRebar::MakeJointMainRebarRib(CJointArray &arrJoint, long nCycle, long nDan, BOOL bUpper, CParabola *pPb)
{
	arrJoint.RemoveAll();
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return;

	// 필요한 RebarInfoCycle를 찾음
	long upper	= bUpper ? iUPPER : iLOWER;
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = &m_pArrRCMainRib[nCycle][upper][nDan];
	if(!pArrRC) return;

	// 정보분석
	m_Util.GetJointAtRebarInfoCycleArray(arrJoint, pArrRC, TRUE);
}
// 일반적인 권고안시는 input형태로 마크하고, 마크권고안용일때는 input아닌 형태로 해서 설정된 값에 맞게 마크를 설정한다.
// BOOL bInit : 마크권고안 할때 초기화를 할 지...
void CRcBridgeRebar::SetStringMarkToRebarInfoCycle(CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC, long nType, long nCycle, BOOL bInput, BOOL bInit, long nDan)
{
	if(!pArrRC) return;
	if(bInit)
		GetMarkRebarMain(nType, bInput, 0, TRUE, TRUE, _T(""), nDan);

	CString str	= _T("");
	long nSize	= pArrRC->GetSize();

	long i = 0; for(i = 0; i < nSize; i++)
	{
		CRebarInfoCycle *pRC	= pArrRC->GetAt(i);
		if(!pRC->m_bExist && !bInput) continue;

		pRC->m_szMark			= GetMarkRebarMain(nType, bInput, nCycle, FALSE, TRUE, _T(""), nDan);
	}
}

// 상부 슬래브 description 설정
void CRcBridgeRebar::SetStringDescriptionRebarInfoCycle_UpperSlab(CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC, long nCycle, BOOL bUpper, long nDan)
{
	if(!pArrRC) return;

	CString sUpper	= bUpper ? "상" : "하";
	CString sCycle	= m_pARcBridgeDataStd->GetStringCircleNum(nCycle+1);
	long nIdx		= 1;

	long nSize	= pArrRC->GetSize();
	long i = 0; for(i = 0; i < nSize; i++)
	{
		CRebarInfoCycle *pRC	= pArrRC->GetAt(i);
		if(!pRC->m_bExist) continue;

		pRC->m_sDescription.Format("상부SLAB %s면 %d단 %s %d", sUpper, nDan+1, sCycle, nIdx++);
	}
}

// 리브 description 설정
void CRcBridgeRebar::SetStringDescriptionRebarInfoCycle_ArchRib(CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC, long nCycle, BOOL bUpper, long nDan)
{
	if(!pArrRC) return;

	CString sUpper	= bUpper ? "배" : "복";
	CString sCycle	= m_pARcBridgeDataStd->GetStringCircleNum(nCycle+1);
	long nIdx		= 1;

	long nSize	= pArrRC->GetSize();
	long i = 0; for(i = 0; i < nSize; i++)
	{
		CRebarInfoCycle *pRC	= pArrRC->GetAt(i);
		if(!pRC->m_bExist) continue;

		pRC->m_sDescription.Format("RIB %s선 %d단 %s %d", sUpper, nDan+1, sCycle, nIdx++);
	}
}

// 외측 벽체 description 설정
void CRcBridgeRebar::SetStringDescriptionRebarInfoCycle_OutWall(CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC, BOOL bStt, BOOL bInner, long nDan, long nCycle)
{
	if(!pArrRC) return;

	CString sStt	= bStt ? "시점" : "종점";
	CString sInner	= bInner ? "내측" : "외측";
	CString sCycle	= m_pARcBridgeDataStd->GetStringCircleNum(nCycle+1);
	long nIdx		= 1;

	long nSize	= pArrRC->GetSize();
	long i = 0; for(i = 0; i < nSize; i++)
	{
		CRebarInfoCycle *pRC	= pArrRC->GetAt(i);
		pRC->m_sDescription.Format("%s벽체 %s면 %d단 %s %d", sStt, sInner, nDan+1, sCycle, nIdx++);
	}
}

// 상부슬래브 헌치 sDescription 설정
void CRcBridgeRebar::SetStringDescriptionRebarInfoCycle_UpperSlabHunch(CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC, long nCycle)
{
	if(!pArrRC) return;

	CString sCycle	= m_pARcBridgeDataStd->GetStringCircleNum(nCycle+1);
	long nIdx		= 1;

	long nSize	= pArrRC->GetSize();
	long i = 0; for(i = 0; i < nSize; i++)
	{
		CRebarInfoCycle *pRC	= pArrRC->GetAt(i);
		pRC->m_sDescription.Format("상부SLAB 헌치부철근 %s %d", sCycle, nIdx++);
	}
}

// rebarinfocycle에 관한 모든걸 생성한다. 
// 다른데선 할 필요 없이 요거만 한번 호출 하면 됨. ㅋㅋ
// BOOL bInput : 철근마크 기호가 상황에 따라서 바뀐다.
// 주의 : 부위별로 for  문을 따로 돌리는 이유는 부위별로 연속해서 철근을 생성해야 철근 기호가 연속으로 정상적으로 나오기 때무닝다.
// *** cycle별로 먼저 만들고 2,3단 철근 생성해야 됨. (반드시 순서 준수)
void CRcBridgeRebar::MakeRebarInfoCycleStd(BOOL bInput, long nVertDir)
{
	BOOL bVertDir	= IsVertDir();
	if(nVertDir != 0)
		bVertDir	= nVertDir == -1 ? TRUE : FALSE;
	m_bMakedRebarInfoCycleByVert	= bVertDir;

	long nCountWall	= GetCountInWall();

	long cycle(0), dan(0), upper(0), left(0);

	// 상부슬래브 철근을 제어하는 내용이 외측벽체 철근 생성함수에 포함되어 있으면 안된다.
	for(dan = 0; dan < MAX_REBAR_DAN; dan++)
	{
		for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle ++)
		{
			// 외측벽체근
			MakeRebarInfoCycle_OutWall(cycle, dan, bInput, nVertDir);
		}
	}

	for(dan = 0; dan < MAX_REBAR_DAN; dan++)
	{
		for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle ++)
		{
			// 상부 슬래브
			MakeRebarInfoCycle_UpperSlab(cycle, dan, bInput, nVertDir);
		}
	}

	// 상부슬래브와 하부슬래브는 For문을 따로 돌린다. 같이 돌리면 static으로 만들어진 번호가 섞여서 뒤죽박죽..
	for(dan = 0; dan < MAX_REBAR_DAN; dan++)
	{
		for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle ++)
		{
			// 하부 슬래브
			MakeRebarInfoCycle_LowerSlab(cycle, dan, bInput, nVertDir);
		}
	}

	// 외측벽체 헌치
	for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle ++)
	{
		MakeRebarInfoCycle_OutWall_Hunch(cycle, bInput, nVertDir);
	}

	// 브라켓
	MakeRebarInfoCycle_OutWall_Bracket(nVertDir);

	//부상방지저판
	MakeRebarInfoCycle_BFooting(nVertDir);
	// 기초
	MakeRebarInfoCycle_FootingAll(bInput, nVertDir);

	
	// 내측 벽체 철근
	for(long wall = 0; wall < nCountWall; wall++)
	{
		CWallApp *pWall	= GetInWall(wall);
		CString sWall	= _T("");
		sWall.Format("중간지점%d", wall+1);
		if(pWall)
		{
			for(dan = 0; dan < MAX_REBAR_DAN; dan++)
			{
				for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle ++)
				{
					pWall->MakeRebarInfoCycle(cycle, TRUE, dan, bInput, bInput ? dan==0 : wall==0&&cycle==0&&dan==0, bVertDir);
					pWall->MakeRebarInfoCycle(cycle, FALSE, dan, bInput, bInput ? dan==0 : FALSE, bVertDir);

					// 중간벽체를 지점별로 분리해서 description 붙여줌 ////
					for(left = 0; left < 2; left++)
					{
						CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = &pWall->m_pArrRCMain[cycle][left][dan];
						long i = 0; for(i = 0; i < pArrRC->GetSize(); i++)
							pArrRC->GetAt(i)->m_sDescription.Replace("중간지점", sWall);
					}
					//////////////////////////////////////////////////////
				}
			}
		}
	}


	for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle ++)
	{
		// 헌치부 철근
		MakeRebarInfoCycle_UpperSlabHunch(cycle, bInput, nVertDir);
		MakeRebarInfoCycle_LowerSlabHunch(cycle, bInput, nVertDir);
	}

	// 단 절점부 철근
	MakeRebarInfoCycle_UpperDanbu(bInput, nVertDir);
	MakeRebarInfoCycle_LowerDanbu(bInput, nVertDir);
	
	// 둔각부
	MakeRebarInfoCycle_ObtuseAngle_Slab(bInput, nVertDir, TRUE);
	if(IsBoxType())
		MakeRebarInfoCycle_ObtuseAngle_Slab(bInput, nVertDir, FALSE);

	// 벽체 예각부
	MakeRebarInfoCycle_ACuteAngle_OutWall(bInput, nVertDir);

	// 리브
	for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
	{
		for(upper = 0; upper < 2; upper++)
		{
			BOOL bUpper	= upper == iUPPER;
			for(dan = 0; dan < MAX_REBAR_DAN; dan++)
			{
				MakeRebarInfoCycle_ArchRib(cycle, dan, bUpper, bInput, nVertDir);
			}
		}
	}

	// Not Exist는 모든 철근을 구한 뒤에 삭제 해야 됨
	// 각각의 철근은 이음 때문에 상호 연관성이 있기 때문임.
	if(!bInput)
	{
	}

}

// 상부슬래브 주철근이 몇단까지 배근되는지 리턴
long CRcBridgeRebar::GetDanMainRebarUpperSlab(long nCycle, BOOL bUpper, long nIdx)
{
	long upper	= bUpper ? iUPPER : iLOWER;
	long nSize = m_pArrSetRebarDanUpperSlab[upper].GetSize();
	if(nIdx == -1) nIdx = nSize-1;
	if(nIdx < 0 || nIdx >= nSize) return 1;

	CSetRebarDan *pRD	= m_pArrSetRebarDanUpperSlab[upper].GetAt(nIdx);

	long nDan	= pRD->m_nCountDan;
	if(nDan < 1 || nDan > MAX_REBAR_DAN) 
	{
		nDan = 1;
	}

	long nDanReal	= 1;

	if(m_bDetailInput23DanMainRebar)
	{
		long dan = 0; for(dan = 1; dan < MAX_REBAR_DAN; dan++)
		{
			BOOL bOKDia	= FALSE;
			BOOL bOKExist	= FALSE;
			long i = 0; for(i = 0; i < m_pArrDiaUpperSlab[nCycle][upper][dan].GetSize(); i++)
			{
				CDoubleArray *pDArr	= m_pArrDiaUpperSlab[nCycle][upper][dan].GetAt(i);
				long j = 0; for(j = 0; j < pDArr->GetSize(); j++)
				{
					if(pDArr->GetAt(j) > 0)
					{
						bOKDia	= TRUE;
						break;
					}
				}
			}

			for(i = 0; i < m_pArrExistUpperSlab[nCycle][upper][dan].GetSize(); i++)
			{
				CDoubleArray *pDArr	= m_pArrExistUpperSlab[nCycle][upper][dan].GetAt(i);
				long j = 0; for(j = 0; j < pDArr->GetSize(); j++)
				{
					if((BOOL)pDArr->GetAt(j) == TRUE)
					{
						bOKExist	= TRUE;
						break;
					}
				}
			}

			if(bOKDia && bOKExist)
				nDanReal++;
		}
	}
	else
	{
		long i = 0; for(i = 1; i < nDan; i++)
		{
			if(pRD->m_dDia[nCycle][i] > 0)
				nDanReal++;
		}

		if(nDanReal < 1 || nDanReal > MAX_REBAR_DAN) 
		{
			nDanReal = 1;
		}
	}

	return nDanReal;
}

// 외측벽체 주철근이 몇단까지 배근되는지 리턴
// 좌우측만 따로 있음.
long CRcBridgeRebar::GetDanMainRebarOutWall(long nCycle, BOOL bStt, BOOL bInner)
{
	long stt	= bStt ? iSTT : iEND;
	long inner	= bInner ? iINNER : iOUTTER;
	CSetRebarDan *pRD	= &m_pArrSetRebarDanOutWall[stt][inner];

	long nDan	= pRD->m_nCountDan;
	if(nDan < 1 || nDan > MAX_REBAR_DAN) 
	{
		nDan = 1;
	}

	long nDanReal	= 1;
	if(m_bDetailInput23DanMainRebar)
	{
		long dan = 0; for(dan = 1; dan < MAX_REBAR_DAN; dan++)
		{
			BOOL bOKDia	= FALSE;
			BOOL bOKExist	= FALSE;
			long i = 0; for(i = 0; i < m_pArrDiaOutWall[nCycle][stt][inner][dan].GetSize(); i++)
			{
				if(m_pArrDiaOutWall[nCycle][stt][inner][dan].GetAt(i) > 0)
				{
					bOKDia	= TRUE;
					break;
				}
			}

			for(i = 0; i < m_pArrExistOutWall[nCycle][stt][inner][dan].GetSize(); i++)
			{
				if((BOOL)m_pArrExistOutWall[nCycle][stt][inner][dan].GetAt(i) == TRUE)
				{
					bOKExist	= TRUE;
					break;
				}
			}

			if(bOKDia && bOKExist)
				nDanReal++;
		}
	}
	else
	{
		long i = 0; for(i = 1; i < nDan; i++)
		{
			if(pRD->m_dDia[nCycle][i] > 0)
				nDanReal++;
		}

		if(nDanReal < 1 || nDanReal > MAX_REBAR_DAN) 
		{
			nDanReal = 1;
		}
	}

	return nDanReal;
}

// 지점번호로 헌치부 철근 지름 파악.
// 헌치 철근 지름은 외측 벽체가 없는 경우라도 한자리 차지하고 잇다. (0)으로 ...
// 어짜피 있고 없고는 0인지 아닌지로 구분하므로..
// 좀 더 확실한 판단을 위해 외측벽체 존재 유무도 검사한다. ㅋㅋ
double CRcBridgeRebar::GetDiaMainRebarUpperSlabHunch(long nCycle, long nJijum)
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return 0;
	if(nJijum == -1) nJijum = m_nQtyJigan;
	if(nJijum < 0 || nJijum > m_nQtyJigan) return 0;
	
	CDoubleArray *pdArr	= &m_dArrDiaUpperSlabHunch[nCycle];
	if(!pdArr) return 0;
	
	double dDia	= 0;
	long nSize	= pdArr->GetSize();
	if(nSize-1 < nJijum) dDia = 0;
	else dDia	= pdArr->GetAt(nJijum);

	// 진짜 헌치가 있는지 한번 더 검사.
	//if(!IsHunch(nJijum)) dDia	= 0;
	
	return dDia;
}

// 입력된 정보로 상부슬래브 상면 헌치 철근(모든 사이클)
void CRcBridgeRebar::MakeRebarInfoCycle_UpperSlabHunch(long nCycle, BOOL bInput, long nVertDir)
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar() - 1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar() - 1) return;

	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC	= &m_pArrRCMainUpperSlabHunch[nCycle];
	if(!pArrRC) return;
	AhTPADelete(pArrRC, (CRebarInfoCycle*)0);

	BOOL bVertDir	= IsVertDir();
	if(nVertDir != 0)
		bVertDir	= nVertDir == -1 ? TRUE : FALSE;

//	const double dSettle	= 100;	// 시종점 헌치철근 좌우로 확장되는 길이(정착장)
	CRebarPlacing rb;
	long nCountJijum	= m_nQtyJigan+1;
	CWallApp *pWall		= NULL;
	double dCover		= m_dCoverLower_UpperSlab[0];
	CTwinVector tvRebarUpper	= GetTvOffset_UpperSlab(0, TRUE, -1, -1, bVertDir);	// 상부슬래브 상면 주철근 1단
	CTwinVector tvInner;
	
	
	// 벽체 없는 경우의 피복 적용 ////////////////////////////
	CDPoint vAngStt	= bVertDir ? CDPoint(0, 1) : GetAngleJijum(0);
	CDPoint vAngEnd	= bVertDir ? CDPoint(0, 1) : GetAngleJijum(m_nQtyJigan);
	
	// dSttSta와 dEndSta가 모두 -1이면 벽체 시작부터 끝까지로 인식...
	double dCoverSideStt	= m_dCoverWallOut[0]/vAngStt.y;//IsOutWall(TRUE) ? m_dCoverWallOut[0]/vAngStt.y : GetCoverSide_UpperSlab(0)/vAngStt.y;
	double dCoverSideEnd	= m_dCoverWallOut[0]/vAngStt.y;//IsOutWall(FALSE) ? m_dCoverWallOut[0]/vAngEnd.y : GetCoverSide_UpperSlab(0)/vAngEnd.y;
	////////////////////////////////////////////////////////////////

	for(long jijum = 0; jijum < nCountJijum; jijum++)
	{
		double dDia	= GetDiaMainRebarUpperSlabHunch(nCycle, jijum);
		if(Compare(dDia, 0.0, "<=")) continue;
		//if(!IsHunch(jijum)) continue;
		if(IsArchType() && jijum == GetJijumConnectRibAndSlab()) continue;
		
		pArrRC->Add(new CRebarInfoCycle);
		CRebarInfoCycle *pRC	= pArrRC->GetAt(pArrRC->GetSize()-1);

		// 공통속성
		pRC->m_nTypeRebar		= REBAR_TYPE_MAIN;
		pRC->m_nRebarDan		= 0;
		pRC->m_nPosStt			= REBARINFO_POS_UPPERSLAB_LOWER;
		pRC->m_nPosEnd			= REBARINFO_POS_UPPERSLAB_LOWER;
		pRC->m_Dia				= dDia;
		pRC->m_bUseTvArrRebar	= TRUE;
		pRC->m_nPosHunch		= jijum;	// 이 철근이 어느 지점의 철근이지 기억 해둔다. (배근할때 반드시 필요함)

		// (39755) 양끝이 정착장 만큼 들어가야 하는데 100 만 넣어줬네.. 철근 그릴때 길이 표현하면 실제 수량과 다름
		double dRebarSpace	= GetCtcRebarMain(TRUE);
		double dSettle(0);
		if(m_pARcBridgeDataStd->IsLsdDesign())
		{
			SRebarEnvOption LsdRebarOpt;
			SetRebarLsdOptionSlab(&LsdRebarOpt, TRUE, TRUE, TRUE, nCycle, 0);
			dSettle = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueSettle(dDia, &LsdRebarOpt);
		}else
		{
			dSettle = m_pARcBridgeDataStd->GetValueSettleByCalc((long)dDia, SETTLE_TENS_NORMAL, dCover, dRebarSpace, 2, 1);
		}

		BOOL bOK = FALSE;
		if(jijum == 0)
		{
			CTwinVector tvHunch;
			if(IsOutWall(TRUE))
			{
				m_tvArrVertSection.GetTvByInfo("시점벽체헌치", tvHunch);
				//헌치가 없는데 직경이 있는경우 모서리 기준으로 헌치 만들어줌
				if(!IsHunch(jijum, TRUE))
				{
					CDPoint xyHunchLeft = tvHunch.GetXyLeft();
					tvHunch.m_v1 = xyHunchLeft + 100 * CDPoint(1, 1);
					tvHunch.m_v2 = xyHunchLeft + 100 * CDPoint(-1, -1);
				}
				rb.Offset(tvHunch.m_v1, tvHunch.m_v2, dCover);

				if(Compare(m_dHRS, 0.0, ">") && m_nTypeRoundOfHunchStt == 1)
				{
					CDPoint xyCen	= tvHunch.GetXyCircleCenter();
					double dAngStt	= (tvHunch.m_v1 - xyCen).Unit().GetAngleDegree();
					double dAngEnd	= (tvHunch.m_v2 - xyCen).Unit().GetAngleDegree();
					CDPoint xyMid	= xyCen + ToDPointFrDegree((dAngStt+dAngEnd)/2) * fabs(tvHunch.m_v2.z);
					CDPoint vAng	= ((CDPoint)tvHunch.m_v2 - (CDPoint)tvHunch.m_v1).Unit();
					tvHunch.m_v1	= xyMid + vAng*-100;
					tvHunch.m_v2	= xyMid + vAng*100;
					tvHunch.m_v1.z	= 0;
					tvHunch.m_v2.z	= 0;
				}

				// 시점측 외측벽체 1단 철근
				CTwinVector tvOutWall	= GetTvOffset_OutWall(0, TRUE, FALSE, bVertDir);
				

				// 시점측벽체 외측면 철근과의 교점
				if(1)//Compare(m_dHRS, 0.0, "<=") || m_nTypeRoundOfHunchStt == 0)
				{
					bOK = GetXyMatchLineAndLine(tvHunch.m_v1, tvHunch.GetXyDir(), tvOutWall.m_v1, tvOutWall.GetXyDir(), pRC->m_xyMid1);

					// 33303 헌치가 수직이면 절대 외측면의 철근과는 만날 수 없다..
					CDPoint vHunchDir = tvHunch.GetXyDir();
					CDPoint vVerticalTop(0,1), vVertical(0,-1);
					if(ComparePt(vHunchDir,vVerticalTop, _T("="),0.01 ) || ComparePt(vHunchDir,vVertical, _T("="),0.01 ))
						bOK = FALSE;

					// 상부슬래브상면철근과의 교점
					if(bOK)
						bOK = GetXyMatchLineAndLine(tvHunch.m_v1, tvHunch.GetXyDir(TRUE), tvRebarUpper.m_v1, tvRebarUpper.GetXyDir(), pRC->m_xyMid2);

					pRC->m_xyStt	= pRC->m_xyMid1 + CDPoint(0, -1) * dSettle;
					pRC->m_xyEnd	= pRC->m_xyMid2 + tvRebarUpper.GetXyDir() * dSettle;
					if(bOK)
					{
						CTwinVector tv;
						tv.m_v1	= pRC->m_xyStt;
						tv.m_v2	= pRC->m_xyMid1;
						pRC->m_tvArrRebar.Add(tv);

						tv.m_v1	= tv.m_v2;
						tv.m_v2	= pRC->m_xyMid2;
						pRC->m_tvArrRebar.Add(tv);

						tv.m_v1	= tv.m_v2;
						tv.m_v2	= pRC->m_xyEnd;
						pRC->m_tvArrRebar.Add(tv);
					}
				}
				else if(Compare(m_dHRS, 0.0, ">"))
				{
					bOK	= TRUE;

					CTwinVector tv;
					tv.m_v1	= tvHunch.m_v1 + tvRebarUpper.GetXyDir() * dSettle;
					tv.m_v2	= tvHunch.m_v1;
					tv.m_v1.z	= 0;
					tv.m_v2.z	= 0;
					pRC->m_tvArrRebar.InsertAt(0, tv);

					pRC->m_tvArrRebar.Add(tvHunch);

					tv.m_v1	= tvHunch.m_v2;
					tv.m_v2	= tv.m_v1 + CDPoint(0, -1) * dSettle;
					tv.m_v1.z	= 0;
					tv.m_v2.z	= 0;
					pRC->m_tvArrRebar.Add(tv);
				}

			}
			else
			{
				// V형 헌치임이 분명함.
				CTwinVectorArray tvArrHunch;
				CString sInfoFir	= _T("시점벽체헌치");
				CString sInfoLast	= _T("시점슬래브측면");
				if(m_tvArrVertSection.GetTvArrByInfoRange(sInfoFir, sInfoLast, tvArrHunch))
				{
					for(long a = 0; a < tvArrHunch.GetSize(); a++)
						tvArrHunch.GetPAt(a)->m_bApplyAngle	= FALSE;

					rb.GetOffsetTvArray(tvArrHunch, dCover);

					// "시점슬래브측면" 철근은 상부피복이 측면 피복이 적용되어야 함.
					CTwinVector tvSide;
					if(tvArrHunch.GetTvByInfo("시점슬래브측면", tvSide))
					{
						tvSide.m_v1.x		+= (dCoverSideStt - dCover);
						tvSide.m_v2.x		+= (dCoverSideStt - dCover);
						tvSide.m_v2.y		-= m_dCoverUpper_UpperSlab[0];

						CTwinVector tvLower	= tvArrHunch.GetTvByInfo("시점헌치하면");
						GetXyMatchLineAndLine(tvSide.m_v1, tvSide.GetXyDir(), tvLower.m_v1, tvLower.GetXyDir(), tvLower.m_v2);
						tvSide.m_v1	= tvLower.m_v2;
					
						tvArrHunch.SetTvByInfo("시점슬래브측면", tvSide);
						tvArrHunch.SetTvByInfo("시점헌치하면", tvLower);
					}
					
					// 처음과 끝은 상부슬래브철근과 교차점 찾음
					if(1)//Compare(m_dHRS, 0.0, "<="))
					{
						long nSize	= tvArrHunch.GetSize();
						if(nSize > 1)
						{
							CTwinVector tv = tvArrHunch.GetAt(0);
							CDPoint xyMatch(0, 0);
							
							bOK = GetXyMatchLineAndLine(tv.m_v2, (CDPoint(tv.m_v1) - (CDPoint)tv.m_v2).Unit(), tvRebarUpper.m_v1, tvRebarUpper.GetXyDir(), xyMatch);
							tv.m_v1	= xyMatch;
							tvArrHunch.SetAt(0, tv);

							if(bOK)	// R이 없을 경우에만 상부 슬래브로 뻗음
							{
								tv	= tvArrHunch.GetAt(nSize-1);
								bOK = GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), tvRebarUpper.m_v1, tvRebarUpper.GetXyDir(), xyMatch);
								tv.m_v2	= xyMatch;
								tvArrHunch.SetAt(nSize-1, tv);
							}

							// 구해진 철근을 rebar info cycle에 넣음
							pRC->m_tvArrRebar	= tvArrHunch;
						}
					}
					else	// 헌치철근은 라운드가 없는 것으로 간주함.
					{
						pRC->m_tvArrRebar	= tvArrHunch;

						CTwinVector tvTmp, tv;
						tvTmp	= tvArrHunch.GetAt(0);
						tv.m_v2	= tvTmp.m_v1;
						tv.m_v1	= tvTmp.m_v1 + tvRebarUpper.GetXyDir() * dSettle;
						tv.m_v1.z	= 0;
						tv.m_v2.z	= 0;
						pRC->m_tvArrRebar.InsertAt(0, tv);
												
						bOK	= TRUE;
					}
				}
			}
		}
		else if(jijum == nCountJijum-1)
		{
			CTwinVector tvHunch;
			if(IsOutWall(FALSE))
			{
				m_tvArrVertSection.GetTvByInfo("종점벽체헌치", tvHunch);
				//헌치가 없는데 직경이 있는경우 모서리 기준으로 헌치 만들어줌
				if(!IsHunch(jijum, TRUE))
				{
					CDPoint xyHunchRight = tvHunch.GetXyRight();
					tvHunch.m_v1 = xyHunchRight + 100 * CDPoint(1, -1);
					tvHunch.m_v2 = xyHunchRight + 100 * CDPoint(-1, 1);
				}
				Offset(tvHunch.m_v1, tvHunch.m_v2, dCover);

				if(Compare(m_dHRE, 0.0, ">") && m_nTypeRoundOfHunchEnd == 1)
				{
					CDPoint xyCen	= tvHunch.GetXyCircleCenter();
					double dAngStt	= (tvHunch.m_v1 - xyCen).Unit().GetAngleDegree();
					double dAngEnd	= (tvHunch.m_v2 - xyCen).Unit().GetAngleDegree();
					if(dAngStt > dAngEnd)
						dAngStt -= 360;
					CDPoint xyMid	= xyCen + ToDPointFrDegree((dAngStt+dAngEnd)/2) * fabs(tvHunch.m_v2.z);
					CDPoint vAng	= (CDPoint(tvHunch.m_v2) - CDPoint(tvHunch.m_v1)).Unit();
					tvHunch.m_v1	= xyMid + vAng*-100;
					tvHunch.m_v2	= xyMid + vAng*100;
					tvHunch.m_v1.z	= 0;
					tvHunch.m_v2.z	= 0;
				}

				// 시점측 외측벽체 1단 철근
				if(1)//Compare(m_dHRE, 0.0, "<=") || m_nTypeRoundOfHunchEnd == 0)
				{
					CTwinVector tvOutWall	= GetTvOffset_OutWall(0, FALSE, FALSE, bVertDir);
					
					// 시점측벽체 외측면 철근과의 교점
					bOK = GetXyMatchLineAndLine(tvHunch.m_v1, tvHunch.GetXyDir(TRUE), tvOutWall.m_v1, tvOutWall.GetXyDir(), pRC->m_xyMid1);

					// 33303 
					CDPoint vHunchDir = tvHunch.GetXyDir();
					CDPoint vVerticalTop(0,1), vVertical(0,-1);
					if(ComparePt(vHunchDir,vVerticalTop, _T("="),0.01 ) || ComparePt(vHunchDir,vVertical, _T("="),0.01 ))
						bOK = FALSE;
					
					// 상부슬래브상면철근과의 교점
					if(bOK)
						bOK = GetXyMatchLineAndLine(tvHunch.m_v1, tvHunch.GetXyDir(), tvRebarUpper.m_v1, tvRebarUpper.GetXyDir(), pRC->m_xyMid2);

					pRC->m_xyStt	= pRC->m_xyMid1 + CDPoint(0, -1) * dSettle;
					pRC->m_xyEnd	= pRC->m_xyMid2 + tvRebarUpper.GetXyDir(TRUE) * dSettle;
					if(bOK)
					{
						CTwinVector tv;
						tv.m_v1	= pRC->m_xyStt;
						tv.m_v2	= pRC->m_xyMid1;
						pRC->m_tvArrRebar.Add(tv);

						tv.m_v1	= tv.m_v2;
						tv.m_v2	= pRC->m_xyMid2;
						pRC->m_tvArrRebar.Add(tv);

						tv.m_v1	= tv.m_v2;
						tv.m_v2	= pRC->m_xyEnd;
						pRC->m_tvArrRebar.Add(tv);
					}
				}
				else
				{
					CTwinVector tv;
					tv.m_v2	= tvHunch.m_v1;
					tv.m_v1	= tv.m_v2 + CDPoint(0, -1) * dSettle;
					tv.m_v1.z	= 0;
					tv.m_v2.z	= 0;
					pRC->m_tvArrRebar.InsertAt(0, tv);

					pRC->m_tvArrRebar.Add(tvHunch);

					tv.m_v1	= tvHunch.m_v2;
					tv.m_v2	= tv.m_v1 + tvRebarUpper.GetXyDir(TRUE) * dSettle;
					tv.m_v1.z	= 0;
					tv.m_v2.z	= 0;
					pRC->m_tvArrRebar.Add(tv);

					bOK	= TRUE;
				}
			}
			else
			{
				// V형 헌치임이 분명함.
				CTwinVectorArray tvArrHunch;
				CString sInfoFir	= _T("종점슬래브측면");
				CString sInfoLast	= _T("종점벽체헌치");
				if(m_tvArrVertSection.GetTvArrByInfoRange(sInfoFir, sInfoLast, tvArrHunch))
				{
					for(long a = 0; a < tvArrHunch.GetSize(); a++)
						tvArrHunch.GetPAt(a)->m_bApplyAngle	= FALSE;

					rb.GetOffsetTvArray(tvArrHunch, dCover);

					// "종점슬래브측면" 철근은 상부피복이 측면 피복이 적용되어야 함.
					CTwinVector tvSide;
					if(tvArrHunch.GetTvByInfo("종점슬래브측면", tvSide))
					{
						tvSide.m_v1.x		-= (dCoverSideEnd - dCover);
						tvSide.m_v2.x		-= (dCoverSideEnd - dCover);
						tvSide.m_v1.y		-= m_dCoverUpper_UpperSlab[0];

						CTwinVector tvLower	= tvArrHunch.GetTvByInfo("종점헌치하면");
						GetXyMatchLineAndLine(tvSide.m_v1, tvSide.GetXyDir(), tvLower.m_v1, tvLower.GetXyDir(), tvLower.m_v1);
						tvSide.m_v2	= tvLower.m_v1;

						tvArrHunch.SetTvByInfo("종점슬래브측면", tvSide);
						tvArrHunch.SetTvByInfo("종점헌치하면", tvLower);
					}

					// 처음과 끝은 상부슬래브철근과 교차점 찾음
					if(1)//Compare(m_dHRE, 0.0, "<="))
					{
						long nSize	= tvArrHunch.GetSize();
						if(nSize > 1)
						{
							CTwinVector tv = tvArrHunch.GetAt(0);
							CDPoint xyMatch(0, 0);
							
							bOK = GetXyMatchLineAndLine(tv.m_v2, tv.GetXyDir(TRUE), tvRebarUpper.m_v1, tvRebarUpper.GetXyDir(), xyMatch);
							tv.m_v1	= xyMatch;
							tvArrHunch.SetAt(0, tv);

							if(bOK) 
							{
								tv	= tvArrHunch.GetAt(nSize-1);
								bOK = GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), tvRebarUpper.m_v1, tvRebarUpper.GetXyDir(), xyMatch);
								tv.m_v2	= xyMatch;
								tvArrHunch.SetAt(nSize-1, tv);
							}

							// 구해진 철근을 rebar info cycle에 넣음
							pRC->m_tvArrRebar	= tvArrHunch;
						}
					}
					else	// 헌치 철근은 라운드가 없는 것으로 간주함.
					{
						pRC->m_tvArrRebar.AddFromTvArray(tvArrHunch);

						CTwinVector tvTmp	= tvArrHunch.GetAt(tvArrHunch.GetSize()-1);
						CTwinVector tv;
						tv.m_v1	= tvTmp.m_v2;
						tv.m_v2	= tv.m_v1 + tvRebarUpper.GetXyDir(TRUE) * dSettle;
						tv.m_v1.z	= 0;
						tv.m_v2.z	= 0;
						pRC->m_tvArrRebar.Add(tv);

						bOK	= TRUE;

					}
				}
			}
		}
		else
		{
			long nIdxWall		= jijum-1;
			CString sNumWall	= _T("");
			sNumWall.Format("%d", nIdxWall+1);
			pWall				= GetInWall(nIdxWall);
			//if(!IsHunch(jijum)) continue;

			BOOL bHunchRebarV	= TRUE;
			if(pWall)
			{
				if(pWall->m_bIs)
				{
					if(pWall->m_bTopIsColumn)
						bHunchRebarV	= TRUE;
					else
						bHunchRebarV	= FALSE;
				}
			}

			if(m_bExpJoint[jijum])
			{
			}
			else
			{
				long nIdxHunch[2]		= {0, 0};
				CString sInfoFir		= _T("");
				CString sInfoLast		= _T("");
				CTwinVectorArray tvArrHunch;

				nIdxHunch[iLEFT]		= GetIdxHunchInWall(nIdxWall, TRUE);
				nIdxHunch[iRIGHT]		= GetIdxHunchInWall(nIdxWall, FALSE);

				double dH = GetHeightHunchByJijum(jijum, TRUE);
				double dW = GetWidthHunchByJijum(jijum, TRUE);
				double dHunchHB = m_dHBH[nIdxHunch[iLEFT]][iUPPER];

				long left = 0; for(left = 0; left < 2; left++)
				{
					// 오른쪽 구할때는 오른쪽와 왼쪽의 헌치 인덱스가 달라야 됨.
					if(left == iRIGHT)
					{
						if(nIdxHunch[iLEFT] == nIdxHunch[iRIGHT]) continue;

						// 오른쪽 구할때는 철근 하나더 추가.
						pArrRC->Add(new CRebarInfoCycle);
						pRC		= pArrRC->GetAt(pArrRC->GetSize()-1);
						*pRC	= *pArrRC->GetAt(pArrRC->GetSize()-2);	// 공통 속성 복사.
					}

					sInfoFir.Format("%d번째내측헌치우측면", nIdxHunch[left]+1);
					sInfoLast.Format("%d번째내측헌치좌측면", nIdxHunch[left]+1);

					// 기둥식 벽체거나 V형인 경우
					long nTypeSlabUpperHunch	= m_dArrTypeUpperSlabHunch.GetSize() > jijum ? (long)m_dArrTypeUpperSlabHunch.GetAt(jijum) : 0;

					// 헌치에 R이 있는 경우 X형만 지원함
					if((bHunchRebarV || nTypeSlabUpperHunch == 1) && !IsRoundHunch(jijum, TRUE, TRUE))
					{
						if(m_tvArrVertSection.GetTvArrByInfoRange(sInfoFir, sInfoLast, tvArrHunch))
						{
							for(long a = 0; a < tvArrHunch.GetSize(); a++)
								tvArrHunch.GetPAt(a)->m_bApplyAngle	= FALSE;

							rb.GetOffsetTvArray(tvArrHunch, dCover);
							
							// 처음과 끝은 상부슬래브철근과 교차점 찾음
							long nSize	= tvArrHunch.GetSize();
							if(nSize > 1 && (Compare(m_dHLR[nIdxHunch[iLEFT]][iUPPER], 0.0, "<=") || Compare(m_dHRR[nIdxHunch[iLEFT]][iUPPER], 0.0, "<=")))
							{
								CDPoint xyMatch(0, 0);
								CTwinVector tv = tvArrHunch.GetAt(0);
								
								//대각선헌치없고 HB만 있는경우 내측헌치아래우측면이 필요하당...
								if((dH == 0 ||dW == 0) && dHunchHB > 0 && tv.m_sInfo == sInfoFir)
								{
									CString strHunch;
									strHunch.Format(_T("%d번째내측헌치아래우측면"),nIdxHunch[left]+1);
									tv = tvArrHunch.GetTvByInfo(strHunch);
								}
								
								bOK = GetXyMatchLineAndLine(tv.m_v2, tv.GetXyDir(TRUE), tvRebarUpper.m_v1, tvRebarUpper.GetXyDir(), xyMatch);
								tv.m_v1	= xyMatch;
								tvArrHunch.SetAt(0, tv);

								if(bOK) 
								{
									tv	= tvArrHunch.GetAt(nSize-1);
									//대각선헌치없고 HB만 있는경우 내측헌치아래우측면이 필요하당...
									if((dH == 0 ||dW == 0) && dHunchHB > 0 && tv.m_sInfo == sInfoLast)
									{
										CString strHunch;
										strHunch.Format(_T("%d번째내측헌치아래좌측면"),nIdxHunch[left]+1);
										tv = tvArrHunch.GetTvByInfo(strHunch);
									}
									bOK = GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), tvRebarUpper.m_v1, tvRebarUpper.GetXyDir(), xyMatch);
									tv.m_v2	= xyMatch;
									tvArrHunch.SetAt(nSize-1, tv);
								}
							}
							// 헌치에 R이 들어간 경우 수평수직헌치인지 구분하기 어려우므로 철근이 있는 것으로 간주함.
							else if(Compare(m_dHLR[nIdxHunch[iLEFT]][iUPPER], 0.0, ">") || Compare(m_dHRR[nIdxHunch[iLEFT]][iUPPER], 0.0, ">"))
							{
								bOK	= TRUE;
							}

							CString strHunch;
							strHunch.Format(_T("%d번째내측헌치아래면좌측"),nIdxHunch[left]+1);
							tvInner = tvArrHunch.GetTvByInfo(strHunch);

							// 철근이 3개 이상이면 첫번째 끝에꺼 그리고 첫번째와 끝을 연결한거만 남기고 다 지움
							long nSizeHunch	= tvArrHunch.GetSize();
							if(nSizeHunch > 3)
							{
								CTwinVector tv1	= tvArrHunch.GetAt(0);
								CTwinVector tv2	= tvArrHunch.GetAt(nSizeHunch-1);
								CTwinVector tvMid;
								tvArrHunch.RemoveAll();

								//#38436
								// 좌우 헌치 높이가 다를 수 있다.
								//if(!Compare(tv1.m_v2.y, tv2.m_v1.y, "="))
								//{
								//	CDPointArray xyArrMatch;
								//	if(tv1.m_v2.y < tv2.m_v1.y)
								//	{
								//		rb.GetXyMatchLineAndArc2(tv2.m_v1, CDPoint(1, 0), tv1.m_v1, tv1.m_v2, fabs(tv1.m_v2.z), tv1.m_v1.z == -1, tv1.m_v2.z>0, xyArrMatch);
								//		if(xyArrMatch.GetSize() > 0)
								//		{
								//			tv1.m_v2	= xyArrMatch.GetAt(0);
								//		}
								//	}
								//	else
								//	{
								//		rb.GetXyMatchLineAndArc2(tv1.m_v2, CDPoint(1, 0), tv2.m_v1, tv2.m_v2, fabs(tv2.m_v2.z), tv2.m_v1.z == -1, tv2.m_v2.z>0, xyArrMatch);
								//		if(xyArrMatch.GetSize() > 0)
								//		{
								//			tv2.m_v1	= xyArrMatch.GetAt(0);
								//		}
								//	}
								//}
								
								//헌치 대각선헌치 + 돌출 높이가 있는경우
								if(dHunchHB > 0 && dH > 0 && dW > 0)
								{
									CTwinVector tvHBR, tvHBL;
									tvHBR.m_v1 = tvHBR.m_v2 = tv1.m_v2;
									//tvHBR.m_v2.y = tvHBR.m_v2.y - dHunchHB;
									tvHBR.m_v2.y = tvInner.m_v1.y;

									tvHBL.m_v1 = tvHBL.m_v2 = tv2.m_v1;
									//tvHBL.m_v1.y = tvHBL.m_v2.y - dHunchHB;
									tvHBL.m_v1.y = tvInner.m_v1.y;
									
									tvMid.m_v1 = tvHBR.m_v2;
									tvMid.m_v2 = tvHBL.m_v1;
								
									tvArrHunch.Add(tv1);
									tvArrHunch.Add(tvHBR);
									tvArrHunch.Add(tvMid);
									tvArrHunch.Add(tvHBL);
									tvArrHunch.Add(tv2);
								}
								//대각선헌치 or 돌출높이만
								else 
								{
									tvMid.m_v1		= tv1.m_v2;
									tvMid.m_v2		= tv2.m_v1;
									tvMid.m_v2.y	= tvMid.m_v1.y;
									tvMid.m_v1.z	= 0;
									tvMid.m_v2.z	= 0;

									tvArrHunch.Add(tv1);
									tvArrHunch.Add(tvMid);
									tvArrHunch.Add(tv2);
								}
								
								// 좌측헌치가 R이 있으면 정착장 추가
								if(Compare(m_dHLR[nIdxHunch[iLEFT]][iUPPER], 0.0, ">"))
								{
									tv2.m_v1	= tv2.m_v2;
									tv2.m_v2	= tv2.m_v1 + tvRebarUpper.GetXyDir(TRUE) * dSettle;
									tv2.m_v1.z	= 0;
									tv2.m_v2.z	= 0;
									tvArrHunch.Add(tv2);
								}

								// 우측헌치가 R이 있으면 정착장 추가
								if(Compare(m_dHRR[nIdxHunch[iLEFT]][iUPPER], 0.0, ">"))
								{
									tv1.m_v2	= tv1.m_v1;
									tv1.m_v1	= tv1.m_v1 + tvRebarUpper.GetXyDir() * dSettle;
									tv1.m_v1.z	= 0;
									tv1.m_v2.z	= 0;
									tvArrHunch.InsertAt(0, tv1);
								}
							}

							// 구해진 철근을 rebar info cycle에 넣음
							tvArrHunch.m_sInfo	= sNumWall;	// 벽체 번호
							pRC->m_tvArrRebar	= tvArrHunch;
						}
					}
					// 벽식 벽체인경우.
					else
					{
						// 좌측
						CTwinVector tvHunch;
						if(m_tvArrVertSection.GetTvByInfo(sInfoLast, tvHunch))
						{
 							//헌치가 없는데 직경이 있는경우 모서리 기준으로 헌치 만들어줌
 							if(!IsHunch(jijum, TRUE) && tvHunch.GetLength() == 0)
 							{
 								CDPoint xyHunchRight = tvHunch.GetXyRight();
 								tvHunch.m_v1 = xyHunchRight + 100 * CDPoint(1, -1);
								tvHunch.m_v2 = xyHunchRight + 100 * CDPoint(-1, 1);
 							}
							Offset(tvHunch.m_v1, tvHunch.m_v2, dCover);
							CTwinVector tvHunchOld	= tvHunch;

							long h = 0; for(h = 0; h < 2; h++)
							{
								tvHunch	= tvHunchOld;
								if(h == 1 && tvHunch.m_v1.z == 0) continue;
																
								// 라운드형태일 경우 1/3 지점 2/3지점에 접선방향으로 철근 만듬
								if(tvHunch.m_v1.z == -1 || tvHunch.m_v2.z == 1)
								{
									CDPoint xyCen	= tvHunch.GetXyCircleCenter();
									double dSttAngle	= (CDPoint(tvHunch.m_v1)-xyCen).Unit().GetAngleDegree();
									double dEndAngle	= (CDPoint(tvHunch.m_v2)-xyCen).Unit().GetAngleDegree();
									if(dSttAngle > dEndAngle)
										dSttAngle -= 360;
									if(tvHunch.m_v2.z < 0)
										GetSwap(dSttAngle, dEndAngle);

									double dCurAngle	= dSttAngle + (dEndAngle-dSttAngle)/3*(2-h);
									CDPoint xyMatch		= xyCen + (ToDPointFrDegree(dCurAngle) * fabs(tvHunch.m_v2.z));

									CDPoint xyDir		= (xyMatch - xyCen).Unit().Rotate90();
									tvHunch.m_v1	= xyMatch + (xyDir * 1000);
									tvHunch.m_v2	= xyMatch + (xyDir * -1000);
								}

								tvHunch.m_v1.z	= 0;
								tvHunch.m_v2.z	= 0;

								// 벽체 1단 우측철근
								CTwinVector tvOutWall	= pWall->GetTvOffset_Front(nCycle, 0, TRUE, left==iLEFT, FALSE, bVertDir);
								
								// 벽체 철근과의 교점
								bOK = GetXyMatchLineAndLine(tvHunch.m_v1, tvHunch.GetXyDir(TRUE), tvOutWall.m_v1, tvOutWall.GetXyDir(), pRC->m_xyStt);

								// 상부슬래브상면철근과의 교점
								if(bOK) bOK = GetXyMatchLineAndLine(tvHunch.m_v1, tvHunch.GetXyDir(), tvRebarUpper.m_v1, tvRebarUpper.GetXyDir(), pRC->m_xyMid1);

								pRC->m_xyMid2	= pRC->m_xyMid1;
								pRC->m_xyEnd	= pRC->m_xyMid1;
								if(bOK)
								{
									CTwinVector tv;
									tv.m_v1	= pRC->m_xyStt;
									tv.m_v2	= pRC->m_xyMid1;
									pRC->m_tvArrRebar.Add(tv);
									pRC->m_tvArrRebar.m_sInfo	= sNumWall;
								}
							}
						}

						// 우측
						if(bOK && m_tvArrVertSection.GetTvByInfo(sInfoFir, tvHunch))
						{
							pArrRC->Add(new CRebarInfoCycle);
							pRC		= pArrRC->GetAt(pArrRC->GetSize()-1);
							*pRC	= *pArrRC->GetAt(pArrRC->GetSize()-2);	// 공통 속성 복사.
							pRC->m_tvArrRebar.RemoveAll();

							if(!IsHunch(jijum, TRUE) && tvHunch.GetLength() == 0)
							{
								CDPoint xyHunchLeft = tvHunch.GetXyLeft();
								tvHunch.m_v1 = xyHunchLeft + 100 * CDPoint(1, 1);
								tvHunch.m_v2 = xyHunchLeft + 100 * CDPoint(-1, -1);
							}
							Offset(tvHunch.m_v1, tvHunch.m_v2, dCover);
							CTwinVector tvHunchOld	= tvHunch;

							long h = 0; for(h = 0; h < 2; h++)
							{
								tvHunch	= tvHunchOld;
								
								if(tvHunch.m_v1.z == 0 && h == 1) continue;
								
								// 라운드형태일 경우 1/3 지점 2/3지점에 접선방향으로 철근 만듬
								if(tvHunch.m_v1.z == -1 || tvHunch.m_v2.z == 1)
								{
									CDPoint xyCen	= tvHunch.GetXyCircleCenter();
									double dSttAngle	= (CDPoint(tvHunch.m_v1)-xyCen).Unit().GetAngleDegree();
									double dEndAngle	= (CDPoint(tvHunch.m_v2)-xyCen).Unit().GetAngleDegree();
									if(dSttAngle > dEndAngle)
										dSttAngle -= 360;
									if(tvHunch.m_v2.z < 0)
										GetSwap(dSttAngle, dEndAngle);

									double dCurAngle	= dSttAngle + (dEndAngle-dSttAngle)/3*(h+1);
									CDPoint xyMatch		= xyCen + (ToDPointFrDegree(dCurAngle) * fabs(tvHunch.m_v2.z));

									CDPoint xyDir		= (xyMatch - xyCen).Unit().Rotate90();
									tvHunch.m_v1	= xyMatch + (xyDir * 1000);
									tvHunch.m_v2	= xyMatch + (xyDir * -1000);
								}

								tvHunch.m_v1.z	= 0;
								tvHunch.m_v2.z	= 0;

								// 벽체 1단 좌측철근
								CTwinVector tvOutWall	= pWall->GetTvOffset_Front(nCycle, 0, TRUE, left==iLEFT, TRUE, bVertDir);
								
								// 벽체 철근과의 교점
								bOK = GetXyMatchLineAndLine(tvHunch.m_v1, tvHunch.GetXyDir(TRUE), tvOutWall.m_v1, tvOutWall.GetXyDir(), pRC->m_xyStt);

								// 상부슬래브상면철근과의 교점
								if(bOK) bOK = GetXyMatchLineAndLine(tvHunch.m_v1, tvHunch.GetXyDir(), tvRebarUpper.m_v1, tvRebarUpper.GetXyDir(), pRC->m_xyMid1);

								pRC->m_xyMid2	= pRC->m_xyMid1;
								pRC->m_xyEnd	= pRC->m_xyMid1;
								if(bOK)
								{
									CTwinVector tv;
									tv.m_v1	= pRC->m_xyStt;
									tv.m_v2	= pRC->m_xyMid1;
									pRC->m_tvArrRebar.Add(tv);
									pRC->m_tvArrRebar.m_sInfo	= sNumWall;
								}
							}
						}
					}
				}
			}
		}

		// 헌치가 수직이나 수평이라 철근이 없는 경우...
		if(!bOK)
		{
			delete pRC;
			pArrRC->RemoveAt(pArrRC->GetSize()-1);
		}
	}

	// szMark 설정
	SetStringMarkToRebarInfoCycle(pArrRC, MARK_UPPERSLAB_HUNCH, nCycle, TRUE, nCycle == 0, 0);
	// sDescription 설정
	SetStringDescriptionRebarInfoCycle_UpperSlabHunch(pArrRC, nCycle);


}

// 철근 관련 동기화
void CRcBridgeRebar::SyncBridgeRebar(BOOL bInput, long nVertDir, BOOL bMakeRebarInfoCycle)
{
	BOOL bVertDir	= nVertDir == 0 ? IsVertDir() : (nVertDir == -1 ? TRUE : FALSE);
	long wall(0), dan(0), nJ(0);

	// 경사교일때는  level로 그리기를 지원 하지 않는다.
	// 아치교일때도 level로 그리기를 지원 하지 않는다.
	if(m_nTypeJongdanForRebar == 0 && (m_nTypeBridge == BRIDGE_TYPE_TRAP || m_nTypeBridge == BRIDGE_TYPE_TRAP2 || m_nTypeBridge == BRIDGE_TYPE_ARCH))
	{
		m_nTypeJongdanForRebar	= 1;
	}
	
	// 모든기초 동기화
	long nCountJijum	= GetCountJijum();

	for(nJ = 0; nJ < nCountJijum; nJ++)
	{
		CFootingApp *pFooting = GetFootingByJijumNumber(nJ);
		if(pFooting)
		{
// 			BOOL bPile	= pFooting->m_exFooting.m_nType == EXFOOTING_TYPE_PILE;

			// 주철근배치타입
			pFooting->m_nTypePlaceMainRebar			= m_nTypePlacingMainRebar_Footing;

			// 주철근 사이클 수
			pFooting->m_nIdxCountCycleMainRebar		= m_nIdxCountCycleMainRebar;
			// 주철근 CTC
			pFooting->m_nIdxCTC_MainRebar			= m_nIdxCTC_MainRebar;
			pFooting->m_dCTC_MainRebar				= m_dCTC_MainRebar;
			pFooting->m_bSameOffsetPlaceTAndCBlock	= m_bSameOffsetPlaceTAndCBlock;	// 인장 압축구간을 동일 간격으로 배치
			pFooting->m_bPlacing23DanByStandardOffset	= m_bPlacing23DanByStandardOffset;

			// 피복두께 동기화
			for(dan = 0; dan < MAX_REBAR_DAN; dan++)
			{
				pFooting->m_dCoverUpper[dan]		= m_dCoverUpper_Footing[dan];
				pFooting->m_dCoverLower[dan]		= pFooting->m_exFooting.m_nType == EXFOOTING_TYPE_PILE ? m_dCoverLower_Footing_Pile[dan] : m_dCoverLower_Footing_Lean[dan];
			}

			double dAngle	= GetAngleJijum(nJ, FALSE).GetAngleDegree();
			pFooting->SyncFooting(!bVertDir, dAngle);
		}
	}


	long nCountWall	= GetCountInWall();
	for(wall = 0; wall < nCountWall; wall++)
	{
		CWallApp *pWall	= GetInWall(wall);
		if(pWall)
		{
			// 피복 두께 동기화
			for(dan = 0; dan < MAX_REBAR_DAN; dan++)
			{
				pWall->m_dCoverLeft[dan]	= m_dCoverWallMid[dan];
				pWall->m_dCoverRight[dan]	= m_dCoverWallMid[dan];
				pWall->m_footing.m_dCoverUpper[dan]	= m_dCoverUpper_Footing[dan];
				if(IsBoxType())
				{
					pWall->m_footing.m_dCoverLower[dan] = m_dCoverLower_LowerSlab[dan];
				}
				else
				{
					pWall->m_footing.m_dCoverLower[dan]	= pWall->m_footing.m_exFooting.m_nType == EXFOOTING_TYPE_PILE ? m_dCoverLower_Footing_Pile[dan] : m_dCoverLower_Footing_Lean[dan];
				}
			}
			
			// 지원가능 사이클 수 동기화
			pWall->m_nIdxCountCycleMainRebar		= m_nIdxCountCycleMainRebar;

			// 주철근 CTC
			pWall->m_nIdxCTC_MainRebar				= m_nIdxCTC_MainRebar;
			pWall->m_dCTC_MainRebar					= GetCtcRebarMain(TRUE);

			pWall->m_bSameOffsetPlaceTAndCBlock		= m_bSameOffsetPlaceTAndCBlock;	// 인장 압축구간을 동일 간격으로 배치
			pWall->m_bPlacing23DanByStandardOffset	= m_bPlacing23DanByStandardOffset;
			pWall->m_bPlacingInWallRebarOfCycle24	= m_bPlacingInWallRebarOfCycle24;
			pWall->m_nTypeCurveOfVertRebar			= m_nTypeCurveOfWallVertRebar;
			pWall->m_bApplyAngleToMainRebarCTC		= m_nTypePlacingMainRebar_UpperSlab == 0;


			// 상부슬래브 상면
			pWall->m_dCoverUpper_UpperSlab			= m_dCoverUpper_UpperSlab[0];
			CTwinVector tvUpper;

			// 벽체 주철근의 상부 한계 철근 설정
			tvUpper	= GetTvOffset_UpperSlab(0, TRUE, -1.0, -1.0, bVertDir);
			pWall->m_tvUpperLimitOfMainRebar		= tvUpper;
			
			// 벽체 배력철근의 상부 한계 설정
			tvUpper	= GetTvOffset_UpperSlab(0, FALSE, -1.0, -1.0, bVertDir);
			pWall->m_tvUpperLimitOfSupportRebar		= tvUpper;

			pWall->m_Column.m_nTypeCouplerMainRebar	= m_nTypeCouplerColumnMainRebar;
			pWall->m_Column.m_dCover[iOUTTER][0] = pWall->m_Column.m_dCover[iINNER][0] = m_dCoverColumn[0];

			if(IsBoxType())
			{
				CTwinVector tvLower;
				tvLower = GetTvOffset_LowerSlab(0, FALSE, -1, -1, bVertDir);
				pWall->m_tvArrLowerLimit_FrontRebar.RemoveAll();
				pWall->m_tvArrLowerLimit_Front.RemoveAll();
				pWall->m_tvLowerLimitOfMainRebar		= tvLower;
				tvLower.m_v1.y -= m_dCoverLower_LowerSlab[0];
				tvLower.m_v2.y -= m_dCoverLower_LowerSlab[0];
				pWall->m_tvArrLowerLimit_FrontRebar.Add(tvLower);

				tvLower = GetTvOffset_LowerSlab(-1, TRUE, -1, -1, bVertDir);
				pWall->m_tvLowerLimitOfSupportRebar		= tvLower;

				pWall->m_dCoverLower_LowerSlab			= m_dCoverLower_LowerSlab[0];
				pWall->m_bRebarLowerSettle[iLEFT]	= FALSE;
				pWall->m_bRebarLowerSettle[iRIGHT]	= FALSE;
			}
			else if(IsArchType())
			{
				CTwinVector tvLower;


				tvLower.m_v1 = GetXyMatchLineAndArchRib(FALSE, CDPoint(pWall->m_xyOrg.x - pWall->m_dW/2, pWall->m_xyOrg.y), CDPoint(0, 1), 0, m_dCoverLower_UpperSlab[0]);
				tvLower.m_v2 = GetXyMatchLineAndArchRib(FALSE, CDPoint(pWall->m_xyOrg.x + pWall->m_dW/2, pWall->m_xyOrg.y), CDPoint(0, 1), 0, m_dCoverLower_UpperSlab[0]);
				pWall->m_tvLowerLimitOfMainRebar		= tvLower;

				tvLower.m_v1 = GetXyMatchLineAndArchRib(TRUE, CDPoint(pWall->m_xyOrg.x - pWall->m_dW/2, pWall->m_xyOrg.y), CDPoint(0, 1), 0, 0);
				tvLower.m_v2 = GetXyMatchLineAndArchRib(TRUE, CDPoint(pWall->m_xyOrg.x + pWall->m_dW/2, pWall->m_xyOrg.y), CDPoint(0, 1), 0, 0);
				tvLower.m_v1.y = tvLower.m_v2.y = max(tvLower.m_v1.y, tvLower.m_v2.y);
				pWall->m_tvLowerLimitOfSupportRebar		= tvLower;

				pWall->m_dCoverLower_LowerSlab			= m_dCoverLower_UpperSlab[0];

//				SyncWall_JongdanLimitFront()에서서 해줄꺼다. 여기서 하면 종단타입이 안맞네..				
//				pWall->m_tvArrLowerLimit_FrontRebar.RemoveAll();
//				pWall->m_tvArrLowerLimit_Front.RemoveAll();

//				pWall->m_tvArrLowerLimit_Front	= m_tvArrVertSectionRib[iUPPER];
//				pWall->m_tvArrLowerLimit_FrontRebar	= m_tvArrVertSectionRib[iLOWER];
			}


			//31720
			CTwinVectorArray tvArrVertSection;
			tvArrVertSection.AddFromTvArray(m_tvArrVertSection);

			pWall->SyncWall(tvArrVertSection, !bVertDir, GetAngleJijum(wall+1).GetAngleDegree());

			// 좌측 벽체 좌표 구한뒤에 벽체 측면이 아크로 된거면 
			// 슬래브의 보정면과 합쳐 버린다. ㅋㅋ
			long nJijum	= wall + 1;
			if(GetJijumConnectRibAndSlab() == nJijum && pWall->m_bSideIsArc)
			{
				CString str	= _T("");
				str.Format("%d번째내측헌치좌측보정면", nJijum);
				CTwinVector tv;
				if(m_tvArrVertSection.GetTvByInfo(str, tv))
				{
					CTwinVector tvLeft	= pWall->m_tvArrFront.GetTvByInfo("벽체좌측면");
					tvLeft.m_v2	= tv.GetXyTop();
					tvLeft.m_v2.z	= tvLeft.GetVerLength()/2;
					tvLeft.m_xyRCenter	= tvLeft.GetXyMid();
					pWall->m_tvArrFront.SetTvByInfo("벽체좌측면", tvLeft);

					tv.m_v1	= tv.GetXyTop();
					tv.m_v2	= tv.GetXyTop();
					m_tvArrVertSection.SetTvByInfo(str, tv);
				}
	

				str.Format("%d번째내측헌치우측보정면", nJijum);
				if(m_tvArrVertSection.GetTvByInfo(str, tv))
				{
					CTwinVector tvRight	= pWall->m_tvArrFront.GetTvByInfo("벽체우측면");
					tvRight.m_v2	= tv.GetXyTop();
					tvRight.m_v2.z	= -tvRight.GetVerLength()/2;
					tvRight.m_xyRCenter	= tvRight.GetXyMid();
					pWall->m_tvArrFront.SetTvByInfo("벽체우측면", tvRight);

					tv.m_v1	= tv.GetXyTop();
					tv.m_v2	= tv.GetXyTop();
					m_tvArrVertSection.SetTvByInfo(str, tv);
				}

			}

			// 내측헌치 R에 대해서 구해줌(접선일 경우에만 구해주면 됨)
			ApplyRoundOfInWallHunch(wall, TRUE);
			ApplyRoundOfInWallHunch(wall, FALSE);
		}
	}

	// 모든 거더 철근 위치 동기화
	for(nJ = 0; nJ < GetCountJijum(); nJ++)
	{
		SetDataDefaultRebarGirder(nJ, FALSE, TRUE);
		if(IsBoxType())
			SetDataDefaultRebarGirder(nJ, FALSE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE);
	}

	if(bMakeRebarInfoCycle)
		MakeRebarInfoCycleStd(bInput, nVertDir);

	// 겹치는 선들에 대해서 체크함
	CheckOverLapLineBetweenSubObject();
}

// 종단면, 상부슬래브, 상하면, 배력철근 위치
// long nVertDir=0 : 자동(원래설정), -1 : 직거리, 1 : 사거리
void CRcBridgeRebar::GetXyRebarSupport_VertSection_UpperSlab(CDPointArray &xyArr, BOOL bUpper, long nDan, long nVertDir, BOOL bCalSupRebar)
{
	xyArr.RemoveAll();

	if(nDan == -1) 
		nDan = MAX_REBAR_DAN - 1;

	if(nDan < 0 || nDan > MAX_REBAR_DAN - 1) 
		return;

	long upper	= bUpper ? iUPPER : iLOWER;
	CRebarPlacing rb;

	static CDPointArray xyArrSupRebar1Dan[2];
	if(bCalSupRebar == FALSE && xyArrSupRebar1Dan[upper].GetSize() > 0)
	{
		//Issue Number:#28115
		if(bUpper == FALSE && nDan > 0 && m_bPlacing23DanByStandardOffset == TRUE)
		{
			long nUpperSize = xyArrSupRebar1Dan[iUPPER].GetSize();
			long nLowerSize = xyArrSupRebar1Dan[iLOWER].GetSize();
			CDPoint xyUp, xyLo;
			double dLoXPos = 0.0;

			//하부 배력철근 2단 철근일 경우 상부배력철근이 있는 곳 정보만 넣어줌.
			for(long nUpIdx = 0; nUpIdx < nUpperSize; nUpIdx++)
			{
				xyUp = xyArrSupRebar1Dan[iUPPER][nUpIdx];
				double dUpXPos = RoundDown(xyUp.x,0);

				for(long nLoIdx = 0; nLoIdx < nLowerSize; nLoIdx++)
				{
					xyLo = xyArrSupRebar1Dan[iLOWER][nLoIdx];
					dLoXPos = RoundDown(xyLo.x,0);

					if(Compare(dUpXPos, dLoXPos, _T("="), 1.0))
					{
						xyArr.Add(xyLo);
						break;
					}
				}
			}
		}
		else
		{
			xyArr = xyArrSupRebar1Dan[upper];
		}
		//

		double dCover	= bUpper ? m_dCoverUpper_UpperSlab[nDan] : m_dCoverLower_UpperSlab[nDan];
		double dCover1	= bUpper ? m_dCoverUpper_UpperSlab[0] : m_dCoverLower_UpperSlab[0];

		if(bUpper)
			rb.MoveRebar(xyArr, CDPoint(0, dCover1-dCover));
		else
			rb.MoveRebar(xyArr, CDPoint(0, dCover-dCover1));
	}
	else
	{
		// 2단, 3단은 입력을 받지 않고 1단의 3개까지 같고 다음부터는 1단 2개에 하나씩 2,3단에 들어간다.
		// 그러다가 끝에 3개도 무조건 들어감
		CPlaceRebarByBlock *pPlace	= &m_placeByBlock_SupportRebar_UpperSlab[upper][0];
		CDPointArray xyArrOffsetInfo;
		xyArrOffsetInfo	= pPlace->m_xyArr;

		// 주철근에 따라 직거리 사거리로 배근하는데, 실제 그려야 되는게 입력된거랑 다르면 데이타를 수정해줌 //////
		BOOL bVertDirMainRebar	= IsVertDir();
		BOOL bVertDir	= nVertDir == -1 ? TRUE : (nVertDir == 0 ? bVertDirMainRebar : FALSE);
		if(bVertDirMainRebar != bVertDir && nVertDir != 0)
		{
			double dAngCur		= GetAngleJijum(0, bVertDirMainRebar).GetAngleDegree();
			double dAngApply	= bVertDir ? 90 : GetAngleJijum(0).GetAngleDegree();
			ApplyAngleToOffsetInfo(xyArrOffsetInfo, dAngCur, dAngApply);
		}
		//////////////////////////////////////////////////////////////////////////////////////////////////////////



		// 상부슬래브 상,하면 피복
		//double dCover			= bUpper ? m_dCoverUpper_UpperSlab[nDan] : m_dTS - m_dCoverLower_UpperSlab[nDan];
		double dRadRebar		= bUpper ? -REBAR_RADIUS : REBAR_RADIUS;
		CRebarInfoCycle *pRC	= GetRebarInfoCycleUpperSlab(0, 0, bUpper, 0);

		// 상부슬래브는 선형의 영향을 받으므로 속도저하가 생길 가능성이 있더라도 일일이 계산 해줘야 됨.
		CDPoint xyR(0, 0);
		CDPoint xy(0, 0);
		CTwinVector tvUpper	= GetTvOffset_UpperSlab(nDan, bUpper, -1, -1, bVertDir, FALSE);

		long nSize	= xyArrOffsetInfo.GetSize();
		double dSta	= pRC ? (bUpper ? pRC->m_xyStt.x + pRC->m_R_Mid : pRC->m_xyStt.x) : tvUpper.m_v1.x;
		if(IsBlockOut(TRUE))
			dSta	= tvUpper.m_v1.x;

		BOOL bSttRebar	= TRUE;
		if(IsMainRebarJointUpperSlabAndOutWall(pRC, bSttRebar))
			dSta	= pRC->m_xyMidExt.x;

		// 시작위치부터 철근 생성
		// 단 상부와 하부는 시작위치가 다르다.
		if(IsOutWall(TRUE))
		{
			if(bUpper)
			{
				//xy	= GetXyMatchLineAndSlabUpper(CDPoint(dSta, 0), CDPoint(0, 1), 0, dCover, bVertDir);
				GetXyMatchLineAndLine(CDPoint(dSta, 0), CDPoint(0, 1), tvUpper.m_v1, tvUpper.GetXyDir(), xy);
				xy.y += dRadRebar;
			}
			else
			{
				CDPoint vAng	= GetAngleJijum(0, bVertDir);
				double dThickWall = m_nTypePlacingMainRebar_UpperSlab == 0 ? GetThickOutWallByLine(TRUE) : m_dWS;
				dSta	+= dThickWall - (m_dCoverWallIn[0]+m_dCoverWallOut[0])/vAng.y;
				//xy		= GetXyMatchLineAndSlabUpper(CDPoint(dSta, 0), CDPoint(0, 1), 0, dCover, bVertDir);
				GetXyMatchLineAndLine(CDPoint(dSta, 0), CDPoint(0, 1), tvUpper.m_v1, tvUpper.GetXyDir(), xy);
				xy.y	+= dRadRebar;
			}
		}
		else
		{
			//xy	= GetXyMatchLineAndSlabUpper(CDPoint(dSta, 0), CDPoint(0, 1), 0, dCover, bVertDir);
			GetXyMatchLineAndLine(CDPoint(dSta, 0), CDPoint(0, 1), tvUpper.m_v1, tvUpper.GetXyDir(), xy);
			xy.y += dRadRebar;
		}
		xyArr.Add(xy);

		for(long block = 0; block < pPlace->m_nCountBlock; block++)
		{
			if(nSize-1 < block) break;
			xyR	= xyArrOffsetInfo.GetAt(block);

			long i = 0; for(i = 0; i < xyR.x; i++)
			{
				dSta += xyR.y;
				//xy	= GetXyMatchLineAndSlabUpper(CDPoint(dSta, 0), CDPoint(0, 1), 0, dCover, bVertDir);
				GetXyMatchLineAndLine(CDPoint(dSta, 0), CDPoint(0, 1), tvUpper.m_v1, tvUpper.GetXyDir(), xy);
				xy.y += dRadRebar;
				xyArr.Add(xy);
			}
		}

		// 1단이고 상면 철근이면 신축이음이 있는 곳을 판단
		if(nDan == 0 && bUpper && (IsBlockOut(TRUE) || IsBlockOut(FALSE)))
		{
			double dTP	= GetThickPave(FALSE);
			CTwinVector tvUpperApplyFlexibleJoint	= GetTvOffset_UpperSlab(nDan, bUpper, -1, -1, bVertDir, TRUE);
			CDPoint xyMatch(0, 0);
			long i = 0; for(i = 0; i < xyArr.GetSize(); i++)
			{
				CDPoint xy	= xyArr.GetAt(i);
				if(!GetXyMatchSegAndLine(tvUpperApplyFlexibleJoint.m_v1, tvUpperApplyFlexibleJoint.m_v2, xy, CDPoint(0, 1), xyMatch))
				{
					if(xy.x <= tvUpperApplyFlexibleJoint.m_v1.x)
						xy.y -= (m_fxJointStt.m_dHeight - dTP);
					else
						xy.y -= (m_fxJointEnd.m_dHeight - dTP);
					xyArr.SetAt(i, xy);

				}
			}
		}

		xyArrSupRebar1Dan[upper].RemoveAll();
		xyArrSupRebar1Dan[upper]	= xyArr;
	}




	// 2단부터는 실제로 주철근이 배근된 곳에만 배력철근이 배근된다. 
	if(nDan > 0 && xyArr.GetSize() > 0)
	{
		//2단 배력철근의 배치 오프셋 크기
		long nCountOffset = 1;

		// 동일 간격이 아닐때는 표준간격의 1/2씩 배근된 곳이 있다.
		// 그 곳에는 m_bPlacing23DanByStandardOffset 옵션 적용 가능함
		if(m_bSameOffsetPlaceTAndCBlock == FALSE)
		{
			nCountOffset = 2;
			if(m_bPlacing23DanByStandardOffset == FALSE)
				nCountOffset = 1;
		}

		//Issue Number:#28115
		if(nDan > 0 && bUpper == FALSE)
			nCountOffset = 1;


		// 2단, 3단은 입력을 받지 않고 1단의 3개까지 같고 다음부터는 1단 2개에 하나씩 2,3단에 들어간다.
		long nCountSame	= bUpper ? 2 : 1;

		CDPointArray xyArrTmp;
		xyArrTmp	= xyArr;
		long nSize		= xyArrTmp.GetSize();
		xyArr.RemoveAll();

		if(m_bPlacing23DanByStandardOffset == FALSE)
		{
			if(nSize > nCountSame)
			{
				for(long i = 0; i < nCountSame; i++)
					xyArr.Add(xyArrTmp.GetAt(i));

				for(long i = nCountSame; i < nSize-(nCountOffset-1)-nCountSame; i+=nCountOffset)
				{

					xyArr.Add(xyArrTmp.GetAt(i));
				}

				for(long i = nSize-(nCountOffset-1)-nCountSame; i < nSize; i++)
					xyArr.Add(xyArrTmp.GetAt(i));
			}
		}
		else
		{
			//Issue Number:#28115
			//교본 구간 표준 CTC에 맞게끔 수정함.
			double dStdCTC = m_dCTC_SupportRebar[iUPPER];

			//ARCBRIDGE-2471
			//첫번째 철근은 무조건 넣어줌
			// 간격이 dStdCTC와 맞지않으면 그냥 넣어주고 dStdCTC간격이거나 dStdCTC의 1/2간격일 경우를 체크하여
			//해당 되는 철근만 넣어준다.
			xyArr.Add(xyArrTmp.GetAt(0));

			CDPoint xyPrev, xyCurr;
			xyPrev = xyArrTmp.GetAt(0);

			for(long ix = 1; ix < xyArrTmp.GetSize()-1; ix++)
			{
				xyCurr = xyArrTmp.GetAt(ix);

				double dLen = fabs(xyCurr.x - xyPrev.x);

				if(Compare(dLen, dStdCTC/2, _T("="), 0.1))
					continue;

				if(Compare(dLen, dStdCTC, _T("="), 0.1) == FALSE && Compare(dLen, dStdCTC/2, _T("="), 0.1) == FALSE)
					xyArr.Add(xyCurr);
				else if(Compare(dLen, dStdCTC, _T("="), 0.1))
					xyArr.Add(xyCurr);

				xyPrev = xyCurr;
			}

// 			double dCTCSum = 0.0;
// 			for(long nIdx = 0; nIdx < nSize; nIdx++)
// 			{
// 				if(nIdx <2)
// 				{
// 					xyArr.Add(xyArrTmp.GetAt(nIdx));
// 					continue;
// 				}
// 				CDPoint xyCurr;
// 				CDPoint xyPre;
// 				xyCurr = xyArrTmp.GetAt(nIdx);
// 				xyPre = xyArrTmp.GetAt(nIdx - 1);
// 				double dDis;
// 				dDis = xyCurr.x - xyPre.x;
// 				dCTCSum += dDis;
// 				if(dCTCSum < dStdCTC)
// 					continue;
// 				else
// 				{
// 					dCTCSum = 0.0;
// 					xyArr.Add(xyArrTmp.GetAt(nIdx));
// 				}
// 			}
		}

		CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = &m_pArrRCMainUpperSlab[0][upper][nDan];
		CHgBaseConcStd baseConcStd;
		baseConcStd.GetXyRangeOfRebarInfoCycleArray(xyArr, pArrRC, TRUE);
	}
}


// 종단면, 시종점 외측벽체, 내외측 배력철근 위치
void CRcBridgeRebar::GetXyRebarSupport_VertSection_OutWall(CDPointArray &xyArr, BOOL bStt, BOOL bInner, long nDan, long nVertDir, BOOL bAcute, BOOL bLeft)
{
	xyArr.RemoveAll();
	long inner		= bInner ? iINNER : iOUTTER;
	long stt		= bStt ? iSTT : iEND;
	long left		= bLeft ? iLEFT : iRIGHT;

	if(nDan == -1) nDan = MAX_REBAR_DAN-1;
	if(nDan < 0 || nDan > MAX_REBAR_DAN-1) return;
	if(!IsOutWall(bStt)) return;

	if(bAcute)
	{
		if(!m_bIsAcuteAngle_OutWall[stt][left]) return;
	}


	BOOL bVertDir	= IsVertDir();
	if(nVertDir!=0)
		bVertDir	= nVertDir == -1 ? TRUE : FALSE;
	
	// 2단, 3단은 입력을 받지 않고 1단의 3개까지 같고 다음부터는 1단 2개에 하나씩 2,3단에 들어간다.
	CPlaceRebarByBlock *pPlace	= &m_placeByBlock_SupportRebar_OutWall[stt][inner][0];
	if(bAcute)
	{
		pPlace	= &m_placeByBlock_AcuteAngle_SupportRebar_OutWall[stt][left];
		bInner	= FALSE;
	}


	// 외측벽체 내외측 피복
	double dRadRebar		= 0;
	if(bStt)
	{
		dRadRebar	= bInner ? -REBAR_RADIUS : REBAR_RADIUS;
	}
	else
	{
		dRadRebar	= bInner ? REBAR_RADIUS : -REBAR_RADIUS;
	}

	CRebarInfoCycle *pRC	= GetRebarInfoCycleOutWall(0, 0, bStt, bInner, 0);
	if(!pRC)
		pRC	= GetRebarInfoCycleUpperSlab(0, 0, TRUE, bStt ? 0 : -1);
	if(bAcute)
	{
		pRC	= &m_rebarInfoCycle_AcuteAngle_OutWall[stt][left];
	}
	if(IsBoxType() && !bInner)
	{
		pRC	= GetRebarInfoCycleLowerSlab(0, 0, FALSE, bStt ? 0 : -1);
	}

	BOOL bSttRebar	= TRUE;
	if(!pRC && !IsMainRebarJointUpperSlabAndOutWall(pRC, bSttRebar) && !bAcute) return;

	CTwinVector tvWall	= bAcute ? GetTvOffset_OutWall_AcuteAngle(bStt, bLeft, bVertDir) : GetTvOffset_OutWall(nDan, bStt, bInner, bVertDir);
	CTwinVector tvWall1Dan	= bAcute ? tvWall : GetTvOffset_OutWall(0, bStt, bInner, bVertDir);
	
	// 철근 좌표 찾기
	CRebarPlacing rb;
	rb.SettingRadius(dRadRebar, TRUE, FALSE);
	// BOX타입은 하부슬래브에서 피복 이격하고 바로 거리로 배치 한다.
	// 2,3단 시작위치를 1단과 같게 해준다.
	CDPoint xyStt	= (pRC && !IsBoxType()) ? CDPoint(tvWall.m_v1.x, pRC->m_xyMid2.y) : CDPoint(tvWall.m_v1.x, tvWall1Dan.m_v1.y);
	CDPoint xyEnd	= tvWall.m_v2;
	if(IsMainRebarJointUpperSlabAndOutWall(pRC, bSttRebar) && !bAcute)
	{
		xyStt	= bSttRebar ? CDPoint(tvWall.m_v1.x, pRC->m_xyMid2.y) : CDPoint(tvWall.m_v1.x, pRC->m_xyEnd.y);
	}
	rb.GetXyDivideLine(xyArr, xyStt, xyEnd, pPlace->m_xyArr, FALSE, FALSE, FALSE);


	// 2단부터는 실제로 주철근이 배근된 곳에만 배력철근이 배근된다. 
	if(nDan > 0 && !bAcute)
	{
		//#0032084 - 컬버트와 같은 방식으로 수정
		xyArr.RemoveAll();

		long nCountOffset	= m_bSameOffsetPlaceTAndCBlock ? 1 : 2;	// 2단 배근시 1단철근 몇개마다 하나씩 배근할지?

		// 동일 간격이 아닐때는 표준간격의 1/2씩 배근된 곳이 있다.
		// 그 곳에는 m_bPlacing23DanByStandardOffset 옵션 적용 가능함
		if(!m_bSameOffsetPlaceTAndCBlock)
		{
			if(m_bPlacing23DanByStandardOffset)// || GetCountCycleMainRebar() > 1)
			{
				//#0032084표준간격이면 한개씩 빼고 배치
				nCountOffset	= 2;
			}
			else
			{
				nCountOffset	= 1;
			}
		}

		if(nDan > 0 && bInner == TRUE)
			nCountOffset = 1;
	
		
		CDPoint xyData;
		CDPointArray xyArrCtC;
		xyArrCtC = pPlace->m_xyArr;

		for(long ix = 0; ix < xyArr.GetSize(); ix ++)
		{
			xyData = xyArr.GetAt(ix);

			
			if(nCountOffset == 2 && Compare(xyData.y,m_dCTC_SupportRebarOutWall[stt]/2.,"=") && ((long)(xyData.x)%2)==0)
			{
				xyData.x /= 2.0;
				xyData.y *= 2.0;
			}

			xyArr.SetAt(ix, xyData);
		}

		rb.GetXyDivideLine(xyArr, xyStt, xyEnd, xyArrCtC, FALSE, FALSE, FALSE);
		
		// 2단, 3단은 입력을 받지 않고 1단의 nCountSame개까지 같고 다음부터는 1단 2개에 하나씩 2,3단에 들어간다.
		long nCountSame	= 0;
		CDPointArray xyArrTmp;
		xyArrTmp		= xyArr;
		long nSize		= xyArrTmp.GetSize();
		xyArr.RemoveAll();

		if(m_bPlacing23DanByStandardOffset == FALSE)
		{
			if(nSize > nCountSame)
			{
				long i = 0; for(i = 0; i < nCountSame; i++)
					xyArr.Add(xyArrTmp.GetAt(i));

				for(i = nCountSame; i < nSize-(nCountOffset-1); i+=nCountOffset)
				{
					xyArr.Add(xyArrTmp.GetAt(i));
				}
			}
		}
		else
		{
			//교본 구간 표준 CTC에 맞게끔 수정함.
			double dStdCTC = m_dCTC_SupportRebarOutWall[bLeft? iLEFT : iRIGHT];
			double dCTCSum = 0.0;
			for(long nIdx = 0; nIdx < nSize; nIdx++)
			{
				if(nIdx==0)
				{
					xyArr.Add(xyArrTmp.GetAt(nIdx));
					continue;
				}
				CDPoint xyCurr;
				CDPoint xyPre;
				xyCurr = xyArrTmp.GetAt(nIdx);
				xyPre = xyArrTmp.GetAt(nIdx - 1);
				double dDis;
				dDis = xyCurr.y - xyPre.y;
				dCTCSum += dDis;
				if(dCTCSum < dStdCTC)
					continue;
				else
				{
					dCTCSum = 0.0;
					xyArr.Add(xyArrTmp.GetAt(nIdx));
				}
			}
		}

		CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = &m_pArrRCMainOutWall[0][stt][inner][nDan];
		// 외측벽체에서 상부슬래브로 연결되는 철근을 추가해서 배력철근을 구한다.
		if(!bInner)
		{
			BOOL bFind = FALSE;
			CRebarInfoCycle *pRCTmp	= GetRebarInfoCycleUpperSlab(0, nDan, TRUE, bStt ? 0 : -1);
			if(pRCTmp && bStt && pRCTmp->m_nPosStt == REBARINFO_POS_STTWALL_OUTTER) bFind = TRUE;
			if(pRCTmp && !bStt && pRCTmp->m_nPosEnd == REBARINFO_POS_ENDWALL_OUTTER) bFind = TRUE;
			if(bFind)
			{
				CRebarInfoCycle *pRC	= new CRebarInfoCycle;
				*pRC	= *pRCTmp;
				pArrRC->Add(pRC);
			}

			if(IsBoxType())
			{
				bFind = FALSE;

				CRebarInfoCycle *pRCTmpLo	= GetRebarInfoCycleLowerSlab(0, nDan, FALSE, bStt ? 0 : -1);
				if(pRCTmpLo && bStt && pRCTmpLo->m_nPosStt == REBARINFO_POS_STTWALL_OUTTER) bFind = TRUE;
				if(pRCTmpLo && !bStt && pRCTmpLo->m_nPosEnd == REBARINFO_POS_ENDWALL_OUTTER) bFind = TRUE;
				if(bFind)
				{
					CRebarInfoCycle *pRC	= new CRebarInfoCycle;
					*pRC	= *pRCTmpLo;
					pArrRC->Add(pRC);
				}
			}
		}

		CHgBaseConcStd baseConcStd;
		baseConcStd.GetXyRangeOfRebarInfoCycleArray(xyArr, pArrRC, FALSE);

		// 추가했던 상부슬래브 철근 제거
		if(!bInner)
		{
			if(IsBoxType())
			{
				CRebarInfoCycle *pRCTmp	= GetRebarInfoCycleLowerSlab(0, nDan, TRUE, bStt ? 0 : -1);
				if(pRCTmp)
				{
					BOOL bFind = FALSE;
					if(pRCTmp && bStt && pRCTmp->m_nPosStt == REBARINFO_POS_STTWALL_OUTTER) bFind = TRUE;
					if(pRCTmp && !bStt && pRCTmp->m_nPosEnd == REBARINFO_POS_ENDWALL_OUTTER) bFind = TRUE;
					nSize	= pArrRC->GetSize();
					if(nSize > 0 && bFind)
					{
						delete pArrRC->GetAt(nSize-1);
						pArrRC->RemoveAt(nSize-1);
					}
				}
			}

			CRebarInfoCycle *pRCTmp	= GetRebarInfoCycleUpperSlab(0, nDan, TRUE, bStt ? 0 : -1);
			if(pRCTmp)
			{
				BOOL bFind = FALSE;
				if(pRCTmp && bStt && pRCTmp->m_nPosStt == REBARINFO_POS_STTWALL_OUTTER) bFind = TRUE;
				if(pRCTmp && !bStt && pRCTmp->m_nPosEnd == REBARINFO_POS_ENDWALL_OUTTER) bFind = TRUE;
				nSize	= pArrRC->GetSize();
				if(nSize > 0 && bFind)
				{
					delete pArrRC->GetAt(nSize-1);
					pArrRC->RemoveAt(nSize-1);
				}
			}
		}
	}
}


CRebarInfoCycle *CRcBridgeRebar::GetRebarInfoCycleOutWall(long nCycle, long nDan, BOOL bStt, BOOL bInner, long nIdx)
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return FALSE;
	if(nDan == -1) nDan = MAX_REBAR_DAN-1;
	if(nDan < 0 || nDan > MAX_REBAR_DAN-1) return FALSE;

	// 필요한 RebarInfoCycle 배열을 찾음
	long stt	= bStt ? iSTT : iEND;
	long inner	= bInner ? iINNER : iOUTTER;
	
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = &m_pArrRCMainOutWall[nCycle][stt][inner][nDan];
	if(!pArrRC) return FALSE;

	long nSize	= pArrRC->GetSize();
	if(nIdx == -1) nIdx = nSize-1;
	if(nIdx >= nSize) return FALSE;
	if(nIdx < 0) return FALSE;

	return pArrRC->GetAt(nIdx);
	/*
	// 포인터를 넘겨도 되지만 별개로 관리해야 메모리 관리가 어지럽지 않을꺼 같아서 이렇게 함.
	*pRC	= *pArrRC->GetAt(nIdx);

	return TRUE;
	*/
}

// 종단면 상부 슬래브 전단철근 좌표
// CTwinVectorArray &tvArrHucnh : 헌치부철근까지 확장된 전단철근
// CTwinVectorArray &tvArrRib : 리브까지 확장된 전단철근
// long nVertDir=0 : 자동(원래설정), -1 : 직거리, 1 : 사거리
void CRcBridgeRebar::GetTvRebarShear_VertSection_UpperSlab(CTwinVectorArray &tvArr, CTwinVectorArray &tvArrHucnh, CTwinVectorArray &tvArrRib, long nVertDir)
{
	tvArr.RemoveAll();
	tvArrHucnh.RemoveAll();
	tvArrRib.RemoveAll();

	BOOL bVertDirMainRebar	= IsVertDir();
	BOOL bVertDir	= nVertDir == -1 ? TRUE : (nVertDir == 0 ? bVertDirMainRebar : FALSE);

	// 상부슬래브 상하면 1단철근에 전단철근 배근함.
	// 단.. 전단철근이 피복을 적용하지 않은 벽체 외측부터 시작되어야 하므로 1단철근 좌표 구할때 피복을 적용하지 않고 구함.
	CTwinVector tvUpper, tvLower;
	CTwinVector tvSide;
	tvUpper				= GetTvOffset_UpperSlab(0, TRUE, -1.0, -1.0, bVertDir);
	tvLower				= GetTvOffset_UpperSlab(0, FALSE, -1.0, -1.0, bVertDir);
	tvSide				= m_tvArrVertSection.GetTvByInfo(IsOutWall(TRUE) ? "시점브라켓상부측면" : "시점슬래브측면");
	tvUpper.m_v1.x = tvSide.m_v1.x;
	tvLower.m_v1.x = tvSide.m_v1.x;

	// 전단철근 배치함.
	CRebarPlacing rb;
	CDPointArray xyArr, xyArrOffsetInfo;
	CPlaceRebarByBlock *pPlace	= &m_placeByBlock_ShearRebar_UpperSlab;
	xyArrOffsetInfo	= pPlace->m_xyArr;


	// 주철근에 따라 직거리 사거리로 배근하는데, 실제 그려야 되는게 입력된거랑 다르면 데이타를 수정해줌 //////
	if(bVertDirMainRebar != bVertDir && nVertDir != 0)
	{
		double dAngCur		= GetAngleJijum(0, bVertDirMainRebar).GetAngleDegree();
		double dAngApply	= bVertDir ? 90 : GetAngleJijum(0).GetAngleDegree();
		ApplyAngleToOffsetInfo(xyArrOffsetInfo, dAngCur, dAngApply);
	}
	//////////////////////////////////////////////////////////////////////////////////////////////////////////


	// 상부슬래브는 선형의 영향을 받으므로 속도저하가 생길 가능성이 있더라도 일일이 계산 해줘야 됨.
	CDPoint xyR(0, 0);
	CDPoint xy(0, 0);
	long nSize		= xyArrOffsetInfo.GetSize();
	double dSta		= tvUpper.m_v1.x;
	//double dCover	= m_dCoverUpper_UpperSlab[0];

	if(nSize < 0) return;

	// 전단철근은 시작위치에 배근하지 않음

	//
	for(long block = 0; block < pPlace->m_nCountBlock; block++)
	{
		if(nSize-1 < block) break;
		xyR	= xyArrOffsetInfo.GetAt(block);

		long i = 0; for(i = 0; i < xyR.x; i++)
		{
			dSta += xyR.y;
			//xy	= GetXyMatchLineAndSlabUpper(CDPoint(dSta, 0), CDPoint(0, 1), 0, dCover, bVertDir);
			GetXyMatchLineAndLine(CDPoint(dSta, 0), CDPoint(0, 1), tvUpper.m_v1, tvUpper.GetXyDir(), xy);
			xyArr.Add(xy);
		}
	}

	// 위치를 알았으면 길이를 줘서 전단철근을 만듬
	double dLen	= m_dTS - (m_dCoverLower_UpperSlab[0] + m_dCoverUpper_UpperSlab[0]);
	rb.MakePointArrayToLineArray(xyArr, tvArr, CDPoint(0, -1), dLen, FALSE);

	// 헌치철근까지 연장할까?
	if(m_bExtendShearRebarToHunchRebar)
	{
		CTwinVector tv;
		CDPointArray xyArrMatch;
		CDPointArray xyArrMatchTot;
		CDPoint xyMatch(0, 0);
		long nSizeHunchRebar	= m_pArrRCMainUpperSlabHunch[0].GetSize();
		long i = 0; for(i = 0; i < tvArr.GetSize(); i++)
		{
			tv	= tvArr.GetAt(i);

			// 헌치철근 사이에 있는지 체크한다.
			xyArrMatchTot.RemoveAll();
			long nJHunch	= -1;
			long j = 0; for(j = 0; j < nSizeHunchRebar; j++)
			{
				CRebarInfoCycle *pRC	= m_pArrRCMainUpperSlabHunch[0].GetAt(j);
				// 같은 지점의 헌치 철근 끼리만 교차점을 찾는다.
				if(nJHunch != pRC->m_nPosHunch && nJHunch != -1)
				{
					// 다른 지점이 나오면 검사를 시작
					if(xyArrMatchTot.GetSize() > 0)
					{
						xyMatch	= rb.GetXyEdgePoint(xyArrMatchTot, UPRIGHT_AREA);
						if(xyMatch.y < tv.m_v2.y)
						{
							tv.m_v2	= xyMatch;
							// 전단철근을 헌치까지 뻗었더니 구조물선에 걸리는 것들은 (경사교.)잘라내고 슬래브 하면까지만 뻗자.
							rb.GetXyMatchTvArrAndSeg(m_tvArrVertSection, tv.m_v1, tv.m_v2, xyArrMatch, FALSE);
							if(xyArrMatch.GetSize() == 0)
							{
								tvArr.RemoveAt(i);
								tvArrHucnh.Add(tv);
								i--;
							}
						}
					}
					break;
				}

				rb.GetXyMatchTvArrAndLine(pRC->m_tvArrRebar, tv.m_v1, tv.GetXyDir(), xyArrMatch);

				for(long k = 0; k < xyArrMatch.GetSize(); k++)
					xyArrMatchTot.Add(xyArrMatch.GetAt(k));

				if(xyArrMatchTot.GetSize() > 0 && nJHunch == -1)
					nJHunch	= pRC->m_nPosHunch;

				// 마지막은 그냥 지나칠수 잇으므로 검사한번 더함.ㄴ
				// (ARCBRIDGE-2661) 매치되는 철근이 있다면 다 헌치 철근으로 넣어줘야지. 마지막 지점만 넣어주는건 뭐지?
				// if(j == nSizeHunchRebar-1)
				{
					// 같은 지점의 헌치 철근 끼리만 교차점을 찾는다.
					if(nJHunch != -1)
					{
						// 다른 지점이 나오면 검사를 시작
						if(xyArrMatchTot.GetSize() > 0)
						{
							xyMatch	= rb.GetXyEdgePoint(xyArrMatchTot, UPRIGHT_AREA);
							if(xyMatch.y < tv.m_v2.y)
							{
								tv.m_v2	= xyMatch;

								// 전단철근을 헌치까지 뻗었더니 구조물선에 걸리는 것들은 (경사교.)잘라내고 슬래브 하면까지만 뻗자.
								rb.GetXyMatchTvArrAndSeg(m_tvArrVertSection, tv.m_v1, tv.m_v2, xyArrMatch, FALSE);
								if(xyArrMatch.GetSize() == 0)
								{
									tvArr.RemoveAt(i);
									tvArrHucnh.Add(tv);
									i--;
								}
							}
						}
						break;
					}
				}

			}
		}

		// 아치교는 상부슬래브와 연결된 중간벽체 사이에 있는 전단철근은 리브 하면 주철근까지 뻗는다.
		long nJ	= GetJijumConnectRibAndSlab();
		if(nJ > 0)
		{
			CWallApp *pWall	= GetInWall(nJ-1);
			if(pWall)
			{
				if(pWall->m_bIs)
				{
					CParabola pbRebar;
					GetRebarRib(pbRebar, FALSE, 0);
					double dLeftX	= pWall->m_xyOrg.x - pWall->GetWidthWall()/2;
					double dRightX	= pWall->m_xyOrg.x + pWall->GetWidthWall()/2;
					// 접합부 라운드인경우
					if(pWall->m_bSideIsArc)
					{
						CTwinVector tvLeft	= pWall->m_tvArrFront.GetTvByInfo("벽체좌측면");
						CTwinVector tvRight	= pWall->m_tvArrFront.GetTvByInfo("벽체우측면");

						dLeftX += fabs(tvLeft.m_v2.z);
						dRightX -= fabs(tvRight.m_v2.z);
					}
					dLeftX += m_dCoverLower_UpperSlab[0];
					dRightX -= m_dCoverLower_UpperSlab[0];

					long i = 0; for(i = 0; i < tvArr.GetSize(); i++)
					{
						tv	= tvArr.GetAt(i);
						if(tv.m_v1.x > dLeftX && tv.m_v1.x < dRightX)
						{
							tv.m_v2	= pbRebar.GetXyByDist(pbRebar.GetDistByXPos(tv.m_v1.x));
							tvArr.RemoveAt(i);
							tvArrRib.Add(tv);
							i--;
						}
					}
				}
			}
		}
	}
}

// 종단면 시종점 외측벽체 전단철근 좌표
void CRcBridgeRebar::GetTvRebarShear_VertSection_OutWall(CTwinVectorArray &tvArr, BOOL bStt, long nVertDir)
{
	tvArr.RemoveAll();
	if(!IsOutWall(bStt)) return;
	tvArr.RemoveAll();

	BOOL bVertDir	= IsVertDir();
	if(nVertDir != 0)
		bVertDir	= nVertDir == -1 ? TRUE : FALSE;
	// 상부슬래브 상하면 1단철근에 전단철근 배근함.
	// 단.. 전단철근이 피복을 적용하지 않은 벽체 외측부터 시작되어야 하므로 1단철근 좌표 구할때 피복을 적용하지 않고 구함.
	long stt	= bStt ? iSTT : iEND;
	CFootingApp *pFooting	= bStt ? &m_footingStt : &m_footingEnd;
	double dOldCoverUpper	= m_dCoverUpper_UpperSlab[0];
	double dOldCoverLower	= pFooting->m_dCoverLower[0];
	m_dCoverUpper_UpperSlab[0]	= 0;
	pFooting->m_dCoverLower[0]	= 0;
	CTwinVector tvWall		= GetTvOffset_OutWall(0, bStt, FALSE, bVertDir);	// 전단철근의 길이 되어 줄 외측벽체 철근..
	if(IsBoxType())
	{
		// 전단철근은 피복 고려 없다.
		tvWall.m_v1.y -= m_dCoverLower_LowerSlab[0];
	}

	m_dCoverUpper_UpperSlab[0]	= dOldCoverUpper;
	pFooting->m_dCoverLower[0]	= dOldCoverLower;

	// 전단철근 배치할 위치 찾음.
	CRebarPlacing rb;
	CDPointArray xyArr;
	CPlaceRebarByBlock *pPlace	= &m_placeByBlock_ShearRebar_OutWall[stt];
	rb.GetXyDivideLine(xyArr, tvWall.m_v1, tvWall.m_v2, pPlace->m_xyArr, FALSE, FALSE, FALSE);

	// 위치를 알았으면 길이를 줘서 전단철근을 만듬
	double dAngle	= bVertDir ? 90 : GetAngleJijum(bStt ? 0 : GetCountJijum()-1).GetAngleDegree();
	double rad		= sin(ToRadian(dAngle));
	double dLen	= ((bStt ? m_dWS : m_dWE) - m_dCoverWallIn[0] - m_dCoverWallOut[0])/rad;
	if(!bStt) dLen = -dLen;
	rb.MakePointArrayToLineArray(xyArr, tvArr, CDPoint(1, 0), dLen, FALSE);
}

// 단 절점부 헌치부 전단철근
// long nCycle : #0031622에 의해 추가한 인수
void CRcBridgeRebar::GetTvRebarShear_VertSection_UpperSlabDanbu(CTwinVectorArray &tvArr, BOOL bStt, long nCycle)
{
	tvArr.RemoveAll();
	long stt		= bStt ? iSTT : iEND;
	long nIdx		= bStt ? 0 : -1;

	if(GetDiaRebarStirrupDanbu(bStt, 0, TRUE) <= 0) return;
	if(m_nCountStirrupAtDanBuRebar[iUPPER][stt] <= 0) return;
	if(!IsOutWall(bStt)) return;


	CTwinVector tvHunch;
	CRebarInfoCycle *pRC	= NULL;

	// 일단 상부슬래브 상면 철근이 있어야 가능
	if(Compare(GetDiaMainRebarUpperSlabHunch(nCycle, nIdx), 0.0, ">"))
	{
		pRC	= GetRebarInfoCycleUpperSlab(nCycle, 0, TRUE, nIdx);
		if(pRC)
		{
			CRebarInfoCycle *pRCHunch	= GetRebarInfoCycleUpperSlab_Hunch(nCycle, nIdx);
			BOOL bOK = FALSE;
			// 헌치부철근이 있으면 헌치부 철근까지 배치하고
			if(pRCHunch)
			{
				tvHunch.m_v1	= pRCHunch->m_xyMid1;
				tvHunch.m_v2	= pRCHunch->m_xyMid2;
				
				if(Compare(tvHunch.GetLength(), 0.0, ">"))
					bOK = TRUE;
			}

			// 없으면 상부슬래브 하부철근까지 배치
			if(!bOK)
			{
				tvHunch	= GetTvOffset_UpperSlab(0, FALSE, -1.0, -1.0, IsVertDir());
			}

			// 상면철근에서 -45(시점)도나 225(종점)도방향으로 뻗음
			CDPoint xyDir	= bStt ? ToDPointFrDegree(-45) : ToDPointFrDegree(225);

			// 혹시라도 슬래브철근과 전단철근의 각도가 같으면 철근이 배근되지 않음
			if(ComparePt(xyDir, tvHunch.GetXyDir(), "=") || ComparePt(xyDir, tvHunch.GetXyDir(TRUE), "=")) return;

			CTwinVector tv;
			
			BOOL bSttRebar	= TRUE;
			// 단 절점부 스터럽 철근이 배치될 영역 구함
			CDPoint xyCen(0, 0);
			double dAngStt	= 0;
			double dAngEnd	= 0;
			double dR		= 0;
			if(IsMainRebarJointUpperSlabAndOutWall(pRC, bSttRebar))
			{
				xyCen	= bSttRebar ? pRC->m_xyCenExt : pRC->m_xyCen;
				dAngStt	= bSttRebar ? (pRC->m_xyMidExt - xyCen).Unit().GetAngleDegree() : (pRC->m_xyMid2 - xyCen).Unit().GetAngleDegree();
				dAngEnd	= bSttRebar ? (pRC->m_xyEnd - xyCen).Unit().GetAngleDegree() : (pRC->m_xyMid1 - xyCen).Unit().GetAngleDegree();
				dR		= bSttRebar ? pRC->m_R_MidExt : pRC->m_R_Mid;
			}
			else if(IsMainRebarJointUpperSlabAndUpperSlab(pRC))
			{
				xyCen	= bStt ? pRC->m_xyCen : pRC->m_xyCenExt;
				dAngStt	= bStt ? (pRC->m_xyMid2 - xyCen).Unit().GetAngleDegree() : (pRC->m_xyMidExt - xyCen).Unit().GetAngleDegree();
				dAngEnd	= bStt ? (pRC->m_xyMid1 - xyCen).Unit().GetAngleDegree() : (pRC->m_xyEnd - xyCen).Unit().GetAngleDegree();
				dR		= bStt ? pRC->m_R_Mid : pRC->m_R_MidExt;
			}
			else
			{
				xyCen	= pRC->m_xyCen;
				dAngStt	= (pRC->m_xyMid2 - xyCen).Unit().GetAngleDegree();
				dAngEnd	= (pRC->m_xyMid1 - xyCen).Unit().GetAngleDegree();
				dR		= pRC->m_R_Mid;
			}

			if(dR > 0)
			{
				long nCountStirrup	= m_nCountStirrupAtDanBuRebar[iUPPER][stt];
				double dAngOffset	= nCountStirrup == 1 ? (dAngEnd - dAngStt) / (nCountStirrup+1) : (dAngEnd - dAngStt) / (nCountStirrup - 1);

				long nIdxOffset	= 1;
				long i = 0; for(i = 0; i < nCountStirrup; i++)
				{
					if(i == 0 && nCountStirrup > 1)
					{
						tv.m_v1	= xyCen + ToDPointFrDegree(dAngStt) * dR;
					}
					else if(i == nCountStirrup-1 && nCountStirrup > 1)
					{
						tv.m_v1	= xyCen + ToDPointFrDegree(dAngEnd) * dR;
					}
					else
					{
						tv.m_v1	= xyCen + ToDPointFrDegree(dAngStt + dAngOffset*(nIdxOffset++)) * dR;
					}
					GetXyMatchLineAndLine(tv.m_v1, xyDir, tvHunch.m_v1, tvHunch.GetXyDir(), tv.m_v2);
					tvArr.Add(tv);
				}
			}
		}
	}
}

// 단 절점부 헌치부 전단철근
void CRcBridgeRebar::GetTvRebarShear_VertSection_LowerSlabDanbu(CTwinVectorArray &tvArr, BOOL bStt, long nCycle)
{
	if(!IsBoxType()) return;

	tvArr.RemoveAll();
	long stt		= bStt ? iSTT : iEND;
	long nIdx		= bStt ? 0 : -1;

	if(GetDiaRebarStirrupDanbu(bStt, 0, FALSE) <= 0) return;
	if(m_nCountStirrupAtDanBuRebar[iLOWER][stt] <= 0) return;
	if(!IsOutWall(bStt)) return;


	CTwinVector tvHunch;
	CRebarInfoCycle *pRC	= NULL;

	// 일단 상부슬래브 상면 철근이 있어야 가능
	if(Compare(GetDiaMainRebarLowerSlabHunch(nCycle, nIdx), 0.0, ">"))
	{
		pRC	= GetRebarInfoCycleLowerSlab(nCycle, 0, FALSE, nIdx);
		if(pRC)
		{
			CRebarInfoCycle *pRCHunch	= GetRebarInfoCycleLowerSlab_Hunch(nCycle, nIdx);
			BOOL bOK = FALSE;
			// 헌치부철근이 있으면 헌치부 철근까지 배치하고
			if(pRCHunch)
			{
				tvHunch.m_v1	= pRCHunch->m_xyMid1;
				tvHunch.m_v2	= pRCHunch->m_xyMid2;

				if(Compare(tvHunch.GetLength(), 0.0, ">"))
					bOK = TRUE;
			}

			// 없으면 상부슬래브 하부철근까지 배치
			if(!bOK)
			{
				tvHunch	= GetTvOffset_LowerSlab(0, FALSE);
			}

			// 하면철근에서 45(시점)도나 135(종점)도방향으로 뻗음
			CDPoint xyDir	= bStt ? ToDPointFrDegree(45) : ToDPointFrDegree(135);

			// 혹시라도 슬래브철근과 전단철근의 각도가 같으면 철근이 배근되지 않음
			if(ComparePt(xyDir, tvHunch.GetXyDir(), "=") || ComparePt(xyDir, tvHunch.GetXyDir(TRUE), "=")) return;

			CTwinVector tv;

			BOOL bSttRebar	= TRUE;
			// 단 절점부 스터럽 철근이 배치될 영역 구함
			CDPoint xyCen(0, 0);
			double dAngStt	= 0;
			double dAngEnd	= 0;
			double dR		= 0;
			if(IsMainRebarJointLowerSlabAndOutWall(pRC, bSttRebar))
			{
				xyCen	= bSttRebar ? pRC->m_xyCenExt : pRC->m_xyCen;
				dAngStt	= bSttRebar ? (pRC->m_xyMidExt - xyCen).Unit().GetAngleDegree() : (pRC->m_xyMid2 - xyCen).Unit().GetAngleDegree();
				dAngEnd	= bSttRebar ? (pRC->m_xyEnd - xyCen).Unit().GetAngleDegree() : (pRC->m_xyMid1 - xyCen).Unit().GetAngleDegree();
				dR		= bSttRebar ? pRC->m_R_MidExt : pRC->m_R_Mid;
			}
			else if(IsMainRebarJointLowerSlabAndLowerSlab(pRC))
			{
				xyCen	= bStt ? pRC->m_xyCen : pRC->m_xyCenExt;
				dAngStt	= bStt ? (pRC->m_xyMid2 - xyCen).Unit().GetAngleDegree() : (pRC->m_xyMidExt - xyCen).Unit().GetAngleDegree();
				dAngEnd	= bStt ? (pRC->m_xyMid1 - xyCen).Unit().GetAngleDegree() : (pRC->m_xyEnd - xyCen).Unit().GetAngleDegree();
				dR		= bStt ? pRC->m_R_Mid : pRC->m_R_MidExt;
			}
			else
			{
				xyCen	= pRC->m_xyCen;
				dAngStt	= (pRC->m_xyMid2 - xyCen).Unit().GetAngleDegree();
				dAngEnd	= (pRC->m_xyMid1 - xyCen).Unit().GetAngleDegree();
				dR		= pRC->m_R_Mid;
			}

			if(dR > 0)
			{
				//AngOffset계산할때 안맞음.. 0도면 360도로 계산;
				if(dAngStt == 0)  
					dAngStt = 360;

				long nCountStirrup	= m_nCountStirrupAtDanBuRebar[iLOWER][stt];
				double dAngOffset	= nCountStirrup == 1 ? (dAngEnd - dAngStt) / (nCountStirrup+1) : (dAngEnd - dAngStt) / (nCountStirrup - 1);

				long nIdxOffset	= 1;
				long i = 0; for(i = 0; i < nCountStirrup; i++)
				{
					if(i == 0 && nCountStirrup > 1)
					{
						tv.m_v1	= xyCen + ToDPointFrDegree(dAngStt) * dR;
					}
					else if(i == nCountStirrup-1 && nCountStirrup > 1)
					{
						tv.m_v1	= xyCen + ToDPointFrDegree(dAngEnd) * dR;
					}
					else
					{
						tv.m_v1	= xyCen + ToDPointFrDegree(dAngStt + dAngOffset*(nIdxOffset++)) * dR;
					}
					GetXyMatchLineAndLine(tv.m_v1, xyDir, tvHunch.m_v1, tvHunch.GetXyDir(), tv.m_v2);
					tvArr.Add(tv);
				}
			}
		}
	}
}

CRebarInfoCycle* CRcBridgeRebar::GetRebarInfoCycleUpperSlab_Hunch(long nCycle, long nIdx)
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return FALSE;

	// 필요한 RebarInfoCycle 배열을 찾음
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = &m_pArrRCMainUpperSlabHunch[nCycle];
	if(!pArrRC) return NULL;

	long nSize	= pArrRC->GetSize();
	if(nIdx == -1) nIdx = nSize-1;
	if(nIdx >= nSize) return NULL;
	if(nIdx < 0) return NULL;

	return pArrRC->GetAt(nIdx);
	/*
	// 포인터를 넘겨도 되지만 별개로 관리해야 메모리 관리가 어지럽지 않을꺼 같아서 이렇게 함.
	*pRC	= *pArrRC->GetAt(nIdx);

	return TRUE;
	*/
}

CRebarInfoCycle* CRcBridgeRebar::GetRebarInfoCycleLowerSlab_Hunch(long nCycle, long nIdx)
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return FALSE;

	// 필요한 RebarInfoCycle 배열을 찾음
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = &m_pArrRCMainLowerSlabHunch[nCycle];
	if(!pArrRC) return NULL;

	long nSize	= pArrRC->GetSize();
	if(nIdx == -1) nIdx = nSize-1;
	if(nIdx >= nSize) return NULL;
	if(nIdx < 0) return NULL;

	return pArrRC->GetAt(nIdx);

}

// 단부철근(주철근 라운드부...) - 벽체가 없으면 없다.
void CRcBridgeRebar::GetXyRebarSupport_VertSection_UpperSlabDanBu(CDPointArray &xyArr, BOOL bStt)
{
	xyArr.RemoveAll();
	if(!m_bPlacingSupportAtDanBuRebar) return;
	if(!IsOutWall(bStt)) return;

	long nIdx	= bStt ? 0 : -1;

	long nCntJoint = GetCountJointMainRebarUpperSlab(0, 0, TRUE, 0);

	CRebarInfoCycle *pRC	= GetRebarInfoCycleUpperSlab(0, 0, TRUE, nIdx);
	if(pRC)
	{
		CDPoint xyCen(0, 0);	// 원의 중심.
		CDPoint xyRebar(0, 0);	// 배력철근 위치
		// 원 중심 찾기
		CRebarPlacing rb;
		double dR	= fabs(pRC->m_xyMid1.x - pRC->m_xyMid2.x);
		if(bStt && IsMainRebarJointUpperSlabAndOutWall(pRC, bStt))
		{
			dR	= fabs(pRC->m_xyEnd.x - pRC->m_xyMidExt.x);
			if(dR > 0)
			{
				xyCen			= pRC->m_xyCenExt;
				CDPoint xyDir	= ToDPointFrDegree(135);
				xyRebar			= xyCen + (xyDir * (dR - REBAR_RADIUS));
			}
			else
			{
				xyRebar	= pRC->m_xyEnd;
			}
		}
		else
		{
			if(dR > 0)
			{
				xyCen				= pRC->m_xyCen;// >getxyrb.GetXyCircleCenter(pRC->m_xyMid1, pRC->m_xyMid2, dR, FALSE);
				if(nCntJoint == 0 && !bStt)
					xyCen = pRC->m_xyCenExt;

				CDPoint xyDir	= bStt ? ToDPointFrDegree(135) : ToDPointFrDegree(45);
				xyRebar			= xyCen + (xyDir * (dR - REBAR_RADIUS));
			}
			else
			{
				xyRebar	= pRC->m_xyMid1;
			}
		}

		xyArr.Add(xyRebar);
	}
}

void CRcBridgeRebar::GetXyRebarSupport_VertSection_LowerSlabDanBu(CDPointArray &xyArr, BOOL bStt)
{
	xyArr.RemoveAll();
	if(!IsBoxType()) return;
	if(!m_bPlacingSupportAtDanBuRebar) return;	
	if(!IsOutWall(bStt)) return;

	long nIdx	= bStt ? 0 : -1;

	long nCntJoint = GetCountJointMainRebarLowerSlab(0, 0, FALSE, 0);

	CRebarInfoCycle *pRC	= GetRebarInfoCycleLowerSlab(0, 0, FALSE, nIdx);
	if(pRC)
	{
		CDPoint xyCen(0, 0);	// 원의 중심.
		CDPoint xyRebar(0, 0);	// 배력철근 위치
		// 원 중심 찾기
		CRebarPlacing rb;
		double dR	= fabs(pRC->m_xyMid1.x - pRC->m_xyMid2.x);
		if(bStt && IsMainRebarJointLowerSlabAndOutWall(pRC, bStt))
		{
			dR	= fabs(pRC->m_xyEnd.x - pRC->m_xyMidExt.x);
			if(dR > 0)
			{
				xyCen			= pRC->m_xyCenExt;
				CDPoint xyDir	= ToDPointFrDegree(135);
				xyRebar			= xyCen + (xyDir * (dR - REBAR_RADIUS));
			}
			else
			{
				xyRebar	= pRC->m_xyEnd;
			}
		}
		else
		{
			if(dR > 0)
			{
				xyCen				= pRC->m_xyCen;
				if(nCntJoint == 0 && !bStt)
					xyCen = pRC->m_xyCenExt;

				CDPoint xyDir	= bStt ? ToDPointFrDegree(225) : ToDPointFrDegree(315);
				xyRebar			= xyCen + (xyDir * (dR - REBAR_RADIUS));
			}
			else
			{
				xyRebar	= pRC->m_xyMid1;
			}
		}

		xyArr.Add(xyRebar);
	}
}

// 각 헌치 철근에 배력철근 배치
long CRcBridgeRebar::GetXyRebarSupport_VertSection_UpperSlabHunch(CDPointArray &xyArrLeft, CDPointArray &xyArrRight, long nIdxHunchRebar)
{
	xyArrLeft.RemoveAll();
	xyArrRight.RemoveAll();
	if(!m_bPlacingSupportAtHunchRebar) return -1;

	long nJ	= -1;
	//const double dGap	= 50;	// 배력철근을 배치하는 헌치철근부위를 구한뒤 실제 배치시 안쪽으로 들어가는 거리.
	
	// 배력철근을 배치할 헌치철근 가져옴
	// 해당 헌치부분에만 들어가며, 슬래브 하면 철근과 동일한 sta에 들어감.
	CRebarInfoCycle *pRC	= GetRebarInfoCycleUpperSlab_Hunch(0, nIdxHunchRebar);
	CRebarPlacing rb;
	if(pRC)
	{
		nJ	= pRC->m_nPosHunch;
		
		// 배력근이 들어갈 헌치부 찾아 옴
		CTwinVectorArray tvArrHunchL, tvArrHunchR;
		CTwinVector tvHunchL, tvHunchR;
		if(nJ > 0 && nJ < GetCountJijum()-1)	// 내측헌치인경우
		{
			CString sHunch	= _T("");

			sHunch.Format("%d번째내측헌치좌측면", nJ);
			if(m_tvArrVertSection.GetTvByInfo(sHunch, tvHunchL))
				tvArrHunchL.Add(tvHunchL);
			sHunch.Format("%d번째내측헌치우측면", nJ);
			if(m_tvArrVertSection.GetTvByInfo(sHunch, tvHunchR))
				tvArrHunchR.Add(tvHunchR);
		}
		else	// 외측헌치인 경우
		{
			if(nJ == 0)
			{
				if(m_tvArrVertSection.GetTvByInfo("시점벽체헌치", tvHunchL))
					tvArrHunchL.Add(tvHunchL);
				if(!IsOutWall(TRUE))
				{
					if(m_tvArrVertSection.GetTvByInfo("시점헌치하면", tvHunchL))
						tvArrHunchL.Add(tvHunchL);
				}
			}
			else
			{
				if(m_tvArrVertSection.GetTvByInfo("종점벽체헌치", tvHunchR))
					tvArrHunchR.Add(tvHunchR);
				if(!IsOutWall(FALSE))
				{
					if(m_tvArrVertSection.GetTvByInfo("종점헌치하면", tvHunchR))
						tvArrHunchR.Add(tvHunchR);
				}
			}
		}


		// 배근함
		CDPointArray xyArrSup;
		GetXyRebarSupport_VertSection_UpperSlab(xyArrSup, FALSE, 0);
		CDPointArray xyArrMatch, xyArrMatchL, xyArrMatchR;
		CDPoint xy(0, 0);
		long nSize	= xyArrSup.GetSize();
		long i = 0; for(i = 0; i < nSize; i++)
		{
			xy	= xyArrSup.GetAt(i);
			rb.GetXyMatchTvArrAndLine(pRC->m_tvArrRebar, xyArrSup.GetAt(i), CDPoint(0, -1), xyArrMatch);
			

			if(xyArrMatch.GetSize() > 0)
			{
				rb.GetXyMatchTvArrAndLine(tvArrHunchL, xyArrSup.GetAt(i), CDPoint(0, -1), xyArrMatchL);
				rb.GetXyMatchTvArrAndLine(tvArrHunchR, xyArrSup.GetAt(i), CDPoint(0, -1), xyArrMatchR);

				xy	= xyArrMatch.GetAt(0);
				if(xyArrMatchL.GetSize() > 0)
					xyArrLeft.Add(CDPoint(xy.x, xy.y + REBAR_RADIUS));
				if(xyArrMatchR.GetSize() > 0)
					xyArrRight.Add(CDPoint(xy.x, xy.y + REBAR_RADIUS));
				/*
				if(nJ == 0 || nJ == m_nQtyJigan)
				{
					if(tvHunchL.GetHorLength() > 0 && Compare(tvHunchL.GetXyLeft().x, xy.x, "<=") && Compare(tvHunchL.GetXyRight().x, xy.x, ">=") && tvHunchL.GetXyBottom().y < xy.y)
						xyArrLeft.Add(CDPoint(xy.x, xy.y+REBAR_RADIUS));
					else if(tvHunchR.GetHorLength() > 0 && Compare(tvHunchR.GetXyLeft().x, xy.x, "<=") && Compare(tvHunchR.GetXyRight().x, xy.x, ">=") && tvHunchR.GetXyBottom().y < xy.y)
						xyArrRight.Add(CDPoint(xy.x, xy.y+REBAR_RADIUS));
				}
				else
				{
					if(pRC->m_tvArrRebar.GetAt(nIdx).GetVerLength() == 0) continue;
					if(~(xy - tvHunchL.GetXyRight()) < ~(xy - tvHunchR.GetXyLeft()))
					{
						if(tvHunchL.m_v1.z != 0 || (Compare(tvHunchL.GetXyLeft().x, xy.x, "<=") && Compare(tvHunchL.GetXyRight().x, xy.x, ">="))) 
						{
							xyArrLeft.Add(CDPoint(xy.x, xy.y+REBAR_RADIUS));
						}
					}
					else
					{
						if(tvHunchR.m_v1.z != 0 || (Compare(tvHunchR.GetXyLeft().x, xy.x, "<=") && Compare(tvHunchR.GetXyRight().x, xy.x, ">="))) 
						{
							xyArrRight.Add(CDPoint(xy.x, xy.y+REBAR_RADIUS));
						}
					}
				}
				*/
			}
		}
	}

	return nJ;
}

// 상부슬래브 헌치에 배근되는 배력철근 간격 리턴
// 일반적으로 상부슬래브 상면 배력철근의 세번째 간격을 따라간다.
double CRcBridgeRebar::GetCTCRebarSupport_UpperSlabHunch()
{
	CPlaceRebarByBlock *pPlace	= &m_placeByBlock_SupportRebar_UpperSlab[iUPPER][0];
	CDPointArray xyArr;
	xyArr	= pPlace->m_xyArr;
	// 헌치부 철근은 표준간격으로 들어간다. pPlace->GetCTC();는 갯수에 따라 1/2간격이 나오기도 하니까 쓰지 말자
	if(TRUE)// xyArr.GetSize() == 0)
	{
		return m_dCTC_SupportRebar[iUPPER];		// index에서 double로 변경(2005.04.25)
	}
	else
	{
		return pPlace->GetCTC();
	}
}

// 상부 슬래브 헌치의 스트럽 철근 좌표 리턴(있는 개수만큼 모두 구함- 겹치더라도) 
// 단, 각 스트럽 철근마다 이름을 붙여줘서 나중에 구분을 할 수 있게 함.
BOOL CRcBridgeRebar::GetTvRebarStirrup_SlabGrider(CTwinVectorArray &tvArr, long nJ, BOOL bStt, BOOL bLeft, BOOL bGagak, BOOL bJongGirder, BOOL bForDraw, BOOL bUpperSlabGirder, double dScaleDom)
{
	tvArr.RemoveAll();
	if(bJongGirder)
	{
		if(!IsGirderRebarJong(bStt, bLeft, bGagak)) return FALSE;
	}
	else
	{
		if(!IsGirderRebar(nJ, bUpperSlabGirder)) return FALSE;
	}
	
	CGirderSectionRebar *pGirderRB		= bJongGirder ? GetGirderRebarJong(bStt, bLeft, bGagak) : &m_SlabGirderRebar[bUpperSlabGirder? iUPPER : iLOWER][nJ];

	// 스트럽 철근은 상부슬래브 윗면과 해당 헌치 아래면을 기준으로 만든다.
	CTwinVector tvOutter;	// 상부슬래브 상면 or 하부슬래브 하면
	CTwinVector tvInner;	// 헌치 아래면 or 하부슬래브 상면
	GetTvVirtualRebarGirder(nJ, tvOutter, tvInner, bStt, bLeft, bGagak, bJongGirder, bUpperSlabGirder);
	
	CTwinVector tvUpper;
	CTwinVector tvLower;
	//상부슬래이브랑 하부슬래이브랑 Outter Inner 상면이 다르다.
	if(bUpperSlabGirder)
	{
		tvUpper = tvOutter;
		tvLower = tvInner;
	}
	else
	{
		tvUpper = tvInner;
		tvLower = tvOutter;
	}
	// 갯수만큼 스트럽 구함.
	CTwinVector tv;
	CString str			= _T("");
	CDPoint xy			= CDPoint(0, 0);	// x : stirrup철근 시작위치까지 거리, y : stirrup철근 길이
	CDPoint xyDir		= tvOutter.GetXyDir();
	CDPoint xyStt		= CDPoint(0, 0);
	long nCountStirrup	= pGirderRB->m_nCountStirrup;
	CRebarPlacing rb;
	long stirrup = 0; for(stirrup = 0; stirrup < nCountStirrup; stirrup++)
	{
		xy		= pGirderRB->m_xyDistStirrup[stirrup];
		CTwinVectorArray tvArrStirrup;
		if(bUpperSlabGirder)
		{
			// 상
			tv.m_v1	= tvUpper.m_v1 + (xyDir * xy.x / xyDir.x);
			tv.m_v2	= tv.m_v1 + (xyDir * xy.y / xyDir.x);
			tv.m_sInfo.Format("상%d", stirrup+1);
			tvArrStirrup.Add(tv);
			xyStt	= tv.m_v1;

			// 우
			tv.m_v1	= tv.m_v2;
			tv.m_v2	= CVector(tv.m_v1.x, tvLower.m_v1.y, 0);
			tv.m_sInfo.Format("우%d", stirrup+1);
			tvArrStirrup.Add(tv);

			// 하
			tv.m_v1		= tv.m_v2;
			tv.m_v2.x	= xyStt.x;
			tv.m_sInfo.Format("하%d", stirrup+1);
			tvArrStirrup.Add(tv);

			// 좌
			tv.m_v1		= tv.m_v2;
			tv.m_v2		= xyStt;
			tv.m_sInfo.Format("좌%d", stirrup+1);
			tvArrStirrup.Add(tv);

			if(bForDraw)
			{
				rb.GetOffsetTvArray(tvArrStirrup, -REBAR_RADIUS * dScaleDom / 50.);
			}
		}
		else
		{
			// 하
			tv.m_v1	= tvLower.m_v1 + (xyDir * xy.x / xyDir.x);
			tv.m_v2	= tv.m_v1 + (xyDir * xy.y / xyDir.x);
			tv.m_sInfo.Format("하%d", stirrup+1);
			tvArrStirrup.Add(tv);
			xyStt	= tv.m_v1;

			// 좌
			tv.m_v1	= tv.m_v2;
			tv.m_v2	= CVector(tv.m_v1.x, tvUpper.m_v1.y, 0);
			tv.m_sInfo.Format("좌%d", stirrup+1);
			tvArrStirrup.Add(tv);

			// 상
			tv.m_v1		= tv.m_v2;
			tv.m_v2.x	= xyStt.x;
			tv.m_sInfo.Format("상%d", stirrup+1);
			tvArrStirrup.Add(tv);

			// 우
			tv.m_v1		= tv.m_v2;
			tv.m_v2		= xyStt;
			tv.m_sInfo.Format("우%d", stirrup+1);
			tvArrStirrup.Add(tv);

			if(bForDraw)
			{
				rb.GetOffsetTvArray(tvArrStirrup, REBAR_RADIUS * dScaleDom / 50.);
			}
		}
	
		tvArr.AddFromTvArray(tvArrStirrup);
	}

	return TRUE;
}

// 스트럽 철근에 붙는 배력근(점) 좌표 찾기.
// 상, 하, 좌우 따로 찾아야 됨.
// long nType : iUPPER 상, iLOWER 하, 2 양측면, -1은 전부
void CRcBridgeRebar::GetxyRebarSupport_SlabGirder(CDPointArray &xyArr, CDPointArray &xyArrDirApplyScale, long nType, long nJ, BOOL bStt, BOOL bLeft, BOOL bGagak, BOOL bJongGirder, BOOL bUpperSlabGirder, BOOL bForDraw, double dScaleDom)
{
	xyArr.RemoveAll();
	xyArrDirApplyScale.RemoveAll();
	if(bJongGirder)
	{
		if(!IsGirderRebarJong(bStt, bLeft, bGagak)) return;
	}
	else
	{
		if(!IsGirderRebar(nJ, bUpperSlabGirder)) return;
	}

	CRebarPlacing rb;

	// 사용할 스트럽
	CGirderSectionRebar *pGirderRB	= bJongGirder ? GetGirderRebarJong(bStt, bLeft, bGagak) : &m_SlabGirderRebar[bUpperSlabGirder ? iUPPER : iLOWER][nJ];

	// 스트럽 좌표 가져옴.
	CTwinVectorArray tvArrStirrup;	// 스트럽철근좌표
	GetTvRebarStirrup_SlabGrider(tvArrStirrup, nJ, bStt, bLeft, bGagak, bJongGirder, FALSE, bUpperSlabGirder, dScaleDom);
	if(tvArrStirrup.GetSize() == 0) return;

	// 스트럽 좌표에서 주철근(점)을 모두 뽑아 낸다. 1단만 ////////////////////////////////////////////
	// 가로는 전체 스트럽 상하를 기준으로 한번만 구하면 됨 
	CTwinVector tvOutter;	// 스트럽 철근의 상면(BOX 형에서는 바깥면 Outter)
	CTwinVector tvInner;	// 스트럽 철근의 하면(BOX 형에서는 안쪽면 Inner)
	GetTvVirtualRebarGirder(nJ, tvOutter, tvInner, bStt, bLeft, bGagak, bJongGirder, bUpperSlabGirder);
	
	//상
	if(nType == iUPPER || nType == -1)
	{
		CTwinVector tvUpper = bUpperSlabGirder ? tvOutter : tvInner; 
		m_Util.GetXyDivideLine(xyArr, tvUpper, pGirderRB->m_dC1[iUPPER][0], pGirderRB->m_nB[iUPPER][0], pGirderRB->m_dC[iUPPER][0], pGirderRB->m_dC2[iUPPER][0]);
		long i = 0; for(i = 0; i < xyArr.GetSize(); i++)
			xyArrDirApplyScale.Add(CDPoint(0, 0));
	}
	//하
	if(nType == iLOWER || nType == -1)
	{
		CTwinVector tvLower = bUpperSlabGirder ? tvInner : tvOutter; 
		m_Util.GetXyDivideLine(xyArr, tvLower, pGirderRB->m_dC1[iLOWER][0], pGirderRB->m_nB[iLOWER][0], pGirderRB->m_dC[iLOWER][0], pGirderRB->m_dC2[iLOWER][0]);
		long i = 0; for(i = 0; i < xyArr.GetSize(); i++)
			xyArrDirApplyScale.Add(CDPoint(0, 0));
	}

	// 좌우는 좌우로 되어 있는 선에 대해서 모두 구함.
	if(nType == 2 || nType == -1)
	{
		long nSize		= tvArrStirrup.GetSize();
		long nSizeTmp	= 0;
		CTwinVector tv;
		CDPointArray xyArrTmp;
		long i = 0; for(i = 0; i < nSize; i++)
		{
			tv	= tvArrStirrup.GetAt(i);
			if(tv.m_sInfo.Find("좌") == -1 && tv.m_sInfo.Find("우") == -1) continue;
			
			// 좌표가 아래에서 위로 가도록 변경
			if(tv.m_sInfo.Find("우") != -1) 
			{
				GetSwap(tv.m_v1, tv.m_v2);
			}

			if(bUpperSlabGirder)
				m_Util.GetXyDivideLine(xyArrTmp, tv, pGirderRB->m_dF1, pGirderRB->m_nE, pGirderRB->m_dF, pGirderRB->m_dF2);
			else
				m_Util.GetXyDivideLine(xyArrTmp, tv, pGirderRB->m_dF2, pGirderRB->m_nE, pGirderRB->m_dF, pGirderRB->m_dF1);
			if(xyArrTmp.GetSize() > 0)
			{
				// 첫번째 점은 지워버림
				xyArrTmp.RemoveAt(0);

				// 기존 좌표에 합침
				nSizeTmp	= xyArrTmp.GetSize();
				long j = 0; for(j = 0; j < nSizeTmp; j++)
				{
					xyArr.Add(xyArrTmp.GetAt(j));
					xyArrDirApplyScale.Add(CDPoint(0,0)); // 주철근이 원래 좌표에 표현되므로 이동하여 표현할 필요가 없음.
				}
			}
		}
	}

	//////////////////////////////////////////// 스트럽 좌표에서 주철근(점)을 모두 뽑아 낸다. 1단만 //
}

// 스트럽 철근 2, 3단 철근(선) - 2, 3단 상하 모두 구함.
// 각 선마다 이름으로 구분
// 한번에 모두 구하는 이유 ? 이렇게 해야 나중에 마우스 이동시스템에 적용할 수 있다.
// 물론 하나씩 구할 수도 있다. ㅋㅋ
// long nUpper, long nDan : 구하는 부위 선택
// nUpper - -1 : 전부, iUPPER : 위, iLOWER : 아래
// nDan - -1 : 전부, 0 ~ 2 선택단.
void CRcBridgeRebar::GetTvRebarMain_SlabGirder(CTwinVectorArray &tvArr, long nJ, long nUpper, long nDan, BOOL bStt, BOOL bLeft, BOOL bGagak, BOOL bJongGirder, BOOL bUpperSlabGirder)
{
	tvArr.RemoveAll();
	if(bJongGirder)
	{
		if(!IsGirderRebarJong(bStt, bLeft, bGagak)) return;
	}
	else
	{
		if(!IsGirderRebar(nJ, bUpperSlabGirder)) return;
	}


	// 일단 스트럽 철근의 외부 좌표를 구해야 됨.
	CTwinVectorArray tvArrHunch;
	if(!GetTvRebarStirrup_SlabGrider(tvArrHunch, nJ, bStt, bLeft, bGagak, bJongGirder, FALSE, bUpperSlabGirder)) return;
	if(tvArrHunch.GetSize() == 0) return;

	CDRect rectStirrup	= tvArrHunch.GetRect();
	CTwinVector tvUpper;	// 스트럽 철근의 상면
	CTwinVector tvLower;	// 스트럽 철근의 하면
	tvLower.m_v1		= CVector(rectStirrup.left, rectStirrup.bottom, 0);
	tvLower.m_v2		= CVector(rectStirrup.right, rectStirrup.bottom, 0);
	tvUpper				= tvArrHunch.GetAt(0);
	GetXyMatchLineAndLine(tvUpper.m_v1, tvUpper.GetXyDir(), tvLower.m_v2, CDPoint(0, 1), tvUpper.m_v2);

	// 사용할 스트럽
	CGirderSectionRebar *pGirderRB		= &m_SlabGirderRebar[bUpperSlabGirder ? iUPPER : iLOWER][nJ];
	CTwinVector tv;
	BOOL bUpper			= TRUE;
	double dCover		= 0;
	long upper = 0; for(upper = 0; upper < 2; upper++)
	{
		bUpper			= (upper == iUPPER);
		long dan = 0; for(dan = 1; dan < MAX_REBAR_DAN; dan++)
		{
			dCover		= bUpper ? (pGirderRB->m_dCoverUpper[dan] - pGirderRB->m_dCoverUpper[0]) : (pGirderRB->m_dCoverLower[dan] - pGirderRB->m_dCoverLower[0]);

			// 원하는것만 걸러내기
			if(!(nUpper == -1 || ((nUpper == iUPPER) && bUpper) || ((nUpper == iLOWER) && !bUpper))) continue;
			if(!(nDan == -1 || (nDan == dan))) continue;

			// 지름과 거리가 있어야만 철근이 있는 것으로 인식
			if(Compare(dCover, 0.0, ">") && Compare((bUpper ? pGirderRB->m_dCoverUpper[dan] : pGirderRB->m_dCoverLower[dan]), 0.0, ">"))
			{
				if(bUpper)
				{
					tv.m_v1	= tvUpper.m_v1;
					tv.m_v2	= tvUpper.m_v2;

					// 피복만큼 아래위로 이동
					tv.m_v1.y	+= -dCover;
					tv.m_v2.y	+= -dCover;

					tv.m_sInfo.Format("상%d", dan+1);
				}
				else
				{
					tv.m_v1	= tvLower.m_v1;
					tv.m_v2	= tvLower.m_v2;

					// 피복만큼 아래위로 이동
					tv.m_v1.y	+= dCover;
					tv.m_v2.y	+= dCover;

					tv.m_sInfo.Format("하%d", dan+1);
				}

				tvArr.Add(tv);
			}
		}
	}
}

// 스트럽 철근 안쪽(2, 3단) 철근에 대한 배력근(점)을 구함
// 스트럽 철근 다른것들은 모두 한번에 다 구했으나, 이 점철근의 경우 상하, 각 단마다 지름을 입력
// 을 받아서 철근 집계를 위해서는 일일이 따로 구해줘야 된다. 아자. !!!!
// long nUpper, long nDan : 구하는 부위 선택
// nUpper - -1 : 전부, iUPPER : 위, iLOWER : 아래
// nDan - -1 : 전부, 0 ~ 2 선택단.
void CRcBridgeRebar::GetXyRebarSupport_SlabGirderInner(CDPointArray &xyArr, long nJ, long nUpper, long nDan, BOOL bStt, BOOL bLeft, BOOL bGagak, BOOL bJongGirder, BOOL bUpperSlabGirder)
{
	xyArr.RemoveAll();
	if(bJongGirder)
	{
		if(!IsGirderRebarJong(bStt, bLeft, bGagak)) return;
	}
	else
	{
		if(!IsGirderRebar(nJ, bUpperSlabGirder)) return;
	}

	CTwinVectorArray tvArrStirrupInner;	// 스트럽 안쪽 철근들(선)
	GetTvRebarMain_SlabGirder(tvArrStirrupInner, nJ, nUpper, nDan, bStt, bLeft, bGagak, bJongGirder);

	// 선철근하나하에 점철근 배치함.
	CTwinVector tvInner;
	CString sInfo	= _T("");
	CRebarPlacing rb;
	CGirderSectionRebar *pGirderRB	= bJongGirder ? GetGirderRebarJong(bStt, bLeft, bGagak) : &m_SlabGirderRebar[bUpperSlabGirder ? iUPPER : iLOWER][nJ];
	long i = 0; for(i = 0; i < tvArrStirrupInner.GetSize(); i++)
	{
		tvInner	= tvArrStirrupInner.GetAt(i);
		sInfo	= tvInner.m_sInfo;
		
		// 상하면, 단 정보 읽기
		long nCurUpdn	= (sInfo.Left(2) == "상") ? iUPPER : iLOWER;
		sInfo.Delete(0, 2);
		long nCurDan		= atol(LPCSTR(sInfo))-1;

		if(nCurDan > 0 && nCurDan < MAX_REBAR_DAN)
		{
			m_Util.GetXyDivideLine(xyArr, tvInner, pGirderRB->m_dC1[nCurUpdn][nCurDan], pGirderRB->m_nB[nCurUpdn][nCurDan], pGirderRB->m_dC[nCurUpdn][nCurDan], pGirderRB->m_dC2[nCurUpdn][nCurDan]);
		}
	}
}

// 날개벽 꼬리 경사 철근의 상부 교차점
CDPoint CRcBridgeRebar::GetXyRebarWingWallTailUpperCross(BOOL bStt, BOOL bLeft, int nOut)
{
	CWingWall* pWing = GetWingWall(bStt, bLeft);

	CTwinVectorArray tvArr;
	CTwinVector tv;
	GetTvWingWallFront(bStt, bLeft, nOut, tvArr);

	double dL1 = pWing->m_dL1;

	tvArr.GetTvByInfo(_T("날개벽정면끝단상부"), tv);
	if(dL1 == 0)
	{
		tvArr.GetTvByInfo(_T("날개벽정면끝단하부"), tv);
	}
	CDPoint xy1 = tv.m_v1;
	CDPoint xy2 = tv.m_v2;
	tvArr.GetTvByInfo(_T("날개벽정면노리"), tv);
	CDPoint xy3 = tv.m_v1;
	CDPoint xy4 = tv.m_v2;
	double dCoverWingEnd = GetCoverWingWallEnd(bStt, bLeft);
	double se = bStt ? -1.0 : 1.0;

	Offset(xy1, xy2, dCoverWingEnd*se);
	Offset(xy3, xy4, dCoverWingEnd*se);

	CDPoint xyResult(0, 0);
	GetXyMatchSegAndSeg(xy1, xy2, xy3, xy4, xyResult);

	// dL1이 0이면 날개벽 D구간이 없어지고 날개벽 정면 노리도 없다
	// 따라서 날개벽 정면끝단 하부의 상단점을 사용한다.
	if(dL1==0)
	{
		xyResult	= xy1;
	}

	return xyResult;
}

// 날개벽 꼬리 경사철근의 하부 교차점
CDPoint CRcBridgeRebar::GetXyRebarWingWallTailLowerCross(BOOL bStt, BOOL bLeft, int nOut)
{
	CWingWall* pWing = GetWingWall(bStt, bLeft);

	CTwinVectorArray tvArr;
	CTwinVector tv;
	GetTvWingWallFront(bStt, bLeft, nOut, tvArr);

	tvArr.GetTvByInfo(_T("날개벽정면노리"), tv);
	CDPoint xy1 = tv.m_v1;
	CDPoint xy2 = tv.m_v2;
	tvArr.GetTvByInfo(_T("날개벽정면끝단하부"), tv);
	CDPoint xy3 = tv.m_v1;
	CDPoint xy4 = tv.m_v2;

	if(pWing->m_bMatchBottom)
	{
		tvArr.GetTvByInfo(_T("날개벽꼬리하단"), tv);
		xy3 = tv.m_v1;
		xy4 = tv.m_v2;
	}

	// 두 점이 같으면 교차점을 못 찾으므로
	if(xy3 == xy4)
	{
		if(IsBoxType() && pWing->m_dH2 > 0)
			xy3.x -= 100;
		else
			xy3.y -= 100;
	}
	double dL1 = pWing->m_dL1;
	double dL2 = pWing->m_dL2;
	double dCoverWingEnd = GetCoverWingWallEnd(bStt, bLeft);
	double dCover = (pWing->m_bMatchBottom)? m_dCoverWingUpper : ((dL2==0) ? 0.0 : dCoverWingEnd);
	double se = bStt ? -1.0 : 1.0;

	Offset(xy1, xy2, dCoverWingEnd*se);
	Offset(xy3, xy4, dCover*se);

	CDPoint xyResult(0, 0);
	GetXyMatchSegAndSeg(xy1, xy2, xy3, xy4, xyResult);

	// dL1이 0이면 날개벽 D구간이 없어지고 날개벽 정면 노리도 없다
	// 따라서 날개벽 정면끝단 하부의 하단점을 사용한다.
	if(dL1==0)
	{
		xyResult = xy4;
	}

	return xyResult;
}

// 날개벽 상단 배근
// nOut = 0 : 내면, 1 : 외면
void CRcBridgeRebar::SetDataDefaultRebarWingWallUpper(BOOL bStt, BOOL bLeft, int nOut, int nDan)
{
	CWingWall* pWing = GetWingWall(bStt, bLeft);

	pWing->m_xyArrUpper[nOut][nDan].RemoveAll();

	BOOL bRangEnd	= pWing->m_bRAngEnd;
	BOOL bSide		= (pWing->m_nAttachPos == 0 )? FALSE : TRUE;
	double dAngle	= 0;

	CDPoint vAng  = GetAngleWingWallBetweenWall(bStt, bLeft);
	dAngle = (vAng.GetAngleDegree()>90)? 180-vAng.GetAngleDegree():vAng.GetAngleDegree();
	BOOL bSideAngAffect = ((vAng.GetAngleDegree() > 90 && nOut) || (vAng.GetAngleDegree() < 90 && !nOut));
	BOOL bTwoBase = (pWing->m_dL2!=0 && pWing->m_dL1!=0) ? TRUE : FALSE;

	double dW = bStt ? (m_dWS)/vAng.y : (m_dWE)/vAng.y;
	double dL1 = pWing->m_dL1;
	double dL2 = pWing->m_dL2;
	double dCoverWingEnd = GetCoverWingWallEnd(bStt, bLeft);
	double TensA = pWing->m_dStdVerCTC/2;
	double CompA = pWing->m_dStdVerCTC;
	double TensD = (pWing->m_bSelMainCTCD)? TensA*2 : TensA;
	double CompD = CompA;
	double ctcA = nOut==0 ? TensA : CompA; // A구간
	double ctcD = nOut==0 ? TensD : CompD; // D구간

	if(ctcA == 0 &&  ctcD == 0) return;

	double dT1 = pWing->m_dT1;
	double dT2 = pWing->m_dT2;
	double dSpareT = 0;
	if(bSide)
	{
		dAngle	= vAng.GetAngleDegree();
		double dAngJijum = GetAngleJijum(bStt? 0 : m_nQtyJigan).GetAngleDegree();
		double dAngA1 = (dAngle - dAngJijum)  * (bLeft? -1:1);
		if((bStt && bLeft) || (!bStt && bLeft))
		{
			dAngJijum = 180 - dAngJijum;
			dAngA1	= (dAngle - dAngJijum) * (bLeft ? 1 : -1);
		}
		
		if(pWing->m_bRAngEnd && nOut==0) dSpareT = (dT2)/tan(ToRadian(dAngA1));
		else dSpareT= 0.0;
//		dSpareT = (nOut==0 && pWing->m_bRAngEnd) ? max(dT1, dT2)/tan(ToRadian(dAngA1)) : 0.0;

		if(!bRangEnd) dAngle = dAngA1;
		bSideAngAffect = ((vAng.GetAngleDegree() > 90 && !nOut) || (vAng.GetAngleDegree() < 90 && nOut));
	}
	else
	{
		if(bRangEnd && nOut == 1) 
			dSpareT = dW; //시점(종점)벽체의 두께 - 벽체 피복
		else if(bRangEnd) 
			dSpareT = dW + (dT2 - m_dCoverWingIn[0] - m_dCoverWingOut[0] - REBAR_RADIUS*2)/vAng.y*vAng.x;
		else 
			dSpareT = (bSideAngAffect)? dW + fabs((min(dT1, dT2) - m_dCoverWingIn[0] - m_dCoverWingOut[0] - REBAR_RADIUS*2)/tan(ToRadian(dAngle))):dW;
	}

	if(bTwoBase)
	{
		double dLenEnd = 0;
		double dLen1 = dL1 - dCoverWingEnd + dCoverWingEnd; // -Cover,+Cover
		double dLen2 = dL2-dCoverWingEnd - dSpareT;
		if(nOut == 0 && !bRangEnd)
		{
			if(vAng.GetAngleDegree() > 90) dLenEnd = (dAngle==90)? 0.0 : (dT2-dT1)/tan(ToRadian(dAngle));
			else dLenEnd = (dAngle==90)? 0.0 : -(dT2-dT1)/tan(ToRadian(dAngle));

//			dLen1 += dLenEnd;
		}
		
		double dLenTemp = 0;
		long   nEa1	= (long)(dLen1/ctcD);
		long   nEa2	= (long)(dLen2/ctcA);
		long   nEaTemp = 0;	

		double ext1 = dLen1 - nEa1*ctcD;
		double ext2 = dLen2 - nEa2*ctcA;
		double extTemp = 0;
		double DivA = nOut==0 ? ctcA/TensA : ctcA/CompA;
		double DivD = nOut==0 ? ctcD/TensD : ctcD/CompD;


		//해당 되는 Dist1은 D구간에 들어 갈수 있도록한다 
		//아래의 dDistRemainD의 값은 D구간에 들어갈수 있는 값, A,B구간에는 들어가지 않도록해야
		//A구간의 상하부를 맞출수 있음 A,B구간이 시작하는 수직 철근 피복 값에 맞추도록함
		double dDiv =  1;
		if(nOut == 1)	dDiv = 1;
		else				dDiv = CompD /TensD == 2? 2 :1;
				
		double dDist1 = fabs((dT1 - m_dCoverWingIn[0] - m_dCoverWingOut[0] - REBAR_RADIUS*2)/tan(ToRadian(dAngle)));
		double dDistRemainD = 0;

		if(dDist1 > ctcD * dDiv)
			dDistRemainD = dDist1 - (ctcD * dDiv);
		else
			dDistRemainD = dDist1;
		/////////////////////////////////////////////////////


		if(!bRangEnd && bSideAngAffect)
		{
			nEa2 = (long)(dLen2 / ctcA);

			if(dDist1 > 0 && bTwoBase)
			{
				// (ARCBRIDGE-3519) 끝단 각도가 적용되는 면의 끝에 dDist1길이가 추가 되었다면 D구간 마지막 간격에서 dDist1를 빼서 B구간 피복에 맞춰준다.
				dDistRemainD = dDist1;
			}

			//D구간의 길이
			double dLenD = (dL1 - dDistRemainD);

			nEaTemp = (long)(dLenD/ctcD);
			extTemp = dLenD - nEaTemp*ctcD;

			if(extTemp >0 )
			{
				nEaTemp = (long)((dLenD - extTemp)/ctcD);
				dDist1 += extTemp;
			}

			if(dDist1 > 0)
			{
				// 남은 거리가 ctc간격보다 큰 경우에 추가로 철근을 넣어줌
				if(dDist1 > ctcD)
				{
					long nEaExt = (long)(dDist1 / ctcD);
					double dExtRemain = dDist1 - (nEaExt*ctcD);
					pWing->m_xyArrUpper[nOut][nDan].Add(CDPoint(1, dExtRemain));
					pWing->m_xyArrUpper[nOut][nDan].Add(CDPoint(nEaExt, ctcD));
				}
				else
					pWing->m_xyArrUpper[nOut][nDan].Add(CDPoint(1, dDist1));
			}
			if(nEaTemp > 0) 
				pWing->m_xyArrUpper[nOut][nDan].Add(CDPoint(nEaTemp, ctcD/DivD));
			if(dDistRemainD > 0)
			{
				if(dDistRemainD > ctcD)
				{
					long nEaExt = (long)(dDistRemainD / ctcD);
					double dExtRemain = dDistRemainD - (nEaExt*ctcD);
					pWing->m_xyArrUpper[nOut][nDan].Add(CDPoint(1, dExtRemain));
					pWing->m_xyArrUpper[nOut][nDan].Add(CDPoint(nEaExt, ctcD));
				}
				else
					pWing->m_xyArrUpper[nOut][nDan].Add(CDPoint(1, dDistRemainD));
			}
			if(nEa2 > 0) 
				pWing->m_xyArrUpper[nOut][nDan].Add(CDPoint(nEa2, ctcA/DivA));

		}
		else if(!bRangEnd && dAngle !=90)
		{
			//본체 구간의 길이 개수 
			nEa2 = (long)(dLen2 / ctcA);

			//D구간의 길이
			double dLenD = (dL1 - dDistRemainD);
			nEaTemp = (long)(dLenD/ctcD);

			extTemp = dLenD - nEaTemp*ctcD;
			if(extTemp>0 && extTemp<100)
			{
				nEaTemp--;
				extTemp += ctcD;
			}


			if(nEa2>0) 
				pWing->m_xyArrUpper[nOut][nDan].Add(CDPoint(nEa2*DivA, ctcA/DivA));
			if(dDistRemainD > 0)
			{
				if(dDistRemainD > ctcD)
				{
					long nEaExt = (long)(dDistRemainD / ctcD);
					double dExtRemain = dDistRemainD - (nEaExt*ctcD);
					pWing->m_xyArrUpper[nOut][nDan].InsertAt(0, CDPoint(nEaExt, ctcD));
					pWing->m_xyArrUpper[nOut][nDan].InsertAt(0, CDPoint(1, dExtRemain));
				}
				else
					pWing->m_xyArrUpper[nOut][nDan].InsertAt(0, CDPoint(1, dDistRemainD));
			}
			if(nEaTemp > 0) 
				pWing->m_xyArrUpper[nOut][nDan].InsertAt(0, CDPoint(nEaTemp, ctcD/DivD));
			if(extTemp > 0) 
				pWing->m_xyArrUpper[nOut][nDan].InsertAt(0, CDPoint(1, extTemp));			


		}
		else
		{
			if(ext1>0 && ext1<100)
			{
				nEa1--;
				ext1 += ctcD;
			}
			if(ext2>0 && ext2<100)
			{
				nEa2--;
			}
			
			if(ext1>0)
				pWing->m_xyArrUpper[nOut][nDan].Add(CDPoint(1, ext1));
			if(nEa1>0)
				pWing->m_xyArrUpper[nOut][nDan].Add(CDPoint(nEa1*DivD, ctcD/DivD));
			
			if(nEa2>0)
				pWing->m_xyArrUpper[nOut][nDan].Add(CDPoint(nEa2*DivA, ctcA/DivA));
		}
	}
	else
	{
		double dLen  = max(dL1, dL2)-dCoverWingEnd - dSpareT;
		
		//하부가 기준이므로 T2의 두께로 사용합니다 XXX
		// 철근 배치는 상부를 기준으로하기 때문에 T1을 적용하고 SetXyArrConvertRebarVirtualLow() 함수에서 하부 배치 간격을 맞춰준다.
		double dDist1 = (dAngle==90)? 0.0 : fabs((dT1 - m_dCoverWingIn[0] - m_dCoverWingOut[0] - REBAR_RADIUS*2)/tan(ToRadian(dAngle)));
		double dDist2 = (dAngle==90)? 0.0 : fabs((dT2 - m_dCoverWingIn[0] - m_dCoverWingOut[0] - REBAR_RADIUS*2)/tan(ToRadian(dAngle)));
		if(!bRangEnd && bSideAngAffect)
		{
			//double dDist1 = fabs((dT1 - m_dCoverWingIn[0] - m_dCoverWingOut[0] - REBAR_RADIUS*2)/tan(ToRadian(dAngle)));
			double dDiv = nOut==0? CompA/ TensA == 2? 2: 1 : 1;
			if(dDist1 > ctcA* dDiv)
			{
				dDist1 -=  ctcA* dDiv;
			}
			pWing->m_xyArrUpper[nOut][nDan].Add(CDPoint(1, dDist1));
			dLen -= dDist1;
		}
		// added by jaeho 2009.04.13
		// 측벽식 날개벽 내측 수직철근 간격 권고안 할대 정확한 거리를 구해야 함.
		else if(bSideAngAffect && nOut == 0)
		{
			double dCoverWingOut = m_dCoverWingOut[0];
			double dCoverWingIn = m_dCoverWingIn[0];

			double lr = bLeft ? -1.0 : 1.0;

			CTwinVectorArray tvArrGen;
			CTwinVector tvOut, tvEnd, tvHuNext, tvSlab;
			
			GetTvWingWallPlane(bStt, TRUE, TRUE, TRUE);
			tvArrGen = m_tvArrPlaneWingWall;

			CString strDir = bLeft ? _T("좌측") : _T("우측");
			tvArrGen.GetTvByInfo(strDir+_T("날개벽외측"), tvOut);
			tvArrGen.GetTvByInfo(strDir+_T("날개벽끝단"), tvEnd);
			tvArrGen.GetTvByInfo(strDir+_T("날개벽내부헌치후"), tvHuNext);
			tvArrGen.GetTvByInfo(_T("슬래브끝단외측"), tvSlab);
			
			Offset(tvOut.m_v1, tvOut.m_v2, -dCoverWingOut*lr);
			Offset(tvEnd.m_v1, tvEnd.m_v2, -dCoverWingEnd*lr);
			Offset(tvHuNext.m_v1, tvHuNext.m_v2, -dCoverWingIn*lr);

			CTwinVector tvSlabIn, tvWallSide;
			tvArrGen.GetTvByInfo(_T("슬래브끝단내측"), tvSlabIn);
//			tvWallSide.m_v1 = (bLeft)? tvSlab.m_v1 : tvSlab.m_v2;
//			tvWallSide.m_v2 = (bLeft)? tvSlabIn.m_v1 : tvSlabIn.m_v2;
			tvWallSide = tvSlabIn;

			if(bSide == FALSE)
			{
				CDPoint xyMatch(0, 0);
				if(GetXyMatchLineAndLine(tvWallSide.m_v1, tvWallSide.GetXyDir(), tvHuNext.m_v1, tvHuNext.GetXyDir(), xyMatch))
					dLen	= ~(xyMatch - tvHuNext.m_v1);
			}
			
		}	
// 		else if(!bRangEnd && nOut == 0 && bTwoBase == FALSE && vAng.GetAngleDegree() > 90)
// 		{
// 			double dDist2 = (dAngle==90)? 0.0 : fabs((dT2 - m_dCoverWingIn[0] - m_dCoverWingOut[0] - REBAR_RADIUS*2)/tan(ToRadian(dAngle)));
// 			pWing->m_xyArrUpper[nOut][nDan].Add(CDPoint(1, dDist2));		
// 		}


		long   nEa	= (long)(dLen/ctcD);
		double ext  = dLen - nEa*ctcD;
		double DivD = nOut==0 ? ctcD/TensD : ctcD/CompD;

		if(ext>0 && ext<100)
		{
			nEa--;
		}
		
		if(nEa>0)
		{
			pWing->m_xyArrUpper[nOut][nDan].Add(CDPoint(nEa*DivD, ctcD/DivD));
		}
	}
}

// 날개벽 하단 배근
void CRcBridgeRebar::SetDataDefaultRebarWingWallLower(BOOL bStt, BOOL bLeft, int nOut, int nDan)
{
	CWingWall* pWing = GetWingWall(bStt, bLeft);

	pWing->m_xyArrLower[nOut][nDan].RemoveAll();

	double L2 = pWing->m_dL2;
	if(L2==0) return;

	BOOL bRangEnd = pWing->m_bRAngEnd;
	BOOL bSide		= (pWing->m_nAttachPos == 0 )? FALSE : TRUE;
	CDPoint vAng = GetAngleWingWallBetweenWall(bStt, bLeft);
	double dAngle = (vAng.GetAngleDegree()>90)? 180-vAng.GetAngleDegree():vAng.GetAngleDegree();
	BOOL bSideAngAffect = ((vAng.GetAngleDegree() > 90 && nOut) || (vAng.GetAngleDegree() < 90 && !nOut));
	BOOL bTwoBase = (pWing->m_dL2!=0 && pWing->m_dL1!=0) ? TRUE : FALSE;

	double dAngWing = vAng.GetAngleDegree();
	double dW = bStt ? (m_dWS)/vAng.y : (m_dWE)/vAng.y;
	if(bSide &&  fabs(dW) > L2 * 3)
	{
		double dT1 = pWing->m_dT1;
		double dT2 = pWing->m_dT2;

		dAngle	= vAng.GetAngleDegree();
		double dAngJijum = GetAngleJijum(bStt? 0 : m_nQtyJigan).GetAngleDegree();
		double dAngA1 = (dAngle - dAngJijum)  * (bLeft? -1:1);
		if((bStt && bLeft) || (!bStt && bLeft))
		{
			dAngJijum = 180 - dAngJijum;
			dAngA1	= (dAngle - dAngJijum) * (bLeft ? 1 : -1);
		}

		if(pWing->m_bRAngEnd && nOut==0) dW = (dT2)/tan(ToRadian(dAngA1));
		else dW= 0.0;
	}

	double dCoverWingEnd = GetCoverWingWallEnd(bStt, bLeft);
	double TensA = pWing->m_dStdVerCTC/2;
	double CompA = pWing->m_dStdVerCTC;
	double ctcA = nOut==0 ? TensA : CompA; // A구간

	if(ctcA == 0) return;

	double dT1 = pWing->m_dT1;
	double dT2 = pWing->m_dT2;
	double dSpareT = 0; //(nOut==0 && pWing->m_bRAngEnd) ? max(dT1, dT2)/vAng.y*vAng.x : 0.0;
	if(bSide)
	{
		double dAngJijum = GetAngleJijum(bStt? 0 : m_nQtyJigan).GetAngleDegree();
		double dAngA1 = (dAngle - dAngJijum) * (bLeft? -1 : 1);
		if((bStt && bLeft) || (!bStt && !bLeft))
		{
			dAngJijum = 180 - dAngJijum;
			dAngA1	= (dAngle - dAngJijum) * (bLeft ? 1 : -1);
		}
		
		if(pWing->m_bRAngEnd && nOut==0) dSpareT = (dT2)/tan(ToRadian(dAngA1));
		else dSpareT= 0.0;

		if(!bRangEnd) dAngle = dAngA1;
		bSideAngAffect = ((vAng.GetAngleDegree() > 90 && !nOut) || (vAng.GetAngleDegree() < 90 && nOut));
	}
	else
	{
		if(bRangEnd && nOut == 1) 
			dSpareT = dW;
		else if(bRangEnd) 
			dSpareT = dW + (dT2 - m_dCoverWingIn[0] - m_dCoverWingOut[0] - REBAR_RADIUS*2)/vAng.y*vAng.x;
		else 
			dSpareT = (bSideAngAffect)? dW + fabs((min(dT1, dT2) - m_dCoverWingIn[0] - m_dCoverWingOut[0] - REBAR_RADIUS*2)/tan(ToRadian(dAngle))):dW;
	}

	double Len2 = 0;
	Len2 = L2-dCoverWingEnd - dSpareT;
	long nEaA = (long)(Len2/ctcA);
	double extA = Len2 - nEaA*ctcA;
	double DivA = nOut==0 ? ctcA/TensA : ctcA/CompA;

	if(bTwoBase)
	{
		if(!bRangEnd && bSideAngAffect)
		{
			double dDist1 = (dAngle==90)? 0.0 : fabs((dT1 - m_dCoverWingIn[0] - m_dCoverWingOut[0] - REBAR_RADIUS*2)/tan(ToRadian(dAngle)));

			if(dDist1 > ctcA)
			{
				long nEaExt = (long)(dDist1 / ctcA);
				double dExtRemain = dDist1 - (nEaExt*ctcA);
				pWing->m_xyArrLower[nOut][nDan].Add(CDPoint(1, dExtRemain));
				pWing->m_xyArrLower[nOut][nDan].Add(CDPoint(nEaExt, ctcA));
			}
			else
				pWing->m_xyArrLower[nOut][nDan].Add(CDPoint(1, dDist1));

			if(nEaA>0)
				pWing->m_xyArrLower[nOut][nDan].Add(CDPoint(nEaA, ctcA/DivA));
		}
		else if(!bRangEnd && dAngle !=90)
		{
			if(nEaA>0)
				pWing->m_xyArrLower[nOut][nDan].Add(CDPoint(nEaA*DivA, ctcA/DivA));
		}
		else
		{
			if(extA > 0 && extA < 100)
				nEaA--;

			if(nEaA>0)
				pWing->m_xyArrLower[nOut][nDan].Add(CDPoint(nEaA*DivA, ctcA/DivA));
		}
	}
	else
	{
		// added by jaeho 2009.04.13
		// 측벽식 날개벽 내측 수직철근 간격 권고안 할대 정확한 거리를 구해야 함.
		if(bSideAngAffect && nOut == 0)
		{
			double dCoverWingOut = m_dCoverWingOut[0];
			double dCoverWingIn = m_dCoverWingIn[0];
			
			double lr = bLeft ? -1.0 : 1.0;

			CTwinVectorArray tvArrGen;
			CTwinVector tvOut, tvEnd, tvHuNext, tvSlab;
			
			GetTvWingWallPlane(bStt, TRUE, TRUE, TRUE);
			tvArrGen = m_tvArrPlaneWingWall;
			
			CString strDir = bLeft ? _T("좌측") : _T("우측");
			tvArrGen.GetTvByInfo(strDir+_T("날개벽외측"), tvOut);
			tvArrGen.GetTvByInfo(strDir+_T("날개벽끝단"), tvEnd);
			tvArrGen.GetTvByInfo(strDir+_T("날개벽내부헌치후"), tvHuNext);
			tvArrGen.GetTvByInfo(_T("슬래브끝단외측"), tvSlab);
			
			Offset(tvOut.m_v1, tvOut.m_v2, -dCoverWingOut*lr);
			Offset(tvEnd.m_v1, tvEnd.m_v2, -dCoverWingEnd*lr);
			Offset(tvHuNext.m_v1, tvHuNext.m_v2, -dCoverWingIn*lr);
			
			CTwinVector tvSlabIn, tvWallSide;
			tvArrGen.GetTvByInfo(_T("슬래브끝단내측"), tvSlabIn);
			tvWallSide = tvSlabIn;
		}

		if(extA>0 && extA<100)
		{
			nEaA--;
		}

		if(nEaA>0)
			pWing->m_xyArrLower[nOut][nDan].Add(CDPoint(nEaA*DivA, ctcA/DivA));
	}
}

// 날개벽 측단 배근
void CRcBridgeRebar::SetDataDefaultRebarWingWallSide(BOOL bStt, BOOL bLeft, int nOut, int nDan)
{
	CWingWall* pWing = GetWingWall(bStt, bLeft);
	
	pWing->m_xyArrSide[nOut][nDan].RemoveAll();
	
	int se = bStt ? -1 : 1;
	int nLeft = bLeft ? -1*se : 1*se;	// 시점일 경우 교량 진행 방향의 좌우와 날개벽의 좌우가 반대임.
//	long nTypeJongdanForRebarOrg = m_nTypeJongdanForRebar;
//	m_nTypeJongdanForRebar = 2;

	//SyncBridge(nLeft, TRUE);
	GetTvVertSection_Std(nLeft, TRUE, FALSE, FALSE, 2);

	CTwinVectorArray tvArr;
	CTwinVector tv, tvUpper, tvLower, tvNori;
	GetTvWingWallFront(bStt, bLeft, nOut, tvArr);
	

	BOOL bEnableA2Dan = pWing->m_nCountLayerA[nOut] == 2;
	BOOL bEnableB2Dan = pWing->m_nCountLayerB[nOut] == 2;

	double dL2 = pWing->m_dL2;
	double dCoverWingUpper = m_dCoverWingUpper;
	double dMinSpace = 100;
	double dDiv = nOut==0 ? 2 : 1;
	double dCTCA = pWing->m_dMainCTCA/dDiv;
	double dCTCB = pWing->m_dMainCTCB/dDiv;
	BOOL bUpperRebarSlope = pWing->m_bUpperRebarSlope;

	if(dCTCA == 0 && dCTCB == 0) return;

	tvArr.GetTvByInfo(_T("날개벽정면상단"), tvUpper);
	tvArr.GetTvByInfo(_T("날개벽정면끝단하부"), tvLower);
	tvArr.GetTvByInfo(_T("날개벽정면노리"), tvNori);

	BOOL bLowReverseType = tvLower.m_v1.y < tvLower.m_v2.y? TRUE : FALSE;
	
	double dThickPRF = 0;
	if(IsBoxType() && m_bExistProtectionRiseFooting)
	{
		dThickPRF = (m_dPRF_H1 + m_dPRF_H2);
	}
	
	if(IsBoxType() && tvNori.GetVerLength() < 1 && tvNori.GetHorLength() >0 && dL2 == 0)
	{
		tvLower.m_v1 = tvNori.m_v2;
		tvLower.m_v2 = tvNori.m_v1;	

		double dHL		= pWing->m_dHL;
		double dL1		= pWing->m_dL1;
		double dSW		= pWing->m_dSW;
		double dHeight	= GetHeightWingWall(bStt);
		double dElEnd	= pWing->GetEndEl(FALSE);
		CDPoint xyStt		= GetXySectionWingWallStt(bStt, TRUE);
		CDPoint xyEnd	= GetXySectionWingWallStt(bStt, FALSE);
		
		
		double dWingH		= (xyStt.y-dElEnd);
		double dHeightEnd = dHeight - dWingH;
		double dHL1			= dL1 / dSW;
		double dMidH		= dHeightEnd - dHL - dHL1;

		if(dMidH > dCTCB || dThickPRF > 0)
		{
			tvLower.m_v1.y -= dMidH;
			tvLower.m_v2.y -= dMidH;
 			bLowReverseType = FALSE;
		}		
	}
	

	double dHgtMin = min(tvUpper.m_v2.y-tvLower.m_v2.y, tvUpper.m_v1.y-tvLower.m_v2.y) - dCoverWingUpper*2;
	double dHgtMax = max(tvUpper.m_v2.y-tvLower.m_v2.y, tvUpper.m_v1.y-tvLower.m_v2.y) - dCoverWingUpper*2;
	double dHgtB = GetLengthWingWallBlockBC(bStt, bLeft) - dCoverWingUpper;
	// 날개벽 끝단이 B구간보다 낮을 경우 경사 철근을 A구간으로 배치한다.
	if(min(tvUpper.m_v2.y, tvUpper.m_v1.y) < tvLower.m_v2.y+dHgtB)
	{
		dHgtB = min(tvUpper.m_v2.y, tvUpper.m_v1.y) - tvLower.m_v2.y - dCoverWingUpper*2;
	}
	

	if(dL2==0)
	{
		dHgtMin += dCoverWingUpper;
		dHgtMax += dCoverWingUpper;
		

		CTwinVectorArray tvArrPRF;
		if(IsBoxType())
		{
			CString sPoint = bStt? _T("시점") : _T("종점");		
			m_tvArrBriSect.GetTvArrByInfo(_T("부상방지저판"), tvArrPRF,FALSE, FALSE);

			for (long nIdx =0; nIdx < tvArrPRF.GetSize(); nIdx++)
			{
				CTwinVector tvPRF = tvArrPRF.GetAt(nIdx);
				if(tvPRF.m_sInfo.Find(sPoint)  == -1 || tvPRF.m_sInfo.Find(_T("상면")) == -1)
				{
					tvArrPRF.RemoveAt(nIdx);
					nIdx--;
					continue;
				}
			}
		}
	

		if(bLowReverseType == FALSE)
		{
			if(tvArrPRF.GetSize() > 0 && dThickPRF > 0)
			{
				CDPoint xyEL_PRF = bStt? tvArrPRF.GetXyLeft() : tvArrPRF.GetXyRight();
				if(Compare(tvLower.m_v2.y , xyEL_PRF.y, _T("=>"), 1))
				{
					dThickPRF = 0;
					dThickPRF = REBAR_RADIUS;
				}
			}

			dHgtMin -= dThickPRF;
			dHgtMax -= dThickPRF;
		}
		
		CDPoint xyCross = GetXyRebarWingWallTailLowerCross(bStt, bLeft, 1);
		double dHgtSpare(0);
		if(pWing->m_bMatchBottom)
		{
			dHgtSpare = xyCross.y-tvLower.m_v2.y;
		}
		else
		{
			int nEaSpare = 0;
			if(IsBoxType() && dThickPRF > 0)
			{
				double dGapLower = xyCross.y - tvLower.GetXyBottom().y;
				if(Compare(dGapLower, dThickPRF, _T(">"),dCoverWingUpper))
				{
					nEaSpare = (int)RoundUp((xyCross.y-tvLower.m_v2.y)/(pWing->m_dMainCTCA/2), 0);
					dHgtSpare = nEaSpare < 0?  dCoverWingUpper : xyCross.y-tvLower.m_v2.y - dThickPRF;
				}
				else
				{
					nEaSpare = (int)RoundUp((xyCross.y-tvLower.m_v2.y-dThickPRF)/(pWing->m_dMainCTCA/2), 0);
					dHgtSpare = nEaSpare < 0?  dCoverWingUpper : xyCross.y-tvLower.m_v2.y ;
				}

				if(Compare(dThickPRF , REBAR_RADIUS, _T("="),1))
					dHgtSpare += REBAR_RADIUS;
			}
			else
			{
				if(Compare(xyCross.y , tvLower.m_v2.y+pWing->m_dMainCTCA, _T(">"),0.1) && Compare(tvLower.GetVerLength(), 0.0, _T("="), 1) && tvLower.GetHorLength() > pWing->m_dMainCTCA)
				{
					dHgtSpare = xyCross.y-tvLower.m_v2.y;					
				}
				else
				{
					nEaSpare = (int)RoundUp((xyCross.y-tvLower.m_v2.y)/(pWing->m_dMainCTCA/2), 0);
					dHgtSpare = nEaSpare*pWing->m_dMainCTCA/2;
				}				
			}			
		}

		int nEaD = (int)(bUpperRebarSlope ? (dHgtMin-dHgtSpare)/dCTCA : (dHgtMax-dHgtSpare)/dCTCA);
		int nEaSlope = (int)((dHgtMax-nEaD*dCTCA-dHgtSpare)/dCTCA);
		double dExt = dHgtMax - (nEaD+nEaSlope)*dCTCA - dHgtSpare;
		if(nEaSlope>0)
		{
			if(dExt<dMinSpace)
				nEaSlope--;
		}
		else
		{
			if(dExt<dMinSpace)
				nEaD--;
		}

		if(Compare(dHgtSpare, 0.0, _T(">"), 1.0))
			pWing->m_xyArrSide[nOut][nDan].Add(CDPoint(1, dHgtSpare));
		pWing->m_xyArrSide[nOut][nDan].Add(CDPoint(nEaD, dCTCA));
		if(nEaSlope>0)
			pWing->m_xyArrSide[nOut][nDan].Add(CDPoint(nEaSlope, dCTCA));
		dExt = dHgtMax - (nEaD+nEaSlope)*dCTCA - dHgtSpare;
		if(!Compare(dExt, 0.0, _T("="), 1.0))
			pWing->m_xyArrSide[nOut][nDan].Add(CDPoint(1, dExt));
	}
	else
	{
		int nEaB = (int)(dHgtB/pWing->m_dMainCTCB * 2);
		if(nEaB%2==1)
			nEaB--;
		if(nOut==1)
			nEaB /= 2;
		int nEaA = (int)(bUpperRebarSlope ? (dHgtMin-nEaB*dCTCB)/dCTCA : (dHgtMax-nEaB*dCTCB)/dCTCA);
		int nEaSlope = (int)((dHgtMax-nEaA*dCTCA-nEaB*dCTCB)/dCTCA);
		double dExt = dHgtMax - (nEaA+nEaSlope)*dCTCA - nEaB*dCTCB;
		if(nEaSlope>0)
		{
			if(dExt<dMinSpace)
				nEaSlope--;

			if(nEaSlope == 0) //경사 한개는 있도록. 
			{
				nEaA--;
				nEaSlope = 1;
			}
		}
		else
		{
			if(dExt<dMinSpace)
				nEaA--;
		}

		//2단인경우 2단설정에 따라서 추가하는 범위가 달라짐
		if(nDan == 0)
		{
			if(Compare(dCoverWingUpper, 0.0, _T(">"), 1.0))
				pWing->m_xyArrSide[nOut][nDan].Add(CDPoint(1, dCoverWingUpper));
			if(dCTCA==dCTCB)
			{
				pWing->m_xyArrSide[nOut][nDan].Add(CDPoint(nEaA+nEaB, dCTCA));
			}
			else
			{
				pWing->m_xyArrSide[nOut][nDan].Add(CDPoint(nEaB, dCTCB));
				pWing->m_xyArrSide[nOut][nDan].Add(CDPoint(nEaA, dCTCA));
			}
			if(nEaSlope>0)
				pWing->m_xyArrSide[nOut][nDan].Add(CDPoint(nEaSlope, dCTCA));
			dExt = dHgtMax - (nEaA+nEaSlope)*dCTCA - nEaB*dCTCB;

			if(!Compare(dExt, 0.0, _T("="), 1.0))
				pWing->m_xyArrSide[nOut][nDan].Add(CDPoint(1, dExt));
		}
		else
		{
			if(Compare(dCoverWingUpper, 0.0, _T(">"), 1.0))
				pWing->m_xyArrSide[nOut][nDan].Add(CDPoint(1, dCoverWingUpper));

			//A구간 B구간 다 2단인경우
			if(bEnableA2Dan && bEnableB2Dan)
			{
				if(dCTCA == dCTCB)
					pWing->m_xyArrSide[nOut][nDan].Add(CDPoint(nEaA+nEaB, dCTCA));
				else
				{
					pWing->m_xyArrSide[nOut][nDan].Add(CDPoint(nEaB, dCTCB));
					pWing->m_xyArrSide[nOut][nDan].Add(CDPoint(nEaA, dCTCA));
				}
			}
			//B구간만 2단인경우
			if(!bEnableA2Dan && bEnableB2Dan)
			{
				pWing->m_xyArrSide[nOut][nDan].Add(CDPoint(nEaB, dCTCB));
				nEaA = 0;
				nEaSlope = 0;
			}
			//A구간만 2단인경우
			if(bEnableA2Dan && !bEnableB2Dan)
			{
				pWing->m_xyArrSide[nOut][nDan].Add(CDPoint(1, nEaB * dCTCB));
				pWing->m_xyArrSide[nOut][nDan].Add(CDPoint(nEaA, dCTCA));
			}

			if(nEaSlope>0 && bEnableA2Dan)
				pWing->m_xyArrSide[nOut][nDan].Add(CDPoint(nEaSlope, dCTCA));
			dExt = dHgtMax - (nEaA+nEaSlope)*dCTCA - nEaB*dCTCB;

			if(!Compare(dExt, 0.0, _T("="), 1.0))
				pWing->m_xyArrSide[nOut][nDan].Add(CDPoint(1, dExt));
		}
	}

	GetTvVertSection_Std(nLeft, TRUE, FALSE, TRUE);	
	//m_nTypeJongdanForRebar = nTypeJongdanForRebarOrg;
}

void CRcBridgeRebar::SetRebarWingWallSideExt(BOOL bStt, BOOL bLeft, int nOut, int nDan)
{
	CWingWall* pWing = GetWingWall(bStt, bLeft);
	
	int se = bStt ? -1 : 1;
	int nLeft = bLeft ? -1*se : 1*se;
	//long nTypeJongdanForRebarOrg = m_nTypeJongdanForRebar;
	//m_nTypeJongdanForRebar = 2;
	
	//SyncBridge(nLeft, TRUE);
	GetTvVertSection_Std(nLeft, TRUE, FALSE, FALSE, 2);

	CDPointArray xyArr = pWing->m_xyArrSide[nOut][nDan];
	if(xyArr.GetSize() == 0) 
	{
		GetTvVertSection_Std(nLeft, TRUE, FALSE, TRUE);
		return;
	}

	CTwinVectorArray tvArr;
	CTwinVector tvUpper, tvLower;
	GetTvWingWallFront(bStt, bLeft, nOut, tvArr);
	
	double dCoverWingUpper = m_dCoverWingUpper;
	
	tvArr.GetTvByInfo(_T("날개벽정면상단"), tvUpper);
	tvArr.GetTvByInfo(_T("날개벽정면끝단하부"), tvLower);
	
	double dHgtMax = max(tvUpper.m_v2.y-tvLower.m_v2.y, tvUpper.m_v1.y-tvLower.m_v2.y) - dCoverWingUpper;

	CDPoint xyR(0, 0);
	double dDimSum = 0;
	long nSize = xyArr.GetSize();
	long i=0; for(i=0; i<nSize; i++)
	{
		xyR = xyArr.GetAt(i);
		dDimSum += xyR.x * xyR.y;
	}
	
	double dDimExt = dHgtMax - dDimSum;
	xyR.x = 1;
	xyR.y = dDimExt;
	pWing->m_xyArrSide[nOut][nDan].Add(xyR);

	GetTvVertSection_Std(nLeft, TRUE, FALSE, TRUE);
	//m_nTypeJongdanForRebar = nTypeJongdanForRebarOrg;

	return;
}

void CRcBridgeRebar::SetConvertWingWallHorRebarDim(BOOL bStt, BOOL bLeft, int nOut, int nDan, BOOL bUpper)
{
	CWingWall* pWing = GetWingWall(bStt, bLeft);
	CDPointArray xyArrOrg = (bUpper)? pWing->m_xyArrUpper[nOut][nDan]:pWing->m_xyArrLower[nOut][nDan];
	CDPointArray xyArrConv;
	
	long nSize = xyArrOrg.GetSize();
	long i=0; for(i=1; i<nSize; i++)
	{
		CDPoint xyR = xyArrOrg.GetAt(i);
		xyArrConv.InsertAt(0, xyR);
	}

	if(bUpper)
	{
		pWing->m_xyArrUpper[nOut][nDan].RemoveAll();
		pWing->m_xyArrUpper[nOut][nDan] = xyArrConv;
	}
	else
	{
		pWing->m_xyArrLower[nOut][nDan].RemoveAll();
		pWing->m_xyArrLower[nOut][nDan] = xyArrConv;
	}
}

// 날개벽 수평 철근 구간의 높이
double CRcBridgeRebar::GetHeightWingWallHorRebar(BOOL bStt, BOOL bLeft, int nOut, int nDan)
{
	CWingWall* pWing = GetWingWall(bStt, bLeft);

	//배면도 전면과 높이가 같다.
	if(nDan == 1) nDan = 0;
	CDPointArray xyArr = pWing->m_xyArrSide[nOut][nDan];
	int nSize = xyArr.GetSize();
	int nSlopeBlock = pWing->m_nCountSlopeBlock[nOut];
	CDPoint xyR(0, 0);

	// 전체 치수 높이
	double dHgtDim = 0;
	int i=0; for(i=0; i<nSize; i++)
	{
		xyR = xyArr.GetAt(i);
		dHgtDim += xyR.x*xyR.y;
	}

	// 수평 철근 구간 높이
	double dHgtHor = dHgtDim;

	if(pWing->m_bUpperRebarSlope)
	{
		int nCount = 0;
		for(i=nSize-1; i>=0; i--)
		{
			if(nCount==nSlopeBlock) break;
			xyR = xyArr.GetAt(i);
			dHgtHor -= xyR.x*xyR.y;
			nCount++;
		}
	}
	else if(nSize > 0)
	{
		xyR = xyArr.GetAt(nSize-1);
		dHgtHor -= xyR.x*xyR.y;
	}

	return dHgtHor;
}

// 날개벽 C구간 주철근 절곡부 반경
double CRcBridgeRebar::GetWingWallVertRebarCurveRadius(BOOL bStt, BOOL bLeft, int nOut, int nDan)
{
	CARcBridgeDataStd* pStd = m_pARcBridgeDataStd;
	CWingWall* pWing = GetWingWall(bStt, bLeft);

	double dL2 = pWing->m_dL2;
	if(dL2==0) return 0;
	if(IsBoxType() && !m_bExistProtectionRiseFooting) return 0;

	int nCurve = pWing->m_nRebarCurve;
	double dDia = pWing->m_dDiaMainC[nOut][nDan];
	double dR = pStd->GetValueBendReBar((int)dDia, JOINT_BEBD_RADIUS);
	if(nCurve==0)
	{
		if(dDia<=19)
			return 0;
		else
			return dR;
	}
	else if(nCurve==1)
		return 0;
	else
		return dR;
}

// 날개벽 정면도 A구간 주철근(수평 철근) 좌표
void CRcBridgeRebar::GetTvArrayRebarWingWallBlockAMainFront(CTwinVectorArray &tvArr, BOOL bStt, BOOL bLeft, int nOut, int nDan)
{
	CARcBridgeDataStd *pStd = m_pARcBridgeDataStd;
	tvArr.RemoveAll();

	CWingWall* pWing = GetWingWall(bStt, bLeft);

	double dL1 = pWing->m_dL1;
	double dL2 = pWing->m_dL2;

	if(dL2==0) return;

	CTwinVectorArray tvArrGen;
	CTwinVector tv, tvUpper, tvLower, tvUpperRebar, tvVarBound, tvVar, tvVar1, tvVar2;

	GetTvWingWallFront(bStt, bLeft, nOut, tvArrGen);
	CDPointArray xyArr = pWing->m_xyArrSide[nOut][nDan];
	int nSize = xyArr.GetSize();

	BOOL bSide		= (pWing->m_nAttachPos == 0 )? FALSE : TRUE;
	CDPoint vAng = GetAngleWingWallBetweenWall(bStt, bLeft);
	double dCoverWall = (!bSide)? m_dCoverWallIn[0]/vAng.y : 0.0;
	double dCoverWingEnd = GetCoverWingWallEnd(bStt, bLeft);
	double dCoverWingUpper = m_dCoverWingUpper;
	double se = bStt ? -1.0 : 1.0;
	double dCoverWing = nOut==0 ? m_dCoverWingIn[0] : m_dCoverWingOut[0];
	BOOL bSelMainCTCD = pWing->m_bSelMainCTCD;
	BOOL bMergedAD = IsMergedRebarWingWall(bStt, bLeft, nOut, nDan, 'A', 'D');	// D구간 주철근과 병합되는지..
	BOOL bUpperRebarSlope = pWing->m_bUpperRebarSlope;	// 상면 주철근을 경사로 배치

	double dHgtB = GetLengthWingWallBlockBC(bStt, bLeft);	// B구간의 높이
	double dT1 = pWing->m_dT1;
	double dT2 = pWing->m_dT2;
	double dSpareT = 0;
	double dSettleA(0);
	if(m_pARcBridgeDataStd->IsLsdDesign() && bSide)
	{
		SRebarEnvOption LsdRebarOpt;
		SetRebarLsdOptionWingWall(&LsdRebarOpt, bStt, bLeft, nOut==0, WINGWALL_SECTA, TRUE);
		dSettleA = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueSettle(pWing->m_dDiaMainA[nOut][nDan], &LsdRebarOpt);
	}
	else
	{
		dSettleA = (bSide)? pStd->GetValueSettle(pWing->m_dDiaMainA[nOut][nDan], SETTLE_TENS_NORMAL, toCm(m_dCoverWallOut[0]), toCm((nOut==1)? pWing->m_dMainCTCA:pWing->m_dMainCTCA/2)) : 0.0;
	}
	
	if(bSide)
	{
		double dAngle	= vAng.GetAngleDegree();
		double dAngJijum = GetAngleJijum(bStt? 0 : m_nQtyJigan).GetAngleDegree();
		double dAngA1 = (dAngle - dAngJijum) * (bLeft? -1 : 1);
		if((bStt && bLeft) || (!bStt && !bLeft))
		{
			dAngJijum = 180 - dAngJijum;
			dAngA1	= (dAngle - dAngJijum) * (bLeft ? 1 : -1);
		}		

		if(pWing->m_bRAngEnd && nOut==0) dSpareT = (dT2)/tan(ToRadian(dAngA1));
		else dSpareT= 0.0;

		double d	= dAngA1-(90-dAngA1);
		if(Compare(d, 0.0, "=") || Compare(fabs(d), 180.0, "=") || Compare(fabs(d), 360.0, "="))
			d	= 90;
		double dFactor	= fabs(ToDPointFrDegree(d).y);

		dSettleA += m_dCoverWallOut[0]/dFactor;
	}
	else dSpareT =(nOut==0 && pWing->m_bRAngEnd) ? max(dT1, dT2)/vAng.y*vAng.x : 0.0;
	
	double dLenA = dL2 - dCoverWall - dCoverWingEnd - dSpareT + dSettleA;	// A구간의 길이

	CDPoint xyR(0, 0), xyResult(0, 0), vY(0, 1);
	
	// 전체 치수 높이
	int i=0; for(i=0; i<nSize; i++)
	{
		xyR = xyArr.GetAt(i);
	}
	double dHgtHor = GetHeightWingWallHorRebar(bStt, bLeft, nOut, nDan);

	// 좌표 계산(tv.m_v1 : 날개벽 시작단)
	tvArrGen.GetTvByInfo(_T("날개벽정면상단"), tvUpper);
	tvArrGen.GetTvByInfo(_T("날개벽정면끝단하부"), tvLower);
	tvArrGen.GetTvByInfo(_T("세로변단면헌치1"), tvVar1);
	tvArrGen.GetTvByInfo(_T("세로변단면헌치2"), tvVar2);
	CDPoint vAngUpper = tvUpper.GetXyDir();
	CDPoint xyMaxUpper = vAngUpper.y>0 ? tvUpper.m_v2 : tvUpper.m_v1;
	CDPoint xyTailUpperCross = GetXyRebarWingWallTailUpperCross(bStt, bLeft, nOut);
	CDPoint xyTailLowerCross = GetXyRebarWingWallTailLowerCross(bStt, bLeft, nOut);
 	double dTailLowerCross = xyTailLowerCross.y - tvLower.m_v2.y;
	if(!bUpperRebarSlope)
		dHgtHor = min(tvUpper.m_v2.y, tvUpper.m_v1.y) - tvLower.m_v2.y - dCoverWingUpper;

	// 가로 방향 변단면일 경우 필요
	double dSH = pWing->m_dSH;
	double dLT = pWing->m_dLT;
	BOOL bCrossVar = pWing->m_nDirHunch==2 && nOut==0;
	CDPoint vVar = (CDPoint(1, 0)+CDPoint(-dSH, 1).Unit()).Unit();
	double dDistVar = dCoverWing/vVar.y*vVar.x;
	CDPoint xyVar = CDPoint(tvUpper.m_v2.x-(dLT+(dT2-dT1)*dSH+dDistVar)*se, 0);

	int nCount = 0;
	int nCountJoint = 0;
	BOOL bFirst = TRUE;
	BOOL bCross = FALSE;
	BOOL bOutRange1 = FALSE, bOutRange2 = TRUE;
	double dHgtSum = 0;
	if(bSide)
	{
		tv.m_v1 = CDPoint(tvUpper.m_v1.x-(dSettleA)*se, tvLower.m_v2.y);
		tv.m_v2 = CDPoint(tv.m_v1.x+dLenA*se, tv.m_v1.y);
	}
	else
	{
		tv.m_v1 = CDPoint(tvUpper.m_v1.x+dCoverWall*se, tvLower.m_v2.y);
		tv.m_v2 = CDPoint(tv.m_v1.x+dLenA*se, tv.m_v1.y);
	}

	tvUpperRebar = GetTvRebarWingWallUpper(bStt, bLeft, nOut);
	CDPoint xyUpperBound1 = bStt ? tvUpperRebar.m_v1 : tvUpperRebar.m_v2;
	CDPoint xyUpperBound2 = bStt ? tvUpperRebar.m_v2 : tvUpperRebar.m_v1;

	for(i=0; i<nSize; i++)
	{
		xyR = xyArr.GetAt(i);
		int j=0; for(j=0; j<xyR.x; j++)
		{
			dHgtSum += xyR.y;
			tv.m_v1.y += xyR.y;
			tv.m_v2.y += xyR.y;
			if(bMergedAD)		// D구간과 합쳐질 경우 A구간은 건너뜀
			{
				nCount++;
				if(nOut==0 && bSelMainCTCD)
				{
					if(nCount%2==1 && dHgtSum>dTailLowerCross) continue;
				}
				else if(dHgtSum>dTailLowerCross) continue;
			}
			if(dHgtSum<= min(dHgtB, dHgtHor)) continue;
			if(i==nSize-1 && j==xyR.x-1) break;				// 최상단 철근은 항상 그려져야 하기에...

			// x좌표만 옮겨서 철근 길이를 조정할경우 경철근을 잘못 그리게됨 뒤에서 MatchLine으로 끊어내므로 삭제
			// tv.m_v2.x = nCountJoint%2==0 ? tvUpper.m_v1.x+(dCoverWall+dLenA)*se : tvUpper.m_v1.x+(dCoverWall+dLenA+dJoint/2)*se;
			tv.m_sInfo = _T("수평A");
			if(bUpperRebarSlope)
			{
				if(dHgtSum>dHgtHor)
				{
					if(bFirst)
					{
						GetXyMatchLineAndLine(CDPoint(xyMaxUpper.x, tv.m_v1.y), vAngUpper, tv.m_v1, vY, tv.m_v1);
						GetXyMatchLineAndLine(CDPoint(xyMaxUpper.x, tv.m_v2.y), vAngUpper, tv.m_v2, vY, tv.m_v2);
						bFirst = FALSE;
					}
					tv.m_sInfo = _T("상단경사A");
				}
			}
			else
			{
				bCross = GetXyMatchSegAndSeg(tv.m_v1, tv.m_v2, xyUpperBound1, xyUpperBound2, xyResult);
				bOutRange1 = GetDirPointByLine(tv.m_v1, xyUpperBound1, xyUpperBound2);
				bOutRange2 = GetDirPointByLine(tv.m_v2, xyUpperBound1, xyUpperBound2);
				if(tvUpperRebar.GetXyDir().y>0)
				{
					if(!bOutRange1 && bCross)
						tv.m_v1 = xyResult;
				}
				else
				{
					if(!bOutRange2 && bCross)
						tv.m_v2 = xyResult;
				}
				if(!bOutRange1 && !bOutRange2) continue;
				tv.m_sInfo = _T("상단경사A");
			}

			if(!bMergedAD && bCrossVar && tv.m_v2.y>xyTailLowerCross.y)
			{
				tv.m_sInfo = tv.m_sInfo==_T("상단경사A") ? _T("상단변단면경사A") : _T("수평변단면A");
				if(GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), xyVar, vY, xyResult))
					tv.m_v2 = xyResult;
			}
			if(dL1 > 0)
			{
				if(GetXyMatchSegAndSeg(tv.m_v1, tv.m_v2, xyTailUpperCross, xyTailLowerCross, xyResult))
					tv.m_v2 = xyResult;
				else if(GetXyMatchSegAndSeg(tv.m_v1, tv.m_v2, xyTailLowerCross, CDPoint(xyTailLowerCross.x, tvLower.m_v2.y), xyResult))
				//else if(GetXyMatchSegAndLine(xyTailLowerCross-CDPoint(-dCoverWingEnd*se, 0), CDPoint(xyTailLowerCross.x-dCoverWingEnd*se, tvLower.m_v2.y), tv.m_v1, tv.GetVDir(), xyResult))
					tv.m_v2 = xyResult;
			}
			else
			{
				CDPoint xyTem = tv.GetXyDir();
				if(GetXyMatchSegAndLine(tvUpper.m_v2-CDPoint(dCoverWingEnd*se, 0), CDPoint(tvUpper.m_v2.x-dCoverWingEnd*se, tvLower.m_v2.y), tv.m_v1, tv.GetXyDir(), xyResult))
					tv.m_v2 = xyResult;
			}
			
			if(dL1==0 && tv.m_v1.y>tvVar2.m_v1.y && tv.m_v1.y<tvVar1.m_v1.y)
				tv.m_sInfo = _T("수평변단면구간A");
			tvArr.Add(tv);
			if(dL1>0)
				nCountJoint++;
		}
	}
	if(!bMergedAD)
	{
		GetXyMatchSegAndLine(tvUpperRebar.m_v1, tvUpperRebar.m_v2,
		CDPoint(tvLower.m_v1.x-dCoverWingEnd*se, 0), vY, tvUpperRebar.m_v2);
		double dHorLen = Round(tvUpperRebar.GetHorLength(), 0);
		double dLen = Round(tvUpperRebar.GetLength(), 0);
		tvUpperRebar.m_sInfo = dHorLen==dLen ? _T("수평A") : _T("상단경사A");
		if(bCrossVar)
		{
			if(GetXyMatchLineAndLine(tvUpperRebar.m_v1, tvUpperRebar.GetXyDir(), xyVar, vY, xyResult))
				tvUpperRebar.m_v2 = xyResult;
			dHorLen = Round(tvUpperRebar.GetHorLength(), 0);
			dLen = Round(tvUpperRebar.GetLength(), 0);
			tvUpperRebar.m_sInfo = dHorLen==dLen ? _T("수평변단면A") : _T("상단변단면경사A");
		}
		tvArr.Add(tvUpperRebar);		// 최상단 철근
	}
}

// 날개벽 정면도 A구간 배력철근(수직 철근) 좌표
void CRcBridgeRebar::GetTvArrayRebarWingWallBlockASupportFront(CTwinVectorArray &tvArr, BOOL bStt, BOOL bLeft, int nOut, int nDan)
{
	tvArr.RemoveAll();

	CWingWall* pWing = GetWingWall(bStt, bLeft);

	double dL1 = pWing->m_dL1;
	double dL2 = pWing->m_dL2;

	if(dL2==0) return;

	BOOL bSide		= (pWing->m_nAttachPos == 0 )? FALSE : TRUE;
	BOOL bVar = IsWingWallVariableSect(bStt, bLeft);
	BOOL bMergedAC = IsMergedRebarWingWall(bStt, bLeft, nOut, nDan, 'A', 'C');	// C구간 주철근과 병합되는지..
	BOOL bDrawJoint = IsMergedRebarWingWall(bStt, bLeft, nOut, nDan, 'A', 'C', FALSE);
	if(((nOut==0 && !bVar) || nOut==1) && bMergedAC) return;		// C구간 주철근과 병합되면 건너뜀

	CTwinVectorArray tvArrGen, tvArrPlane;
	CTwinVector tvVer, tvVar, tvHun, tvJoint, tvTemp, tvUpper, tvLower, tvUpperRebar, tvEnd;
	GetTvWingWallFront(bStt, bLeft, nOut, tvArrGen);

	CDPointArray xyArr = pWing->m_xyArrUpper[nOut][nDan];
	CDPoint vAng = GetAngleWingWallBetweenWall(bStt, bLeft);
	double dCoverWingEnd = GetCoverWingWallEnd(bStt, bLeft);
	double dCoverWingIn = m_dCoverWingIn[0];
	double se = bStt ? 1.0 : -1.0;
	double dAngWing = vAng.GetAngleDegree();

	tvArrGen.GetTvByInfo(_T("날개벽정면상단"), tvUpper);
	tvArrGen.GetTvByInfo(_T("날개벽정면끝단하부"), tvLower);
	double dHeightMin = min(tvUpper.m_v2.y-tvLower.m_v2.y, tvUpper.m_v1.y-tvLower.m_v2.y);

	double dCoverWingEndAng = dCoverWingEnd/vAng.y;
	if(bSide && fabs(dCoverWingEndAng) > dL2 * 3 && Compare(dAngWing, (double)180, _T("="),1.2))
		dCoverWingEndAng = dCoverWingEnd;

	double dLenSum = dCoverWingEndAng;
	double dHgtB = GetLengthWingWallBlockBC(bStt, bLeft);	// B구간의 높이
	double dT1 = pWing->m_dT1;
	double dT2 = pWing->m_dT2;

	// B구간 높이가 날개벽 높이보다 커서 A구간이 없을때는 Return시켜준다.
	if(dHeightMin < dHgtB) return;

	if(bSide)
	{
//		double dAngle	= vAng.GetAngleDegree();
		double dAngJijum = GetAngleJijum(bStt? 0 : m_nQtyJigan).GetAngleDegree();
		if((bStt && bLeft) || (!bStt && !bLeft))
		{
			dAngJijum = 180 - dAngJijum;
		}
		
		dLenSum = dCoverWingEnd;
	}

	double dDiaA = pWing->m_dDiaSupportA[0][nDan];
	double dDia = max(dDiaA, pWing->m_dDiaMainC[nOut][nDan]);
	double dCTC = nOut==0 ? pWing->m_dStdVerCTC/2 : pWing->m_dStdVerCTC;
	double dSettle = m_pARcBridgeDataStd->GetValueSettle(dDiaA, SETTLE_TENS_NORMAL, toCm(dCoverWingIn), toCm(dCTC));
	double dCoverWing = nOut==0 ? dCoverWingIn : m_dCoverWingOut[0];
	double dJoint(0);
	if(m_pARcBridgeDataStd->IsLsdDesign())
	{
		SRebarEnvOption LsdRebarOpt;
		SetRebarLsdOptionWingWall(&LsdRebarOpt, bStt, bLeft, nOut==0, WINGWALL_SECTA, FALSE);
		dJoint = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueJoint(dDia, &LsdRebarOpt);
	}
	else
	{
		dJoint = m_pARcBridgeDataStd->GetValueJoint(dDia, JOINT_TENS_NORMAL_B, toCm(dCoverWing), toCm(dCTC));
	}

	// A, C 구간이 Merge되지않고 A구간이 철근이음길이 보다 짧을때 이음을 모두 아래로 내린다.
	BOOL bIsShort = (dHeightMin-dHgtB < dJoint/2)? TRUE : FALSE;
	CDPoint xyVar[3];
	GetXyRebarWingWallVarySect(xyVar, bStt, bLeft);

	// 좌표 계산(tv.m_v1 : A구간 하단)
	tvUpperRebar = GetTvRebarWingWallUpper(bStt, bLeft, nOut);

	int nSize = xyArr.GetSize();
	tvVer.m_sInfo = _T("수직A");
	tvVar.m_sInfo = _T("변단면수직A");
	tvHun.m_sInfo = _T("*변단면헌치A");
	tvJoint.m_sInfo = _T("*수직이음");
	tvVer.m_v1.x = tvUpper.m_v2.x + dCoverWingEnd*se;
	if(nOut==0 && bVar)
	{
		tvVer.m_v1.y = dT1<dT2 ? xyVar[1].y - dSettle : xyVar[0].y;
		tvVar.m_v1.y = tvLower.m_v2.y + dHgtB;
		tvVar.m_v2.y = dT1<dT2 ? xyVar[0].y : xyVar[1].y + dSettle;
	}
	else
		tvVer.m_v1.y = tvLower.m_v2.y + dHgtB;
	
	int nCount = 0;
	CDPoint xyR(0, 0);
	int i=0; for(i= (dL1==0)? -1:0; i<nSize; i++)
	{
		if(i<0) xyR = CDPoint(1, 0);
		else xyR = xyArr.GetAt(i);
		int j=0; for(j=0; j<xyR.x; j++)
		{
			dLenSum += xyR.y;
			tvVer.m_v1.x += xyR.y*se;
			GetXyMatchSegAndLine(tvUpperRebar.m_v1, tvUpperRebar.m_v2, tvVer.m_v1, CDPoint(0, 1), tvVer.m_v2);
			if(Compare(dLenSum, (dL1 + dCoverWingEndAng), _T("<"), 0.1)) continue;

			if(nOut==0 && bVar) tvVer.m_v1.y = dT1<dT2 ? xyVar[1].y - dSettle : xyVar[0].y;
			else
			{
				if(bIsShort) tvVer.m_v1.y = tvLower.m_v2.y+dHgtB-dJoint;
				else tvVer.m_v1.y = nCount%2==0 ? tvLower.m_v2.y+dHgtB : tvLower.m_v2.y+dHgtB-dJoint/2;
			}

			tvArr.Add(tvVer);
			if(nOut==0 && bVar/* && !bMergedAC*/)
			{
				CDPoint xyResult(0, 0);
				tvVar.m_v1.x = tvVar.m_v2.x = tvVer.m_v1.x;
				if(bIsShort) tvVar.m_v1.y = tvLower.m_v2.y+dHgtB-dJoint;
				else tvVar.m_v1.y = (nCount%2==0)? tvLower.m_v2.y+dHgtB : tvLower.m_v2.y+dHgtB-dJoint/2;
				if(!bMergedAC) tvArr.Add(tvVar);

				tvHun.m_v1 = tvVar.m_v2;
				tvHun.m_v2 = CDPoint(tvHun.m_v1.x, tvHun.m_v1.y+xyVar[2].y-xyVar[0].y);
				if(GetXyMatchSegAndSeg(tvUpperRebar.m_v1, tvUpperRebar.m_v2, tvHun.m_v1, tvHun.m_v2, xyResult))
					tvHun.m_v2 = xyResult;
				tvArr.Add(tvHun);
			}

			if(!bMergedAC && bDrawJoint)
			{
				if(nOut==0 && bVar)
				{
					tvVar.m_v1.x = tvVar.m_v2.x = tvVer.m_v1.x;
					if(bIsShort) 
					{
						tvVar.m_v1.y = tvLower.m_v2.y+dHgtB-dJoint*2 + dJoint/2;
					}
					else
					{
						tvVar.m_v1.y = (nCount%2==0)? tvLower.m_v2.y+dHgtB : tvLower.m_v2.y+dHgtB-dJoint/2;
					}
					tvJoint.m_v1 = tvVar.m_v1 + CDPoint(30*se, 0);
				}
				else
				{
					tvJoint.m_v1 = tvVer.m_v1 + CDPoint(30*se, 0);
				}
					
				tvJoint.m_v2 = tvJoint.m_v1 + CDPoint(0, dJoint);
				
				tvArr.Add(tvJoint);
			}
			nCount++;
		}
	}
}

// 날개벽 정면도 B구간 주철근(수평 철근) 좌표
void CRcBridgeRebar::GetTvArrayRebarWingWallBlockBMainFront(CTwinVectorArray &tvArr, BOOL bStt, BOOL bLeft, int nOut, int nDan)
{
	CARcBridgeDataStd *pStd = m_pARcBridgeDataStd;
	tvArr.RemoveAll();

	CWingWall* pWing = GetWingWall(bStt, bLeft);

	double dL2 = pWing->m_dL2;
	if(dL2==0) return;

	CTwinVectorArray tvArrGen;
	CTwinVector tv, tvTemp, tvUpper, tvLower, tvVar;

	GetTvWingWallFront(bStt, bLeft, nOut, tvArrGen);
	CDPointArray xyArr = pWing->m_xyArrSide[nOut][nDan];

	BOOL bSide		= (pWing->m_nAttachPos == 0 )? FALSE : TRUE;
	CDPoint vAng = GetAngleWingWallBetweenWall(bStt, bLeft);
	double dCoverWall = (!bSide)? m_dCoverWallIn[0]/vAng.y : 0.0;
	double dCoverWingEnd = GetCoverWingWallEnd(bStt, bLeft);
	double dCoverWingUpper = m_dCoverWingUpper;
	double se = bStt ? -1.0 : 1.0;
	BOOL bSelMainCTCD = pWing->m_bSelMainCTCD;
	BOOL bMergedBD = IsMergedRebarWingWall(bStt, bLeft, nOut, nDan, 'B', 'D');	// B구간 주철근과 병합되는지..

	tvArrGen.GetTvByInfo(_T("날개벽정면상단"), tvUpper);
	tvArrGen.GetTvByInfo(_T("날개벽정면끝단하부"), tvLower);

	double dHgtB = GetLengthWingWallBlockBC(bStt, bLeft);	// B구간의 높이
	double dT1 = pWing->m_dT1;
	double dT2 = pWing->m_dT2;
	double dSpareT = 0;
	double dSettleB(0);
	if(m_pARcBridgeDataStd->IsLsdDesign() && bSide)
	{
		SRebarEnvOption LsdRebarOpt;
		SetRebarLsdOptionWingWall(&LsdRebarOpt, bStt, bLeft, nOut==0, WINGWALL_SECTB, TRUE);
		dSettleB = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueSettle(pWing->m_dDiaMainB[nOut][nDan], &LsdRebarOpt);
	}
	else
	{
		dSettleB = (bSide)? pStd->GetValueSettle(pWing->m_dDiaMainB[nOut][nDan], SETTLE_TENS_NORMAL, toCm(m_dCoverWallOut[0]), toCm((nOut==1)? pWing->m_dMainCTCB:pWing->m_dMainCTCB/2)) : 0.0;
	}

	if(bSide)
	{
		double dAngle	= vAng.GetAngleDegree();
		double dAngJijum = GetAngleJijum(bStt? 0 : m_nQtyJigan).GetAngleDegree();
		double dAngA1 = (dAngle - dAngJijum) * (bLeft? -1 : 1);
		if((bStt && bLeft) || (!bStt && !bLeft))
		{
			dAngJijum = 180 - dAngJijum;
			dAngA1	= (dAngle - dAngJijum) * (bLeft ? 1 : -1);
		}
		
//		if(pWing->m_bRAngEnd && nOut==0) dSpareT = fabs((dT2 - m_dCoverWingIn[0] - m_dCoverWingOut[0] - REBAR_RADIUS*2)/tan(ToRadian(dAngA1))));

		//{ 31447 //해당 날개벽 평면에서의 실제 수평철근 길이들
		CTwinVectorArray tvArrPlan;
		double dWingBackLen = GetWingWallBackAndSideAttach(tvArrPlan, nOut, nDan, bLeft);		

		CTwinVectorArray tvArrSide;
		GetWingWallbackAndSideAttachRebar(tvArrSide, nOut, nDan, bStt , TRUE, bLeft);
		double  dSettleDistWing = GetSettleRebarHoriRevision(tvArrSide,dWingBackLen, nOut, bStt, bLeft);


		if(pWing->m_bRAngEnd && nOut==0) dSpareT = (dT2)/tan(ToRadian(dAngA1));
		else dSpareT= 0.0;

		double d	= dAngA1-(90-dAngA1);

		if(Compare(d, 0.0, "=") || Compare(fabs(d), 180.0, "=") || Compare(fabs(d), 360.0, "="))
			d	= 90;
		double dFactor	= fabs(ToDPointFrDegree(d).y);

		//ARCBRIDGE-2463 주석처리 부분이 맞지 않아서 아래로 바꿈
		if(dSettleDistWing == 0)
			dSettleB += m_dCoverWallOut[0]/dFactor;
		else
			dSettleB = dSettleDistWing;
	}
	else dSpareT =(nOut==0 && pWing->m_bRAngEnd) ? max(dT1, dT2)/vAng.y*vAng.x : 0.0;

	double dLenA = dL2 - dCoverWall - dCoverWingEnd - dSpareT + dSettleB; // A구간의 길이

	// 좌표 계산(tv.m_v1 : 날개벽 시작단)
	CDPoint xyR(0, 0), vY(0, 1);
	CDPoint xyUpper1 = CDPoint(tvUpper.m_v1.x, tvUpper.m_v1.y-dCoverWingUpper);
	CDPoint xyUpper2 = CDPoint(tvUpper.m_v2.x, tvUpper.m_v2.y-dCoverWingUpper);
	CDPoint xyUpperCross = GetXyRebarWingWallTailUpperCross(bStt, bLeft, nOut);
	CDPoint xyLowerCross = GetXyRebarWingWallTailLowerCross(bStt, bLeft, nOut);

	double dUpperCross = xyUpperCross.y - tvLower.m_v2.y;
	double dLowerCross = xyLowerCross.y - tvLower.m_v2.y;

	// B구간에 수평철근 경사배치 구간이 있을경우...
	double dHgtHor = GetHeightWingWallHorRebar(bStt, bLeft, nOut, nDan);
	CDPoint vAngUpper = tvUpper.GetXyDir();
	// 가로 방향 변단면일 경우 필요
	double dCoverWing = m_dCoverWingIn[0];
	double dDia = pWing->m_dDiaMainB[nOut][nDan];
	double dCTC = nOut==0 ? pWing->m_dMainCTCB/2 : pWing->m_dMainCTCB;
	double dSettle(0);
	if(m_pARcBridgeDataStd->IsLsdDesign() && bSide)
	{
		SRebarEnvOption LsdRebarOpt;
		SetRebarLsdOptionWingWall(&LsdRebarOpt, bStt, bLeft, nOut==0, WINGWALL_SECTB, TRUE);
		dSettle = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueSettle(dDia, &LsdRebarOpt);
	}else
	{
		dSettle = m_pARcBridgeDataStd->GetValueSettle(dDia, SETTLE_TENS_NORMAL, toCm(dCoverWing), toCm(dCTC));
	}
	
	double dSH = pWing->m_dSH;
	double dLT = pWing->m_dLT;
	BOOL bCrossVar = pWing->m_nDirHunch==2 && nOut==0;
	CDPoint vVar = (CDPoint(1, 0)+CDPoint(-dSH, 1).Unit()).Unit();
	double dDistVar = dCoverWing/vVar.y*vVar.x;
	CDPoint xyVar1 = CDPoint(tvUpper.m_v2.x-(dLT+(dT2-dT1)*dSH+dDistVar)*se, 0);
	CDPoint xyVar2 = CDPoint(tvUpper.m_v2.x-(dLT+dDistVar)*se, 0);
	CDPoint xyLowerCrossVar1(0, 0), xyLowerCrossVar2(0, 0);
	GetXyMatchSegAndLine(xyUpperCross, xyLowerCross, xyVar1, vY, xyLowerCrossVar1);
	GetXyMatchSegAndLine(xyUpperCross, xyLowerCross, xyVar2, vY, xyLowerCrossVar2);
	xyVar2.x -= dSettle*se;

	int nCount = 0;
	double dHgtSum = 0;
	int nSize = xyArr.GetSize();
	if(bSide)
	{
		tv.m_v1.x = tvUpper.m_v1.x - (dSettleB)*se;
		tv.m_v1.y = tvLower.m_v2.y;
	}
	else
	{
		tv.m_v1.x = tvUpper.m_v1.x + dCoverWall*se;
		tv.m_v1.y = tvLower.m_v2.y;
	}
	
	int i=0; for(i=0; i<nSize; i++)
	{
		xyR = xyArr.GetAt(i);
		int j=0; for(j=0; j<xyR.x; j++)
		{
			dHgtSum += xyR.y;
			if(dHgtSum>dHgtB || dHgtSum>dHgtHor)
				break;

			BOOL bHalfRebar = FALSE;

			tv.m_v1.y += xyR.y;
			tv.m_v2.y = tv.m_v1.y;

			// (ARCBRIDGE-2479)  날개벽 D구간 하부 처리
			nCount++;
			if(bMergedBD && dHgtSum > dLowerCross)
			{
				if(nOut==0 && bSelMainCTCD && nCount%2==0) bHalfRebar = TRUE;
				else continue;
			}

			//D구간의 하단이 슬래브와 거의 붙어 있을 경우에는 변화구간이 나올수 없다(D구간과 겹침)
			double dGapLowerToCrossX = fabs(tvLower.GetXyTop().x - xyLowerCross.x);
			double dGapLowerToCrossY = fabs(tvLower.GetXyTop().y - xyLowerCross.y);
			BOOL bSmallGapCorssToLower = Compare(dGapLowerToCrossX, m_dCoverSide_Footing[0], _T("<="),1) && Compare(dGapLowerToCrossY, m_dCoverSide_Footing[0], _T("<="),1)? TRUE : FALSE;
			bSmallGapCorssToLower = !bMergedBD && bSmallGapCorssToLower;
			
			if(Compare(dHgtSum, dLowerCross, _T(">="), 0.5) && bSmallGapCorssToLower == FALSE)
			{
				if(dHgtSum<=dUpperCross)
					GetXyMatchSegAndLine(xyUpperCross, xyLowerCross, tv.m_v1, CDPoint(1, 0), tv.m_v2);
				else
					GetXyMatchLineAndLine(xyUpperCross, CDPoint(0, 1), tv.m_v1, CDPoint(1, 0), tv.m_v2);

				if(bHalfRebar) tv.m_v2.x = xyLowerCross.x;
				tv.m_sInfo = _T("수평변화B");
				
				if(bCrossVar && tv.m_v2.y>xyLowerCrossVar1.y)
				{
					tvVar = tv;
					GetXyMatchSegAndLine(tvVar.m_v1, tvVar.m_v2, xyVar2, vY, tvVar.m_v1);
					if(tv.m_v2.y>xyLowerCrossVar2.y)
						tvVar.m_sInfo = _T("수평변단면변화B");
					else
						tvVar.m_sInfo = _T("*");
					tvArr.Add(tvVar);
					GetXyMatchSegAndLine(tv.m_v1, tv.m_v2, xyVar1, vY, tv.m_v2);
					tv.m_sInfo = _T("수평변단면B");
				}
			}
			else
			{
				tv.m_v2.x = tv.m_v1.x + dLenA*se;
				tv.m_sInfo = _T("수평B");
			}
			
			tvArr.Add(tv);
		}
	}
}

// 날개벽 정면도 C구간 주철근(수직 철근) 좌표
void CRcBridgeRebar::GetTvArrayRebarWingWallBlockCMainFront(CTwinVectorArray &tvArrCurve, CTwinVectorArray &tvArr, BOOL bStt, BOOL bLeft, int nOut, int nDan)
{
	tvArrCurve.RemoveAll();
	tvArr.RemoveAll();

	CWingWall* pWing = GetWingWall(bStt, bLeft);
	if(!pWing) return;
	if(!IsWingWall(bStt, bLeft)) return;

	double dL2 = pWing->m_dL2;
	if(dL2==0) return;

	CTwinVectorArray tvArrGen;
	CTwinVector tv1, tv2, tvUpper, tvLower;
	
	GetTvWingWallFront(bStt, bLeft, nOut, tvArrGen);
	CDPointArray xyArr = pWing->m_xyArrLower[nOut][nDan];
	CDPointArray xyArrSide;
	GetDimArrayRebarWingWallSttSide(xyArrSide, bStt, bLeft, nOut, nDan);

	CDPoint vAng = GetAngleWingWallBetweenWall(bStt, bLeft);
	double dCoverWingEnd = GetCoverWingWallEnd(bStt, bLeft);
	double dCoverWingUpper = m_dCoverWingUpper;
	double dCoverWingLower = (xyArrSide.GetSize()>0)? xyArrSide.GetAt(0).y:0;
	double dCoverWingIn = m_dCoverWingIn[0];
	double dCoverWing = nOut==0 ? dCoverWingIn : m_dCoverWingOut[0];
	double dCoverFoot = GetCoverFooting(bStt, FALSE, 0);//m_dCoverLower_Footing[0];  재호가 수정
	double dLenFoot = GetLengthFootingWingWall(bStt, bLeft, FALSE, FALSE, nOut);
	double dDiaC = pWing->m_dDiaMainC[nOut][nDan];
	double dDia = max(pWing->m_dDiaSupportA[nOut][nDan], dDiaC);
	double dCTC = nOut==0 ? pWing->m_dStdVerCTC/2 : pWing->m_dStdVerCTC;
	double dJoint(0), dSettle(0);
	if(m_pARcBridgeDataStd->IsLsdDesign())
	{
		SRebarEnvOption LsdRebarOpt;
		SetRebarLsdOptionWingWall(&LsdRebarOpt, bStt, bLeft, nOut==0, WINGWALL_SECTC, TRUE);
		dJoint = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueJoint(dDia, &LsdRebarOpt);
		dSettle = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueSettle(dDia, &LsdRebarOpt);
	}
	else
	{
		dJoint = m_pARcBridgeDataStd->GetValueJoint(dDia, JOINT_TENS_NORMAL_B, toCm(dCoverWing), toCm(dCTC));
		dSettle = m_pARcBridgeDataStd->GetValueSettle(dDiaC, SETTLE_TENS_NORMAL, toCm(dCoverWingIn), toCm(dCTC));
	}

	double dFH = bStt ? (m_footingStt.m_dFH + m_footingStt.m_dFSRH) : (m_footingEnd.m_dFH + m_footingEnd.m_dFSLH);
	double dR = GetWingWallVertRebarCurveRadius(bStt, bLeft, nOut, nDan);
	double se = bStt ? 1.0 : -1.0;
	BOOL bMergedAC = IsMergedRebarWingWall(bStt, bLeft, nOut, nDan, 'A', 'C');	// A구간 주철근과 병합되는지..

	tvArrGen.GetTvByInfo(_T("날개벽정면상단"), tvUpper);
	tvArrGen.GetTvByInfo(_T("날개벽정면끝단하부"), tvLower);

	CTwinVector tvPRFTop, tvPRFBottom;
	if(m_nTypeBridge == BRIDGE_TYPE_BOX && m_bExistProtectionRiseFooting)
	{
		double dWall = bStt ? m_dWS/vAng.y : m_dWE/vAng.y; //날개벽각도먹은 두께
		dLenFoot = dWall + m_dPRF_W;
		dFH = m_dPRF_H1;

		CTwinVectorArray tvArrPRF;
		CDPoint xyPosTop, xyPosBottom;
		CString strPRFTop = bStt ? _T("시점부상방지저판상면") : _T("종점부상방지저판상면");
		CString strPRFBottom = bStt ? _T("시점부상방지저판하단") : _T("종점부상방지저판하단");

		GetTvPRF_VertSection(tvArrPRF, bStt, bLeft, m_bSlopeLowerSlab);
		tvArrPRF.GetTvByInfo(strPRFTop, tvPRFTop);
		tvArrPRF.GetTvByInfo(strPRFBottom, tvPRFBottom);

		GetXyMatchSegAndLine(tvPRFTop.m_v1, tvPRFTop.m_v2, tvLower.m_v1, CDPoint(0,1), xyPosTop); 
		GetXyMatchSegAndLine(tvPRFBottom.m_v1, tvPRFBottom.m_v2, tvLower.m_v1, CDPoint(0,1), xyPosBottom);

		Offset(tvPRFBottom.m_v1, tvPRFBottom.m_v2, dCoverWingLower * se);
		
		//날개벽이(L1)이 부상방지판 상면에 있을경우 FH = 바닥 ~ 만나는점,
		if(IsWingWallOnPRF(bStt, bLeft))
		{
			double dHeightPRF = xyPosTop.y - xyPosBottom.y;
			dFH = dHeightPRF;
		}
	}

	double dHgtB = GetLengthWingWallBlockBC(bStt, bLeft);	// B구간의 높이
	double dT1 = pWing->m_dT1;
	double dT2 = pWing->m_dT2;

	BOOL bVar = IsWingWallVariableSect(bStt, bLeft);
	CDPoint xyVar[3];
	GetXyRebarWingWallVarySect(xyVar, bStt, bLeft);

	// 좌표 계산(tv.m_v1 : 기초 하단)
	CDPoint xyR(0, 0);
	CDPoint xyUpper1 = CDPoint(tvUpper.m_v1.x, tvUpper.m_v1.y-dCoverWingUpper);
	CDPoint xyUpper2 = CDPoint(tvUpper.m_v2.x, tvUpper.m_v2.y-dCoverWingUpper);

	int nCount = 0;
	int nSize = xyArr.GetSize();
	tv1.m_v1.x = tvLower.m_v2.x + dCoverWingEnd*se;
	tv1.m_v1.y = tvLower.m_v2.y - dFH + dCoverFoot;
	tv1.m_v2.y = tv1.m_v1.y + dR;
	tv2.m_v1.y = tv1.m_v2.y;
	tv1.m_v2.x = tv2.m_v1.x = tv2.m_v2.x = tv1.m_v1.x;
	
	// A,C구간이 Merge되지는 않았으나 A구간이 철근이음길이보다 짧을때는 이음표시에 대한부분을 제외한다.
	BOOL bExisSecA = (min(xyUpper1.y, xyUpper2.y) > tvLower.m_v2.y+dHgtB);
	BOOL bIsShortA = (min(xyUpper1.y, xyUpper2.y) > tvLower.m_v2.y+dHgtB+dJoint/2);

	if(!bIsShortA) tv2.m_v2.y = tvLower.m_v2.y+dHgtB;
	else tv2.m_v2.y = nCount%2==0 ? tvLower.m_v2.y+dHgtB+dJoint : tvLower.m_v2.y+dHgtB+dJoint/2;
	if(bMergedAC || !bExisSecA)
	{
		GetXyMatchSegAndLine(xyUpper1, xyUpper2, tv2.m_v1, CDPoint(0, 1), tv2.m_v2);
		if(nOut==0 && bVar)
			tv2.m_v2.y = dT1<dT2 ? xyVar[0].y : xyVar[1].y + dSettle;
	}
	
	if(fabs(Round(tv2.m_v1.x-tvUpper.m_v1.x, 0))>Round(dLenFoot-dCoverWingEnd+1, 0) && !IsWingWallTailBottom(bStt, bLeft))
	{
		tv2.m_v1.y = tvLower.m_v2.y + dCoverWingLower;
		tv2.m_sInfo = _T("기초외수직C");		// 직선부
	}
	else if(fabs(Round(tv2.m_v1.x-tvUpper.m_v1.x, 0))>Round(dLenFoot-dCoverWingEnd+1, 0) && IsWingWallTailBottom(bStt, bLeft))
	{
		tv2.m_v1.y = tv1.m_v2.y;
		tv2.m_sInfo = _T("수직C");		// 직선부
	}
	else
	{
		tv2.m_v1.y = tv1.m_v2.y;
		tv2.m_sInfo = _T("수직C");		// 직선부
		tv1.m_sInfo = _T("수직C곡");	// 곡선부
		tvArrCurve.Add(tv1);
	}
	
	tvArr.Add(tv2);
	nCount++;

	int i=0; for(i=0; i<nSize; i++)
	{
		xyR = xyArr.GetAt(i);
		int j=0; for(j=0; j<xyR.x; j++)
		{
			tv1.m_v1.x += xyR.y*se;
			tv1.m_v2.x = tv2.m_v1.x = tv2.m_v2.x = tv1.m_v1.x;

			//부상방지판 위로 철근이 내려올때.
			// tv.m_v1.y값 위치가 바뀐다. BOX는 종단적용이 있으니까 바닥하고 교차점 찾아서..
			if(m_nTypeBridge == BRIDGE_TYPE_BOX && m_bExistProtectionRiseFooting && tv1.m_v1.x > tvPRFBottom.m_v2.x)
			{
				CDPoint xyBottom;
				GetXyMatchSegAndLine(tvPRFBottom.m_v1, tvPRFBottom.m_v2, tv1.m_v1, CDPoint(0, 1), xyBottom);
				tv1.m_v1.y = tv1.m_v2.y = xyBottom.y;
				tv1.m_v2.y += dR;
			}

			if(!bIsShortA)
			{
				tv2.m_v2.y = tvLower.m_v2.y+dHgtB;
			}
			else
			{
				tv2.m_v2.y = nCount%2==0 ? tvLower.m_v2.y+dHgtB+dJoint : tvLower.m_v2.y+dHgtB+dJoint/2;
			}
			if(bMergedAC || !bExisSecA)
			{
				GetXyMatchSegAndLine(xyUpper1, xyUpper2, tv2.m_v1, CDPoint(0, 1), tv2.m_v2);
				if(nOut==0 && bVar)
					tv2.m_v2.y = dT1<dT2 ? xyVar[0].y : xyVar[1].y + dSettle;
			}

			if(fabs(Round(tv2.m_v1.x-tvUpper.m_v1.x, 0))>Round(dLenFoot-dCoverWingEnd+1, 0) && !IsWingWallTailBottom(bStt, bLeft))
			{
				tv2.m_v1.y = tvLower.m_v2.y + dCoverWingLower;
				tv2.m_sInfo = _T("기초외수직C");		// 직선부
			}
			else if(fabs(Round(tv2.m_v1.x-tvUpper.m_v1.x, 0))>Round(dLenFoot-dCoverWingEnd+1, 0) && IsWingWallTailBottom(bStt, bLeft))
			{
				tv2.m_v1.y = tv1.m_v2.y;
				tv2.m_sInfo = _T("수직C");		// 직선부
			}
			else
			{
				tv2.m_v1.y = tv1.m_v2.y;
				tv2.m_sInfo = _T("수직C");		// 직선부
				tv1.m_sInfo = _T("수직C곡");	// 곡선부
				tvArrCurve.Add(tv1);
			}

			tvArr.Add(tv2);
			nCount++;
		}
	}
}

// 날개벽 정면도 D구간 주철근(수평 철근) 좌표
void CRcBridgeRebar::GetTvArrayRebarWingWallBlockDMainFront(CTwinVectorArray &tvArr, BOOL bStt, BOOL bLeft, int nOut, int nDan)
{
	CARcBridgeDataStd *pStd = m_pARcBridgeDataStd;
	tvArr.RemoveAll();

	CWingWall* pWing = GetWingWall(bStt, bLeft);

	double dL1 = pWing->m_dL1;
	double dL2 = pWing->m_dL2;
	if(dL1==0) return;

	CTwinVectorArray tvArrGen;
	CTwinVector tv, tvJoint, tvUpper, tvLower, tvUpperRebar, tvVar, tvUpperVar, tvVar1, tvVar2;

	GetTvWingWallFront(bStt, bLeft, nOut, tvArrGen, TRUE, TRUE);
	CDPointArray xyArr = pWing->m_xyArrSide[nOut][nDan];
	int nSize = xyArr.GetSize();

	BOOL bSide		= (pWing->m_nAttachPos == 0 )? FALSE : TRUE;
	CDPoint vAng = GetAngleWingWallBetweenWall(bStt, bLeft);
	double se = bStt ? -1.0 : 1.0;
	BOOL bSelMainCTCD = pWing->m_bSelMainCTCD;
	double dCoverWall = (!bSide)? m_dCoverWallIn[0]/vAng.y : 0.0;
	double dCoverWingEnd = GetCoverWingWallEnd(bStt, bLeft);
	double dCoverWingUpper = m_dCoverWingUpper;
	double dCoverWing = nOut==0 ? m_dCoverWingIn[0] : m_dCoverWingOut[0];
	double dDia = max(pWing->m_dDiaMainA[nOut][nDan], pWing->m_dDiaMainD[nOut][nDan]);
	double dCTC = nOut==0 ? pWing->m_dMainCTCA/2 : pWing->m_dMainCTCA;
	if(nOut==0 && bSelMainCTCD)
		dCTC = pWing->m_dMainCTCA;
	double dJoint(0), dSettle(0), dSettleD(0);
	if(m_pARcBridgeDataStd->IsLsdDesign())
	{
		SRebarEnvOption LsdRebarOpt;
		SetRebarLsdOptionWingWall(&LsdRebarOpt, bStt, bLeft, nOut==0, WINGWALL_SECTA, TRUE);
		dJoint = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueJoint(dDia, &LsdRebarOpt);
		dSettle = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueSettle(dDia, &LsdRebarOpt);
		if(bSide)
		{
			SetRebarLsdOptionWingWall(&LsdRebarOpt, bStt, bLeft, nOut==0, WINGWALL_SECTD, TRUE);
			dSettleD = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueSettle(pWing->m_dDiaMainD[nOut][nDan], &LsdRebarOpt);
		}
	}
	else
	{
		dJoint = m_pARcBridgeDataStd->GetValueJoint(dDia, JOINT_TENS_NORMAL_B, toCm(dCoverWing), toCm(dCTC));
		dSettle = m_pARcBridgeDataStd->GetValueSettle(dDia, SETTLE_TENS_NORMAL, toCm(dCoverWing), toCm(dCTC));
		dSettleD = (bSide)? pStd->GetValueSettle(pWing->m_dDiaMainD[nOut][nDan], SETTLE_TENS_NORMAL, toCm(m_dCoverWallOut[0]), toCm((nOut==1)? pWing->m_dMainCTCA:pWing->m_dMainCTCA/2)) : 0.0;
	}
	BOOL bMergedAD = IsMergedRebarWingWall(bStt, bLeft, nOut, nDan, 'A', 'D');	// A구간 주철근과 병합되는지..
	BOOL bMergedBD = IsMergedRebarWingWall(bStt, bLeft, nOut, nDan, 'B', 'D');	// B구간 주철근과 병합되는지..
	BOOL bUpperRebarSlope = pWing->m_bUpperRebarSlope;	// 상면 주철근을 경사로 배치

	double dHgtB = GetLengthWingWallBlockBC(bStt, bLeft);	// B구간의 높이
	double dT1 = pWing->m_dT1;
	double dT2 = pWing->m_dT2;
	double dSpareT = 0;
	double  dSettleDistWing = 0;
	
	//31447
	CTwinVectorArray tvArrSide;
	tvArrSide.RemoveAll();

	if(bSide)
	{
		double dAngle	= vAng.GetAngleDegree();
		double dAngJijum = GetAngleJijum(bStt? 0 : m_nQtyJigan).GetAngleDegree();
		double dAngA1 = (dAngle - dAngJijum) * (bLeft? -1 : 1);

		
		//각도 계산이 이상해서 막음
		//예전에 수정할때 잘못 수정한 코드인거 같음(modified by jaeho 2009.06.15)
		/*
		if( ((bStt && bLeft) || (!bStt && !bLeft)) && bOverAngle)
		{
			dAngJijum = 180 - dAngJijum;
			dAngA1	= (dAngle - dAngJijum) * (bLeft ? 1 : -1);
		}
		*/

		CTwinVectorArray tvArrPlan;
		double dWingBackLen = GetWingWallBackAndSideAttach(tvArrPlan, nOut, nDan, bLeft);		

		if(nOut==0)
			dSpareT = (dL1 + dL2 - dWingBackLen);
		else
			dSpareT = 0;
		//}

		//{ 31447 //해당 날개벽 평면에서의 실제 수평철근 길이들
		GetWingWallbackAndSideAttachRebar(tvArrSide, nOut, nDan, bStt , TRUE, bLeft);
		dSettleDistWing = GetSettleRebarHoriRevision(tvArrSide,dWingBackLen, nOut, bStt, bLeft);
		

// 		if(pWing->m_bRAngEnd && nOut==0) dSpareT = (dT2)/tan(ToRadian(dAngA1));
// 		else dSpareT= 0.0;

//		double d	= dAngA1-(90-dAngA1);
//		if(Compare(d, 0.0, "=") || Compare(fabs(d), 180.0, "=") || Compare(fabs(d), 360.0, "="))
//			d	= 90;

		/*
		정면도 철근좌표는 철근집계시 철근 길이 파악용으로 사용되므로
		실제 길이 그대로를 정면도에 그려줘야 된다.
		따라서 정착장과 피복에 팩터를 곱하거나 나눠주면 안됨
		// 
		double dFactor	= fabs(sin(d));
		dSettleD += m_dCoverWallOut[0]/dFactor;
		*/

		if(dSettleDistWing == 0)
			dSettleD += m_dCoverWallOut[0];
		else
			dSettleD = dSettleDistWing;
	
		if(nOut==0 && !pWing->m_bRAngEnd)  dL1 -= ((dT2-dT1)/tan(ToRadian(dAngA1)));
	}
	else
	{
		if(nOut==0 && !pWing->m_bRAngEnd) dL1 -= ((dT2-dT1)/vAng.y*vAng.x);
		dSpareT =(nOut==0 && pWing->m_bRAngEnd) ? max(dT1, dT2)/vAng.y*vAng.x : 0.0;
	}
	
	CDPoint xyR(0, 0), xyResult(0, 0), vX(1, 0), vY(0, 1);
	
	// 전체 치수 높이
	int i=0; for(i=0; i<nSize; i++)
	{
		xyR = xyArr.GetAt(i);
	}
	double dHgtHor = GetHeightWingWallHorRebar(bStt, bLeft, nOut, nDan);

	// 좌표 계산(tv.m_v1 : 날개벽 시작단)
	tvArrGen.GetTvByInfo(_T("날개벽정면상단"), tvUpper);
	tvArrGen.GetTvByInfo(_T("날개벽정면끝단하부"), tvLower);
	tvArrGen.GetTvByInfo(_T("세로변단면헌치1"), tvVar1);
	tvArrGen.GetTvByInfo(_T("세로변단면헌치2"), tvVar2);
	CDPoint vAngUpper = tvUpper.GetXyDir();
	CDPoint xyMaxUpper = vAngUpper.y>0 ? tvUpper.m_v2 : tvUpper.m_v1;
	CDPoint xyTailUpperCross = GetXyRebarWingWallTailUpperCross(bStt, bLeft, nOut);
	CDPoint xyTailLowerCross = GetXyRebarWingWallTailLowerCross(bStt, bLeft, nOut);
	double dTailLowerCross = xyTailLowerCross.y - tvLower.m_v2.y;
	if(!bUpperRebarSlope)
		dHgtHor = min(tvUpper.m_v2.y, tvUpper.m_v1.y) - tvLower.m_v2.y - dCoverWingUpper;

	// 가로 방향 변단면일 경우 필요
	double dSH = pWing->m_dSH;
	double dLT = pWing->m_dLT;
	BOOL bCrossVar = pWing->m_nDirHunch==2 && nOut==0;
	CDPoint vVar = (CDPoint(1, 0)+CDPoint(-dSH, 1).Unit()).Unit();
	double dDistVar = dCoverWing/vVar.y*vVar.x;
	CDPoint xyVar1 = CDPoint(tvUpper.m_v2.x-(dLT+(dT2-dT1)*dSH+dDistVar)*se, 0);
	CDPoint xyVar2 = CDPoint(tvUpper.m_v2.x-(dLT+dDistVar+dSettle)*se, 0);
	CDPoint xyVar3 = CDPoint(tvUpper.m_v2.x-(dLT)*se, 0);
	CDPoint xyTemp = CDPoint(0, 0);

	int nCount = 0;
	int nCountJoint = 0;
	BOOL bFirst = TRUE;
	BOOL bCross = FALSE;
	BOOL bOutRange1 = FALSE, bOutRange2 = FALSE;
	double dHgtSum = 0;
	// D구간 하면이 수평인 경우는 첫번째 구간부터 그려져야 한다.
	double dHgtMargin = pWing->m_bMatchBottom? 10 : 0;
	double dSttY = dTailLowerCross - dHgtMargin;//max(dTailLowerCross, dHgtB);
	if(bSide)
	{
		tv.m_v1 = CDPoint(tvUpper.m_v1.x-(dSettleD)*se, tvLower.m_v2.y);
		tv.m_v2 = CDPoint(tvUpper.m_v1.x+(dL1+dL2-dCoverWingEnd+(dSpareT-dSettleD))*se, tvLower.m_v2.y);
	}
	else
	{
		tv.m_v1 = CDPoint(tvUpper.m_v1.x+dCoverWall*se, tvLower.m_v2.y);
		tv.m_v2 = CDPoint(tvUpper.m_v1.x+(dL1+dL2-dCoverWingEnd-dSpareT)*se, tvLower.m_v2.y);
	}
	tvJoint.m_sInfo = _T("*수평이음");
	tvUpperRebar = GetTvRebarWingWallUpper(bStt, bLeft, nOut);
	CDPoint xyUpperBound1 = bStt ? tvUpperRebar.m_v1 : tvUpperRebar.m_v2;
	CDPoint xyUpperBound2 = bStt ? tvUpperRebar.m_v2 : tvUpperRebar.m_v1;

	for(i=0; i<nSize; i++)
	{
		xyR = xyArr.GetAt(i);
		int j=0; for(j=0; j<xyR.x; j++)
		{
			dHgtSum += xyR.y;
			tv.m_v1.y += xyR.y;
			tv.m_v2.y += xyR.y;

			nCount++;
			if(nOut==0 && bSelMainCTCD)
			{
				if(nCount%2==0) continue;
			}
			if(dHgtSum<=dSttY) continue;
			// (ARCBRIDGE-2479) 날개벽 D구간 하부 처리
			//if(!bMergedBD && dHgtSum<dHgtB) continue;
			if(i==nSize-1 && j==xyR.x-1) break;		// 최상단 철근은 항상 그려져야 하기에 여기서는 제외함.
			
			// (ARCBRIDGE-2479) B D 구간은 무조건 D구간으로 밀어버린다.
			// ==> (ARCBRIDGE-3423) 다시 분리하도록 변경
			BOOL bMergeRebar = ((dHgtSum>dHgtB && bMergedAD) || (dHgtSum<dHgtB && bMergedBD))? TRUE : FALSE;
			// BOOL bMergeRebar = ((dHgtSum>dHgtB && bMergedAD) || (dHgtSum<dHgtB))? TRUE : FALSE;

			if(bUpperRebarSlope && dHgtSum>dHgtHor)
			{
				double dTemp = 0;
				if(tv.m_v2.y>(xyTailLowerCross.y - dHgtMargin) && tv.m_v2.y<xyTailUpperCross.y)
				{
					GetXyMatchSegAndLine(xyTailUpperCross, xyTailLowerCross, tv.m_v2, vX, xyTemp);
					dTemp = xyTemp.x - tv.m_v2.x;
				}
				else
				{
					dTemp = tvUpper.m_v1.x + (dL1+dL2-dCoverWingEnd-dSpareT)*se - tv.m_v2.x;
				}
				tv.m_v2 += CDPoint(dTemp, 0);
				tv.m_v1 += CDPoint(dTemp, 0);
				tv.m_sInfo = _T("상단경사D");
			}
			else if(tv.m_v2.y>(xyTailLowerCross.y - dHgtMargin) && tv.m_v2.y<xyTailUpperCross.y)
			{
				GetXyMatchSegAndLine(xyTailUpperCross, xyTailLowerCross, tv.m_v1, vX, tv.m_v2);
				tv.m_sInfo = _T("수평변화D");

				// (ARCBRIDGE-3423) BD 구간 무조건 D구간 철근 적용했다가 다시 분리.
				if(dHgtSum<dHgtB && bMergedBD != bMergedAD)
 				// if(!bMergedAD && dHgtSum<dHgtB)
 				{
 					// (ARCBRIDGE-2479) AD구간이 Merge가 아니라면 B구간은 무조건 D구간과 Merge기 때문에 다른 철근으로 들어간다.
 					tv.m_sInfo = _T("수평변화D2");
 				}
			}
			//#27990
			else if(tv.m_v2.y>min(xyUpperBound1.y,xyUpperBound2.y) && tv.m_v2.y<max(xyUpperBound1.y,xyUpperBound2.y))
			{
				GetXyMatchSegAndLine(tvUpperRebar.m_v1, tvUpperRebar.m_v2, tv.m_v1, vX, tv.m_v2);
				tv.m_sInfo = _T("수평변화D");
			}
			else
			{
				tv.m_v2.x = tvUpper.m_v1.x + (dL1+dL2-dCoverWingEnd-dSpareT)*se;
				tv.m_sInfo = _T("수평D");
			}

			if(dL2>0)
			{
				if(nCountJoint%2==0) GetXyMatchLineAndLine(tv.m_v2, tv.GetXyDir(), tvUpper.m_v1+CDPoint((dL2-dCoverWingEnd-dSpareT-dJoint)*se, 0), vY, tv.m_v1);
				else GetXyMatchLineAndLine(tv.m_v2, tv.GetXyDir(), tvUpper.m_v1+CDPoint((dL2-dCoverWingEnd-dSpareT-dJoint/2)*se, 0), vY, tv.m_v1);
			}

			if(bMergeRebar || dL2 == 0)		// A구간과 합쳐질 경우 또는 D구간만 있는경우 D구간 연장
				GetXyMatchLineAndLine(tv.m_v2, tv.GetXyDir(), CDPoint((bSide)? (tvUpper.m_v1.x-(dSettleD)*se) : (tvUpper.m_v1.x+dCoverWall*se), 0), vY, tv.m_v1);
			
			if(bUpperRebarSlope)
			{
				if(dHgtSum>dHgtHor)
				{
					if(bFirst)
					{
						GetXyMatchLineAndLine(CDPoint(xyMaxUpper.x, tv.m_v1.y), vAngUpper, tv.m_v1, vY, tv.m_v1);
						GetXyMatchLineAndLine(CDPoint(xyMaxUpper.x, tv.m_v2.y), vAngUpper, tv.m_v2, vY, tv.m_v2);
						bFirst = FALSE;
					}
					tv.m_sInfo = _T("상단경사D");
				}
			}
			else
			{
				bCross = GetXyMatchSegAndSeg(tv.m_v1, tv.m_v2, xyUpperBound1, xyUpperBound2, xyResult);
				bOutRange1 = GetDirPointByLine(tv.m_v1, xyUpperBound1, xyUpperBound2);
				bOutRange2 = GetDirPointByLine(tv.m_v2, xyUpperBound1, xyUpperBound2);
				if(tvUpperRebar.GetXyDir().y>0)
				{
					if(!bOutRange1 && bCross)
						tv.m_v1 = xyResult;
				}
				else
				{
					if(!bOutRange2 && bCross)
						tv.m_v2 = xyResult;
				}
				if(!bOutRange1 && !bOutRange2) continue;
				tv.m_sInfo = _T("상단경사D");
			}
			if(bCrossVar)
			{
				// 변단면일때 수평D , 수평변단면D, 변단면 헌치  세부분 으로 나눈다..
				if(bMergeRebar || dL2 == 0)
				{
					tvVar = tv;
					tvVar.m_sInfo = tv.m_sInfo==_T("상단경사D") ? _T("상단변단면경사D") : _T("수평변단면하단D");
					if(GetXyMatchSegAndLine(tvVar.m_v1, tvVar.m_v2, xyVar1, vY, xyResult))
					{
						tvVar.m_sInfo = _T("수평변단면D");
						tvVar.m_v2 = xyResult;
					}
					tvArr.Add(tvVar);
				}
				if(GetXyMatchSegAndLine(tv.m_v1, tv.m_v2, xyVar2, vY, xyResult))
					tv.m_v1 = xyResult;
				if(tvVar.m_v2.x == xyVar1.x)
				{
					CTwinVector tvHun;
					tvHun = tvVar;
					GetXyMatchSegAndLine(tvHun.m_v1, tvHun.m_v2, xyVar3, vY, xyResult);
					tvHun.m_v1 = tvVar.m_v2;
					tvHun.m_v2 = xyResult;
					if(GetXyMatchSegAndSeg(tvHun.m_v1, tvHun.m_v2, xyTailUpperCross, xyTailLowerCross, xyResult)) 
						tvHun.m_v2 = xyResult;
					tvHun.m_sInfo = "*수평변단면헌치";
					tvArr.Add(tvHun);
				}	
			}
			if(tv.m_v1.y>tvVar2.m_v1.y && tv.m_v1.y<tvVar1.m_v1.y)
				tv.m_sInfo = _T("수평변단면구간D");
			if(!(bCrossVar && fabs((tvUpper.m_v2.x-dLT)*se) > fabs(tv.m_v2.x*se))) tvArr.Add(tv);

			if(dL2>0 && !bMergeRebar && !bCrossVar)
			{
				tvJoint.m_v1 = tv.m_v1 - CDPoint(0, 30);
				tvJoint.m_v2 = tvJoint.m_v1 + dJoint*tv.GetXyDir();
				if(GetXyMatchSegAndSeg(tvJoint.m_v1, tvJoint.m_v2, xyTailUpperCross, xyTailLowerCross, xyResult))
					tvJoint.m_v2 = xyResult;
				tvArr.Add(tvJoint);
				nCountJoint++;
			}
		}
	}
	if(!bMergedAD)
	{
		if(dL2==0)
			GetXyMatchSegAndLine(tvUpperRebar.m_v1, tvUpperRebar.m_v2, CDPoint(tvUpper.m_v1.x+(dCoverWall-dSettleD)*se, 0), vY, tvUpperRebar.m_v1);
		else
		{
			GetXyMatchSegAndLine(tvUpperRebar.m_v1, tvUpperRebar.m_v2, CDPoint(tvLower.m_v1.x-dCoverWingEnd*se, 0), vY, tvUpperRebar.m_v1);
			tvUpperRebar.m_v1 -= dJoint*tvUpperRebar.GetXyDir();
		}
	}

	double dHorLen(0), dLen(0);
	if(bCrossVar)
	{
		if(bMergedAD || dL2 == 0)
		{
			tvUpperVar = tvUpperRebar;
			if(GetXyMatchSegAndLine(tvUpperVar.m_v1, tvUpperVar.m_v2, xyVar1, vY, xyResult))
				tvUpperVar.m_v2 = xyResult;
			dHorLen = Round(tvUpperVar.GetHorLength(), 0);
			dLen = Round(tvUpperVar.GetLength(), 0);
			tvUpperVar.m_sInfo = dHorLen==dLen ? _T("수평변단면D") : _T("상단변단면경사D");
			tvArr.Add(tvUpperVar);
		}
		if(GetXyMatchSegAndLine(tvUpperRebar.m_v1, tvUpperRebar.m_v2, xyVar2, vY, xyResult))
			tvUpperRebar.m_v1 = xyResult;
	}
	dHorLen = Round(tvUpperRebar.GetHorLength(), 0);
	dLen = Round(tvUpperRebar.GetLength(), 0);
	tvUpperRebar.m_sInfo = dHorLen==dLen ? _T("수평D") : _T("상단경사D");
	tvArr.Add(tvUpperRebar);		// 최상단 철근

	if(dL2>0 && !bMergedAD && !bCrossVar)
	{
		tvJoint.m_v1 = tvUpperRebar.m_v1 - CDPoint(0, 30);
		tvJoint.m_v2 = tvJoint.m_v1 + dJoint*tvUpperRebar.GetXyDir();
		tvArr.Add(tvJoint);
	}
}

// 날개벽 정면도 D구간 배력철근(수직 철근) 좌표
void CRcBridgeRebar::GetTvArrayRebarWingWallBlockDSupportFront(CTwinVectorArray &tvArr, BOOL bStt, BOOL bLeft, int nOut, int nDan)
{
	tvArr.RemoveAll();

	CWingWall* pWing = GetWingWall(bStt, bLeft);

	double dL1 = pWing->m_dL1;
	double dL2 = pWing->m_dL2;
	if(dL1==0) return;

	CTwinVectorArray tvArrGen;
	CTwinVector tv1, tv2, tv3, tvTail, tvTemp, tvUpper, tvLower, tvUpperRebar, tvVar1, tvVar2, tvFrontLower;

	GetTvWingWallFront(bStt, bLeft, nOut, tvArrGen, TRUE, TRUE);
	CDPointArray xyArr = pWing->m_xyArrUpper[nOut][nDan];
	BOOL bSide		= (pWing->m_nAttachPos == 0 )? FALSE : TRUE;

	CDPoint vAng = GetAngleWingWallBetweenWall(bStt, bLeft);
	double dCoverWingEnd = GetCoverWingWallEnd(bStt, bLeft);
	double dCoverWingUpper = m_dCoverWingUpper;
	double dCoverWingIn = m_dCoverWingIn[0];
	double dDia = pWing->m_dDiaSupportD[nOut][nDan];
	double dCTC = (nOut==0 && !pWing->m_bSelMainCTCD)? pWing->m_dStdVerCTC/2 : pWing->m_dStdVerCTC;
	double dSettle(0);
	if(m_pARcBridgeDataStd->IsLsdDesign())
	{
		SRebarEnvOption LsdRebarOpt;
		SetRebarLsdOptionWingWall(&LsdRebarOpt, bStt, bLeft, nOut==0, WINGWALL_SECTD, TRUE);
		dSettle = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueSettle(dDia, &LsdRebarOpt);
	}
	else
	{
		if(bSide)
		{
			CTwinVectorArray tvArrPlan, tvArrSide;
			double dWingBackLen = GetWingWallBackAndSideAttach(tvArrPlan, nOut, nDan, bLeft);		

			//{ 31447 //해당 날개벽 평면에서의 실제 수평철근 길이들
			GetWingWallbackAndSideAttachRebar(tvArrSide, nOut, nDan, bStt , TRUE, bLeft);
			double  dSettleDistWing = GetSettleRebarHoriRevision(tvArrSide,dWingBackLen, nOut, bStt, bLeft);

			dSettle = dSettleDistWing;
		}
		else
		{
			dSettle = m_pARcBridgeDataStd->GetValueSettle(dDia, SETTLE_TENS_NORMAL, toCm(dCoverWingIn), toCm(dCTC));
		}
	}
	double se = bStt ? 1.0 : -1.0;

	tvArrGen.GetTvByInfo(_T("날개벽정면상단"), tvUpper);
	tvArrGen.GetTvByInfo(_T("날개벽정면끝단하부"), tvLower);
	tvArrGen.GetTvByInfo(_T("가로변단면헌치1"), tvVar1);
	tvArrGen.GetTvByInfo(_T("가로변단면헌치2"), tvVar2);
	tvArrGen.GetTvByInfo(_T("날개벽정면하단"), tvFrontLower);

	double dHgtB = GetLengthWingWallBlockBC(bStt, bLeft);	// B구간의 높이
	double dT1 = pWing->m_dT1;
	double dT2 = pWing->m_dT2;
	double dLenD = dL1;	// D구간의 길이

	BOOL bVar = IsWingWallVariableSect(bStt, bLeft);
	CDPoint xyVar[3];
	GetXyRebarWingWallVarySect(xyVar, bStt, bLeft);

	// 좌표 계산(tv.m_v1 : D구간 하단)

	CDPoint xyUpper1 = CDPoint(tvUpper.m_v1.x, tvUpper.m_v1.y-dCoverWingUpper);
	CDPoint xyUpper2 = CDPoint(tvUpper.m_v2.x, tvUpper.m_v2.y-dCoverWingUpper);
	CDPoint xyUpperCross = GetXyRebarWingWallTailUpperCross(bStt, bLeft, nOut);
	CDPoint xyLowerCross = GetXyRebarWingWallTailLowerCross(bStt, bLeft, nOut);

	double dLenSum = 0;
	int nSize = xyArr.GetSize();
	tv2.m_sInfo = _T("변단면수직D");
//  변단면 수직과 변단면 헌치로 나눠져 있으면 현치만 남아있는경우에 철근집계에 포함할수 없어..
//  하나의 철근으로 합치고 철근집계할때 나누어야됨..
//	tv3.m_sInfo = _T("*변단면헌치D");
	tv1.m_v1.x = tvUpper.m_v2.x + dCoverWingEnd*se;
	if(nOut==0 && bVar)
	{
		tv1.m_v1.y = dT1<dT2 ? xyVar[1].y - dSettle : xyVar[0].y;
		tv2.m_v1.y = tvLower.m_v2.y + dHgtB;
		tv2.m_v2.y = dT1<dT2 ? xyVar[0].y : xyVar[1].y + dSettle;
	}
	else
		tv1.m_v1.y = tvLower.m_v2.y + dHgtB;

	GetXyMatchSegAndLine(xyUpper1, xyUpper2, tv1.m_v1, CDPoint(0, 1), tv1.m_v2);
	
	GetXyMatchSegAndLine(xyUpperCross, xyLowerCross, tv1.m_v2, CDPoint(0, 1), tv1.m_v1);

	tvTail =  tv1;
	tvTail.m_sInfo = _T("꼬리수직");
	tvArr.Add(tvTail);
	
	dLenSum += dCoverWingEnd;
	
	double dFootLeft = 0, dFootRight=0;
	

	CDPoint xyR(0, 0), xyResult(0, 0);
	double dFH = bStt ? m_footingStt.m_dFH : m_footingEnd.m_dFH;
	double dCoverFoot = GetCoverFooting(bStt, FALSE);
	int i=0; for(i=0; i<nSize; i++)
	{
		xyR = xyArr.GetAt(i);
		int j=0; for(j=0; j<xyR.x; j++)
		{
			dLenSum += xyR.y;
			tv1.m_v1.x += xyR.y*se;

			GetXyMatchSegAndLine(xyUpper1, xyUpper2, tv1.m_v1, CDPoint(0, 1), tv1.m_v2);
			GetXyMatchSegAndLine(xyUpperCross, xyLowerCross, tv1.m_v2, CDPoint(0, 1), tv1.m_v1);

			BOOL bOverDGugan = FALSE;
			if(se==1)
			{
				if(Compare(tvFrontLower.GetXyLeft().x + dCoverWingEnd, tv1.m_v1.x, _T("<="),0.1))
					bOverDGugan = TRUE;
			}
			else
			{
				if(Compare(tvFrontLower.GetXyRight().x - dCoverWingEnd, tv1.m_v1.x, _T(">="),0.1))
					bOverDGugan = TRUE;
			}
			if(bOverDGugan)
				continue;

			BOOL bFlat = FALSE;
			if(pWing->m_bMatchBottom && ((xyLowerCross.x * se) < (tv1.m_v1.x * se)))
				bFlat = TRUE;

			if(nOut==0 && bVar)
			{
				tv2.m_v2.y = xyVar[2].y;
				tv2.m_v1.x = tv2.m_v2.x = tv1.m_v1.x;
				if(GetXyMatchSegAndSeg(xyUpper1, xyUpper2, tv2.m_v1, tv2.m_v2, xyResult))
					tv2.m_v2 = xyResult;
				if(GetXyMatchSegAndLine(xyUpperCross, xyLowerCross, tv2.m_v1, tv2.GetXyDir(), xyResult))
					tv2.m_v1 = xyResult;
				if(bFlat)
					tv2.m_v1.y = xyLowerCross.y;

				if(tv2.m_v1.y < xyVar[1].y)
				{
					tv2.m_sInfo = (tv2.m_v1.y < xyVar[0].y)? _T("변단면수직D") : _T("수직변단면헌치D");  
					if(bFlat)
						tv2.m_sInfo += _T("_2");
					tvArr.Add(tv2);
				}

				tv1.m_v1.y = xyVar[1].y - dSettle;
				if(GetXyMatchSegAndSeg(xyUpperCross, xyLowerCross, tv1.m_v1, tv1.m_v2, xyResult))
					tv1.m_v1 = xyResult;
				tv1.m_sInfo = (tv2.m_v1.y > xyVar[1].y)? _T("수직D") : _T("변단면상부수직D");  
				tvArr.Add(tv1);

			}
			else
			{
				if(GetXyMatchSegAndSeg(tv1.m_v1, tv1.m_v2, xyUpperCross, xyLowerCross, xyResult))
					tv1.m_v1 = xyResult;

				if(bFlat)
					tv1.m_v1.y = xyLowerCross.y;

				if(tv1.m_v1.x*se>tvVar2.m_v1.x*se && tv1.m_v1.x*se<tvVar1.m_v1.x*se)
					tv1.m_sInfo = _T("수직변단면구간D");
				else
					tv1.m_sInfo = _T("수직D");

				if(bFlat)
					tv1.m_sInfo += _T("_2");

				tvArr.Add(tv1);
			}
		}
	}

	// 끝단 경사 철근
	//Box형에서 H2가 있을경우 꼬리경사철근 정착장이 바깥으로 튀어나가는경우 피복까지 처리
	tvTail.m_v1 = xyUpperCross;
	tvTail.m_v2 = xyLowerCross - dSettle*(xyUpperCross-xyLowerCross).Unit();

	if(IsBoxType() && pWing->m_dH2)
	{
		CTwinVector tvBottom;
		tvArrGen.GetTvByInfo(_T("날개벽정면하단"), tvBottom);
		if(tvTail.m_v2.y < tvBottom.m_v1.y + dCoverWingIn)
		{
			double dVertDir = xyLowerCross.y - (tvBottom.m_v1.y + dCoverWingIn);
			double dSettle = dVertDir / (xyUpperCross-xyLowerCross).Unit().y;
			tvTail.m_v2 = xyLowerCross - dSettle*(xyUpperCross-xyLowerCross).Unit();
		}
	}
	
	//L1만 있는경우 경사철근이 바닥 밑에까지 가는경우가있음.
	if(IsBoxType() && pWing->m_bMatchBottom)
	{
		CDPoint xyMatch;
		BOOL bMatTail = GetXyMatchSegAndLine(tvTail.m_v1, tvTail.m_v2, tvLower.m_v1 + dCoverWingUpper * CDPoint(0,1), CDPoint(1,0).Unit(), xyMatch);
		if(bMatTail)
		{
			tvTail.m_v2 = xyMatch;
		}
		else
		{
			tvTail.m_v2 = tvLower.m_v1 + dCoverWingUpper * CDPoint(0,1) - dSettle*(xyUpperCross-xyLowerCross).Unit();
		}
	}


	tvTail.m_sInfo = _T("꼬리경사");
	tvArr.Add(tvTail);

	
}



// 상부슬래브 RebarInfoCycle 권고안
// 이음은 그대로 두고 권고안을 이음에 맞게 함.
void CRcBridgeRebar::SetDataDefaultRebarInfoCycle_UpperSlab(long nCycle, BOOL bDefaultUpper, BOOL bDefaultLower, BOOL bOnlyCountArray, long nDan, BOOL bOnlyDiffJoint)
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar() - 1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar() - 1) return;

	// 아치교는 1사이클 권고안과 같이 권고안 함.(특별 케이스)
	if((nCycle == 1 || nCycle == 3) && !bOnlyCountArray && m_nTypeBridge != BRIDGE_TYPE_ARCH)
	{
		if(!bOnlyDiffJoint)
		{
			SetDataDefaultRebarInfoCycle_UpperSlab_Cycle2(nCycle, bOnlyCountArray, TRUE, TRUE, nDan);
			return;
		}
	}

	BOOL bVertDir	= IsVertDir();
	BOOL bCycle3	= nCycle == 2 ? TRUE : FALSE;
	
	long upper(0), jigan(0), dia(0), joint(0);
	for(upper = 0; upper < 2; upper++)
	{
		BOOL bUpper	= upper == iUPPER;

		if(bUpper && !bDefaultUpper) continue;
		if(!bUpper && !bDefaultLower) continue;

		// 이음개수가 변경된 경우에만 권고안 하도록 하는 경우 /////////
		if(bOnlyDiffJoint)
		{
			BOOL bDiff	= FALSE;
			for(long dia	= 0; dia < m_nQtyJigan; dia++)
			{
				long nCountJoint	= nCycle == 0 || nCycle == 2 ? m_nCountJointMainRebar_UpperSlab_Cycle1[dia][upper][nDan] : m_nCountJointMainRebar_UpperSlab_Cycle2[dia][upper][nDan];
				long nCountJointOld	= nCycle == 0 || nCycle == 2 ? m_nCountJointMainRebar_UpperSlab_Cycle1_Old[dia][upper][nDan] : m_nCountJointMainRebar_UpperSlab_Cycle2_Old[dia][upper][nDan];
				if(nCountJoint != nCountJointOld)
					bDiff	= TRUE;
			}

			if(!bDiff) continue;
		}
		//////////////////////////////////////////////////////////////////

		if(m_nTypeBridge == BRIDGE_TYPE_ARCH && !bUpper && (nCycle==1 || nCycle==3) && !bOnlyCountArray)
		{
			if(!bOnlyDiffJoint)
			{
				SetDataDefaultRebarInfoCycle_UpperSlab_Cycle2(nCycle, bOnlyCountArray, FALSE, TRUE, nDan);
				continue;
			}
		}

		if(!bCycle3)	// 3cycle이 아닌 경우 일반 권고안 함
		{
			CSafetyTypedPtrArray <CObArray, CDoubleArray*> pArrDiaSlabUpper;
			CSafetyTypedPtrArray <CObArray, CDoubleArray*> pArrExistSlabUpper;
			AhTPACopy(&pArrDiaSlabUpper, &m_pArrDiaUpperSlab[nCycle][upper][nDan], (CDoubleArray*)0);
			AhTPACopy(&pArrExistSlabUpper, &m_pArrExistUpperSlab[nCycle][upper][nDan], (CDoubleArray*)0);

			// 각 지간별 지름을 모두 22로 만든다.
			// 지름은 지간보다 1개 더 들어감.(마지막 지간에 하나 더 들어감)
			AhTPADelete(&m_pArrDiaUpperSlab[nCycle][upper][nDan], (CDoubleArray*)0);
			AhTPADelete(&m_pArrExistUpperSlab[nCycle][upper][nDan], (CDoubleArray*)0);
			BOOL bExist	= TRUE;
			for(dia	= 0; dia < m_nQtyJigan; dia++)
			{
				long nCountJoint	= nCycle == 0 || nCycle == 2 ? m_nCountJointMainRebar_UpperSlab_Cycle1[dia][upper][nDan] : m_nCountJointMainRebar_UpperSlab_Cycle2[dia][upper][nDan];

				// 신축이음이 있는 경우 하나 더 들어감.
				if(dia < m_nQtyJigan-1)
				{
					if(m_bExpJoint[dia+1]) nCountJoint++;
				}
				
				CDoubleArray *pDArr			= new CDoubleArray;
				CDoubleArray *pDArrExist	= new CDoubleArray;
				for(joint = 0; joint < nCountJoint; joint++)
				{
					pDArr->Add(22);
					pDArrExist->Add((double)nDan == 0 ? TRUE : FALSE);
				}
				if(dia == m_nQtyJigan - 1) 
				{
					pDArr->Add(22);
					pDArrExist->Add((double)nDan == 0 ? TRUE : FALSE);
				}

				if(m_nTypeBridge == BRIDGE_TYPE_ARCH && (nCycle == 1 || nCycle == 3))
				{
					for(long l = 0; l < pDArrExist->GetSize(); l++)
					{
						pDArrExist->SetAt(l, (double)bExist);
						bExist = !bExist;
					}
				}

				m_pArrDiaUpperSlab[nCycle][upper][nDan].Add(pDArr);
				m_pArrExistUpperSlab[nCycle][upper][nDan].Add(pDArrExist);
			}

			if(bOnlyCountArray)
			{
				long i = 0; for(i = 0; i < m_pArrDiaUpperSlab[nCycle][upper][nDan].GetSize(); i++)
				{
					CDoubleArray *pDArr	= m_pArrDiaUpperSlab[nCycle][upper][nDan].GetAt(i);
					CDoubleArray *pDArrSrc	= NULL;
					if(pArrDiaSlabUpper.GetSize() > i)
						pDArrSrc	= pArrDiaSlabUpper.GetAt(i);
					else
					{
						pArrDiaSlabUpper.Add(new CDoubleArray);
						pDArrSrc	= pArrDiaSlabUpper.GetAt(i);
					}
					long j = 0; for(j = 0; j < pDArr->GetSize(); j++)
					{
						if(pDArrSrc->GetSize() > j)
							pDArr->SetAt(j, pDArrSrc->GetAt(j));
					}
				}
				for(i = 0; i < m_pArrExistUpperSlab[nCycle][upper][nDan].GetSize(); i++)
				{
					CDoubleArray *pDArr	= m_pArrExistUpperSlab[nCycle][upper][nDan].GetAt(i);
					CDoubleArray *pDArrSrc	= NULL;
					if(pArrExistSlabUpper.GetSize() > i)
						pDArrSrc	= pArrExistSlabUpper.GetAt(i);
					else
					{
						pArrExistSlabUpper.Add(new CDoubleArray);
						pDArrSrc	= pArrExistSlabUpper.GetAt(i);
					}
					long j = 0; for(j = 0; j < pDArr->GetSize(); j++)
					{
						if(pDArrSrc->GetSize() > j)
							pDArr->SetAt(j, pDArrSrc->GetAt(j));
					}
				}
			
			}
			AhTPADelete(&pArrDiaSlabUpper, (CDoubleArray*)0);
			AhTPADelete(&pArrExistSlabUpper, (CDoubleArray*)0);
			
			// 각 지간별 이음 거리는 각 지간의 간격의 반정도를 한다.
			// 거리는 지간개수 만큼 들어감.
			double dWS	= IsOutWall(TRUE) ? m_dWS-m_dCoverWallOut[nDan] : -GetCoverSide_UpperSlab(nDan);
			double dWE	= IsOutWall(FALSE) ? m_dWE-m_dCoverWallOut[nDan] : -GetCoverSide_UpperSlab(nDan);
			if(!bVertDir)
			{
				dWS	/= GetAngleJijum(0).y;
				dWE	/= GetAngleJijum(m_nQtyJigan).y;
			}

			if(upper==iUPPER)
			{
				dWS	-= GetLenRebarAtEdge(22, FALSE);
				dWE	-= GetLenRebarAtEdge(22, FALSE);
			}

			CSafetyTypedPtrArray <CObArray, CDoubleArray*> pArrDistSlabUpper;
			AhTPACopy(&pArrDistSlabUpper, &m_pArrDistUpperSlab[nCycle][upper][nDan], (CDoubleArray*)0);

			AhTPADelete(&m_pArrDistUpperSlab[nCycle][upper][nDan], (CDoubleArray*)0);
			for(jigan = 0; jigan < m_nQtyJigan; jigan++)
			{
				long nCountJoint	= nCycle == 0 || nCycle == 2 ? m_nCountJointMainRebar_UpperSlab_Cycle1[jigan][upper][nDan] : m_nCountJointMainRebar_UpperSlab_Cycle2[jigan][upper][nDan];
				double dDist	= GetLengthJigan(jigan, 0, bVertDir);

				if(jigan == 0) dDist += dWS;
				if(jigan == m_nQtyJigan-1) dDist += dWE;

				CDoubleArray *pDArr	= new CDoubleArray;
				for(joint = 0; joint < nCountJoint; joint++)
				{
					// 4cycle까지 지원되면 3cycle 자동 권고안에 의해 이음 위치가 조금씩 이동 할 수 있다.
					dDist += GetDistMoveJointCycle13_UpperSlab(bUpper, bCycle3, jigan, joint);

					pDArr->Add(Round(dDist/(nCountJoint+1), -1));
				}
				m_pArrDistUpperSlab[nCycle][upper][nDan].Add(pDArr);
			}
			
			if(bOnlyCountArray)
			{
				long i = 0; for(i = 0; i < m_pArrDistUpperSlab[nCycle][upper][nDan].GetSize(); i++)
				{
					CDoubleArray *pDArr	= m_pArrDistUpperSlab[nCycle][upper][nDan].GetAt(i);
					CDoubleArray *pDArrSrc	= NULL;
					if(pArrDistSlabUpper.GetSize() > i)
						pDArrSrc	= pArrDistSlabUpper.GetAt(i);
					else
					{
						pArrDistSlabUpper.Add(new CDoubleArray);
						pDArrSrc	= pArrDistSlabUpper.GetAt(i);
					}
					long j = 0; for(j = 0; j < pDArr->GetSize(); j++)
					{
						if(pDArrSrc->GetSize() > j)
							pDArr->SetAt(j, pDArrSrc->GetAt(j));
					}
				}
			}
		
			AhTPADelete(&pArrDistSlabUpper, (CDoubleArray*)0);
		}
		else	// 3cycle인 경우 1cycle을 참고해서 권고안 함
		{
			AhTPACopy(&m_pArrDiaUpperSlab[nCycle][upper][nDan], &m_pArrDiaUpperSlab[0][upper][nDan], (CDoubleArray*)0);
			AhTPACopy(&m_pArrExistUpperSlab[nCycle][upper][nDan], &m_pArrExistUpperSlab[0][upper][nDan], (CDoubleArray*)0);
			AhTPACopy(&m_pArrDistUpperSlab[nCycle][upper][nDan], &m_pArrDistUpperSlab[0][upper][nDan], (CDoubleArray*)0);
			
			long i = 0; for(i = 0; i < m_pArrDistUpperSlab[nCycle][upper][nDan].GetSize(); i++)
			{
				CDoubleArray *pdArr	= m_pArrDistUpperSlab[nCycle][upper][nDan].GetAt(i);
				long j = 0; for(j = 0; j < pdArr->GetSize(); j++)
				{
					double dMove	= GetDistMoveJointCycle13_UpperSlab(bUpper, bCycle3, i, j) * 2;
					pdArr->SetAt(j, pdArr->GetAt(j)+(j == 0 ? dMove : 0));
				}
			}
		}

		// 하면일 경우 신축이음에 대해서 권고안 해줌
		m_fxJointStt.m_dLenHorRebar[nCycle][nDan]	= IsBlockOut(TRUE) ? m_fxJointStt.m_dWidth*2 : 0;
		m_fxJointEnd.m_dLenHorRebar[nCycle][nDan]	= IsBlockOut(FALSE) ? m_fxJointEnd.m_dWidth*2 : 0;
	}
}


// 권고안 
// 상부 슬래브 전사이클의 2단이상/1단의 2,4사이클
void CRcBridgeRebar::SetDataDefaultRebarInfoCycle_UpperSlab_Cycle2(long nCycle, BOOL bOnlyCountArray, BOOL bDefaultUpper, BOOL bDefaultLower, long nDan)
{
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar() - 1) return;

	// 상부슬래브가 2사이클이 모두 연결된 경우 외측벽체는 연결될 수 없다.
	if(!IsEnableJointMainRebar_OutWallOutterAndUpperSlabUpper(TRUE, FALSE) && !IsEnableJointMainRebar_OutWallOutterAndUpperSlabUpper(FALSE, FALSE))
	{
		m_pArrSetRebarJointOutWall_Outter[iSTT].m_bJoint	= FALSE;
		m_pArrSetRebarJointOutWall_Outter[iEND].m_bJoint	= FALSE;
	}

	long jigan(0), dia(0);
	BOOL bVertDir	= IsVertDir();
	
	// 상부 
	if(bDefaultUpper)
	{
		CSafetyTypedPtrArray <CObArray, CDoubleArray*> pArrDiaSlabUpper;
		AhTPACopy(&pArrDiaSlabUpper, &m_pArrDiaUpperSlab[nCycle][iUPPER][nDan], (CDoubleArray*)0);

		// 각 지간별 지름을 모두 22로 만든다.
		// 지름은 마지막 지간만 2개들어가고 나머지는 1개씩 들어감.
		// 지름은 지간보다 1개 더 들어감.(지점마다 하나씩)
		AhTPADelete(&m_pArrDiaUpperSlab[nCycle][iUPPER][nDan], (CDoubleArray*)0);
		for(dia	= 0; dia < m_nQtyJigan; dia++)
		{
			CDoubleArray *pDArr	= new CDoubleArray;
			pDArr->Add(22);
			if(dia == m_nQtyJigan-1)
				pDArr->Add(22);
			else if(m_bExpJoint[dia+1])	// 신축이음일때는 나머지 지간에도 하나씩 더 들어간다.
				pDArr->Add(22);
			m_pArrDiaUpperSlab[nCycle][iUPPER][nDan].Add(pDArr);
		}

		if(bOnlyCountArray)
		{
			long i = 0; for(i = 0; i < m_pArrDiaUpperSlab[nCycle][iUPPER][nDan].GetSize(); i++)
			{
				CDoubleArray *pDArr	= m_pArrDiaUpperSlab[nCycle][iUPPER][nDan].GetAt(i);
				CDoubleArray *pDArrSrc	= pArrDiaSlabUpper.GetAt(i);
				long j = 0; for(j = 0; j < pDArr->GetSize(); j++)
				{
					if(pDArrSrc->GetSize() > j)
						pDArr->SetAt(j, pDArrSrc->GetAt(j));
				}
			}
		}
		AhTPADelete(&pArrDiaSlabUpper, (CDoubleArray*)0);
		
		CSafetyTypedPtrArray <CObArray, CDoubleArray*> pArrDistSlabUpper;
		AhTPACopy(&pArrDistSlabUpper, &m_pArrDistUpperSlab[nCycle][iUPPER][nDan], (CDoubleArray*)0);

		// 각 지간별 이음 거리는 각 지간의 간격의 반정도를 한다.
		// 거리는 지간개수 만큼 들어감.
		AhTPADelete(&m_pArrDistUpperSlab[nCycle][iUPPER][nDan], (CDoubleArray*)0);
		for(jigan = 0; jigan < m_nQtyJigan; jigan++)
		{
			//long nJijum		= jigan+1;
			double dDist	= GetLengthJigan(jigan, 0, bVertDir, TRUE);//GetStationOnJijum(nJijum, 0) - GetStationOnJijum(nJijum-1, 0);

			if(jigan == 0)
			{
				double dAng = bVertDir ? 1 : GetAngleJijum(0).y;
				dDist += m_dWS / dAng;
				dDist -= m_dCoverWallOut[nDan] / dAng;
				dDist -= GetLenRebarAtEdge(22, FALSE, 0, TRUE);
			}
			
			if(jigan == m_nQtyJigan-1) 
			{
				double dAng = bVertDir ? 1 : GetAngleJijum(m_nQtyJigan).y;
				dDist += m_dWE / dAng;
				dDist -= m_dCoverWallOut[nDan] / dAng;
				dDist -= GetLenRebarAtEdge(22, FALSE, 0, TRUE);
			}

			CDoubleArray *pDArr	= new CDoubleArray;
			pDArr->Add(Round(dDist/4, -1));
			pDArr->Add(Round(dDist/4*2, -1));
			m_pArrDistUpperSlab[nCycle][iUPPER][nDan].Add(pDArr);
		}
	
		if(bOnlyCountArray)
		{
			long i = 0; for(i = 0; i < m_pArrDistUpperSlab[nCycle][iUPPER][nDan].GetSize(); i++)
			{
				CDoubleArray *pDArr	= m_pArrDistUpperSlab[nCycle][iUPPER][nDan].GetAt(i);
				CDoubleArray *pDArrSrc	= pArrDistSlabUpper.GetAt(i);
				long j = 0; for(j = 0; j < pDArr->GetSize(); j++)
				{
					if(pDArrSrc->GetSize() > j)
						pDArr->SetAt(j, pDArrSrc->GetAt(j));
				}
			}
		}
		AhTPADelete(&pArrDistSlabUpper, (CDoubleArray*)0);
	}

	// 하부
	if(bDefaultLower)
	{
		CSafetyTypedPtrArray <CObArray, CDoubleArray*> pArrDiaSlabUpper;
		AhTPACopy(&pArrDiaSlabUpper, &m_pArrDiaUpperSlab[nCycle][iLOWER][nDan], (CDoubleArray*)0);

		// 각 지간별 지름을 모두 22로 만든다.
		// 지름은 지간개수만큼 있음(지간마다 하나씩)
		AhTPADelete(&m_pArrDiaUpperSlab[nCycle][iLOWER][nDan], (CDoubleArray*)0);
		for(dia	= 0; dia < m_nQtyJigan; dia++)
		{
			CDoubleArray *pDArr	= new CDoubleArray;
			pDArr->Add(22);
			m_pArrDiaUpperSlab[nCycle][iLOWER][nDan].Add(pDArr);
		}

		if(bOnlyCountArray)
		{
			long i = 0; for(i = 0; i < m_pArrDiaUpperSlab[nCycle][iLOWER][nDan].GetSize(); i++)
			{
				CDoubleArray *pDArr	= m_pArrDiaUpperSlab[nCycle][iLOWER][nDan].GetAt(i);
				CDoubleArray *pDArrSrc	= pArrDiaSlabUpper.GetAt(i);
				long j = 0; for(j = 0; j < pDArr->GetSize(); j++)
				{
					if(pDArrSrc->GetSize() > j)
						pDArr->SetAt(j, pDArrSrc->GetAt(j));
				}
			}
		}
		AhTPADelete(&pArrDiaSlabUpper, (CDoubleArray*)0);

		CSafetyTypedPtrArray <CObArray, CDoubleArray*> pArrDistSlabUpper;
		AhTPACopy(&pArrDistSlabUpper, &m_pArrDistUpperSlab[nCycle][iLOWER][nDan], (CDoubleArray*)0);

		// 각 지간별 이음 거리는 각 지간의 간격의 반정도를 한다.
		// 거리는 지간마다 2개씩 들어감.
		AhTPADelete(&m_pArrDistUpperSlab[nCycle][iLOWER][nDan], (CDoubleArray*)0);
		for(jigan = 0; jigan < m_nQtyJigan; jigan++)
		{
			CDoubleArray *pDArr	= new CDoubleArray;
			long nIdxHunchPrev	= GetIdxHunchInWall(jigan-1, TRUE);
			long nIdxHunchNext	= GetIdxHunchInWall(jigan, TRUE);
			CWallApp *pWallPrev	= GetInWall(jigan-1);
			CWallApp *pWallNext	= GetInWall(jigan);
			double dW			= 0;

			CJijum *pJ = GetJijum(jigan);
			CDPoint vAng = pJ == NULL? GetAngleAzimuthJijum(jigan) : pJ->m_vAngle;

			if(jigan == 0)
			{
				double dSttLenOut = IsOutWall(TRUE) ? Round(m_dWS+m_dHWS-m_dCoverWallOut[nDan], -1) : 0;
				
				if(bVertDir == FALSE)
				{
					dSttLenOut /= vAng.y;
					dSttLenOut = fabs(dSttLenOut);
				}				

				pDArr->Add(dSttLenOut);	// 시점벽체와헌치너비
			}
			else
			{
				if(nIdxHunchPrev > -1)
				{
					dW	= m_dHRW[nIdxHunchPrev][iUPPER];
					
					if(pWallPrev) dW += pWallPrev->m_dW/2;
					
					if(bVertDir == FALSE)
					{
						dW /= vAng.y;
						dW = fabs(dW);
					}

					pDArr->Add(Round(dW, -1));
				}
			}

			if(jigan == m_nQtyJigan-1)
			{
				double dEndLenOut = IsOutWall(FALSE) ? Round(m_dWE+m_dHWE-m_dCoverWallOut[nDan], -1) : 0;

				if(bVertDir == FALSE)
				{
					dEndLenOut /= vAng.y;
					dEndLenOut = fabs(dEndLenOut);
				}
				
				pDArr->Add(dEndLenOut);	// 종점벽체와 헌치너비
			}
			else
			{
				if(nIdxHunchNext > -1)
				{
					dW	= m_dHLW[nIdxHunchNext][iUPPER];
					
					if(pWallNext) dW += pWallNext->m_dW/2;
					if(bVertDir == FALSE)
					{
						dW /= vAng.y;
						dW = fabs(dW);
					}

					pDArr->Add(Round(dW, -1));
				}
			}

			m_pArrDistUpperSlab[nCycle][iLOWER][nDan].Add(pDArr);
		}		

		if(bOnlyCountArray)
		{
			long i = 0; for(i = 0; i < m_pArrDistUpperSlab[nCycle][iLOWER][nDan].GetSize(); i++)
			{
				CDoubleArray *pDArr	= m_pArrDistUpperSlab[nCycle][iLOWER][nDan].GetAt(i);
				CDoubleArray *pDArrSrc	= pArrDistSlabUpper.GetAt(i);
				long j = 0; for(j = 0; j < pDArr->GetSize(); j++)
				{
					if(pDArrSrc->GetSize() > j)
						pDArr->SetAt(j, pDArrSrc->GetAt(j));
				}
			}
		}
		AhTPADelete(&pArrDistSlabUpper, (CDoubleArray*)0);
	}

	SyncRebar2CycleMainRebarOldAndNew(0, bDefaultUpper, bDefaultLower);
}

// (RebarInfoCycle) 권고안 통합
// long nType, long nCycle
// nType : 권고안 부위
// 0 : 상부 슬래브, 1 : 외측벽체, 2 : 내측벽체, 3 : 기초, 4 : 아치리브, -1 : 모두
// BOOL bOnlyCountArray : 배열 개수만 정리해준다.
// BOOL bOnlyDiffJoint : 이음 개수가 바뀐 것만 권고안 한다.
void CRcBridgeRebar::SetDataDefaultRebarInfoCycle_Std(long nType, long nCycle, BOOL bOnlyCountArray, long nDan, BOOL bOnlyDiffJoint)
{
	if(nDan > 0 && !m_bDetailInput23DanMainRebar) return;

	long cycle = 0; for(cycle = 0; cycle < GetCountCycleMainRebar(); cycle++)
	{
		if(!(nCycle == -1 || cycle == nCycle)) continue;
		

		// 상부 슬래브
		if(nType == 0 || nType == -1)
		{
			SetDataDefaultRebarInfoCycle_UpperSlab(cycle, TRUE, TRUE, bOnlyCountArray,  nDan, bOnlyDiffJoint);
		}

		// 하부 슬래브
		// 하부슬래브를 먼저 기본값 해줘야 외측벽체가 정상적으로 만들어지지
		if(nType == 5 || (nType == -1 && m_nTypeBridge == BRIDGE_TYPE_BOX))
		{
			SetDataDefaultRebarInfoCycle_LowerSlab(cycle, TRUE, TRUE, bOnlyCountArray,  nDan, bOnlyDiffJoint);
		}
		
		// 외측벽체
		if(nType == 1 || nType == -1)
		{
			SetDataDefaultRebarInfoCycle_OutWall(cycle, TRUE, TRUE, bOnlyCountArray, nDan, bOnlyDiffJoint);
		}
		
		// 벽체
		if(nType == 2 || nType == -1)
		{
			long nCountInWall	= GetCountInWall();
			for(long wall = 0; wall < nCountInWall; wall++)
			{
				CWallApp *pWall	= GetInWall(wall);
				if(pWall)
				{
					pWall->SetDataDefaultRebarInfoCycle(cycle, bOnlyCountArray, nDan, bOnlyDiffJoint);
				}
			}
		}
		
		// 기초
		if(nType == 3 || nType == -1)
		{
			long nCountFooting	= GetCountFooting();
			for(long footing = 0; footing < nCountFooting; footing++)
			{
				CFootingApp *pFooting	= GetFooting(footing);
				if(pFooting)
				{
					if(!bOnlyDiffJoint)
						pFooting->SetDataDefaultRebarInfoCycle(cycle, bOnlyCountArray);
				}
			}
		}
		
		// 아치리브
		if(nType == 4 || nType == -1)
		{
			SetDataDefaultRebarInfoCycleArchRib(nCycle, bOnlyCountArray, bOnlyDiffJoint);
		}
	}

}

// 외측벽체 1,3사이클 1단에 대한 주철근 권고안.
void CRcBridgeRebar::SetDataDefaultRebarInfoCycle_OutWall(long nCycle, BOOL bDefaultOutter, BOOL bDefaultInner, BOOL bOnlyCountArray, long nDan, BOOL bOnlyDiffJoint)
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar() - 1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar() - 1) return;
	if((nCycle == 1 || nCycle == 3) && !bOnlyCountArray)
	{
		if(!bOnlyDiffJoint)
		{
			SetDataDefaultRebarInfoCycle_OutWall_Cycle2(nCycle, bOnlyCountArray, nDan);
			return;
		}
	}

	BOOL bCycle3	= nCycle == 2 ? TRUE : FALSE;

	BOOL bVertDir	= IsVertDir();
	long joint(0), stt(0);
	BOOL bStt(TRUE);
	double dMove	= 0;

	// 외측벽체는 거리나 지름이나 모두 이음 개수만큼만 받으면 된다.
	// 단 내측의 지름은 이음 개수보다 하나 더 받아야 됨.
	for(stt = 0; stt < 2; stt++)
	{
		bStt	= (stt == iSTT);

		// 외측 //////////////////////////////////////////////////////////
		// 외측벽체 외측 주철근은 무조건 이음이 하나이상이어야 한다.
		// 왜냐하면 상부슬래브와 연결되기 때문이다.
		//long nCountJointOrg	= nCycle == 0 || nCycle == 2 ? m_nCountJointMainRebar_OutWall_Cycle1[stt][iOUTTER][nDan] : m_nCountJointMainRebar_OutWall_Cycle2[stt][iOUTTER][nDan];
		if(0)//nCountJointOrg == 0 && !IsEnableJointMainRebar_OutWallOutterAndUpperSlabUpper(bStt, TRUE)) 
		{
			if(nCycle == 0 || nCycle == 2)
				m_nCountJointMainRebar_OutWall_Cycle1[stt][iOUTTER][nDan] = 1;
			else
				m_nCountJointMainRebar_OutWall_Cycle2[stt][iOUTTER][nDan] = 1;
		}

		long nCountJoint	= nCycle == 0 || nCycle == 2 ? m_nCountJointMainRebar_OutWall_Cycle1[stt][iOUTTER][nDan] : m_nCountJointMainRebar_OutWall_Cycle2[stt][iOUTTER][nDan];

		// 이음개수가 변경된 경우에만 권고안 하도록 하는 경우 /////////
		BOOL bDefaultOutter	= TRUE;
		BOOL bDefaultInner	= TRUE;
		if(bOnlyDiffJoint)
		{
			long nCountJoint	= nCycle == 0 || nCycle == 2 ? m_nCountJointMainRebar_OutWall_Cycle1[stt][iOUTTER][nDan] : m_nCountJointMainRebar_OutWall_Cycle2[stt][iOUTTER][nDan];
			long nCountJointOld	= nCycle == 0 || nCycle == 2 ? m_nCountJointMainRebar_OutWall_Cycle1_Old[stt][iOUTTER][nDan] : m_nCountJointMainRebar_OutWall_Cycle2_Old[stt][iOUTTER][nDan];
			if(nCountJoint == nCountJointOld)
				bDefaultOutter	= FALSE;

			nCountJoint	= nCycle == 0 || nCycle == 2 ? m_nCountJointMainRebar_OutWall_Cycle1[stt][iINNER][nDan] : m_nCountJointMainRebar_OutWall_Cycle2[stt][iINNER][nDan];
			nCountJointOld	= nCycle == 0 || nCycle == 2 ? m_nCountJointMainRebar_OutWall_Cycle1_Old[stt][iINNER][nDan] : m_nCountJointMainRebar_OutWall_Cycle2_Old[stt][iINNER][nDan];
			if(nCountJoint == nCountJointOld)
				bDefaultInner	= FALSE;
		}
		//////////////////////////////////////////////////////////////////
		
		double dHeight		= GetTvOffset_OutWall(0, bStt, FALSE, bVertDir).GetVerLength();
		
		CDoubleArray dArrDistRC;
		CDoubleArray dArrDiaRC;
		CDoubleArray dArrExistRC;

		if(bDefaultOutter)
		{
			dArrDistRC	= m_pArrDistOutWall[nCycle][stt][iOUTTER][nDan];
			dArrDiaRC	= m_pArrDiaOutWall[nCycle][stt][iOUTTER][nDan];
			dArrExistRC	= m_pArrExistOutWall[nCycle][stt][iOUTTER][nDan];

			m_pArrDistOutWall[nCycle][stt][iOUTTER][nDan].RemoveAll();
			m_pArrDiaOutWall[nCycle][stt][iOUTTER][nDan].RemoveAll();
			m_pArrExistOutWall[nCycle][stt][iOUTTER][nDan].RemoveAll();
			
			// 거리/지름
			if(!bCycle3)
			{
				for(joint = 0; joint < nCountJoint; joint++)
				{
					m_pArrDistOutWall[nCycle][stt][iOUTTER][nDan].Add(Round(dHeight/(nCountJoint+1), -1));
					m_pArrDiaOutWall[nCycle][stt][iOUTTER][nDan].Add(22);
					m_pArrExistOutWall[nCycle][stt][iOUTTER][nDan].Add((double)nDan == 0 ? TRUE : FALSE);
				}

				if(bOnlyCountArray)
				{
					long i = 0; for(i = 0; i < m_pArrDistOutWall[nCycle][stt][iOUTTER][nDan].GetSize(); i++)
					{
						if(i < dArrDistRC.GetSize())
							m_pArrDistOutWall[nCycle][stt][iOUTTER][nDan].SetAt(i, dArrDistRC.GetAt(i));
					}

					for(i = 0; i < m_pArrDiaOutWall[nCycle][stt][iOUTTER][nDan].GetSize(); i++)
					{
						if(i < dArrDiaRC.GetSize())
							m_pArrDiaOutWall[nCycle][stt][iOUTTER][nDan].SetAt(i, dArrDiaRC.GetAt(i));
					}

					for(i = 0; i < m_pArrExistOutWall[nCycle][stt][iOUTTER][nDan].GetSize(); i++)
					{
						if(i < dArrExistRC.GetSize())
							m_pArrExistOutWall[nCycle][stt][iOUTTER][nDan].SetAt(i, dArrExistRC.GetAt(i));
					}
				}
				else
				{
					// 4cycle 지원시 3cycle옵션에 따라 조금씩 이동 가능
					for(joint = 0; joint < nCountJoint; joint++)
					{
						dMove	= GetDistMoveJointCycle13_OutWall(bStt, FALSE, bCycle3, joint);
						m_pArrDistOutWall[nCycle][stt][iOUTTER][nDan].SetAt(joint, (Round(dHeight/(nCountJoint+1)+dMove, -1)));
					}
				}
			}
			else
			{
				m_pArrDistOutWall[nCycle][stt][iOUTTER][nDan]		= m_pArrDistOutWall[0][stt][iOUTTER][nDan];
				m_pArrDiaOutWall[nCycle][stt][iOUTTER][nDan]		= m_pArrDiaOutWall[0][stt][iOUTTER][nDan];
				m_pArrExistOutWall[nCycle][stt][iOUTTER][nDan]	= m_pArrExistOutWall[0][stt][iOUTTER][nDan];

				long i = 0; for(i = 0; i < m_pArrDistOutWall[nCycle][stt][iOUTTER][nDan].GetSize(); i++)
				{
					dMove	= GetDistMoveJointCycle13_OutWall(bStt, FALSE, bCycle3, i);
					m_pArrDistOutWall[nCycle][stt][iOUTTER][nDan].SetAt(i, m_pArrDistOutWall[nCycle][stt][iOUTTER][nDan].GetAt(i)+(i == 0 ? dMove*2 : 0));
				}
			}
		}


		// 내측 //////////////////////////////////////////////////////////
		if(bDefaultInner)
		{
			nCountJoint	= nCycle == 0 || nCycle == 2 ? m_nCountJointMainRebar_OutWall_Cycle1[stt][iINNER][nDan] : m_nCountJointMainRebar_OutWall_Cycle2[stt][iINNER][nDan];

			
			dHeight		= GetTvOffset_OutWall(0, bStt, TRUE, bVertDir).GetVerLength();

			dArrDistRC	= m_pArrDistOutWall[nCycle][stt][iINNER][nDan];
			dArrDiaRC	= m_pArrDiaOutWall[nCycle][stt][iINNER][nDan];
			dArrExistRC	= m_pArrExistOutWall[nCycle][stt][iINNER][nDan];

			m_pArrDistOutWall[nCycle][stt][iINNER][nDan].RemoveAll();
			m_pArrDiaOutWall[nCycle][stt][iINNER][nDan].RemoveAll();
			m_pArrExistOutWall[nCycle][stt][iINNER][nDan].RemoveAll();
			
			// 거리/지름
			if(!bCycle3)
			{
				if(nCountJoint == 0) 
				{
					m_pArrDiaOutWall[nCycle][stt][iINNER][nDan].Add(22);
					m_pArrExistOutWall[nCycle][stt][iINNER][nDan].Add((double)nDan == 0 ? TRUE : FALSE);
				}
				else
				{
					for(joint = 0; joint < nCountJoint; joint++)
					{
						m_pArrDistOutWall[nCycle][stt][iINNER][nDan].Add(Round(dHeight/(nCountJoint+1), -1));
						m_pArrDiaOutWall[nCycle][stt][iINNER][nDan].Add(22);
						m_pArrExistOutWall[nCycle][stt][iINNER][nDan].Add((double)nDan == 0 ? TRUE : FALSE);
						if(joint == nCountJoint-1)
						{
							m_pArrDiaOutWall[nCycle][stt][iINNER][nDan].Add(22);
							m_pArrExistOutWall[nCycle][stt][iINNER][nDan].Add((double)nDan == 0 ? TRUE : FALSE);
						}
					}
				}


				if(bOnlyCountArray)
				{
					long i = 0; for(i = 0; i < m_pArrDistOutWall[nCycle][stt][iINNER][nDan].GetSize(); i++)
					{
						if(i < dArrDistRC.GetSize())
							m_pArrDistOutWall[nCycle][stt][iINNER][nDan].SetAt(i, dArrDistRC.GetAt(i));
					}

					for(i = 0; i < m_pArrDiaOutWall[nCycle][stt][iINNER][nDan].GetSize(); i++)
					{
						if(i < dArrDiaRC.GetSize())
							m_pArrDiaOutWall[nCycle][stt][iINNER][nDan].SetAt(i, dArrDiaRC.GetAt(i));
					}

					for(i = 0; i < m_pArrExistOutWall[nCycle][stt][iINNER][nDan].GetSize(); i++)
					{
						if(i < dArrExistRC.GetSize())
							m_pArrExistOutWall[nCycle][stt][iINNER][nDan].SetAt(i, dArrExistRC.GetAt(i));
					}
				}
				else
				{
					for(joint = 0; joint < nCountJoint; joint++)
					{
						dMove	= GetDistMoveJointCycle13_OutWall(bStt, TRUE, bCycle3, joint);
						m_pArrDistOutWall[nCycle][stt][iINNER][nDan].SetAt(joint, (Round(dHeight/(nCountJoint+1)+dMove, -1)));
					}
				}
			}
			else
			{
				m_pArrDistOutWall[nCycle][stt][iINNER][nDan]	= m_pArrDistOutWall[0][stt][iINNER][nDan];
				m_pArrDiaOutWall[nCycle][stt][iINNER][nDan]	= m_pArrDiaOutWall[0][stt][iINNER][nDan];
				m_pArrExistOutWall[nCycle][stt][iINNER][nDan]	= m_pArrExistOutWall[0][stt][iINNER][nDan];

				long i = 0; for(i = 0; i < m_pArrDistOutWall[nCycle][stt][iINNER][nDan].GetSize(); i++)
				{
					dMove	= GetDistMoveJointCycle13_OutWall(bStt, TRUE, bCycle3, i);
					m_pArrDistOutWall[nCycle][stt][iINNER][nDan].SetAt(i, m_pArrDistOutWall[nCycle][stt][iINNER][nDan].GetAt(i)+(i == 0 ? dMove*2 : 0));
				}
			}
		}
	}
}

// 외측벽체 주철근 권고안(2,3단 and 2, 4 사이클의 1단)
void CRcBridgeRebar::SetDataDefaultRebarInfoCycle_OutWall_Cycle2(long nCycle, BOOL bOnlyCountArray, long nDan)
{
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar() - 1) return;
	if(bOnlyCountArray) return;

	long stt(0);
	BOOL bStt(TRUE);
	BOOL bVertDir	= IsVertDir();

	// 2, 4사이클의 1단
	for(stt = 0; stt < 2; stt++)
	{
		bStt	= (stt == iSTT);
		CFootingApp *pFooting	= bStt ? &m_footingStt : &m_footingEnd;
		
		// 외측
		double dHeight	= GetTvOffset_OutWall(0, bStt, FALSE, bVertDir).GetVerLength();
		m_pArrDistOutWall[nCycle][stt][iOUTTER][nDan].RemoveAll();
		m_pArrDiaOutWall[nCycle][stt][iOUTTER][nDan].RemoveAll();
		
		m_pArrDistOutWall[nCycle][stt][iOUTTER][nDan].Add(Round((dHeight/3), 0));
		m_pArrDistOutWall[nCycle][stt][iOUTTER][nDan].Add(Round((dHeight/3), 0));
		m_pArrDiaOutWall[nCycle][stt][iOUTTER][nDan].Add(22);
		if(nDan > 0)
		{
			long nSizePrevDia = m_pArrDiaOutWall[nCycle][stt][iOUTTER][nDan-1].GetSize();
			long nSizeCurrDia = m_pArrDiaOutWall[nCycle][stt][iOUTTER][nDan].GetSize();

			if(nSizePrevDia != nSizeCurrDia)
			{
				for (long ix =0; ix < nSizePrevDia - nSizeCurrDia+1; ix++)
				{
					m_pArrDiaOutWall[nCycle][stt][iOUTTER][nDan].Add(22);
				}
			}
		}
	

		// 내측
		m_pArrDistOutWall[nCycle][stt][iINNER][nDan].RemoveAll();
		m_pArrDiaOutWall[nCycle][stt][iINNER][nDan].RemoveAll();
		
		if(IsBoxType())
			m_pArrDistOutWall[nCycle][stt][iINNER][nDan].Add(Round(m_dTS_Lower + (bStt ? m_dWSHH : m_dWEHH) - m_dCoverUpper_UpperSlab[nDan], 0));
		else
			m_pArrDistOutWall[nCycle][stt][iINNER][nDan].Add(Round(pFooting->GetHeight()-pFooting->m_dCoverLower[nDan], 0));
		m_pArrDistOutWall[nCycle][stt][iINNER][nDan].Add(Round(m_dTS + (bStt ? m_dHHS : m_dHHE) - m_dCoverUpper_UpperSlab[nDan], 0));
		m_pArrDiaOutWall[nCycle][stt][iINNER][nDan].Add(22);
		if(nDan > 0)
		{
			long nSizePrevDia = m_pArrDiaOutWall[nCycle][stt][iINNER][nDan-1].GetSize();
			long nSizeCurrDia = m_pArrDiaOutWall[nCycle][stt][iINNER][nDan].GetSize();

			if(nSizePrevDia > nSizeCurrDia)
			{
				for (long ix =0; ix < nSizePrevDia - nSizeCurrDia+1; ix++)
				{
					m_pArrDiaOutWall[nCycle][stt][iINNER][nDan].Add(22);
				}
			}
		}

		m_pArrSetRebarJointOutWall_Inner[stt][iLOWER].m_bJoint	= IsBoxType()? FALSE : TRUE;
	}

	// 모든 사이클의 2, 3단은 단수 설정만으로 모든 치수가 결정되므로 따로 권고안 할 필요 없음.

	SyncRebar2CycleMainRebarOldAndNew(1);

	// 모든사이클 2단 철근에 대해서 2Cycle 1단과 동일하게 셋팅
	for(stt = 0; stt < 2; stt++)
	{
		for(long inner = 0; inner < 2; inner++)
		{
			long cycle = 0; for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
			{
				long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
				{
					if(cycle == 1 && dan == 0) continue;
					m_pARcBridgeDataStd->CopyDoubleArray(&m_pArrExistOutWall[cycle][stt][inner][dan], &m_pArrExistOutWall[1][stt][inner][nDan]);
				}
			}
		}
	}
}

// 상부슬래브 배력철근 권고안.
void CRcBridgeRebar::SetDataDefaultRebarSupport_VertSection_UpperSlab(BOOL bUpper, BOOL bLowerSlab)
{
	const long nCountOverLap	= 1;	// 상하철근이 겹치게 배근되는 개수

	BOOL bVertDir		= IsVertDir();
	CHgBaseConcStd baseConc;
	long upper			= bUpper ? iUPPER : iLOWER;	
	double dCTC			= m_dCTC_SupportRebar[bLowerSlab ? iLOWER : iUPPER];		// index에서 double로 변경(2005.04.25)
	double sw			= bUpper ? 1 : -1;
	double dCTCOfJijum	= bUpper ? dCTC/2.0 : dCTC;
	double dCTCOfCenter	= bUpper ? dCTC : dCTC/2.0;
	if(bLowerSlab)
	{
		sw				= bUpper ? -1 : 1;
		dCTCOfJijum		= bUpper ? dCTC : dCTC/2.0;
		dCTCOfCenter	= bUpper ? dCTC/2.0 : dCTC;
	}

	// 인장압축구간 동일 적용일경우 지점부 중앙부 모두 dCTC로 설정하고 구간을 하나로 한다.
	if(m_bSameOffsetPlaceTAndCBlock)
	{
		dCTCOfJijum		= dCTC;
		dCTCOfCenter	= dCTC;
	}

	CPlaceRebarByBlock *pPlace	= bLowerSlab? &m_placeByBlock_SupportRebar_LowerSlab[upper][0] : &m_placeByBlock_SupportRebar_UpperSlab[upper][0];
	pPlace->m_xyArr.RemoveAll();

	long nCount			= 0;	// 철근 개수
	double dDist		= 0;
	double dLenRound	= 0;
	double dDia			= 0;
	double dRemain		= 0;	// 앞쪽에 구하고 남는 거리
	double dCoverLeft	= 0;
	double dCoverRight	= 0;
	CDPoint vAngStt	= GetAngleJijum(0, bVertDir);
	CDPoint vAngEnd	= GetAngleJijum(m_nQtyJigan, bVertDir);

	double dRemainAccuByRound	= 0;	// Round에 의해서 잘리거나 남게되는 소수점이하 값들.
	BOOL bIncludeSupInWall	= TRUE;	// 벽체 사이에 배력근을 채울지?

	for(long jigan = 0; jigan < m_nQtyJigan; jigan++)
	{
		// 지간 길이 설정(철근~철근까지) //////////////////////////////////////
		double dLenJigan	= 0;	// 지간 길이
		dLenJigan	= GetLengthBetweenWall(jigan, bVertDir);
		if(jigan == 0)
		{
			dCoverLeft	= IsOutWall(TRUE) ? m_dCoverWallOut[0]/vAngStt.y : -m_dCoverWallOut[0]/vAngStt.y;
		}
		else 
		{
			CWallApp *pWall	= GetInWall(jigan-1);
			if(pWall)
				dCoverLeft	= pWall->m_bIs ? pWall->m_dCoverRight[0]/vAngStt.y : 0;//m_dCoverWallOut[0]/vAngStt.y;//GetCoverSide_UpperSlab(0)/vAngStt.y;
			else
				dCoverLeft	= m_dCoverWallOut[0]/vAngStt.y;//GetCoverSide_UpperSlab(0)/vAngStt.y;
		}

		if(jigan == m_nQtyJigan-1)
		{
			dCoverRight	= IsOutWall(FALSE) ? m_dCoverWallOut[0]/vAngEnd.y : -m_dCoverWallOut[0]/vAngEnd.y;
		}
		else
		{
			CWallApp *pWall	= GetInWall(jigan);
			if(pWall)
				dCoverRight	= pWall->m_bIs ? pWall->m_dCoverRight[0]/vAngEnd.y : 0;//m_dCoverWallOut[0]/vAngEnd.y;//GetCoverSide_UpperSlab(0)/vAngEnd.y;
			else
				dCoverRight	= m_dCoverWallOut[0]/vAngEnd.y;//GetCoverSide_UpperSlab(0)/vAngEnd.y;
		}
		dLenJigan += (dCoverLeft + dCoverRight);
		// 지간 길이 설정(철근~철근까지) //////////////////////////////////////

		// 좌측 벽체/지점에 대해서 배근 /////////////////////////////////////
		if(jigan == 0)
		{
			if(IsOutWall(TRUE))
			{
				if(bUpper != bLowerSlab)
				{
					if(bLowerSlab)
						dDia		= GetDiaMainRebarLowerSlab(0, 0, FALSE, 0, 0);
					else
						dDia		= GetDiaMainRebarUpperSlab(0, 0, TRUE, 0, 0);

					dLenRound	= GetLenRebarAtEdge(dDia, FALSE);
					dDist		= (m_dWS - (m_dCoverWallOut[0] + m_dCoverWallIn[0]))/vAngStt.y - dLenRound;
					dRemainAccuByRound += dDist - Round(dDist, 0);
					pPlace->m_xyArr.Add(CDPoint(1, Round(dDist, 0)));
				}
			}
			else
			{
				if(!bUpper)
				{
					/*
					dDia	= GetDiaMainRebarUpperSlab(0, 0, TRUE, 0, 0);
					dLenRound	= GetLenRebarAtEdge(dDia, FALSE);
					pPlace->m_xyArr.Add(CDPoint(1, dLenRound));
					*/
				}
			}
		}
		else
		{
			CWallApp *pWall	= GetInWall(jigan-1);
			CDPoint vAng	= GetAngleJijum(jigan, bVertDir);
			if(pWall)
			{
				if(pWall->m_bIs)
				{
					dDist	= (pWall->GetWidthWall()-pWall->m_dCoverLeft[0]-pWall->m_dCoverRight[0])/vAng.y;
					dRemainAccuByRound += dDist - Round(dDist, 0);
					if(bIncludeSupInWall)
					{
						nCount	= (long)(dDist / (dCTC/2));
						dRemain	= Round(dDist - ((dCTC/2) * nCount), 0);
						if(dRemain/2 < MIN_LEN_BLOCK)
						{
							dRemain += dCTC/2;
							nCount --;
						}

						if(nCount >= 0)
						{
							pPlace->m_xyArr.Add(CDPoint(1, dRemain/2));
							pPlace->m_xyArr.Add(CDPoint(nCount, dCTC/2));
							pPlace->m_xyArr.Add(CDPoint(1, dRemain/2));
						}
						else
						{
							// (ARCBRIDGE-3147) 벽체 폭이 좁아서 갯수가 -가 나오는 경우에는 철근을 넣지 않는다.
							pPlace->m_xyArr.Add(CDPoint(1, Round(dDist, 0)));
						}
					}
					else
					{
						pPlace->m_xyArr.Add(CDPoint(1, Round(dDist, 0)));
					}
					
				}
				else
				{
					long nIdxHunch	= GetIdxHunchInWall(jigan-1, TRUE);
					double dW	= m_dWL[nIdxHunch][iUPPER] + m_dWR[nIdxHunch][iUPPER];
					if(!bVertDir)
						dW = dW/GetAngleJijum(jigan).y;
					pPlace->m_xyArr.Add(CDPoint(1, dW));
				}
			}
		}
		// 좌측 벽체/지점에 대해서 배근 /////////////////////////////////////

		// 좌우벽체 사이 지간에 대해서 배근 //////////////////////////////////////
		nCount	= (long)(dLenJigan / dCTC);
		dRemain	= Round(dLenJigan - (dCTC * nCount), 0);
		if(dRemain/2 < MIN_LEN_BLOCK)
		{
			dRemain += dCTC;
			nCount --;
		}
		dRemainAccuByRound += dRemain/2 - Round(dRemain/2, 0);
		pPlace->m_xyArr.Add(CDPoint(1, Round(dRemain/2, 0)));

		// dCTC에 대해서는 지점부 간격과 센타부 간격으로 다시 조정 해야 된다.
		long nCount1	= (long)(m_bSameOffsetPlaceTAndCBlock ? 0 : nCount/3 + nCountOverLap * sw);
		long nCount3	= (long)(m_bSameOffsetPlaceTAndCBlock ? 0 : nCount/3 + nCountOverLap * sw);
		long nCount2	= nCount - nCount1 - nCount3;
		pPlace->m_xyArr.Add(CDPoint(nCount1*(dCTC/dCTCOfJijum), dCTCOfJijum));
		pPlace->m_xyArr.Add(CDPoint(nCount2*(dCTC/dCTCOfCenter), dCTCOfCenter));
		pPlace->m_xyArr.Add(CDPoint(nCount3*(dCTC/dCTCOfJijum), dCTCOfJijum));
		
		dRemainAccuByRound += dRemain/2 - Round(dRemain/2, 0);
		pPlace->m_xyArr.Add(CDPoint(1, Round(dRemain/2, 0)));
		// 좌우벽체 사이 지간에 대해서 배근 //////////////////////////////////////

		// 마지막인 경우 우측 벽체에 대해서도 배근한다. /////////////////////
		if(jigan == m_nQtyJigan-1)
		{
			if(IsOutWall(FALSE) && (bUpper != bLowerSlab))
			{
				if(bLowerSlab)
					dDia		= GetDiaMainRebarLowerSlab(0, 0, FALSE, -1, -1);
				else
					dDia		= GetDiaMainRebarUpperSlab(0, 0, TRUE, -1, -1);
				dLenRound	= GetLenRebarAtEdge(dDia, FALSE);
				dDist		= (m_dWE - (m_dCoverWallIn[0] + m_dCoverWallOut[0]))/vAngEnd.y - dLenRound;
//				if(!bUpper)
//					dDist += dLenRound;

				pPlace->m_xyArr.Add(CDPoint(1, RoundDown(dDist-dRemainAccuByRound, 0)));
			}
		}
		// 마지막인 경우 우측 벽체에 대해서도 배근한다. /////////////////////
	}

	// 구한 간격들에서 최소 간격은 걸러낸다.
	pPlace->m_nCountBlock		= pPlace->m_xyArr.GetSize();
	pPlace->ModifyPlaceRebarByMinLimits(100);
	pPlace->RemoveZeroCount();
	pPlace->m_nCountBlock		= pPlace->m_xyArr.GetSize();
}

// 종단면 배력철근 배근 권고안.
// nType 권고안 부위
// 0 : 상부슬래브, 1 : 시점측외측벽체, 2 : 종점측외측벽체, 3 : 내측벽체, 4 : 기초, 5 : 브라켓, 6 : 리브, 7 : 리브지점부보강
// long nIdxFooting : 기초의 경우 각가 따로 권고안 한다.(
void CRcBridgeRebar::SetDataDefaultRebarSupport_VertSection_Std(long nType, long nIdxFooting)
{
	// 상부슬래브
	if(nType == 0 || nType == -1)
	{
		SetDataDefaultRebarSupport_VertSection_UpperSlab(TRUE);
		SetDataDefaultRebarSupport_VertSection_UpperSlab(FALSE);
	}

	// 시점측 외측벽체
	if(nType == 1 || nType == -1)
	{
		SetDataDefaultRebarSupport_VertSection_OutWall(TRUE, TRUE);
		SetDataDefaultRebarSupport_VertSection_OutWall(TRUE, FALSE);
	}

	// 종점측 외측벽체
	if(nType == 2 || nType == -1)
	{
		SetDataDefaultRebarSupport_VertSection_OutWall(FALSE, TRUE);
		SetDataDefaultRebarSupport_VertSection_OutWall(FALSE, FALSE);
	}
	// 내측벽체
	if(nType == 3 || nType == -1)
	{
		long nCountInWall	= GetCountInWall();
		for(long wall = 0; wall < nCountInWall; wall++)
		{
			CWallApp *pWall	= GetInWall(wall);
			if(pWall)
			{
				if(!pWall->m_bIs) continue;
				pWall->SetDataDefaultRebarSupport_VertSection_InWall(TRUE);
				pWall->SetDataDefaultRebarSupport_VertSection_InWall(FALSE);
			}
		}
	}

	// 기초
	if(nType == 4 || nType == -1)
	{
		long nIdxCurFooting	= 0;
		long j = 0; for(j = 0; j <= m_nQtyJigan; j++)
		{
			CFootingApp *pFooting	= GetFootingByJijumNumber(j);
			if(!pFooting) continue;
			if(!pFooting->m_bIs) continue;

			if(nIdxFooting == -1 || nIdxFooting == nIdxCurFooting || nType == -1)
			{
				if(j == 0 || j == m_nQtyJigan)
				{
					BOOL bStt	= j == 0;
					if(IsOutWall(bStt))
					{
						CWallApp wall;
						MakeWallByOutWall(wall, j==0, FALSE);
						wall.SetDataDefaultRebarSupportFront_Footing(FALSE);
						wall.SetDataDefaultRebarSupportFront_Footing(TRUE);

						CFootingApp *pFooting	= bStt ? &m_footingStt : &m_footingEnd;
						pFooting->m_placeByBlock_Support_Front[iUPPER][0]	= wall.m_footing.m_placeByBlock_Support_Front[iUPPER][0];
						pFooting->m_placeByBlock_Support_Front[iLOWER][0]	= wall.m_footing.m_placeByBlock_Support_Front[iLOWER][0];
					}
				}
				else
				{
					CWallApp *pWall	= GetInWall(j - 1);
					if(!pWall) continue;
					if(!pWall->m_bIs) continue;
					pWall->SetDataDefaultRebarSupportFront_Footing(FALSE);
					pWall->SetDataDefaultRebarSupportFront_Footing(TRUE);
				}

				pFooting->SetDataDefaultRebarSide_Out();
			}

			nIdxCurFooting++;
		}
	}

	// 리브
	if(nType == 6 || nType == -1)
	{
		SetDataDefaultRebarSupport_VertSection_ArchRib();
	}
	
	// 리브 지점부
	if(nType == 7 || nType == -1)
	{
		if(m_nTypeBridge == BRIDGE_TYPE_ARCH)
		{
			m_footingStt.SetDataDefaultRebarSupport_FrontSlope();
			m_footingEnd.SetDataDefaultRebarSupport_FrontSlope();
		}
	}

	// 하부슬래브
	if(nType == 9 || nType == -1)
	{
		SetDataDefaultRebarSupport_VertSection_UpperSlab(TRUE, TRUE);
		SetDataDefaultRebarSupport_VertSection_UpperSlab(FALSE, TRUE);
	}
}

// 외측벽체 배력근 권고안.
void CRcBridgeRebar::SetDataDefaultRebarSupport_VertSection_OutWall(BOOL bStt, BOOL bInner)
{
	const long nCountOverLap	= 1;	// 상하철근이 겹치게 배근되는 개수
	CHgBaseConcStd baseConc;
	long inner			= bInner ? iINNER : iOUTTER;
	long stt			= bStt ? iSTT : iEND;
	double dCTC			= m_dCTC_SupportRebarOutWall[stt];// 배력/전단철근 표준 배치 간격
	double sw			= !bInner ? 1 : -1;
	double dCTCOfJijum	= bInner ? dCTC : dCTC/2.0;
	double dCTCOfCenter	= bInner ? dCTC/2.0 : dCTC;
	
	// 인장압축구간 동일 적용일경우 지점부 중앙부 모두 dCTC로 설정하고 구간을 하나로 한다.
	if(m_bSameOffsetPlaceTAndCBlock)
	{
		dCTCOfJijum		= dCTC;
		dCTCOfCenter	= dCTC;
	}
	
	CPlaceRebarByBlock *pPlace	= &m_placeByBlock_SupportRebar_OutWall[stt][inner][0];
	pPlace->m_xyArr.RemoveAll();
	if(!IsOutWall(bStt)) return;

	BOOL bVertDir	= IsVertDir();

	// 기초부
	long nCount			= 0;	// 철근 개수
	double dLenRound	= 0;
	double dLenWall		= 0;	// 벽체(철근이 드어가는 기준이 되는 부분)
	double dRemain		= 0;	// 앞쪽에 구하고 남는 거리
	CDPoint xyMatcUpper	= 0;
	double dRebarOffset	= 0;
	CTwinVector tvWall;
	double	dLengInnerFirst = 0;

	tvWall		= GetTvOffset_OutWall(0, bStt, bInner, bVertDir);
	xyMatcUpper	= GetXyMatchLineAndSlabUpper(tvWall.m_v1, CDPoint(0, 1), 0, m_dTS);
	// () 슬래브두께가 철근 절곡길이보다 작으면 기본값이 정상적으로 되지 않는다.
	// 철근배치구간 상단을 절곡부 위치보다는 아래로 내려주자.
	BOOL bThinSlab = FALSE;
	if(bInner == FALSE)
	{
		CRebarInfoCycle *pRC1 = NULL;
		pRC1	= GetRebarInfoCycleUpperSlab(0, 0, TRUE, bStt? 0 : -1);
		if(pRC1)
		{
			double dLenRound	= GetLenRebarAtEdge(pRC1->m_Dia, TRUE, 0, FALSE);
			if(dLenRound > (m_dTS - m_dCoverUpper_UpperSlab[0] - m_dCoverLower_UpperSlab[0]))
			{
				xyMatcUpper.y += (m_dTS - dLenRound - m_dCoverUpper_UpperSlab[0]);
				bThinSlab = TRUE;
			}
		}
	}
	
	if(IsBoxType())
	{
		// 배력철근의 전면 배면 위치를 맞춰주기 위해서 xyLower는 전면 배면이 같은 높이가 되어야 한다.
		CTwinVector tvWallIn, tvWallOut;
		tvWallIn		= GetTvOffset_OutWall(0, bStt, TRUE, bVertDir);
		tvWallOut		= GetTvOffset_OutWall(0, bStt, FALSE, bVertDir);
		CDPoint xyLowerIn	= GetXyMatchLineAndLowerSlab(tvWallIn.m_v1, CDPoint(0, 1), 0, m_dTS_Lower);
		CDPoint xyLowerOut	= GetXyMatchLineAndLowerSlab(tvWallOut.m_v1, CDPoint(0, 1), 0, m_dTS_Lower);

		double dDiff = bInner? (xyLowerOut.y - xyLowerIn.y) : 0;
		CDPoint xyLower	= bInner? xyLowerIn : xyLowerOut;
		// 기둥 높이는 전면배면이 같아야 기본값을 상하대칭을로 맞출수있기 때문에 외측을 기준으로 해주자.
		dLenWall	= (xyMatcUpper.y - xyLower.y) + (bThinSlab? 0 : m_dCoverLower_UpperSlab[0]) + m_dCoverUpper_LowerSlab[0];
		dRebarOffset = m_dCoverUpper_LowerSlab[0] + 100.0;

		// 외측일경우 하단 단부 라운드위치에 추가
		if(!bInner)
		{
			CRebarInfoCycle *pRC	= GetRebarInfoCycleLowerSlab(0, 0, FALSE, bStt ? 0 : -1);
			if(pRC)
			{
				//이음이 하부슬래브의 하면의 이음이 없을 경우 위치를 end로 설정해준다.
				double dYRcMid = bStt? pRC->m_xyMid2.y : pRC->m_xyMid1.y;
				if(!bStt && GetCountJointMainRebarLowerSlab(0, 0, FALSE, 0) == 0)
					dYRcMid = pRC->m_xyMid2.y;				

				double dDiffH = (dYRcMid) - (xyLower.y - m_dTS_Lower + m_dCoverLower_LowerSlab[0]);
				dLenRound	= GetLenRebarAtEdge(pRC->m_Dia) + dDiffH;
				pPlace->m_xyArr.Add(CDPoint(1, dLenRound));

				double dFirstDist = m_dTS_Lower - m_dCoverUpper_LowerSlab[0] - m_dCoverLower_LowerSlab[0] - dLenRound + dRebarOffset + dDiff;
				pPlace->m_xyArr.Add(CDPoint(1, dFirstDist));
				// 벽체철근 라운드 상단부터 기초 상면 철근까지 ////////////////////////////////////
			}
		}
		else 
		{
			dLenRound = 0;
			dLengInnerFirst = m_dTS_Lower - m_dCoverUpper_LowerSlab[0] - m_dCoverLower_LowerSlab[0] - dLenRound + dRebarOffset + dDiff;
		}
	}
	else
	{
		CFootingApp *pFooting	= bStt ? &m_footingStt : &m_footingEnd;

		// 벽체 높이 구하기 위해서만 사용.
		CTwinVector tvLower;
		pFooting->m_tvArrFront.GetTvByInfo("기초하면", tvLower);
		if(bThinSlab)
			dLenWall	= (xyMatcUpper.y - tvLower.m_v1.y) - pFooting->GetHeight() + pFooting->m_dCoverUpper[0];
		else
			dLenWall	= (xyMatcUpper.y - tvLower.m_v1.y) - pFooting->GetHeight() + m_dCoverLower_UpperSlab[0] + pFooting->m_dCoverUpper[0];

		// 벽체철근 라운드 상단부터 기초 상면 철근까지 ////////////////////////////////////
		CRebarInfoCycle *pRC	= GetRebarInfoCycleOutWall(0, 0, bStt, bInner, 0);
		if(pRC)
		{
			dLenRound	= pRC->m_xyMid2.y - pRC->m_xyMid1.y;
		}
		else
		{
			pRC	= GetRebarInfoCycleUpperSlab(0, 0, TRUE, 0);
			if(IsMainRebarJointUpperSlabAndOutWall(pRC, bStt))
			{
				dLenRound	= GetLenRebarAtEdge(pRC->m_Dia, TRUE, 0, FALSE);
			}
		}

		//Issue Numer: 27652
		dRebarOffset = pFooting->m_dCoverUpper[0] + 100.0;

		pPlace->m_xyArr.Add(CDPoint(1, pFooting->GetHeight() - pFooting->m_dCoverUpper[0] - pFooting->m_dCoverLower[0] - dLenRound + dRebarOffset));
		// 벽체철근 라운드 상단부터 기초 상면 철근까지 ////////////////////////////////////
	}
	
	// 기초와 상부슬래브 사이에 대해서 배근 //////////////////////////////////////
	nCount	= (long)(dLenWall / dCTC);
	if(bThinSlab) 
		dRemain	= dLenWall - (dCTC * nCount) - dRebarOffset;
	else
		dRemain	= dLenWall - (dCTC * nCount) - dRebarOffset;

	if(dRemain < MIN_LEN_BLOCK)
	{
		dRemain += dCTC;
		nCount --;
	}

	// 전면과 배면의 높이가 같지 않은 종단경사가 있는 교량이라면 대칭을 맞출수 없다.. 그냥 상단으로 몰아주자.
	// 하부 슬래브가 경사라면 
// 	if(dRemain/2 < MIN_LEN_BLOCK)
// 	{
// 		dRemain += dCTC;
// 		nCount --;
// 	}
// 	pPlace->m_xyArr.Add(CDPoint(1, Round(dRemain/2, 0)));
	if(IsBoxType() && bInner)
	{
		// 하부헌치 높이 빼주자.
		long nCntHunch = 0;//static_cast<long>((bStt? m_dWSHH : m_dWEHH) / dCTC); //ARCBRIDGE-2763 Box형 하부에 따로 뺄 이유는 없으므로 추후 문제가 발견될시 주석 살림
		pPlace->m_xyArr.Add(CDPoint(1, Round(dLengInnerFirst + nCntHunch * dCTC, 0)));
		nCount -= nCntHunch;
	}

	// dCTC에 대해서는 지점부 간격과 센타부 간격으로 다시 조정 해야 된다.
	long nCount1	= (long)(m_bSameOffsetPlaceTAndCBlock ? 0 : nCount/3 + nCountOverLap * sw);
	long nCount3	= (long)(m_bSameOffsetPlaceTAndCBlock ? 0 : nCount/3 + nCountOverLap * sw);
	if(nCount < 8)
	{

		// 단면 높이가 작아서 2구간이 안생길수도 있으니 조정해주자.
		nCount1	= (long)(m_bSameOffsetPlaceTAndCBlock ? 0 : 2);
		nCount3	= (long)(m_bSameOffsetPlaceTAndCBlock ? 0 : 2);
	}
	long nCount2	= nCount - nCount1 - nCount3;
	if(nCount1 < 0 || nCount2 < 0 || nCount3 < 2)
	{
		pPlace->m_xyArr.Add(CDPoint(nCount, dCTC));
	}
	else
	{
		pPlace->m_xyArr.Add(CDPoint(nCount1*(dCTC/dCTCOfJijum), dCTCOfJijum));
		pPlace->m_xyArr.Add(CDPoint(nCount2*(dCTC/dCTCOfCenter), dCTCOfCenter));
		pPlace->m_xyArr.Add(CDPoint(nCount3*(dCTC/dCTCOfJijum), dCTCOfJijum));
	}
	
	if(Compare(dRemain, 0.0, _T(">"), 0.1))
	{
		pPlace->m_xyArr.Add(CDPoint(1, dRemain));
	}

	// 외측일경우 단부 라운드 아래쪽에 하나 더 넣어 준다.
	if(!bInner && bThinSlab == FALSE)
	{
		CRebarInfoCycle *pRC	= GetRebarInfoCycleUpperSlab(0, 0, TRUE, bStt ? 0 : -1);
		if(pRC)
		{
			double dYRcMid = bStt ? pRC->m_xyMid1.y : pRC->m_xyMid2.y;
			if(bStt == FALSE && GetCountJointMainRebarUpperSlab(0, 0, TRUE, -1) == 0)
				dYRcMid = pRC->m_xyMidExt.y;				

			double dLastDist = 0;
			if(bStt)
			{
				dLastDist = Round(dYRcMid- xyMatcUpper.y - m_dCoverLower_UpperSlab[0], 0);
			}
			else
			{
				dLastDist = Round(dYRcMid - xyMatcUpper.y - m_dCoverLower_UpperSlab[0], 0);
			}
			if(dLastDist > dCTC/2)
				pPlace->m_xyArr.Add(CDPoint(1, dLastDist));
			else
			{
				long nLast = pPlace->m_xyArr.GetSize()-1;
				CDPoint xyLast = pPlace->m_xyArr.GetAt(nLast);
				xyLast.y += dLastDist;
				pPlace->m_xyArr.SetAt(nLast, xyLast);
			}
		}
	}
	// 기초와 상부슬래브 사이에 대해서 배근 //////////////////////////////////////

	// 내측일때는 마지막 철근 하나를 제거해야 된다. 
	if(bInner)
	{
		long nSize	= pPlace->m_xyArr.GetSize();
		if(nSize > 0)
		{
			CDPoint xyR	= pPlace->m_xyArr.GetAt(nSize-1);
			if(xyR.x > 1)
			{
				xyR.x --;
				pPlace->m_xyArr.SetAt(nSize-1, xyR);
			}
			else
			{
				pPlace->m_xyArr.RemoveAt(nSize-1);

				/*double dTotVertLen = 0;
				CDPoint xyVert;
				for (long nIdx =0; nIdx < pPlace->m_xyArr.GetSize(); nIdx++)
				{
					xyVert = pPlace->m_xyArr.GetAt(nIdx);
					dTotVertLen += xyVert.x * xyVert.y;
				}
				double dLastDist = xyVert.x >0? xyVert.y : 0;
				dTotVertLen -= (xyVert.x * xyVert.y);
				
				double dThickCover = tvWall.GetXyTop().y - xyMatcUpper.y - m_dCoverLower_UpperSlab[0];
				double dVertWall = tvWall.GetVerLength() - dThickCover;
				double dRemain = dVertWall - dTotVertLen;

				if(dRemain < 0 )
				{
					pPlace->m_xyArr.RemoveAt(nSize-1);
					nSize	= pPlace->m_xyArr.GetSize();
					if(nSize > 0)
					{
						xyR	= pPlace->m_xyArr.GetAt(nSize-1);
						xyR.x --;
						pPlace->m_xyArr.SetAt(nSize-1, xyR);
					}
				}			
				else if(dLastDist > dRemain)
				{
					pPlace->m_xyArr.RemoveAt(nSize-1);
				}*/
			}
		}
	}

	// 거리가 0이되는 구간과 최소 간격 제거
	pPlace->m_nCountBlock		= pPlace->m_xyArr.GetSize();
	pPlace->RemoveZeroCount();
	pPlace->ModifyPlaceRebarByMinLimits();
	pPlace->m_nCountBlock		= pPlace->m_xyArr.GetSize();


	// 브라켓 철근 지름 권고안 해줌
	m_dDiaRebarSupport_Bracket[stt]	= 19;
}


// 상부슬래브 전단철근 권고안
void CRcBridgeRebar::SetDataDefaultRebarShear_VertSection_UpperSlab(BOOL bLowerSlab)
{
	CPlaceRebarByBlock *pPlace	= bLowerSlab? &m_placeByBlock_ShearRebar_LowerSlab : &m_placeByBlock_ShearRebar_UpperSlab;
	pPlace->m_xyArr.RemoveAll();

	BOOL bVertDir	= IsVertDir();
	// 시작점은 시점벽체 외측부나 시점 부터 시작.
	// 각 벽체(외측벽체 포함)바깥쪽에 있는 모든 배력철근의 배치를 따라감.
	// 배력철근 좌표 구함.
	CDPointArray xyArrSup;
	if(bLowerSlab)
		GetXyRebarSupport_VertSection_LowerSlab(xyArrSup, FALSE, 0);
	else
		GetXyRebarSupport_VertSection_UpperSlab(xyArrSup, TRUE, 0);

	// 신축이음 있는 곳의 배력철근은 제거함
	if(IsBlockOut(TRUE) || IsBlockOut(FALSE))
	{
		CTwinVector tvUpperFlexibleJoint	= GetTvOffset_UpperSlab(0, TRUE, -1, -1, bVertDir, TRUE);
		CDPoint xyMatch(0, 0);
		long i = 0; for(i = 0; i < xyArrSup.GetSize(); i++)
		{
			if(!GetXyMatchSegAndLine(tvUpperFlexibleJoint.m_v1, tvUpperFlexibleJoint.m_v2, xyArrSup.GetAt(i), CDPoint(0, 1), xyMatch))
			{
				xyArrSup.RemoveAt(i);
				i--;
			}
		}
	}

	// 각 벽체 안쪽에 있는 배력철근만 제거함.

	// 각 벽체의 시작점과 끝점을 모두 구함 /////////////////////////
	CDPointArray xyArrLimit;	// 각 벽체의 시작점과 끝점(x : 시작점, y : 끝점)
	// 시점측 벽체
	if(IsOutWall(TRUE))
	{
		CDPoint vAngJijum = GetAngleJijum(0);
		double dWS = bVertDir ? m_dWS : m_dWS/vAngJijum.y;
		xyArrLimit.Add(CDPoint(m_dStationBridgeStt-dWS, m_dStationBridgeStt));
	}
	// 각 내측 벽체들.
	long nCountInWall	= GetCountInWall();
	for(long wall = 0; wall < nCountInWall; wall++)
	{
		CWallApp *pWall	= GetInWall(wall);
		if(pWall)
		{
			if(pWall->m_bIs)
			{
				if(pWall->m_nType == WALL_TYPE_V)
				{
					CTwinVector tvLeft, tvRight;
					pWall->m_tvArrFront.GetTvByInfo("벽체좌측팔상면", tvLeft);
					pWall->m_tvArrFront.GetTvByInfo("벽체우측팔상면", tvRight);
					xyArrLimit.Add(CDPoint(tvLeft.GetXyLeft().x, tvRight.GetXyRight().y));
				}
				else 
				{
					double dSta	= GetStationOnJijum(wall+1, 0, bVertDir);
					xyArrLimit.Add(CDPoint(dSta-pWall->m_dW/2, dSta+pWall->m_dW/2));
				}
			}
			else
			{
				double dSta	= GetStationOnJijum(wall+1, 0, bVertDir);
				long nIdxHunch	= GetIdxHunchInWall(wall, TRUE);
				xyArrLimit.Add(CDPoint(dSta-m_dWL[nIdxHunch][iUPPER], dSta+m_dWR[nIdxHunch][iUPPER]));
			}
		}
	}
	// 종점 벽체
	if(IsOutWall(FALSE))
	{
		CDPoint xyEnd = GetXySectionSttEnd(FALSE, 0, bVertDir);
		CDPoint vAngJijum = GetAngleJijum(GetCountJijum()-1);
		double dWE = bVertDir ? m_dWE : m_dWE/vAngJijum.y;
		xyArrLimit.Add(CDPoint(xyEnd.x, xyEnd.x+dWE));
	}
	/////////////////////////////////////////////////////////////////
	
	// 위에서 구한 범위 안에 드는것들은 모두 제거
	CDPoint xy(0, 0);
	CDPoint xyLimit(0, 0);
	BOOL bOK	= TRUE;
	long nSizeLimit	= xyArrLimit.GetSize();
	if(m_nTypeBridge != BRIDGE_TYPE_ARCH)
	{
		long sup(0), limit(0);
		for(sup = 0; sup < xyArrSup.GetSize(); sup++)
		{
			xy	= xyArrSup.GetAt(sup);
			bOK	= FALSE;
			for(limit = 0; limit < nSizeLimit; limit++)
			{
				xyLimit	= xyArrLimit.GetAt(limit);
				if(xyLimit.x > xyLimit.y) GetSwap(xyLimit.x, xyLimit.y);
				if(Compare(xy.x, xyLimit.x, ">") && Compare(xy.x, xyLimit.y, "<"))
				{
					bOK	= TRUE;
					break;
				}
			}

			if(bOK)
			{
				xyArrSup.RemoveAt(sup);
				sup--;
			}
		}
	}

	// 벽체가 없는경우는 시작배력철근 2개 제거하고, 마지막철근도 2개 제거함.
	// 전단철근이 세번째 부터 들어갈 것이기 때문
	if(!IsOutWall(TRUE))
	{
		if(xyArrSup.GetSize() > 0)
		{
			xyArrSup.RemoveAt(0, 1);
		}
	}

	if(!IsOutWall(FALSE))
	{
		if(xyArrSup.GetSize() > 0)
		{
			xyArrSup.RemoveAt(xyArrSup.GetSize()-2, 1);
		}
	}

	// 배력근의 2개이상마다 전단철근이 들어가야 된다면 여기서 뺀다. ///////////////////
	long nOffset	= (long)(m_dCTC_ShearRebar[bLowerSlab ? iLOWER : iUPPER] / m_dCTC_SupportRebar[bLowerSlab ? iLOWER : iUPPER]);
	if(nOffset > 1)
	{
		CDPointArray xyArrTmp;

//		long i = 0; for(i = 0; i < xyArrSup.GetSize()-(nOffset-1); i+=nOffset)
//		{
//			xyArrTmp.Add(xyArrSup.GetAt(i));
//		}

		// 간격이 바뀌면서 어긋나는것을 최대한 맞춰보자.
		long nIndex = -1;
		double dDistPrev = 0;
		for(long ix=0; ix<xyArrSup.GetSize(); ix++)
		{
			nIndex++;
			double dDist = 0;
			if(ix > 0 && ix < xyArrSup.GetSize())
			{
				dDist = ~(xyArrSup.GetAt(ix-1) - xyArrSup.GetAt(ix));
				// (ARCBRIDGE-3576) 벽체 위치에서 빠진 부분이 있기 때문에 무조건 한칸씩 띄울수는 없다.
				if(m_dCTC_ShearRebar[bLowerSlab ? iLOWER : iUPPER] < dDist)
				{
					nIndex = 0;
					dDistPrev = dDist;
				}
				if(nIndex % nOffset != 0)
				{
					dDistPrev = dDist;
					continue;
				}
			}

			if(Compare(dDist, dDistPrev, _T("="), 0.5) == FALSE) ix++;
			if(ix >= xyArrSup.GetSize()) break;

			xyArrTmp.Add(xyArrSup.GetAt(ix));
			dDistPrev = dDist;
		}

		xyArrSup.RemoveAll();
		xyArrSup	= xyArrTmp;
	}
	////////////////////////////////////////////////////////////////////////////////////


	// 배력철근에 시점벽체 좌측 좌표하나 추가해줌.(전단철근이 시작되는 위치기 때문)
	CTwinVector tv;
	CTwinVectorArray *pTvArrVertSection	= bVertDir ? &m_tvArrVertSection_Vert_Center[m_nTypeJongdanForRebar] : &m_tvArrVertSection_Ang_Center[m_nTypeJongdanForRebar][0];;
	if(pTvArrVertSection)
		pTvArrVertSection->GetTvByInfo(IsOutWall(TRUE) ? "시점브라켓상면" : "시점슬래브측면", tv);
	else
		m_tvArrVertSection.GetTvByInfo(IsOutWall(TRUE) ? "시점브라켓상면" : "시점슬래브측면", tv);

	xyArrSup.InsertAt(0, CDPoint(tv.m_v2.x, 0));
	

	// 범위안에 드는 것을 제거한 배력철근 간격을 분석해서 전단철근 간격으로 치환한다.
	CRebarPlacing rb;
	rb.ConvertPointArrayToOffsetInfo(xyArrSup, pPlace->m_xyArr, 0);
	
	pPlace->m_nCountBlock	= pPlace->m_xyArr.GetSize();
}

// 상부슬래브 전단철근 권고안 통합
// nType -> 0 : 상부슬래브, 1 : 시점측 벽체, 2 : 종점측 벽체, 3 : 내측벽체, 4 : 기초, 5 : 브라켓, 6 : 리브, 9 : 하부슬래브
void CRcBridgeRebar::SetDataDefaultRebarShear_VertSection_Std(long nType, long nIdxFooting)
{
	// 상부 슬래브
	if(nType == 0 || nType == -1) 
	{
		SetDataDefaultRebarShear_VertSection_UpperSlab();
	}
	
	// 시점측 벽체
	if(nType == 1 || nType == -1)
	{
		SetDataDefaultRebarShear_VertSection_OutWall(TRUE);
	}
	
	// 종점측 벽체
	if(nType == 2 || nType == -1)
	{
		SetDataDefaultRebarShear_VertSection_OutWall(FALSE);
	}
	

	// 내측벽체
	if(nType == 3 || nType == -1)
	{
		long nCountInWall	= GetCountInWall();
		for(long wall = 0; wall < nCountInWall; wall++)
		{
			CWallApp *pWall	= GetInWall(wall);
			if(pWall)
			{
				pWall->SetDataDefaultRebarShear_VertSection();
			}
		}
	}

	// 기초
	if(nType == 4 || nType == -1)
	{
		long nIdxCurFooting	= 0;
		long j = 0; for(j = 0; j <= m_nQtyJigan; j++)
		{
			CFootingApp *pFooting	= GetFootingByJijumNumber(j);
			if(!pFooting) continue;
			if(!pFooting->m_bIs) continue;

			if(nIdxFooting == -1 || nIdxFooting == nIdxCurFooting || nType == -1)
			{
				if(j == 0 || j == m_nQtyJigan)
				{
					BOOL bStt	= j == 0;
					if(IsOutWall(bStt))
					{
						CWallApp wall;
						// 기초 배근 입력은 각방향 단면으로 받으니까 직거리 Station을 만들어주자.
						double dStaVert = GetStationOnJijum(j, 0, TRUE) + (bStt ? -m_dWS/2 : m_dWE/2);
						MakeWallByOutWall(wall, j==0, FALSE, FALSE, FALSE, FALSE, dStaVert);
						wall.SetDataDefaultRebarShearFront_Footing(TRUE);

						CFootingApp *pFooting	= bStt ? &m_footingStt : &m_footingEnd;
						pFooting->m_placeByBlock_Shear_Front	= wall.m_footing.m_placeByBlock_Shear_Front;
					}
				}
				else
				{
					CWallApp *pWall	= GetInWall(j - 1);
					if(!pWall) continue;
					if(!pWall->m_bIs) continue;
					pWall->SetDataDefaultRebarShearFront_Footing(TRUE);
				}
			}

			nIdxCurFooting++;
		}
	}

	// 브라켓
	if(nType == 5 || nType == -1)
	{
		SetDataDefaultRebarShear_VertSection_Bracket();
	}

	// 리브
	if(nType == 6 || nType == -1)
	{
		SetDataDefaultRebarShear_VertSection_ArchRib();
	}

	// 하부슬래브
	if(nType == 9 || nType == -1)
	{
		SetDataDefaultRebarShear_VertSection_UpperSlab(TRUE);
	}
}

// 외측벽체 전단철근 권고안
void CRcBridgeRebar::SetDataDefaultRebarShear_VertSection_OutWall(BOOL bStt)
{
	long stt	= bStt ? iSTT : iEND;
	CPlaceRebarByBlock *pPlace	= &m_placeByBlock_ShearRebar_OutWall[stt];
	pPlace->m_xyArr.RemoveAll();
	pPlace->m_nCountBlock	= 0;
	if(!IsOutWall(bStt)) return;

	BOOL bVertDir	= IsVertDir();
	// (39435) 현재 종단면과 m_tvArrVerSection이 가지고 있는 단면이 맞지 않아 기본값이 잘못되는경우가...
	GetTvVertSection(0, !bVertDir);

	// 외측벽체 배력철근에서 상부슬래브하면과 기초상면 사이에 있는 철근에 배치됨.
	CTwinVector tvWall		= GetTvOffset_OutWall(0, bStt, FALSE, bVertDir);
	CDPoint xyTop			= GetXyMatchLineAndSlabUpper(tvWall.m_v1, CDPoint(0, 1), 0, m_dTS);
	CDPoint xyBottom(0,0);
	double dYBot = 0;

	if(IsBoxType())
	{
		xyBottom	= GetXyMatchLineAndLowerSlab(tvWall.m_v1, CDPoint(0, 1), 0, m_dTS_Lower, bVertDir);
		dYBot		= xyBottom.y - m_dTS_Lower;

		// Box타입의 하단은 전면/배면 비대칭 이기때문에 전면 배력근이 있는 구간부터.
		CDPointArray xyArrSupIn;
		GetXyRebarSupport_VertSection_OutWall(xyArrSupIn, bStt, TRUE, 0, bVertDir? -1 : 0);
		if(xyArrSupIn.GetSize() > 0)
		{
			xyBottom.y = max(xyBottom.y, xyArrSupIn.GetAt(0).y - 10);
			xyTop.y = min(xyTop.y, xyArrSupIn.GetAt(xyArrSupIn.GetSize()-1).y + 10);
		}
	}
	else
	{
		CFootingApp *pFooting	= bStt ? &m_footingStt : &m_footingEnd;
		CTwinVector tvLower;
		pFooting->m_tvArrFront.GetTvByInfo("기초하면", tvLower);
		xyBottom	= CDPoint(tvWall.m_v1.x, tvLower.m_v1.y+pFooting->GetHeight());
		dYBot		= tvLower.m_v1.y;
	}

	// 상부슬래브하면과 기초상면 사이에 있는 철근만 빼고 모두 제거
	CDPoint xy(0, 0);
	CDPointArray xyArrSup;
	GetXyRebarSupport_VertSection_OutWall(xyArrSup, bStt, FALSE, 0, bVertDir? -1 : 0);
	long i = 0; for(i = 0; i < xyArrSup.GetSize(); i++)
	{
		xy	= xyArrSup.GetAt(i);
		if(xy.y <= xyBottom.y || xy.y >= xyTop.y)
		{
			xyArrSup.RemoveAt(i);
			i--;
		}
	}

	// 배력근의 2개이상마다 전단철근이 들어가야 된다면 여기서 뺀다. ///////////////////
	long nOffset	= (long)(m_dCTC_ShearRebarOutWall[stt] / m_dCTC_SupportRebarOutWall[stt]);
	if(nOffset > 1)
	{
		CDPointArray xyArrTmp;

//		long i = 0; for(i = 0; i < xyArrSup.GetSize()-(nOffset-1); i+=nOffset)
//		{
//			xyArrTmp.Add(xyArrSup.GetAt(i));
//		}

		// 간격이 바뀌면서 어긋나는것을 최대한 맞춰보자.
		long nIndex = -1;
		double dDistPrev = 0;
		long nSizeSup = xyArrSup.GetSize();
		for(long ix=0; ix<nSizeSup; ix++)
		{
			nIndex++;
			double dDist = 0;
			if(ix > 0)
			{
				dDist = ~(xyArrSup.GetAt(ix-1) - xyArrSup.GetAt(ix));
				if(nIndex % nOffset != 0)
				{
					dDistPrev = dDist;
					continue;
				}
			}

			if(Compare(dDist,dDistPrev,_T("="),0.5) == FALSE && ix < nSizeSup-1) ix++;

			xyArrTmp.Add(xyArrSup.GetAt(ix));
			dDistPrev = dDist;
		}

		xyArrSup.RemoveAll();
		xyArrSup	= xyArrTmp;
	}
	////////////////////////////////////////////////////////////////////////////////////

	// 배력철근에 기초하면 좌표하나 추가해줌(전단철근이 시작되는 위치기 때문)
	xyArrSup.InsertAt(0, CDPoint(tvWall.m_v1.x, dYBot));
	

	// 범위안에 드는 것을 제거한 배력철근 간격을 분석해서 전단철근 간격으로 치환한다.
	CRebarPlacing rb;
	rb.ConvertPointArrayToOffsetInfo(xyArrSup, pPlace->m_xyArr, 1);
	pPlace->m_nCountBlock	= pPlace->m_xyArr.GetSize();	
}

// 내측벽체 전단철근 권고안은 외측벽체 전단철근 권고안과 방법이 동일함.
// 원래 내측벽체 권고안은 CWallApp에 포함되어야 하지만, 권고안은 다른 개체들과 상관관계를 파악해야 되기 때문에
// 가능하다면 최상위 개체에서 하위 개체까지 권고안을 해준다.
// void CRcBridgeRebar::SetDataDefaultRebarShear_VertSection_InWall(long nIdxInWall)
// {
// 	CWallApp *pWall	= GetInWall(nIdxInWall);
// 	if(!pWall) return;
// 	if(pWall->m_bTopIsColumn) return;
// 
// 	CPlaceRebarByBlock *pPlace	= &pWall->m_placeByBlock_ShearRebar;
// 	pPlace->m_xyArr.RemoveAll();
// 	pPlace->m_nCountBlock	= 0;
// 
// 	// 외측벽체 배력철근에서 상부슬래브하면과 기초상면 사이에 있는 철근에 배치됨.
// 	CFootingApp *pFooting	= &pWall->m_footing;
// 	CTwinVector tvWall		= pWall->GetTvOffset_Front(0, 0, FALSE, TRUE, TRUE, TRUE);
// 	CTwinVector tvLower;
// 	pFooting->m_tvArrFront.GetTvByInfo("기초하면", tvLower);
// 
// 	CDPoint xyTop			= GetXyMatchLineAndSlabUpper(tvWall.m_v1, CDPoint(0, 1), 0, m_dTS);
// 	CDPoint xyBottom		= CDPoint(tvWall.m_v1.x, tvLower.m_v1.y+pFooting->GetHeight());
// 
// 	// 상부슬래브하면과 기초상면 사이에 있는 철근만 빼고 모두 제거
// 	CDPoint xy(0, 0);
// 	CDPointArray xyArrSup;
// 	pWall->GetXyRebarSupport_Front(xyArrSup, TRUE, 0);
// 	long i = 0; for(i = 0; i < xyArrSup.GetSize(); i++)
// 	{
// 		xy	= xyArrSup.GetAt(i);
// 		if(xy.y <= xyBottom.y || xy.y >= xyTop.y)
// 		{
// 			xyArrSup.RemoveAt(i);
// 			i--;
// 		}
// 	}
// 
// 	// 배력철근에 기초하면 좌표하나 추가해줌(전단철근이 시작되는 위치기 때문)
// 	xyArrSup.InsertAt(0, CDPoint(tvWall.m_v1.x, tvLower.m_v1.y));
// 	
// 
// 	// 범위안에 드는 것을 제거한 배력철근 간격을 분석해서 전단철근 간격으로 치환한다.
// 	CRebarPlacing rb;
// 	rb.ConvertPointArrayToOffsetInfo(xyArrSup, pPlace->m_xyArr, 1);
// 	pPlace->m_nCountBlock	= pPlace->m_xyArr.GetSize();	
// }

// 상부슬래브 거더부 스트럽 철근 권고안.
// bDefaultByNum : TRUE -> 스트럽 개수에 따라 권고안을 함.
//                 FALSE -> 스트럽 개수를 2개로 맞추고 권고안을 함. (위치,너비 권고안 같이 함)

// 1. 스트럽 기준이되는 점철근 개수를 짝수로 맞춘다.(홀수일 경우 가운데 철근 제거)
// 2. 시작위치 : 점철근/스트럽개수
// 3. 철근길이 : 점철근/스트럽개수 + 1
// 4. 위와 같이 스트럽 개수만큼 반복하되, 스트럽 철근이 홀수개일 경우 가운데 스트럽 철근에만
//    철근길이를 +1해주고 다음 철근의 시작위치를 +1해준다. 
// BOOL bOnlyOrg : 거더 기준 위치 권고안 만 한다.
void CRcBridgeRebar::SetDataDefaultRebarGirder(long nJ, BOOL bDefaultByNum, BOOL bOnlyOrg, BOOL bStt, BOOL bLeft, BOOL bGagak, BOOL bJongGirder, BOOL bApplyVert, BOOL bUpperSlabGirder)
{
	if(bJongGirder)
	{
		if(!IsGirderRebarJong(bStt, bLeft, bGagak)) return;
	}
	else
	{
		if(!IsGirderRebar(nJ, bUpperSlabGirder)) return;
	}
	
	// 사용할 스트럽.
	CGirderSectionRebar *pGirderRB	= bJongGirder ? GetGirderRebarJong(bStt, bLeft, bGagak) : &m_SlabGirderRebar[bUpperSlabGirder ? iUPPER : iLOWER][nJ];
	if(bJongGirder)
	{
		pGirderRB->m_nType		= bLeft ? 0 : 1;
	}
	else
	{
		if(nJ == 0 || nJ == m_nQtyJigan)
			pGirderRB->m_nType	= nJ == 0 ? 0 : 1;
		else
			pGirderRB->m_nType	= 2;
	}

	if(!bDefaultByNum || bOnlyOrg)
	{
		if(nJ == 0 || nJ == m_nQtyJigan || bJongGirder)
		{
			CTwinVectorArray tvArrLower;
			CString sLower	= _T("");
			if(bJongGirder)
			{
				GetTvGirderLowerJong(tvArrLower, bStt, bLeft, bGagak);
				if(bOnlyOrg || !bDefaultByNum)
					pGirderRB->m_xyOrg = bLeft ? tvArrLower.GetAt(0).GetXyLeft() : tvArrLower.GetAt(tvArrLower.GetSize()-1).GetXyRight();
			}
			else
			{
				if(nJ == 0 || nJ == m_nQtyJigan)
				{
					sLower	= nJ == 0 ? "시점슬래브측면" : "종점슬래브측면";//IsHunch(nJ) ? "시점헌치하면" : "슬래브하면";
				}
				else
				{
					long nCountInHunch	= GetIdxHunchInWall(m_nQtyJigan, FALSE) + 1;
					if(IsHunch(nJ))
						sLower	= "종점헌치하면";
					else
					{
						if(m_nQtyJigan == 1)
							sLower	= "슬래브하면";
						else
							sLower.Format("%d번째내측헌치우측슬래브하면", nCountInHunch);
					}
				}
				CTwinVector tvLower	= m_tvArrVertSection.GetTvByInfo(sLower).Sort(TRUE);
				if(bOnlyOrg || !bDefaultByNum)
					pGirderRB->m_xyOrg	= nJ == 0 ? tvLower.GetXyLeft() : tvLower.GetXyRight();
			}

			
			if(!bDefaultByNum && !bOnlyOrg)
			{
				double dCover	= GetCoverSide_UpperSlab(0);
				if(bJongGirder)
				{
					pGirderRB->m_dDist		= dCover;
					pGirderRB->m_dWidthL	= 900 - dCover * 2;

					pGirderRB->m_dCoverSide	= 0;
					//pGirderRB->m_nType		= bLeft ? 0 : 1;
				}
				else
				{
					// 슈를 기준으로 권고안 하자.
					CJijum *pJ	= GetJijum(nJ);
					pGirderRB->m_dDist		= pJ ? (nJ == 0 ? pJ->m_dLengthSlabToShoe[1] : pJ->m_dLengthSlabToShoe[0]) : 550;
					pGirderRB->m_dWidthL	= 900 - (GetCoverSide_UpperSlab(0) * 2);
					pGirderRB->m_dDist		-= pGirderRB->m_dWidthL/2;
					pGirderRB->m_dCoverSide	= 0;
					//pGirderRB->m_nType		= nJ == 0 ? 0 : 1;
				}
			}
		}
		else
		{
			long nIdxInWall	= nJ - 1;
			CTwinVector tvLeft, tvRight;
			long nIdxHunch	= GetIdxHunchInWall(nIdxInWall, TRUE);
			CString sLeft	= _T("");
			CString sRight	= _T("");
			if(nIdxHunch < 0) return;

			if(bUpperSlabGirder)
			{
				sLeft.Format("%d번째내측헌치아래면좌측", nIdxHunch+1);
				sRight.Format("%d번째내측헌치아래면우측", nIdxHunch+1);
			}
			else
			{
				sLeft.Format("%d번째내측하부헌치윗면좌측", nIdxHunch+1);
				sRight.Format("%d번째내측하부헌치윗면우측", nIdxHunch+1);
			}

			m_tvArrVertSection.GetTvByInfo(sLeft, tvLeft);
			m_tvArrVertSection.GetTvByInfo(sRight, tvRight);

			if(bOnlyOrg || !bDefaultByNum)
			{
				BOOL bVertDir	= bApplyVert ? IsVertDir() : FALSE; // 거더철근은 무조건 사거리로 입력
				pGirderRB->m_xyOrg = CDPoint(GetStationShoeOnJijum(nJ, 0, 0, bVertDir), tvLeft.GetXyRight().y);
			}

			if(!bDefaultByNum && bOnlyOrg)
			{
				pGirderRB->m_dDist		= 0;
				if(nJ > 0 && nJ < m_nQtyJigan && !bJongGirder)
				{
					SetDataDefaultWidthGirder(nJ, bStt, TRUE, FALSE, FALSE, bUpperSlabGirder);
					pGirderRB->m_dCoverSide	= m_dCoverUpper_UpperSlab[0]; //슬래브상면 피복으로 대체
				}
				else
				{
					pGirderRB->m_dWidthL	= tvLeft.GetHorLength() < 600 ? tvLeft.GetHorLength() : 600;
					pGirderRB->m_dWidthR	= tvRight.GetHorLength() < 600 ? tvRight.GetHorLength() : 600;
					pGirderRB->m_dCoverSide	= 100;
				}
				
				//pGirderRB->m_nType		= 2;
			}
		}
	}

	if(bOnlyOrg) return;

	// 스트럽에 들어가는 점철근구해서 홀수인 경우 가운데 점철근을 제거한다.
	CDPointArray xyArr, xyArrDirApplyScale;
	BOOL iUL = iUPPER;	
	//Upper일떄 xyArr가져올경우에 인자로 iUpper넣으면 경사가져서 xyArr가 오차가 생김. 반듯한 Lower에서 계산
	if(IsBoxType() && bUpperSlabGirder)  iUL = iLOWER;
	
	GetxyRebarSupport_SlabGirder(xyArr, xyArrDirApplyScale, iUL, nJ, bStt, bLeft, bGagak, bJongGirder, bUpperSlabGirder);

	if(xyArr.GetSize() == 0) return;

	// 개수초기화를 해야 되는지..
	if(!bDefaultByNum) pGirderRB->m_nCountStirrup	= 2;
	long stirrup = 0; for(stirrup = 0; stirrup < MAX_REBAR_STIRRUP; stirrup++)
		pGirderRB->m_xyDistStirrup[stirrup] = CDPoint(0, 0);

	pGirderRB->m_dDiaStirrup	= 19;
	long nCountStirrup	= pGirderRB->m_nCountStirrup;
	BOOL bOddStirrup	= (nCountStirrup % 2) == 1;						// 스트럽 철근이 홀수개인지 판단
	BOOL bOddPoint		= (xyArr.GetSize() % 2) == 1;
	if(bOddPoint) 
		xyArr.RemoveAt(xyArr.GetSize()/2);
	long nCountPoint	= xyArr.GetSize();
	if(nCountPoint == 0) return;

	// 개수에 맞게 권고안을 함.
	long nCountPos		= (long)(((double)nCountPoint / (double)nCountStirrup) + 0.5f);	// 다음철근과 이전 철근과의 싲가위치 간격
	long nCountLen		= nCountPos + 1;								// 현 철근의 길이를 판단할 점 철근 개수
	long nLastPos		= 0;											// 마지막으로 놓여진 스트럽 철근의 점 위치
	if(nCountStirrup == 1) nCountLen --;

	CDPoint xyStt		= xyArr.GetAt(0);
	CDPoint xy			= xyStt;
	// 첫번째 스트럽의 시작위치
	xy.x				= 0;
	for(stirrup = 0; stirrup < nCountStirrup; stirrup++)
	{
		if(bOddStirrup)
		{
			if(stirrup == nCountStirrup/2 && nCountStirrup > 1)
			{
				nCountLen++;
				nCountPos++;

				if(bOddPoint)
				{
					nCountLen++;	
					nCountPos++;
				}
			}
		}

		// 스트럽길이 
		if(nLastPos+(nCountLen-1) >= xyArr.GetSize()) break;
		xy.y = (xyArr.GetAt(nLastPos+(nCountLen-1)).x - xyStt.x) - xy.x;

		// 스트럽 데이타 저장
		pGirderRB->m_xyDistStirrup[stirrup]	= xy;

		// 스트럽 시작위치 이동
		if(stirrup < nCountStirrup-1)
		{
			nLastPos	+= nCountPos > 1 ? (nCountPos-1) : 1;
			xy.x		= xyArr.GetAt(nLastPos).x - xyStt.x;
		}

		if(bOddStirrup)
		{
			if(stirrup == nCountStirrup/2 && nCountStirrup > 1)
			{
				nCountLen--;
				nCountPos--;
				if(bOddPoint)
				{
					nCountLen--;	
					nCountPos--;
				}
			}
		}
	}
}

// 스트럽내 주철근 권고안.
void CRcBridgeRebar::SetDataDefaultRebarMainInGirder_Girder(long nJ, BOOL bStt, BOOL bLeft, BOOL bGagak, BOOL bJongGirder, BOOL bUpperSlabGirder)
{
	//if(bUpperSlabGirder && IsBoxType() == FALSE) return;

	if(bJongGirder)
	{
		if(!IsGirderRebarJong(bStt, bLeft, bGagak)) return;
	}
	else
	{
		if(!IsGirderRebar(nJ, bUpperSlabGirder)) return;
	}

	const double dCTCHor	= 100;	// 스트럽내 주철근 권고안시 기본간격(가로)
	const double dCTCVer	= 150;	// 스트럽내 주철근 권고안시 기본간격(세로)
	const double dScaleMin	= 1;	// 기본간격보다 작을 수 있는 최소 간격비율

	CGirderSectionRebar *pGirderRB	= bJongGirder ? GetGirderRebarJong(bStt, bLeft, bGagak) : &m_SlabGirderRebar[bUpperSlabGirder ? iUPPER : iLOWER][nJ];

	// 스트럽 피복/지름 기본값 설정
	// 보통 슬래브 주철근 피복 + 50
	long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
	{
		double dCoverSlabOut = bUpperSlabGirder ? m_dCoverUpper_UpperSlab[0] : m_dCoverLower_LowerSlab[0];
		double dCoverSlabIn  = bUpperSlabGirder ? m_dCoverLower_UpperSlab[0] : m_dCoverUpper_LowerSlab[0];
		double dCoverU	= (dan == 0) ? dCoverSlabOut + 50 : 0;
		double dCoverL	= (dan == 0) ? dCoverSlabIn + 50 : 0;
		double dDiaU	= (dan == 0) ? 25 : 0;
		double dDiaL	= (dan == 0) ? 22 : 0;
		double dDiaS	= 19;

		if(!bJongGirder && nJ == 0 && IsBlockOut(TRUE))
		{
			double dTP	= GetThickPave(FALSE);
			dCoverU += m_fxJointStt.m_dHeight - dTP;
		}
		else if(!bJongGirder && nJ == m_nQtyJigan && IsBlockOut(FALSE))
		{
			double dTP	= GetThickPave(FALSE);
			dCoverU += m_fxJointEnd.m_dHeight - dTP;
		}

		// 피복
		pGirderRB->m_dCoverUpper[dan]	= dCoverU;
		pGirderRB->m_dCoverLower[dan]	= dCoverL;

		// 지름
		pGirderRB->m_dDiaUL[iUPPER][dan]	= dDiaU;
		pGirderRB->m_dDiaUL[iLOWER][dan]	= dDiaL;
		pGirderRB->m_dDiaSide				= dDiaS;
		pGirderRB->m_dDiaSide_I				= dDiaS;
	}

	// 스트럽 주철근은 상부슬래브 윗면과 해당 헌치 아래면을 기준으로 만든다.
	// BOX형 하부슬래이부일경우 tvUpper랑 Lower반대
	CTwinVector tvUpper;	// 상부슬래브 상면
	CTwinVector tvLower;	// 헌치 아래면
	GetTvVirtualRebarGirder(nJ, tvUpper, tvLower, bStt, bLeft, bGagak, bJongGirder, bUpperSlabGirder);
	
	// 가로(하단을 기준으로 권고안 함 - 하단에 치수를 기입하기 때문)
	CRebarPlacing rb;
	double dDist	= tvLower.GetHorLength();
	pGirderRB->m_nB[iLOWER][0]		= (long)(dDist / dCTCHor);
	pGirderRB->m_dC[iLOWER][0]		= dCTCHor;
	pGirderRB->m_dC1[iLOWER][0]	= (dDist - (pGirderRB->m_nB[iLOWER][0] * pGirderRB->m_dC[iLOWER][0]))/2;
	pGirderRB->m_dC2[iLOWER][0]	= pGirderRB->m_dC1[iLOWER][0];

	// 기본간격의 최소비율보다 작은 간격은 아예 기본간격을 더해서 키워준다.
	if(pGirderRB->m_dC1[iLOWER][0] < dCTCHor * dScaleMin)
	{
		if(pGirderRB->m_nB[iLOWER][0] > 0)
		{
			pGirderRB->m_nB[iLOWER][0]-=2;
			pGirderRB->m_dC1[iLOWER][0] += dCTCHor;
			pGirderRB->m_dC2[iLOWER][0] = pGirderRB->m_dC1[iLOWER][0];
		}
	}

	// 가로상면
	pGirderRB->m_nB[iUPPER][0]		= pGirderRB->m_nB[iLOWER][0];
	pGirderRB->m_dC[iUPPER][0]		= pGirderRB->m_dC[iLOWER][0];
	pGirderRB->m_dC1[iUPPER][0]	= pGirderRB->m_dC1[iLOWER][0];
	pGirderRB->m_dC2[iUPPER][0]	= pGirderRB->m_dC2[iLOWER][0];

	//거더 좌우측중 낮은 단면을 기준
	if(bUpperSlabGirder)
		dDist			= min((tvUpper.GetXyRight().y - tvLower.GetXyRight().y), (tvUpper.GetXyLeft().y - tvLower.GetXyLeft().y));
	else
		dDist			= min((tvLower.GetXyRight().y - tvUpper.GetXyRight().y), (tvLower.GetXyLeft().y - tvUpper.GetXyLeft().y));

	pGirderRB->m_nE	= (long)(dDist / dCTCVer);
	pGirderRB->m_dF	= dCTCVer;
	pGirderRB->m_dF1	= (dDist - (pGirderRB->m_nE * pGirderRB->m_dF))/2;
	pGirderRB->m_dF2	= pGirderRB->m_dF1;

	// 기본간격의 최소비율보다 작은 간격은 아예 기본간격을 더해서 키워준다.
	if(pGirderRB->m_dF1 < dCTCVer * dScaleMin)
	{
		if(pGirderRB->m_nE > 0)
		{
			pGirderRB->m_nE--;
			pGirderRB->m_dF1 += dCTCVer/2;
			pGirderRB->m_dF2 = pGirderRB->m_dF1;
		}
	}
}

// 스트럽 주철근의 좌표를 구하기 위한 기준이 되는 상면과하면을 리턴한다.
// BOX형에서 하부슬래이브일경우 상면과 하면이 반대로 리턴한다!!!!.
// 스터럽 주철근은 직거리로 그리자.
void CRcBridgeRebar::GetTvVirtualRebarGirder(long nJ, CTwinVector &tvUpper, CTwinVector &tvLower, BOOL bStt, BOOL bLeft, BOOL bGagak, BOOL bJongGirder, BOOL bUpperSlabGirder)
{
	if(bJongGirder)
	{
		if(!IsGirderRebarJong(bStt, bLeft, bGagak)) return;
	}
	else
	{
		if(!IsGirderRebar(nJ, bUpperSlabGirder)) return;
	}
	
	SetDataDefaultYPosOfGirder(nJ, bStt, bLeft, bGagak, bJongGirder, bUpperSlabGirder);
	CGirderSectionRebar *pGirderRB	= bJongGirder ? GetGirderRebarJong(bStt, bLeft, bGagak) : &m_SlabGirderRebar[bUpperSlabGirder ? iUPPER : iLOWER][nJ];

	// 스트럽 주철근은 상부슬래브 윗면과 해당 헌치 아래면을 기준으로 만든다.
	if(bJongGirder)
	{
		CTwinVectorArray tvArrLower;
		if(!GetTvGirderLowerJong(tvArrLower, bStt, bLeft, bGagak)) return;
		if(bLeft)
		{
			tvLower.m_v1	= tvArrLower.GetAt(0).m_v1;
			tvLower.m_v2	= tvLower.m_v1 + CDPoint(1000, 0);
		}
		else
		{
			tvLower.m_v1	= tvArrLower.GetAt(tvArrLower.GetSize() - 1).m_v2;
			tvLower.m_v2	= tvLower.m_v1 + CDPoint(-1000, 0);
		}
	}
	else
	{
		if(!GetTvHunchLower(tvLower, nJ, TRUE, bUpperSlabGirder)) return;
	}

	CDPoint xyMatch(0, 0);
	
	CDPoint xyOrg	= pGirderRB->m_xyOrg;
	if(pGirderRB->m_nType == 0)
		xyOrg.x += pGirderRB->m_dDist;
	else if(pGirderRB->m_nType == 1)
		xyOrg.x -= pGirderRB->m_dDist;

	GetXyMatchLineAndLine(tvLower.m_v1, tvLower.GetXyDir(), xyOrg, CDPoint(0, 1), xyMatch);
	
	if(pGirderRB->m_nType == 0)
	{
		tvLower.m_v1	= CVector(xyMatch.x + (pGirderRB->m_dCoverSide), xyMatch.y, 0);
		tvLower.m_v2	= CVector(xyMatch.x + (pGirderRB->m_dWidthL - pGirderRB->m_dCoverSide), xyMatch.y, 0);
	}
	else if(pGirderRB->m_nType == 1)
	{
		tvLower.m_v1	= CVector(xyMatch.x - (pGirderRB->m_dWidthL + pGirderRB->m_dCoverSide), xyMatch.y, 0);
		tvLower.m_v2	= CVector(xyMatch.x - (pGirderRB->m_dCoverSide), xyMatch.y, 0);
	}
	else
	{
		tvLower.m_v1	= CVector(xyMatch.x - (pGirderRB->m_dWidthL - pGirderRB->m_dCoverSide), xyMatch.y, 0);
		tvLower.m_v2	= CVector(xyMatch.x + (pGirderRB->m_dWidthR - pGirderRB->m_dCoverSide), xyMatch.y, 0);
	}
	
	if(bJongGirder)
	{
		tvUpper		= tvLower;
		tvUpper.m_v1	+= CDPoint(0, m_dTS - pGirderRB->m_dCoverUpper[0]);
		tvUpper.m_v2	+= CDPoint(0, m_dTS - pGirderRB->m_dCoverUpper[0]);
	}
	else
	{
		if(bUpperSlabGirder)
		{
			tvUpper.m_v1	= GetXyMatchLineAndSlabUpper(tvLower.m_v1, CDPoint(0, 1), 0, pGirderRB->m_dCoverUpper[0]);
			tvUpper.m_v2	= GetXyMatchLineAndSlabUpper(tvLower.m_v2, CDPoint(0, 1), 0, pGirderRB->m_dCoverUpper[0]);				
		}
		else
		{
			tvUpper.m_v1 = GetXyLowerSlabBottomByOffsetFrStation(tvLower.m_v1.x, 0, 0);
			tvUpper.m_v2 = GetXyLowerSlabBottomByOffsetFrStation(tvLower.m_v2.x, 0, 0);
			tvUpper.m_v1.y	+= pGirderRB->m_dCoverLower[0];
			tvUpper.m_v2.y	+= pGirderRB->m_dCoverLower[0];
		}
	}

	if(bUpperSlabGirder)
	{
		tvLower.m_v1.y	+= pGirderRB->m_dCoverLower[0];
		tvLower.m_v2.y	+= pGirderRB->m_dCoverLower[0];
	}
	else
	{
		tvLower.m_v1.y	-= pGirderRB->m_dCoverUpper[0];
		tvLower.m_v2.y	-= pGirderRB->m_dCoverUpper[0];
	}
}

// 기둥 띠철근 배치 권고안.
// 내측과 크로스타이도 함께 한다.
void CRcBridgeRebar::SetDataDefaultRebarRoundAndCrossTie_VertSection_InWall(long nIdxInWall)
{
	CWallApp *pWall	= GetInWall(nIdxInWall);
	if(!pWall) return;
	CColumnApp *pColumn			= &pWall->m_Column;
	long dan(0);
	CPlaceRebarByBlock *pPlace	= NULL;
	for(dan = 0; dan < MAX_REBAR_DAN; dan++)
	{
		pPlace	= &pColumn->m_placeRebarRound[iOUTTER][dan];
		pPlace->m_nCountBlock	= 0;
		pPlace->m_xyArr.RemoveAll();
		pPlace->m_dDia			= 0;
	}
	if(!pWall->m_bTopIsColumn) return;

	pPlace	= &pColumn->m_placeRebarRound[iOUTTER][0];

	// 1구간은 기둥위 상부 슬래브 간격이기 때문에 여기서 권고안 하지 않음
	// 기둥은 2, 3, 4구간을 권고안함.(기둥하단부터 위로)
	// D : 기둥폭
	// 2구간 : 2D
	// 3구간 : 기둥높이 - (2D-D);
	// 4구간 : D
	CTwinVector tvColumn;
	CTwinVector tvColumnOther;
	CTwinVector tvRebar, tvRebarOther;
	CTwinVectorArray tvArrRebar;	

	pColumn->m_tvArrFront.GetTvByInfo("기둥우측면", tvColumn);
	pColumn->m_tvArrFront.GetTvByInfo("기둥좌측면", tvColumnOther);

	if(m_nTypeBridge == BRIDGE_TYPE_ARCH)
	{
		tvColumn.m_v1	= m_pbRib[iLOWER].GetXyByDist(m_pbRib[iLOWER].GetDistByXPos(tvColumn.m_v1.x));
		tvColumnOther.m_v1	= m_pbRib[iLOWER].GetXyByDist(m_pbRib[iLOWER].GetDistByXPos(tvColumnOther.m_v1.x));
	}

	pColumn->GetTvRebarMain_Front(tvArrRebar, FALSE, 0, 0, FALSE);
	tvRebar	= tvArrRebar.GetAt(0);
	tvRebarOther	= tvArrRebar.GetAt(tvArrRebar.GetSize()-1);

	if(tvColumnOther.GetLength() < tvColumn.GetLength())
	{
		GetSwap(tvColumn, tvColumnOther);
		GetSwap(tvRebar, tvRebarOther);
	}
	
	

	double dHBlock1		= 0;	// 1구간의 높이
	double dHBlock2		= 0;	// 2구간의 높이
	double dHBlock3		= 0;	// 3구간의 높이
	double dCTCBlock1	= 300;	// 1구간의 ctc
	double dCTCBlock2	= 150;	// 2구간의 ctc
	double dCTCBlock3	= 300;	// 3구간의 ctc
	if(Compare(dCTCBlock1, 0.0, "<=")) return;
	if(Compare(dCTCBlock2, 0.0, "<=")) return;
	if(Compare(dCTCBlock2, 0.0, "<=")) return;

	double dH		= tvColumn.GetLength();		// 기둥 높이
	double dHBottom	= tvColumn.GetXyBottom().y - tvRebar.GetXyBottom().y;	// 기초부에 들어가는 기둥주철근의 높이
	double dHTop	= tvRebar.GetXyTop().y - tvColumn.GetXyTop().y;			// 상부슬래브부 들어가는 기둥주철근의 높이
	double dW		= pColumn->GetWidth(FALSE);	// 기둥 폭
	
	if(IsBoxType())
	{
		dHBlock1		= dH / 4 + dCTCBlock1*2;			// 1구간
		dHBlock2		= dH / 2;		// 2구간
		dHBlock3		= dH / 4 + dCTCBlock3*2 - 150;			// 3구간
	}
	else
	{
		dHBlock1		= dHBottom+dW;			// 1구간
		dHBlock2		= dH - (dW + 2*dW);		// 2구간
		dHBlock3		= dHTop + 2*dW;			// 3구간
	}

	// 기둥폭이 클 경우 dHBlock2가 -가 될 수 있다.
	if(dHBlock2 < 0)
	{
		dHBlock3 += dHBlock2;
		dHBlock2	= 0;
	}

	pPlace->m_dDia	= 19;
	long nX	= (long)Round((dHBlock1/dCTCBlock1)-1, 0);
	nX	= nX - (nX % 2);
	if(nX > 0)
		pPlace->m_xyArr.Add(CDPoint(nX, dCTCBlock1));
	nX	= (long)Round((dHBlock2/dCTCBlock2)-1, 0);
	nX	= nX - (nX % 2);
	if(nX > 0)
		pPlace->m_xyArr.Add(CDPoint(nX, dCTCBlock2));
	nX	= (long)Round((dHBlock3/dCTCBlock3)-1, 0);
	nX	= nX - (nX % 2);
	if(nX > 0)
		pPlace->m_xyArr.Add(CDPoint(nX, dCTCBlock3));

	// 기초하면에서 기둥철근라운드 상단까지의 거리를 한구간으로 추가 해 준다.
	if(pColumn->m_footing.m_bIs)
	{
		CTwinVector tvLower	= pColumn->m_footing.m_tvArrFront.GetTvByInfo("기초하면");
		pPlace->m_xyArr.InsertAt(0, CDPoint(1, tvRebar.GetXyBottom().y-tvLower.m_v1.y));
	}
	else if(IsBoxType())
	{
		double dH1 = tvColumn.GetXyBottom().y - GetElevationBoxBottom(nIdxInWall+1) - m_dCoverLower_LowerSlab[0] + 75;
		pPlace->m_xyArr.InsertAt(0, CDPoint(1, dH1));
	}
	else
	{
		pPlace->m_xyArr.InsertAt(0, CDPoint(1, fabs(tvColumn.GetXyBottom().y-tvColumnOther.GetXyBottom().y)));
	}

	pPlace->m_nCountBlock	= pPlace->m_xyArr.GetSize();

	// 내측주철근이 없어도 항상 내측에 대한 권고안을 해 준다.
	pPlace	= &pColumn->m_placeRebarRound[iOUTTER][1];
	pPlace->m_dDia	= 19;
	nX	= (long)Round((dHBlock1/dCTCBlock1)-1, 0);
	nX	= nX / 2;
	if(nX > 0)
		pPlace->m_xyArr.Add(CDPoint(nX, dCTCBlock1*2));
	nX	= (long)Round((dHBlock2/dCTCBlock2)-1, 0);
	nX	= nX / 2;
	if(nX > 0)
		pPlace->m_xyArr.Add(CDPoint(nX, dCTCBlock2*2));
	nX	= (long)Round((dHBlock3/dCTCBlock3)-1, 0);
	nX	= nX / 2;
	if(nX > 0)
		pPlace->m_xyArr.Add(CDPoint(nX, dCTCBlock3*2));

	// 기초하면에서 기둥철근라운드 상단까지의 거리를 한구간으로 추가 해 준다.
	if(pColumn->m_footing.m_bIs)
	{
		CTwinVector tvLower	= pColumn->m_footing.m_tvArrFront.GetTvByInfo("기초하면");
		pPlace->m_xyArr.InsertAt(0, CDPoint(1, tvRebar.GetXyBottom().y-tvLower.m_v1.y));
	}
	else if(IsBoxType())
	{
		double dH1 = tvColumn.GetXyBottom().y - GetElevationBoxBottom(nIdxInWall+1) - m_dCoverLower_LowerSlab[0] + 75;
		pPlace->m_xyArr.InsertAt(0, CDPoint(1, dH1));
	}
	else
	{
		pPlace->m_xyArr.InsertAt(0, CDPoint(1, fabs(tvColumn.GetXyBottom().y-tvColumnOther.GetXyBottom().y)));
	}

	pPlace->m_nCountBlock	= pPlace->m_xyArr.GetSize();

	// 크로스타이도 해준다.
	pColumn->m_placeRebarCrossTie	= pColumn->m_placeRebarRound[iOUTTER][0];
	pColumn->SyncRebar();
}

// 날개벽 철근 옵션 권고안
void CRcBridgeRebar::SetDataDefaultRebarWingWallOption(BOOL bStt, BOOL bLeft)
{
	CWingWall* pWing = GetWingWall(bStt, bLeft);

	double dL1 = pWing->m_dL1;
	double dL2 = pWing->m_dL2;

	long nDan = 0;
	int i=0; for(i=0; i<2; i++)
	{
		pWing->m_dDiaMainA[i][nDan] = dL2==0 ? 0 : 29;
		pWing->m_dDiaMainB[i][nDan] = dL2==0 ? 0 : 25;
		pWing->m_dDiaMainC[i][nDan] = dL2==0 ? 0 : 25;
		pWing->m_dDiaMainD[i][nDan] = dL1==0 ? 0 : 29;
		pWing->m_dDiaSupportA[i][nDan] = dL2==0 ? 0 : 16;
		pWing->m_dDiaSupportB[i][nDan] = dL2==0 ? 0 : pWing->m_dDiaMainC[i][nDan];
		pWing->m_dDiaSupportC[i][nDan] = dL2==0 ? 0 : pWing->m_dDiaMainB[i][nDan];
		pWing->m_dDiaSupportD[i][nDan] = dL1==0 ? 0 : 16;
	}
	pWing->m_dDiaHuUpper = 29;
	pWing->m_dDiaHuLower = dL2==0 ? 0 : 25;
	pWing->m_dDiaHuFoot  = dL2==0 ? 0 : 25;;
	pWing->m_RebarShearDetailA.m_dDia = dL2==0 ? 0 : 16;
	pWing->m_RebarShearDetailB.m_dDia = dL2==0 ? 0 : 16;
	pWing->m_RebarShearDetailC.m_dDia = dL2==0 ? 0 : 16;
	pWing->m_RebarShearDetailD.m_dDia = dL1==0 ? 0 : 16;
	pWing->m_dSpaceShearA = dL2==0 ? 0 : 500;
	pWing->m_dSpaceShearB = dL2==0 ? 0 : 500;
	pWing->m_dSpaceShearC = dL2==0 ? 0 : 500;
	pWing->m_dSpaceShearD = dL1==0 ? 0 : 500;

	pWing->m_dStdVerCTC = 250;
	pWing->m_dMainCTCA = 250;
	pWing->m_dMainCTCB = 250;
	pWing->m_nHunchCTC = 1;
	pWing->m_nCountShearBind = 4;
	pWing->m_nRebarCurve = 0;
	pWing->m_bUpperRebarSlope = TRUE;

	SetDataDefaultRebarWingWallSide(bStt, bLeft, 1, nDan);
	SetDataDefaultRebarWingWallSide(bStt, bLeft, 0, nDan);
	int nSize = pWing->m_xyArrSide[1][nDan].GetSize();
	pWing->m_nCountSlopeBlock[1] = nSize-2;
	nSize = pWing->m_xyArrSide[0][nDan].GetSize();
	pWing->m_nCountSlopeBlock[0] = nSize-2;
	pWing->m_bSelMainCTCD = FALSE;
	pWing->m_nTypeShearBC = 0;
}

// 날개벽 상단 철근의 좌표를 구함
CTwinVector CRcBridgeRebar::GetTvRebarWingWallUpper(BOOL bStt, BOOL bLeft, int nOut)
{
	CARcBridgeDataStd *pStd = m_pARcBridgeDataStd;
	CWingWall* pWing = GetWingWall(bStt, bLeft);
	CTwinVectorArray tvArrGen;
	CTwinVector tv, tvUpper;

	GetTvWingWallFront(bStt, bLeft, nOut, tvArrGen);
	tvArrGen.GetTvByInfo(_T("날개벽정면상단"), tvUpper);

	BOOL bSide		= (pWing->m_nAttachPos == 0 )? FALSE : TRUE;
	CDPoint vAng = GetAngleWingWallBetweenWall(bStt, bLeft);
	double dCoverWall = (!bSide)? m_dCoverWallIn[0]/vAng.y : 0.0;
	double dCoverWingEnd = GetCoverWingWallEnd(bStt, bLeft);
	double dCoverWingUpper = m_dCoverWingUpper;
	double se = bStt ? -1.0 : 1.0;
	double  dSettleDistWing  = 0;

	long nDan = 0;
	double dSettleA = (bSide)? pStd->GetValueSettle(pWing->m_dDiaMainA[nOut][nDan], SETTLE_TENS_NORMAL, toCm(m_dCoverWallOut[0]), toCm((nOut==1)? pWing->m_dMainCTCA:pWing->m_dMainCTCA/2)) : 0.0;
	if(m_pARcBridgeDataStd->IsLsdDesign() && bSide)
	{
		SRebarEnvOption LsdRebarOpt;
		SetRebarLsdOptionWingWall(&LsdRebarOpt, bStt, bLeft, nOut==0, WINGWALL_SECTA, TRUE);
		dSettleA = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueSettle(pWing->m_dDiaMainA[nOut][nDan], &LsdRebarOpt);
	}
	else
	{
		dSettleA = (bSide)? pStd->GetValueSettle(pWing->m_dDiaMainA[nOut][nDan], SETTLE_TENS_NORMAL, toCm(m_dCoverWallOut[0]), toCm((nOut==1)? pWing->m_dMainCTCA:pWing->m_dMainCTCA/2)) : 0.0;
	}

	if(bSide)
	{
		double dAngle	= vAng.GetAngleDegree();
		double dAngJijum = GetAngleJijum(bStt? 0 : m_nQtyJigan).GetAngleDegree();
		double dAngA1 = (dAngle - dAngJijum) * (bLeft? -1 : 1);
		
		if((bStt && bLeft) || (!bStt && !bLeft))
		{
			dAngJijum = 180 - dAngJijum;
			dAngA1	= (dAngle - dAngJijum) * (bLeft ? 1 : -1);
		}

		
		double d	= dAngA1-(90-dAngA1);
		if(Compare(d, 0.0, "=") || Compare(fabs(d), 180.0, "=") || Compare(fabs(d), 360.0, "="))
			d	= 90;
		double dFactor	= fabs(sin(d));

		CTwinVectorArray tvArrPlan , tvArrSide;
		double dWingBackLen = GetWingWallBackAndSideAttach(tvArrPlan, nOut, nDan, bLeft);		

		//{ 31447 //해당 날개벽 평면에서의 실제 수평철근 길이들
		GetWingWallbackAndSideAttachRebar(tvArrSide, nOut, nDan, bStt , TRUE, bLeft);
		dSettleDistWing = GetSettleRebarHoriRevision(tvArrSide,dWingBackLen, nOut, bStt, bLeft);

		if(dSettleDistWing == 0)
			dSettleA += m_dCoverWallOut[0]/dFactor;
		else
			dSettleA = dSettleDistWing;		
	}

	CDPoint xyUpper1 = CDPoint(tvUpper.m_v1.x, tvUpper.m_v1.y-dCoverWingUpper);
	CDPoint xyUpper2 = CDPoint(tvUpper.m_v2.x, tvUpper.m_v2.y-dCoverWingUpper);

	CDPoint xyStt, xyEnd;
	if(bSide)
	{
		xyStt = CDPoint(xyUpper1.x - (dSettleA)*se, 0);
		xyEnd = CDPoint(xyUpper2.x - dCoverWingEnd*se, 0);
	}
	else
	{
		xyStt = CDPoint(xyUpper1.x + dCoverWall*se, 0);
		xyEnd = CDPoint(xyUpper2.x - dCoverWingEnd*se, 0);
	}

	if(!GetXyMatchSegAndLine(xyUpper1, xyUpper2, xyStt, CDPoint(0, 1), tv.m_v1))
		GetXyMatchLineAndLine(xyUpper1, tvUpper.GetXyDir(), xyStt, CDPoint(0, 1), tv.m_v1);
	if(!GetXyMatchSegAndLine(xyUpper1, xyUpper2, xyEnd, CDPoint(0, 1), tv.m_v2))
		GetXyMatchLineAndLine(xyUpper1, tvUpper.GetXyDir(), xyEnd, CDPoint(0, 1), tv.m_v1);

	return tv;
}

// 각 구간의 철근이 병합되는지 판단
BOOL CRcBridgeRebar::IsMergedRebarWingWall(BOOL bStt, BOOL bLeft, int nOut, int nDan, char cFirBlock, char cSecBlock, BOOL bReal)
{
	char cBlock1 = min(cFirBlock, cSecBlock);
	char cBlock2 = max(cFirBlock, cSecBlock);

	CWingWall* pWing = GetWingWall(bStt, bLeft);

	if(cBlock1==cBlock2 || (cBlock1=='A'&& cBlock2=='B') || (cBlock1=='B' && cBlock2=='C')
		|| (cBlock1=='C' && cBlock2=='D')
		|| pWing->m_xyArrUpper[nOut][nDan].GetSize()==0)
		return FALSE;

	// (ARCBRIDGE-2479) B D 구간은 무조건 D구간으로 밀어버린다. B - D 구간은 무조건 병합
	// ==> (ARCBRIDGE-3423) 다시 분리하도록 변경
// 	if(cBlock1=='B' && cBlock2=='D')
// 	{
// 		if(pWing->m_dL1 == 0)	return FALSE;
// 		else							return TRUE;
// 	}


	BOOL bMerged = FALSE;

	if(cBlock1=='B' && cBlock2=='D')
	{
		double dDiaMainB = pWing->m_dDiaMainB[nOut][nDan];
		double dDiaMainD = pWing->m_dDiaMainD[nOut][nDan];

		if(dDiaMainB==dDiaMainD && pWing->m_dL1>0 && pWing->m_dL2>0)
			bMerged = TRUE;
		else
			bMerged = FALSE;
	}

	if(cBlock1=='A' && cBlock2=='C')
	{
		CDPoint xyUpper = CDPoint(0, 0);
		CDPoint xyLower = CDPoint(0, 0);
		double dLenDim = 0;
		double dWidthUpper = pWing->m_dL1 + pWing->m_dL2;
		double dWidthLower = pWing->m_dL2;
		long nDimCntUpper = pWing->m_xyArrUpper[nOut][nDan].GetSize();
		long nDimCntLower = pWing->m_xyArrLower[nOut][nDan].GetSize();
		if(nDimCntUpper==0 || nDimCntLower==0) return FALSE;
		
		double dDiaSuppA = pWing->m_dDiaSupportA[nOut][nDan];
		double dDiaMainC = pWing->m_dDiaMainC[nOut][nDan];
		double dExtSuppA = 0;
		double dExtMainC = 0;

		dLenDim = GetCoverWingWallEnd(bStt, bLeft);
		long i=0; for(i=0; i<nDimCntUpper; i++)
		{
			xyUpper = pWing->m_xyArrUpper[nOut][nDan].GetAt(i);
			dLenDim += xyUpper.x * xyUpper.y;
		}
		dExtSuppA = dWidthUpper - dLenDim;

		dLenDim = GetCoverWingWallEnd(bStt, bLeft);
		for(i=0; i<nDimCntLower; i++)
		{
			xyLower = pWing->m_xyArrLower[nOut][nDan].GetAt(i);
			dLenDim += xyLower.x * xyLower.y;
		}
		dExtMainC = dWidthLower - dLenDim;

		if(dDiaSuppA==dDiaMainC || !bReal)
		{
			if(Compare(dExtSuppA, dExtMainC, _T("="),0.5))
			{
				xyUpper = pWing->m_xyArrUpper[nOut][nDan].GetAt(nDimCntUpper-1);
				xyLower = pWing->m_xyArrLower[nOut][nDan].GetAt(nDimCntLower-1);
				if(xyUpper.y == xyLower.y)
				{
					bMerged = TRUE;
				}
				else
				{
					bMerged = FALSE;
				}
			}
			else
				bMerged = FALSE;
		}
		else
			bMerged = FALSE;
	}

	if(cBlock1=='A' && cBlock2=='D')
	{
		double dDiaMainA = pWing->m_dDiaMainA[nOut][nDan];
		double dDiaMainD = pWing->m_dDiaMainD[nOut][nDan];

		if(dDiaMainA==dDiaMainD && pWing->m_dL1>0 && pWing->m_dL2>0)
			bMerged = TRUE;
		else
			bMerged = FALSE;
	}

	return bMerged;
}

// 날개벽 A구간 전단철근 좌표
void CRcBridgeRebar::GetTvArrayRebarWingWallShearAFront(CTwinVectorArray &tvArr, BOOL bStt, BOOL bLeft, int nOut)
{
	tvArr.RemoveAll();

	CWingWall* pWing = GetWingWall(bStt, bLeft);

	double dL2 = pWing->m_dL2;
	if(dL2==0) return;

	double TensA = pWing->m_dStdVerCTC/2;
	double CompA = pWing->m_dStdVerCTC;
	double TensD = (pWing->m_bSelMainCTCD)? TensA*2 : TensA;
	double CompD = CompA;
	double ctcA = nOut==0 ? TensA : CompA; // A구간
	double ctcD = nOut==0 ? TensD : CompD; // D구간

	BOOL bRangEnd = pWing->m_bRAngEnd;
	BOOL bAngAffect = (!bRangEnd && bLeft==nOut);

	CTwinVectorArray tvArrGen;
	CTwinVector tvGenUpper, tvGenLower, tvUpperRebar, tv;
	GetTvWingWallFront(bStt, bLeft, nOut, tvArrGen);
	tvArrGen.GetTvByInfo(_T("날개벽정면상단"), tvGenUpper);
	tvArrGen.GetTvByInfo(_T("날개벽정면하단"), tvGenLower);
	tvUpperRebar = GetTvRebarWingWallUpper(bStt, bLeft, nOut);
	CDPoint xyUpperBound1 = bStt ? tvUpperRebar.m_v1 : tvUpperRebar.m_v2;
	CDPoint xyUpperBound2 = bStt ? tvUpperRebar.m_v2 : tvUpperRebar.m_v1;

	//BOX형에서 부상방지가있으면 날개벽 정면하단이 길이가 바뀜
	if(m_nTypeBridge == BRIDGE_TYPE_BOX && m_bExistProtectionRiseFooting)
	{
		CTwinVectorArray tvArrPRF;
		CTwinVector tvPRFBottom, tvPRFTop;
		GetTvPRF_VertSection(tvArrPRF, bStt, bLeft, TRUE);
		double se = bStt ? 1 : -1;
		tvArrPRF.GetTvByInfo(bStt ? _T("시점부상방지저판하단") : _T("종점부상방지저판하단"), tvPRFBottom);
		tvArrPRF.GetTvByInfo(bStt ? _T("시점부상방지저판상면") : _T("종점부상방지저판상면"), tvPRFTop);

		double dLengthW = tvPRFBottom.GetLength();
		if(IsWingWallOnPRF(bStt, bLeft))
		{
			CTwinVector tvWing;
			CDPoint xyMatch;
			tvArrGen.GetTvByInfo(_T("날개벽정면끝단하부"), tvWing);
			GetXyMatchSegAndLine(tvPRFTop.m_v1, tvPRFTop.m_v2, tvWing.m_v2, CDPoint(0,1), xyMatch);
			double dLengthMatch = tvPRFBottom.m_v1.x - xyMatch.x * se;
			dLengthW = dLengthMatch;
		}

		tvGenLower.m_v2.x += dLengthW * se;
	}

	int nBind = pWing->m_nCountShearBind;
	double dSpaceShear = pWing->m_dSpaceShearA;
	double dCoverWingEnd = GetCoverWingWallEnd(bStt, bLeft);
	BOOL bUpperRebarSlope = pWing->m_bUpperRebarSlope;	// 상면 주철근을 경사로 배치
	double dB = GetLengthWingWallBlockBC(bStt, bLeft, TRUE);
	double se = bStt ? -1.0 : 1.0;

	CDPointArray xyArrUpper = pWing->m_xyArrUpper[0];
	CDPointArray xyArrSide = pWing->m_xyArrSide[0];
	int nSizeSide = xyArrSide.GetSize();
	int nSizeUpper = xyArrUpper.GetSize();
	if(nSizeSide==0 || nSizeUpper==0) return;

	CDPoint xyUpperStt(0, 0), xyUpperMid(0, 0);
	xyUpperStt.x = tvUpperRebar.m_v1.x + xyArrUpper.GetAt(0).y*se;
	GetXyMatchSegAndLine(tvUpperRebar.m_v1, tvUpperRebar.m_v2, xyUpperStt, CDPoint(0, 1), xyUpperStt);
	GetXyMatchSegAndLine(tvUpperRebar.m_v1, tvUpperRebar.m_v2,
		CDPoint(tvGenLower.m_v1.x-dCoverWingEnd*se, 0), CDPoint(0, 1), xyUpperMid);

	if(nBind <= 0 || dSpaceShear <= 0) return;
	
	BOOL bSide	= (pWing->m_nAttachPos == 0 )? FALSE : TRUE;
	CDPoint vAng = GetAngleWingWallBetweenWall(bStt, bLeft);
	double dT1 = pWing->m_dT1;
	double dT2 = pWing->m_dT2;
	double dAngA1 = 0;
	if(bSide)
	{
		double dAngle1	= vAng.GetAngleDegree();
		double dAngJijum = GetAngleJijum(bStt? 0 : m_nQtyJigan).GetAngleDegree();
		dAngA1 = dAngle1 - dAngJijum;
		if((bStt && bLeft) || (!bStt && !bLeft))
		{
			dAngJijum = 180 - dAngJijum;
			dAngA1	= (dAngle1 - dAngJijum) * (bLeft ? 1 : -1);
		}
	}

	CDPoint xyR(0, 0);
	long nDan = 0;
	double dHgtHor = GetHeightWingWallHorRebar(bStt, bLeft, nOut, nDan);
	double dRangeVer = dHgtHor + tvGenLower.m_v1.y;
	double dRangeHor = tvGenUpper.m_v2.x - dCoverWingEnd*se;

	int i=0; for(i=nSizeUpper-1; i>=0; i--)
	{
		xyR = xyArrUpper.GetAt(i);
		int j=0; for(j=0; j<xyR.x; j++)
		{
			dRangeHor -= xyR.y*se;
			if((tvGenLower.m_v2.x-dRangeHor)*se>0) break;
		}
		if((tvGenLower.m_v2.x-dRangeHor)*se>0)
		{
			dRangeHor += xyR.y*se;
			break;
		}
	}

	
	int nCountRow = 0;		// 전단 철근 행 개수
	
	CDPoint xy(0, tvGenLower.m_v1.y+xyArrSide.GetAt(0).y);

	double dAngle = (bSide)?  dAngA1: (bStt==bLeft)? 180-vAng.GetAngleDegree():vAng.GetAngleDegree();
	//	끝단 사각처리이고 변단면일경우 T2로주면 실제 입력한 배면혹은 전면과 맞지 안는다. (pWing->m_nDirHunch==1 && !pWing->m_bRAngEnd)일때 그래서 T1으로
	double dDist1 = (dAngle==90)? 0.0 : fabs((min(dT1,dT2) - m_dCoverWingIn[0] - m_dCoverWingOut[0] - REBAR_RADIUS*2)/tan(ToRadian(dAngle)));
	BOOL bSideAngAffect = ((vAng.GetAngleDegree() > 90 && nOut) || (vAng.GetAngleDegree() < 90 && !nOut));
	if(!bRangEnd)
	{
		// 끝단 각도 때문에 평면에서 전면에는 철근이 있지만 배면에 철근이 없는 경우
		if(nOut == 1 && !bSideAngAffect)
			dRangeHor -= dDist1;

		if(bSideAngAffect)
		{
			double dDiv = nOut==0? CompA/ TensA == 2? 2: 1 : 1;
			if(dDist1 > ctcA* dDiv)
			{
				dDist1 -=  ctcA* dDiv;
			}
		}
		else
		{
			dDist1 = 0;
		}	
	}
	else
	{
		if(bSide == FALSE)
			dDist1 = 0;
	}

	while(1)
	{
		if(nCountRow%2==0)
			xy.x = tvGenLower.m_v1.x - (dCoverWingEnd)*se;
		else
			xy.x = tvGenLower.m_v1.x - (dCoverWingEnd-dSpaceShear)*se;
		
		if(bSideAngAffect) xy.x -= dDist1*se;

		double dLenShear = 0;
		int nCount = 0;			// 총 전단 철근 개수
		double dSumSide = tvGenLower.m_v1.y;
		for(i=0; i<nSizeSide; i++)
		{
			xyR = xyArrSide.GetAt(i);
			int j=0; for(j=0; j<xyR.x; j++)
			{
				if(nCount==nBind) break;
				dSumSide += xyR.y;
				if(dSumSide<=xy.y) continue;
				dLenShear += xyR.y;
				nCount++;
			}
			if(nCount==nBind) break;
		}

		if(xy.y <= dRangeVer && dLenShear == 0)
		{
			dLenShear = pWing->m_dMainCTCA/2 * nBind;
		}
		xy.y += dLenShear;
		nCountRow++;
		if(xy.y-dLenShear<dB && dLenShear > 0) continue;
		if(bUpperRebarSlope)
		{
			if(pWing->m_RebarShearDetailA.m_nType==TYPE_SHEAR_DIGUT || pWing->m_RebarShearDetailA.m_nType==TYPE_SHEAR_SINGLE_HOOK)
			{
				// ㄷ형은 전단철근 길이를 더해서 체크하지 않아도 된다.
				if(xy.y-dLenShear > dRangeVer) break;
			}
			else
			{
				if(xy.y>dRangeVer) break;
			}
		}
		else
		{
			// 날개벽상단이이 수평이고 철근을 상단부에 배근하지 않았을때...
			if(dLenShear==0 || xy.y<max(xyUpperStt.y, xyUpperMid.y))
			{
				dLenShear = pWing->m_dMainCTCA/2 * nBind;
				xy.y += dLenShear;
			}
			if(xy.y>max(xyUpperStt.y, xyUpperMid.y)) break;
		}

		while(1)
		{
			xy.x -= dSpaceShear*2*se;
			if((dRangeHor-xy.x)*se>=0) break;
			if(!bUpperRebarSlope && !GetDirPointByLine(xy, xyUpperBound1, xyUpperBound2)) continue;
			tv.m_v1 = CDPoint(xy.x, xy.y-dLenShear);
			tv.m_v2 = xy;
			tv.m_sInfo = _T("전단A");

			CDPoint xyTemp(0, 0);
			GetXyMatchSegAndLine(tvUpperRebar.m_v1, tvUpperRebar.m_v2, xy, CDPoint(0, 1), xyTemp); 
			if(pWing->m_RebarShearDetailA.m_nType==TYPE_SHEAR_DIGUT || pWing->m_RebarShearDetailA.m_nType==TYPE_SHEAR_SINGLE_HOOK)
			{
				if(xy.y-dLenShear <= xyTemp.y) tvArr.Add(tv);
			}
			else
			{
				if(xy.y <= xyTemp.y) tvArr.Add(tv);
			}
		}
	}
}

// 날개벽 BC구간 전단철근 좌표
void CRcBridgeRebar::GetTvArrayRebarWingWallShearBCFront(CTwinVectorArray &tvArr, BOOL bStt, BOOL bLeft, int nOut)
{
	tvArr.RemoveAll();

	CWingWall* pWing = GetWingWall(bStt, bLeft);

	double TensA = pWing->m_dStdVerCTC/2;
	double CompA = pWing->m_dStdVerCTC;
	double TensD = (pWing->m_bSelMainCTCD)? TensA*2 : TensA;
	double CompD = CompA;
	double ctcA = nOut==0 ? TensA : CompA; // A구간
	double ctcD = nOut==0 ? TensD : CompD; // D구간


	BOOL bRangEnd = pWing->m_bRAngEnd;
	BOOL bAngAffect = (!bRangEnd && bLeft==nOut);
	BOOL bVer = (pWing->m_nTypeShearBC == 1)? FALSE:TRUE;
	BOOL bHor = (pWing->m_nTypeShearBC == 0)? FALSE:TRUE;

	double dL2 = pWing->m_dL2;
	if(dL2==0) return;

	CTwinVectorArray tvArrGen;
	CTwinVector tvGen, tv;
	GetTvWingWallFront(bStt, bLeft, nOut, tvArrGen);
	tvArrGen.GetTvByInfo(_T("날개벽정면하단"), tvGen);

	//BOX형에서 부상방지가있으면 날개벽 정면하단이 길이가 바뀜.
	if(m_nTypeBridge == BRIDGE_TYPE_BOX && m_bExistProtectionRiseFooting)
	{
		CTwinVectorArray tvArrPRF;
		CTwinVector tvPRFBottom, tvPRFTop;
		GetTvPRF_VertSection(tvArrPRF, bStt, bLeft, TRUE);
		double se = bStt ? 1 : -1;
		tvArrPRF.GetTvByInfo(bStt ? _T("시점부상방지저판하단") : _T("종점부상방지저판하단"), tvPRFBottom);
		tvArrPRF.GetTvByInfo(bStt ? _T("시점부상방지저판상면") : _T("종점부상방지저판상면"), tvPRFTop);

		double dLengthW = tvPRFBottom.GetLength();
		if(IsWingWallOnPRF(bStt, bLeft))
		{
			CTwinVector tvWing;
			CDPoint xyMatch;
			tvArrGen.GetTvByInfo(_T("날개벽정면끝단하부"), tvWing);
			GetXyMatchSegAndLine(tvPRFTop.m_v1, tvPRFTop.m_v2, tvWing.m_v2, CDPoint(0,1), xyMatch);
			double dLengthMatch = tvPRFBottom.m_v1.x - xyMatch.x * se;
			dLengthW = dLengthMatch;
		}

		tvGen.m_v2.x += dLengthW * se;
	}

	int nBind = pWing->m_nCountShearBind;
	double dSpaceShearB = pWing->m_dSpaceShearB;
	double dSpaceShearC = pWing->m_dSpaceShearC;
	double dCoverWingEnd = GetCoverWingWallEnd(bStt, bLeft);
	double se = bStt ? -1.0 : 1.0;
	
	CDPointArray xyArrLower = pWing->m_xyArrLower[0][0];
	CDPointArray xyArrSide = pWing->m_xyArrSide[0][0];
	int nSizeLower = xyArrLower.GetSize();
	int nSizeSide = xyArrSide.GetSize();

	if(nBind <= 0 || (dSpaceShearB <= 0 && pWing->m_nTypeShearBC!=1) || (dSpaceShearC <= 0 && pWing->m_nTypeShearBC!=0)) return;
	if(nSizeSide==0) return;

	BOOL bSide		= (pWing->m_nAttachPos == 0 )? FALSE : TRUE;
	CDPoint vAng = GetAngleWingWallBetweenWall(bStt, bLeft);
	double dT1 = pWing->m_dT1;
	double dT2 = pWing->m_dT2;
	double dAngA1 = 0;
	if(bSide)
	{
		double dAngle	= vAng.GetAngleDegree();
		double dAngJijum = GetAngleJijum(bStt? 0 : m_nQtyJigan).GetAngleDegree();
		dAngA1 = dAngle - dAngJijum;
		if((bStt && bLeft) || (!bStt && !bLeft))
		{
			dAngJijum = 180 - dAngJijum;
			dAngA1	= (dAngle - dAngJijum) * (bLeft ? 1 : -1);
		}
	}

	CDPoint xyR(0, 0);
	long nDan = 0;
	double dHgtHor = GetHeightWingWallHorRebar(bStt, bLeft, nOut, nDan);
	double dRangeVer = min(GetLengthWingWallBlockBC(bStt, bLeft, TRUE), (dHgtHor + tvGen.m_v2.y));
	double dRangeHor = tvGen.m_v1.x - dCoverWingEnd*se;

	int i=0; for(i=nSizeLower-1; i>=0; i--)
	{
		xyR = xyArrLower.GetAt(i);
		int j=0; for(j=0; j<xyR.x; j++)
		{
			dRangeHor -= xyR.y*se;
			if((tvGen.m_v2.x-dRangeHor)*se>0) break;
		}
		if((tvGen.m_v2.x-dRangeHor)*se>0)
		{
			dRangeHor += xyR.y*se;
			break;
		}
	}
	
	double dLenShear = 0;
	
	int nCount = 0;
	double dAngle = (bSide)?  dAngA1: (bStt==bLeft)? 180-vAng.GetAngleDegree():vAng.GetAngleDegree();
	//	끝단 사각처리이고 변단면일경우 T2로주면 실제 입력한 배면혹은 전면과 맞지 안는다. (pWing->m_nDirHunch==1 && !pWing->m_bRAngEnd)일때 그래서 T1으로
	BOOL bSideAngAffect = ((vAng.GetAngleDegree() > 90 && nOut) || (vAng.GetAngleDegree() < 90 && !nOut));
	double dDist1 = (dAngle==90)? 0.0 : fabs((dT1 - m_dCoverWingIn[0] - m_dCoverWingOut[0] - REBAR_RADIUS*2)/tan(ToRadian(dAngle)));
	if(!bRangEnd)
	{
		if(bSideAngAffect)
		{
			double dDiv = nOut==0? CompA/ TensA == 2? 2: 1 : 1;
			if(dDist1 > ctcA* dDiv)
			{
				dDist1 -=  ctcA* dDiv;
			}
		}
		else 
		{
			dDist1 = 0;
		}	
	}
	else
	{
		if(bSide == FALSE)
			dDist1 = 0;
	}

// 	double dThickTemp = (pWing->m_nDirHunch==1 && !pWing->m_bRAngEnd)? dT1 : dT2;
// 	double dDist1 = (dAngle==90)? 0.0 : fabs((dThickTemp - m_dCoverWingIn[0] - m_dCoverWingOut[0] - REBAR_RADIUS*2)/tan(ToRadian(dAngle)));


	if(bVer)
	{
		CDPoint xy(0, tvGen.m_v1.y+xyArrSide.GetAt(0).y);
		int nCountRow = 0;	
		while(1)
		{
			if(nCountRow%2==0)
				xy.x = tvGen.m_v1.x - (dCoverWingEnd+dSpaceShearB*2)*se;
			else
				xy.x = tvGen.m_v1.x - (dCoverWingEnd+dSpaceShearB)*se;
			
			if(bSideAngAffect) xy.x -= dDist1*se;

			dLenShear = 0;
			nCount = 0;
			double dSumSide = tvGen.m_v1.y;
			for(i=0; i<nSizeSide; i++)
			{
				xyR = xyArrSide.GetAt(i);
				int j=0; for(j=0; j<xyR.x; j++)
				{
					if(nCount==nBind) break;
					dSumSide += xyR.y;
					if(dSumSide<=xy.y) continue;
					dLenShear += xyR.y;
					nCount++;
				}
				if(nCount==nBind) break;
			}
			
			xy.y += dLenShear;
			nCountRow++;
			if(xy.y-dLenShear>dRangeVer || dLenShear <= 0) break;
			// 경사구간이 B구간 까지 내려오면 전단철근 윗부분에서 체그해야한다.
			if(xy.y>dHgtHor + tvGen.m_v2.y || dLenShear <= 0) break;
			
			while((dRangeHor-xy.x)*se<0)
			{
				tv.m_v1 = CDPoint(xy.x, xy.y-dLenShear);
				tv.m_v2 = xy;
				tv.m_sInfo = _T("전단B");
				tvArr.Add(tv);
				xy.x -= dSpaceShearB*2*se;
			}
		}
	}

	if(bHor)
	{
		CDPoint xy(tvGen.m_v1.x - dCoverWingEnd*se, 0);
		if(bAngAffect) xy.x -= dDist1*se;
		int nCountCol = 0;
		while(1)
		{
			if(nCountCol%2==0)
				xy.y = tvGen.m_v1.y + xyArrSide.GetAt(0).y + dSpaceShearC*2;
			else
				xy.y = tvGen.m_v1.y + xyArrSide.GetAt(0).y + dSpaceShearC;

			dLenShear = 0;
			nCount = 0;
//			double dSumLower = tvGen.m_v1.x;
			for(i=0; i<nSizeLower; i++)
			{
				xyR = xyArrLower.GetAt(i);
				int j=0; for(j=0; j<xyR.x; j++)
				{
					if(nCount==nBind) break;
//					dSumLower -= xyR.y*se;
//					if((bStt && dSumLower <= xy.x) || (!bStt && dSumLower >= xy.x)) continue;
					if(i==0 && xyR.x==1) continue;
					dLenShear += xyR.y;
					nCount++;
				}
				if(nCount==nBind) break;
			}
			if(nCount<nBind) break;
			
			xy.x -= dLenShear*se;
			nCountCol++;
			if((bStt && xy.x>dRangeHor) || (!bStt && xy.x<dRangeHor) || dLenShear <= 0) break;
			
			while((dRangeVer-xy.y)>0)
			{
				if(bStt)
				{
					tv.m_v1 = xy;
					tv.m_v2 = CDPoint(xy.x-dLenShear*se, xy.y);
				}
				else
				{
					tv.m_v1 = xy;
					tv.m_v2 = CDPoint(xy.x-dLenShear*se, xy.y);
				}
				
				tv.m_sInfo = _T("전단C");
				tvArr.Add(tv);
				xy.y += dSpaceShearC*2;
			}
		}
	}
}

// 날개벽 D구간 전단철근 좌표
void CRcBridgeRebar::GetTvArrayRebarWingWallShearDFront(CTwinVectorArray &tvArr, BOOL bStt, BOOL bLeft, int nOut)
{
	tvArr.RemoveAll();

	CWingWall* pWing = GetWingWall(bStt, bLeft);

	BOOL bSide = (pWing->m_nAttachPos == 0)? FALSE : TRUE;
	BOOL bRangEnd = pWing->m_bRAngEnd;
	CDPoint vAng = GetAngleWingWallBetweenWall(bStt, bLeft);
	double dAngle = (bStt==bLeft)? 180-vAng.GetAngleDegree():vAng.GetAngleDegree();
	BOOL bSideAngAffect = ((vAng.GetAngleDegree() > 90 && nOut) || (vAng.GetAngleDegree() < 90 && !nOut));
	if(bSide)
	{
		double dAngleBeet	= vAng.GetAngleDegree();
		double dAngJijum = GetAngleJijum(bStt? 0 : m_nQtyJigan).GetAngleDegree();
		dAngle = dAngleBeet - dAngJijum;

		/*
		if((bStt && bLeft) || (!bStt && !bLeft))
		{
			dAngJijum = 180 - dAngJijum;
			dAngle	= (dAngleBeet - dAngJijum) * (bLeft ? 1 : -1);
		}
		*/

		bSideAngAffect = ((vAng.GetAngleDegree() > 90 && !nOut) || (vAng.GetAngleDegree() < 90 && nOut));
	}

	double dL1 = pWing->m_dL1;
	double dL2 = pWing->m_dL2;
	if(dL1==0) return;

	CTwinVectorArray tvArrGen, tvArrShearBC;
	CTwinVector tvGenUpper, tvGenLower, tvUpperRebar, tv, tvNori;
	GetTvWingWallFront(bStt, bLeft, nOut, tvArrGen);
	tvArrGen.GetTvByInfo(_T("날개벽정면상단"), tvGenUpper);
	tvArrGen.GetTvByInfo(_T("날개벽정면하단"), tvGenLower);
	tvArrGen.GetTvByInfo(_T("날개벽정면노리"), tvNori);
	tvUpperRebar = GetTvRebarWingWallUpper(bStt, bLeft, nOut);
	CDPoint xyUpperBound1 = bStt ? tvUpperRebar.m_v1 : tvUpperRebar.m_v2;
	CDPoint xyUpperBound2 = bStt ? tvUpperRebar.m_v2 : tvUpperRebar.m_v1;

	int nBind = pWing->m_nCountShearBind;
	double dCTCMain = pWing->m_dMainCTCA/2;
	double dSpaceShear = pWing->m_dSpaceShearD;
	double dStdLenShear = dCTCMain*nBind;
	double dCoverWingEnd = GetCoverWingWallEnd(bStt, bLeft);
	double dB = GetLengthWingWallBlockBC(bStt, bLeft, TRUE);
	BOOL bUpperRebarSlope = pWing->m_bUpperRebarSlope;	// 상면 주철근을 경사로 배치
	double se = bStt ? -1.0 : 1.0;
	double dHgtMin = min(tvGenUpper.m_v2.y, tvGenUpper.m_v1.y);
	CDPoint xyTailUpperCross = GetXyRebarWingWallTailUpperCross(bStt, bLeft, nOut);
	CDPoint xyTailLowerCross = GetXyRebarWingWallTailLowerCross(bStt, bLeft, nOut);

	CDPoint xyUpperMid(0, 0);
	GetXyMatchSegAndLine(tvUpperRebar.m_v1, tvUpperRebar.m_v2,
		CDPoint(tvGenLower.m_v1.x-dCoverWingEnd*se, 0), CDPoint(0, 1), xyUpperMid);

	long nDan = 0;
	CDPointArray xyArrUpper = pWing->m_xyArrUpper[nOut][nDan];
	CDPointArray xyArrSide;
	// D구간 주철근 간격 2배옵션이 적용되면 전단철근이 제대로 안나옴
	// 전단철근은 기본 주철근 간격에 기준해야 되므로 
	// 잠시 옵션을 꺼 둠
	BOOL bSelD	= pWing->m_bSelMainCTCD;
	pWing->m_bSelMainCTCD	= FALSE;
	if(dHgtMin==tvGenUpper.m_v2.y)
	{
		GetDimArrayRebarWingWallMinSide(xyArrSide, bStt, bLeft, 0, nDan);

		if(tvNori.GetVerLength() < 1 && tvNori.GetHorLength() >0 && pWing->m_dL2 == 0 && xyArrSide.GetSize() > 1)
		{
			long nSizeXyArr = xyArrSide.GetSize();
			CDPoint xyFrist		= xyArrSide.GetAt(0);
			CDPoint xySecond	= xyArrSide.GetAt(1);

			xyFrist.y += xySecond.y*2;
			xySecond.x-=2;

			if(xySecond.x < 1)
			{
				xyArrSide.RemoveAt(0);
				xyArrSide.SetAt(0, xyFrist);
			}
			else
			{
				xyArrSide.SetAt(0, xyFrist);
				xyArrSide.SetAt(1, xySecond);
			}
		}
	}
	else
	{
		GetDimArrayRebarWingWallMaxSide(xyArrSide, bStt, bLeft, 0, nDan);
	}
	pWing->m_bSelMainCTCD	= bSelD;
	int nSizeSide = xyArrSide.GetSize();
	int nSizeUpper = xyArrUpper.GetSize();

	// 전단철근에 관한사항이 입력되지않았을경우 리턴시켜 버림..
	// nBind, dSpaceShear
	if(nBind <= 0 || dSpaceShear<= 0) return;
	///////////////////////////////////////////////////////////
	if(nSizeSide==0 || nSizeUpper==0) return;

	double dT1 = pWing->m_dT1;
	double dT2 = pWing->m_dT2; 
	//	끝단 사각처리이고 변단면일경우 T2로주면 실제 입력한 배면혹은 전면과 맞지 안는다. (pWing->m_nDirHunch==1 && !pWing->m_bRAngEnd)일때 그래서 T1으로
	double dDist1 = fabs((dT1 - m_dCoverWingIn[0] - m_dCoverWingOut[0] - REBAR_RADIUS*2)/tan(ToRadian(dAngle)));
 	//double dThickTemp = (pWing->m_nDirHunch==1 && !pWing->m_bRAngEnd)? dT2-dT1 : dT1;
 	//double dDist1 = fabs((dThickTemp - m_dCoverWingIn[0] - m_dCoverWingOut[0] - REBAR_RADIUS*2)/tan(ToRadian(dAngle)));
	
	CDPoint xyR(0, 0);
//	double dHgtHor = GetHeightWingWallHorRebar(bStt, bLeft, nOut, nDan);
//	double dRangeVer = dHgtHor + tvGenLower.m_v1.y;
	//#27990 날개벽의 시점과 종점중 가장 높은값을 dRangeVer로 정한다.
	double dRangeVer = max(tvUpperRebar.m_v1.y, tvUpperRebar.m_v2.y);
	double dLen1 = dL1 - dCoverWingEnd;
	long   nEa1	= (long)(dLen1/dCTCMain);
	double ext1 = dLen1 - nEa1*dCTCMain;
	double dRangeHor = tvGenUpper.m_v2.x - dCoverWingEnd*se - ext1*se;
	double dRangeHorStt = 0;

	// 철근을 표준간격 외로입력했을경우. 표준길이를 재설정..
	double dCtcStd = 0;
	double dMaxEa = 0;
	long n=0; for(n=0; n<nSizeSide; n++)
	{
		xyR = xyArrSide.GetAt(n);
		if(xyR.x > dMaxEa || n==0)
		{
			dCtcStd = xyR.y;
			dMaxEa = xyR.x;
		}
	}
	dStdLenShear = fabs(dCtcStd * nBind);
	

	if(bSideAngAffect && !pWing->m_bRAngEnd)
	{
		dRangeHor -= xyArrUpper.GetAt(0).y*se;
	}
	if(dL2==0)
	{
		dRangeHor = tvGenUpper.m_v2.x - dCoverWingEnd*se;
		dRangeHorStt = dRangeHor;
		if(bSideAngAffect) dRangeHorStt -= dDist1*se;

		int i=0; for(i=nSizeUpper-1; i>=0; i--)
		{
			xyR = xyArrUpper.GetAt(i);
			int j=0; for(j=0; j<xyR.x; j++)
			{
				dRangeHor -= xyR.y*se;
			}
		}
	}

	
	int nCountRow = 0;
	
	CDPoint xy(0, tvGenLower.m_v1.y+xyArrSide.GetAt(0).y);
	BOOL bBound = FALSE;

	
	while(1)
	{
		if(nCountRow > 200) break;
		if(bRangEnd)
		{
			if(nCountRow%2==0)
				xy.x = dL2==0 ? tvGenUpper.m_v2.x-dCoverWingEnd*se : tvGenLower.m_v1.x-(dCoverWingEnd+dSpaceShear*2)*se;
			else
				xy.x = dL2==0 ? tvGenUpper.m_v2.x-(dCoverWingEnd-dSpaceShear)*se : tvGenLower.m_v1.x-(dCoverWingEnd+dSpaceShear)*se;
		}
		else
		{
			if(dL2 == 0)
			{
				xy.x = (nCountRow%2==0)? tvGenUpper.m_v2.x-dCoverWingEnd*se : tvGenUpper.m_v2.x-(dCoverWingEnd-dSpaceShear)*se;
				if(bSideAngAffect) xy.x -= dDist1*se;
			}
			else if(!bSideAngAffect)
				xy.x = (nCountRow%2==0)? tvGenLower.m_v1.x - (-dDist1 + dCoverWingEnd + dSpaceShear*2)*se : tvGenLower.m_v1.x - (-dDist1 + dCoverWingEnd + dSpaceShear)*se;
			else
				xy.x = (nCountRow%2==0)? tvGenLower.m_v1.x + (-dCoverWingEnd)*se - dSpaceShear*2*se : tvGenLower.m_v1.x + (-dCoverWingEnd)*se - dSpaceShear*se;
			// 뒤의 수평방향으로 돌리는 while문에서 dSpaceShear*2만큼 더하면서 돌리기때문에 기준점에서 dSpaceShear*2를 빼고 시작한다.
		}

		double dLenShear = 0;
		int nCount = 0;
		double dSumSide = tvGenLower.m_v1.y;
		int i=0; for(i=0; i<nSizeSide; i++)
		{
			xyR = xyArrSide.GetAt(i);
			int j=0; for(j=0; j<xyR.x; j++)
			{
				if(nCount==nBind || dLenShear>=dStdLenShear) break;
				dSumSide += xyR.y;
				
				if(dSumSide<=xy.y) continue;
				dLenShear += xyR.y;
				nCount++;
			}
			if(nCount==nBind || dLenShear>=dStdLenShear) break;
		}
		if(xy.y>=dB && dStdLenShear!=dLenShear)
			dLenShear = dStdLenShear;

		nCountRow++;
		xy.y += dLenShear;
		if(xy.y-dLenShear<xyTailLowerCross.y) continue;
		if(bUpperRebarSlope)
		{
			if(xy.y>dRangeVer || nCount<nBind) break;
		}
		else
		{
			if(xy.y>max(tvUpperRebar.m_v2.y, xyUpperMid.y) || nCount<nBind) break;
		}
		while(1)
		{
			if(dL2==0)
			{
				xy.x -= dSpaceShear*2*se;
				if((dRangeHor-xy.x)*se>=0) break;
				if(bSideAngAffect && (xy.x - dRangeHorStt)*se>=0) continue; 
			}
			else
			{
				xy.x += dSpaceShear*2*se;
				if((dRangeHor-xy.x)*se<0) break;
			}
			if(!bUpperRebarSlope && !GetDirPointByLine(xy, xyUpperBound1, xyUpperBound2)) continue;
			tv.m_v1 = CDPoint(xy.x, xy.y-dLenShear);
			tv.m_v2 = xy;
			if(bStt)
				bBound = GetDirPointByLine(tv.m_v1, xyTailLowerCross, xyTailUpperCross);
			else
				bBound = GetDirPointByLine(tv.m_v1, xyTailUpperCross, xyTailLowerCross);
			if(bBound) continue;

			CDPoint xyTemp(0, 0);
			GetXyMatchSegAndLine(tvUpperRebar.m_v1, tvUpperRebar.m_v2, xy, CDPoint(0, 1), xyTemp); 
			if(xy.y > xyTemp.y) continue;
			if(tvUpperRebar.GetVerLength() > 10 && Compare(tvUpperRebar.GetXyBottom().y, xy.y , _T("<="),1))
				continue;

			CString sEqul = bStt? _T(">") : _T("<");
			double dXLower = tvGenLower.m_v1.x + dCoverWingEnd;
			if(Compare(xy.x, dXLower, sEqul, 1))
				continue;			
			
			tv.m_sInfo = _T("전단D");
			tvArr.Add(tv);
		}
	}
}

// 날개벽 시점으로부터의 전면 전단철근 거리 배열
void CRcBridgeRebar::GetLengthArrayShearFront(CDoubleArray &dArr, char cBlock, BOOL bStt, BOOL bLeft)
{
	dArr.RemoveAll();

	CTwinVectorArray tvArr, tvArrGen;
	CTwinVector tvUpper;
	GetTvWingWallFront(bStt, bLeft, 1, tvArrGen);
	tvArrGen.GetTvByInfo(_T("날개벽정면상단"), tvUpper);
	CDPoint xyStt = tvUpper.m_v1;

	if(cBlock=='A')
		GetTvArrayRebarWingWallShearAFront(tvArr, bStt, bLeft, 1);
	else if(cBlock=='B' || cBlock=='C')
		GetTvArrayRebarWingWallShearBCFront(tvArr, bStt, bLeft, 1);
	else if(cBlock=='D')
		GetTvArrayRebarWingWallShearDFront(tvArr, bStt, bLeft, 1);

	set<double> length;
	int nSize = tvArr.GetSize();
	CDPoint xy(0, 0);
	int i=0; for(i=0; i<nSize; i++)
	{
		xy = tvArr.GetAt(i).m_v1;
		length.insert(fabs(xyStt.x-xy.x));
	}

	set<double>::iterator pos;
	for(pos=length.begin(); pos!=length.end(); ++pos)
		dArr.Add(*pos);
}

void CRcBridgeRebar::GetDimArrayRebarWingWallMinSide(CDPointArray &xyArr, BOOL bStt, BOOL bLeft, int nOut, int nDan)
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	CWingWall* pWing = GetWingWall(bStt, bLeft);

	xyArr.RemoveAll();

	CDPointArray xyArrSide = pWing->m_xyArrSide[nOut][nDan];
	int nSize = xyArrSide.GetSize();
	if(nSize<2) return;

	CTwinVectorArray tvArr, tvArrA, tvArrB, tvArrD;
	CTwinVector tv, tvUpper, tvLower, tvBound, tvNori;
	GetTvWingWallFront(bStt, bLeft, nOut, tvArr);

	double dCoverWingUpper = m_dCoverWingUpper;
	double dCoverWingLower = xyArrSide.GetAt(0).y;

	tvArr.GetTvByInfo(_T("날개벽정면상단"), tvUpper);
	tvArr.GetTvByInfo(_T("날개벽정면끝단하부"), tvLower);
	tvArr.GetTvByInfo(_T("날개벽정면노리"), tvNori);

	double dHgtMin = min(tvUpper.m_v2.y, tvUpper.m_v1.y) - tvLower.m_v2.y - dCoverWingUpper;
	double dHgtEnd = tvUpper.m_v2.y - tvLower.m_v2.y - dCoverWingUpper;
	BOOL bWingEnd = dHgtMin==dHgtEnd ? TRUE : FALSE;
	BOOL bSelMainCTCD = (pWing->m_bSelMainCTCD && pWing->m_dL2 > 0);
	BOOL bUpperRebarSlope = pWing->m_bUpperRebarSlope;	// 상면 주철근을 경사로 배치
	double dHgtHor = bUpperRebarSlope ? GetHeightWingWallHorRebar(bStt, bLeft, nOut, nDan) : dHgtMin;
	
	if(IsBoxType() && tvNori.GetVerLength() < 1 && tvNori.GetHorLength() >0 && pWing->m_dL2 == 0)
	{
		//검사
		double dRemain = dHgtHor - dHgtMin;
		double dLimitH	= 10;
		if(dRemain < 10)
			dHgtHor = dHgtMin;
	}

	if(nOut==0 && bWingEnd && bSelMainCTCD)
	{
		CDPointArray xyArrBound, xyArrBoundA, xyArrBoundB, xyArrBoundD, xyArrB, xyArrD;

		tvArr.GetTvByInfo(_T("날개벽정면끝단상부"), tvBound);
		xyArrBound.Add(tvLower.m_v2);
		xyArrBound.Add(tvLower.m_v1);
		xyArrBound.Add(tvBound.m_v2);
		xyArrBound.Add(tvBound.m_v1);

		GetTvArrayRebarWingWallBlockAMainFront(tvArrA, bStt, bLeft, nOut, nDan);
		GetTvArrayRebarWingWallBlockBMainFront(tvArrB, bStt, bLeft, nOut, nDan);
		GetTvArrayRebarWingWallBlockDMainFront(tvArrD, bStt, bLeft, nOut, nDan);


		long i = 0; for(i = 0; i < tvArrD.GetSize(); i++)
		{
			if(tvArrD.GetAt(i).m_sInfo.GetAt(0) == '*')
			{
				tvArrD.RemoveAt(i);
				i--;
			}
		}
		
		int nSizeA = tvArrA.GetSize();
		int nSizeB = tvArrB.GetSize();
		int nSizeD = tvArrD.GetSize();
		CDPoint xyBound1(0, 0), xyBound2(0, 0), xyResult(0, 0);
		BOOL bCross = FALSE;
		for(i=0; i<3; i++)
		{
			xyBound1 = xyArrBound.GetAt(i);
			xyBound2 = xyArrBound.GetAt(i+1);
			int j=0; for(j=0; j<nSizeB; j++)
			{
				tv = tvArrB.GetAt(j);
				bCross = GetXyMatchSegAndLine(xyBound1, xyBound2, tv.m_v2, tv.GetXyDir(), xyResult);
				if(bCross && tv.m_sInfo.GetAt(0) != '*')
					xyArrBoundB.Add(xyResult);
			}
			for(j=0; j<nSizeD; j++)
			{
				tv = tvArrD.GetAt(j);
				if(tv.GetXyDir().y!=0 && j!=nSizeD-1) continue;
				bCross = GetXyMatchSegAndLine(xyBound1, xyBound2, tv.m_v2, tv.GetXyDir(), xyResult);
				if(bCross && tv.m_sInfo.GetAt(0) != '*')
					xyArrBoundD.Add(xyResult);
			}
			for(j=0; j<nSizeA; j++)
			{
				tv = tvArrA.GetAt(j);
				if(tv.GetXyDir().y!=0 && j!=nSizeD-1) continue;
				bCross = GetXyMatchSegAndLine(xyBound1, xyBound2, tv.m_v2, tv.GetXyDir(), xyResult);
				if(bCross && tv.m_sInfo.GetAt(0) != '*')
					xyArrBoundA.Add(xyResult);
			}
		}
		// D구간과 B구간 사이를 메꿔주기 위함 /////
		// 만약 그 사이가 D구간이나 B구간중 큰 간격보다 크지 않다면 메꿀 필요 없음
		CDPointArray xyArrTemp;
		for(i=0; i<xyArrBoundA.GetSize(); i++)
		{
			if(xyArrBoundA.GetAt(i).y > xyArrBoundB.GetAt(xyArrBoundB.GetSize()-1).y && xyArrBoundA.GetAt(i).y < xyArrBoundD.GetAt(0).y)
				xyArrTemp.Add(xyArrBoundA.GetAt(i));
		}
		if(xyArrTemp.GetSize() > 2)
		{
			for(i = 0; i < xyArrTemp.GetSize(); i++)
				xyArrBoundB.Add(xyArrTemp.GetAt(i));
		}

		//상위 조건이 안맞을 경우 D구간의 최하단이 B구간의 최상단보다 클경우 B구간의 최상단을 수정해준다.
		if(xyArrTemp.GetSize() ==0 && xyArrBoundD.GetSize() >1 && xyArrBoundB.GetSize() > 1)
		{
			double dBotBoundD = xyArrBoundD.GetAt(0).y;
			double dTopBoundB = xyArrBoundB.GetAt(xyArrBoundB.GetSize()-1).y;

			if(Compare(dBotBoundD, dTopBoundB, _T("<"), 1))
			{
				for (long nIdx =0; nIdx <xyArrBoundB.GetSize(); nIdx++)
				{
					CDPoint xyB = xyArrBoundB.GetAt(nIdx);
					double dCurrY = xyB.y;

					if(Compare(dCurrY, dBotBoundD, _T(">"),1))
					{
						xyArrBoundB.RemoveAt(nIdx);
						nIdx--;
					}
				}
			}
		}
		//////////////////////////////////////////

		double dY = 0, dY1 = 0, dY2 = 0;
		CDoubleArray dArrB, dArrD;
		nSizeB = xyArrBoundB.GetSize();
		nSizeD = xyArrBoundD.GetSize();
		for(i=0; i<nSizeB-1; i++)
		{
			dY1 = xyArrBoundB.GetAt(i).y;
			dY2 = xyArrBoundB.GetAt(i+1).y;
			dY = Round(dY2-dY1, 0);
			if(dY != 0) dArrB.Add(dY);
		}
		for(i=0; i<nSizeD-1; i++)
		{
			dY1 = xyArrBoundD.GetAt(i).y;
			dY2 = xyArrBoundD.GetAt(i+1).y;
			dY = Round(dY2-dY1, 0);
			if(dY != 0) dArrD.Add(dY);
		}

		dY1 = xyArrBoundB.GetAt(nSizeB-1).y;
		dY2 = xyArrBoundD.GetAt(0).y;
		dY = Round(dY2-dY1, 0);
		if(dArrB.GetSize() > 0 && dY==dArrB.GetAt(dArrB.GetSize()-1))
			dArrB.Add(dY);
		else
			dArrD.InsertAt(0, dY);

		pStd->GetPointArrayCountAndValue(xyArrB, dArrB);
		pStd->GetPointArrayCountAndValue(xyArrD, dArrD);

		xyArr.Add(CDPoint(1, dCoverWingLower));
		for(i=0; i<xyArrB.GetSize(); i++)
			xyArr.Add(xyArrB.GetAt(i));
		for(i=0; i<xyArrD.GetSize(); i++)
			xyArr.Add(xyArrD.GetAt(i));

	}
	else
	{
		double dSumHgt = 0;
		int nCountBlock = 0;
		CDPoint xyR(0, 0);
		int i=0; for(i=0; i<nSize; i++)
		{
			xyR = xyArrSide.GetAt(i);
			if(xyR.x == 0 || xyR.y == 0)
				continue;
			dSumHgt += xyR.x*xyR.y;
			if(dSumHgt>dHgtHor)
			{
				dSumHgt -= xyR.x*xyR.y;
				break;
			}
			xyArr.Add(xyR);
			nCountBlock++;
		}

		CDPointArray xyArrBlock;
		CDoubleArray dArrBlock;
		for(i=nCountBlock; i<nSize; i++)
		{
			xyR = xyArrSide.GetAt(i);
			int j=0; for(j=0; j<xyR.x; j++)
			{
				dSumHgt += xyR.y;
				if(dSumHgt>dHgtHor) break;
				dArrBlock.Add(xyR.y);
			}
		}

		pStd->GetPointArrayCountAndValue(xyArrBlock, dArrBlock);
		for(i=0; i<xyArrBlock.GetSize(); i++)
			xyArr.Add(xyArrBlock.GetAt(i));

		dSumHgt = 0;
		for(i=0; i<xyArr.GetSize(); i++)
		{
			xyR = xyArr.GetAt(i);
			dSumHgt += xyR.x*xyR.y;
		}
		xyArr.Add(CDPoint(1, dHgtMin-dSumHgt));
	}
}

void CRcBridgeRebar::GetDimArrayRebarWingWallMaxSide(CDPointArray &xyArr, BOOL bStt, BOOL bLeft, int nOut, int nDan)
{
	CWingWall* pWing = GetWingWall(bStt, bLeft);

	xyArr.RemoveAll();

	CDPointArray xyArrSide = pWing->m_xyArrSide[nOut][nDan];
	int nSize = xyArrSide.GetSize();
	if(nSize<2) return;
	
	CTwinVectorArray tvArr, tvArrA, tvArrB, tvArrD;
	CTwinVector tv, tvUpper, tvLower, tvBound;
	GetTvWingWallFront(bStt, bLeft, nOut, tvArr);

	double dCoverWingUpper = m_dCoverWingUpper;
	double dCoverWingLower = xyArrSide.GetAt(0).y;

	tvArr.GetTvByInfo(_T("날개벽정면상단"), tvUpper);
	tvArr.GetTvByInfo(_T("날개벽정면끝단하부"), tvLower);

	double dHgtMax = max(tvUpper.m_v2.y-tvLower.m_v2.y, tvUpper.m_v1.y-tvLower.m_v2.y) - dCoverWingUpper;
	double dHgtEnd = tvUpper.m_v2.y - tvLower.m_v2.y - dCoverWingUpper;
	BOOL bWingEnd = dHgtMax==dHgtEnd ? TRUE : FALSE;
	BOOL bSelMainCTCD = pWing->m_bSelMainCTCD;

	if(nOut==0 && bWingEnd && bSelMainCTCD)
	{
		CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
		CDPointArray xyArrBound, xyArrBoundA, xyArrBoundB, xyArrBoundD, xyArrB, xyArrD;

		tvArr.GetTvByInfo(_T("날개벽정면끝단상부"), tvBound);
		xyArrBound.Add(tvLower.m_v2);
		xyArrBound.Add(tvLower.m_v1);
		xyArrBound.Add(tvBound.m_v2);
		xyArrBound.Add(tvBound.m_v1);

		GetTvArrayRebarWingWallBlockAMainFront(tvArrA, bStt, bLeft, nOut, nDan);
		GetTvArrayRebarWingWallBlockBMainFront(tvArrB, bStt, bLeft, nOut, nDan);
		GetTvArrayRebarWingWallBlockDMainFront(tvArrD, bStt, bLeft, nOut, nDan);
		int nSizeA = tvArrA.GetSize();
		int nSizeB = tvArrB.GetSize();
		int nSizeD = tvArrD.GetSize();
		CDPoint xyBound1(0, 0), xyBound2(0, 0), xyResult(0, 0);
		BOOL bCross = FALSE;
		int i=0; for(i=0; i<xyArrBound.GetSize()-1; i++)
		{
			xyBound1 = xyArrBound.GetAt(i);
			xyBound2 = xyArrBound.GetAt(i+1);
			int j=0; for(j=0; j<nSizeB; j++)
			{
				tv = tvArrB.GetAt(j);
				bCross = GetXyMatchSegAndLine(xyBound1, xyBound2, tv.m_v2, tv.GetXyDir(), xyResult);
				if(bCross)
					xyArrBoundB.Add(xyResult);
			}
			for(j=0; j<nSizeD; j++)
			{
				tv = tvArrD.GetAt(j);
				if(tv.m_sInfo == "*수평이음") continue;
				bCross = GetXyMatchSegAndLine(xyBound1, xyBound2, tv.m_v2, tv.GetXyDir(), xyResult);
				if(bCross)
					xyArrBoundD.Add(xyResult);
			}
			for(j=0; j<nSizeA; j++)
			{
				tv = tvArrA.GetAt(j);
				if(tv.m_sInfo == "*수평이음") continue;
				bCross = GetXyMatchSegAndLine(xyBound1, xyBound2, tv.m_v2, tv.GetXyDir(), xyResult);
				if(bCross)
					xyArrBoundA.Add(xyResult);
			}
		}
		for(i=0; i<xyArrBoundA.GetSize(); i++)
		{
			if(xyArrBoundA.GetAt(i).y > xyArrBoundB.GetAt(xyArrBoundB.GetSize()-1).y
				&& xyArrBoundA.GetAt(i).y < xyArrBoundD.GetAt(0).y)
				xyArrBoundB.Add(xyArrBoundA.GetAt(i));
		}

		double dY = 0, dY1 = 0, dY2 = 0;
		CDoubleArray dArrB, dArrD;
		nSizeB = xyArrBoundB.GetSize();
		nSizeD = xyArrBoundD.GetSize();
		if(nSizeB == 0 || nSizeD == 0) return;
		for(i=0; i<nSizeB-1; i++)
		{
			dY1 = xyArrBoundB.GetAt(i).y;
			dY2 = xyArrBoundB.GetAt(i+1).y;
			dY = Round(dY2-dY1, 0);
			if(dY==0) continue;
			dArrB.Add(dY);
		}
		for(i=0; i<nSizeD-1; i++)
		{
			dY1 = xyArrBoundD.GetAt(i).y;
			dY2 = xyArrBoundD.GetAt(i+1).y;
			dY = Round(dY2-dY1, 0);
			if(dY==0) continue;
			dArrD.Add(dY);
		}

		dY1 = xyArrBoundB.GetAt(nSizeB-1).y;
		dY2 = xyArrBoundD.GetAt(0).y;
		dY = Round(dY2-dY1, 0);
		if(dY==dArrB.GetAt(dArrB.GetSize()-1))
			dArrB.Add(dY);
		else
			dArrD.InsertAt(0, dY);

		pStd->GetPointArrayCountAndValue(xyArrB, dArrB);
		pStd->GetPointArrayCountAndValue(xyArrD, dArrD);

		xyArr.Add(CDPoint(1, dCoverWingLower));
		for(i=0; i<xyArrB.GetSize(); i++)
			xyArr.Add(xyArrB.GetAt(i));
		for(i=0; i<xyArrD.GetSize(); i++)
			xyArr.Add(xyArrD.GetAt(i));
	}
	else
		xyArr = xyArrSide;
}



// 날개벽 기초부 헌치 철근 좌표(정면도)
void CRcBridgeRebar::GetTvArrayRebarWingWallHunchFootingFront(CTwinVectorArray &tvArr, BOOL bStt, BOOL bLeft)
{
	CWingWall* pWing = GetWingWall(bStt, bLeft);

	if(!pWing->m_bExist) return;

	CTwinVectorArray tvArrGen, tvArrHu;
	CTwinVector tv, tvUpper, tvLower, tvHuFoot;
	GetTvWingWallFront(bStt, bLeft, 0, tvArrGen);
	tvArrGen.GetTvByInfo(_T("날개벽정면상단"), tvUpper);
	tvArrGen.GetTvByInfo(_T("날개벽정면끝단하부"), tvLower);
//	tvArrGen.GetTvByInfo(_T("날개벽정면하단헌치"), tvHuFoot);

	CDPointArray xyArr = pWing->m_xyArrLower[0];
	CDPoint vAng = GetAngleWingWallBetweenWall(bStt, bLeft);
	double dCoverFoot = GetCoverFooting(bStt, FALSE, 0);//m_dCoverLower_Footing[0]; 재호가 수정
	double dCoverWingEnd = GetCoverWingWallEnd(bStt, bLeft);
	double dLenFoot = GetLengthFootingWingWall(bStt, bLeft, FALSE, FALSE, 0);
	double dFH = bStt ? m_footingStt.m_dFH : m_footingEnd.m_dFH;
	GetTvArrayRebarWingWallHunchFootingSect(tvArrHu, bStt, bLeft);
	double dLenHunch = tvArrHu.GetAt(0).m_v1.y - tvArrHu.GetAt(2).m_v2.y;
	double dSpacing = 30;
	double se = bStt ? -1.0 : 1.0;
	CDPoint vX(1, 0), vY(0, 1);

	BOOL bRangEnd = pWing->m_bRAngEnd;
	int nSize = xyArr.GetSize();
	CDPoint xyR(0, 0), xyHunch(0, 0);
	xyHunch.x = tvLower.m_v1.x - dCoverWingEnd*se;
	xyHunch.y = tvLower.m_v2.y - dFH + dCoverFoot;

	// 기초헌치 철근은 날개벽 외측면 배근 간격을 따라가지만 구간은 내측면에서..
	double dLenTemp = 0;
	int i=0; for(i=0; i<nSize; i++)
	{
		xyR = xyArr.GetAt(i);
		dLenTemp += xyR.x * xyR.y;
	}
	
	
	xyArr = pWing->m_xyArrLower[1];
	nSize = xyArr.GetSize();
	double dLenSum = 0;

	//#0029288 - 0029235과 동일이슈지만 0029235은 엔진에서 처리됨
	double dWingGap = 0;

	double dAng = GetAngleWingWallBetweenWall(bStt, bLeft).GetAngleDegree();

	if(bRangEnd == FALSE && 90 < dAng /*(90 < dAng && 180 < dAng)*/)
	{
		GetTvWingWallPlane(bStt, TRUE, TRUE, TRUE);
		CTwinVectorArray tvArrPlane;

		tvArrPlane.AddFromTvArray(m_tvArrPlaneWingWall);


		CString strInfoFront = bLeft ? _T("좌측날개벽전면") : _T("우측날개벽전면");

		CString strInfoRear = bLeft ? _T("좌측날개벽배면변단면후") : _T("우측날개벽배면변단면후");

		CTwinVector tvFront = tvArrPlane.GetTvByInfo(strInfoFront, FALSE);

		CTwinVector tvRear = tvArrPlane.GetTvByInfo(strInfoRear, FALSE);

		CDPoint xyFront = tvFront.GetXyRight();

		CDPoint xyRear = tvRear.GetXyRight();

		CRebarPlacing rb;

		CDPoint xyMatch;

		if(GetXyMatchSegAndLine(tvRear.m_v1, tvRear.m_v2, xyFront, tvFront.GetXyDir().Rotate90(), xyMatch))
		{
			dWingGap = ~(xyMatch - xyRear);
		}	
	}

	for(i=0; i<nSize; i++)
	{
		xyR = xyArr.GetAt(i);

		int j=0; for(j=0; j<xyR.x; j++)
		{
			dLenSum += xyR.y;
			if(dLenSum > dLenTemp) break;

			//#0029288 - 0029235과 동일이슈지만 0029235은 엔진에서 처리됨
			if(dLenSum < dWingGap) continue;

			xyHunch -= xyR.y*vX*se;
			tv.m_v1 = xyHunch + dSpacing*vX*se;
			tv.m_v2 = tv.m_v1 + dLenHunch*vY;

			tv.m_sInfo = _T("기초헌치");
			if(fabs(Round(xyHunch.x-tvUpper.m_v1.x, 0))<=Round(dLenFoot-dCoverWingEnd, 0))
				tvArr.Add(tv);
		}
	}
}

// 날개벽 시점부의 철근 배치
void CRcBridgeRebar::GetDimArrayRebarWingWallSttSide(CDPointArray &xyArr, BOOL bStt, BOOL bLeft, int nOut, int nDan)
{
	CWingWall* pWing = GetWingWall(bStt, bLeft);

	if(!pWing->m_bExist) return;

	CTwinVectorArray tvArrGen;
	CTwinVector tvUpper, tvLower;
	GetTvWingWallFront(bStt, bLeft, nOut, tvArrGen);
	tvArrGen.GetTvByInfo(_T("날개벽정면상단"), tvUpper);
	tvArrGen.GetTvByInfo(_T("날개벽정면끝단하부"), tvLower);

	double dHgtStt = tvUpper.m_v1.y-tvLower.m_v2.y;
	double dHgtEnd = tvUpper.m_v2.y-tvLower.m_v2.y;

	if(dHgtStt>=dHgtEnd)
		xyArr = pWing->m_xyArrSide[nOut][nDan];
	else
		GetDimArrayRebarWingWallMinSide(xyArr, bStt, bLeft, nOut, nDan);
}

// 날개벽 상면 철근 배치
void CRcBridgeRebar::GetDimArrayRebarWingWallUpper(CDPointArray &xyArr, BOOL bStt, BOOL bLeft, int nOut, int nDan)
{
	xyArr.RemoveAll();

	CWingWall* pWing = GetWingWall(bStt, bLeft);

	if(!pWing->m_bExist) return;

	xyArr = pWing->m_xyArrUpper[nOut][nDan];
	return;
	
	// 철근배치 재정렬 안함 ... 2005.06.28 - jeon
/*	CDPoint vAng = GetAngleWingWallBetweenWall(bStt, bLeft);
	double dT1 = pWing->m_dT1;
	double dT2 = pWing->m_dT2;
	double dVarT = (nOut==0 && pWing->m_bRAngEnd) ? (dT1-dT2)/vAng.y*vAng.x : 0.0;
	if(pWing->m_nDirHunch==2)
		dVarT = 0.0;

	CDPointArray xyArrInput = pWing->m_xyArrUpper[nOut][nDan];
	vector<double> len;
	int nSize = xyArrInput.GetSize();
	CDPoint xyR(0, 0);
	int i=0; for(i=0; i<nSize; i++)
	{
		xyR = xyArrInput.GetAt(i);
		int j=0; for(j=0; j<xyR.x; j++)
		{
			if(i==0 && j==0)
				xyR.y -= dVarT;

			len.push_back(xyR.y);
		}
	}
	vector<double>::iterator pos = len.begin();
	int nEa = 0;
	while(pos!=len.end())
	{
		double *d1 = len.end();
		double *d2 = len.begin();
		nEa = count(len.begin(), len.end(), *pos);
		xyArr.Add(CDPoint(nEa, *pos));
		pos += nEa;
	}*/
}

// 날개벽 벽체부 헌치 철근 좌표(정면도)
void CRcBridgeRebar::GetTvArrayRebarWingWallHunchWallFront(CTwinVectorArray &tvArr, BOOL bStt, BOOL bLeft)
{
	CARcBridgeDataStd *pStd = m_pARcBridgeDataStd;
	CWingWall* pWing = GetWingWall(bStt, bLeft);

	if(!pWing->m_bExist) return;

	CDPointArray xyArr;
	CTwinVectorArray tvArrGen, tvArrHu, tvArrUpper, tvArrPlan;
	CTwinVector tv, tvUpper, tvLower, tvUpperRebar;
	int nOut = pWing->m_nHunchCTC;
	GetTvWingWallFront(bStt, bLeft, nOut, tvArrGen);

	BOOL bSide		= (pWing->m_nAttachPos == 0 )? FALSE : TRUE;
	tvArrGen.GetTvByInfo(_T("날개벽정면상단"), tvUpper);
	tvArrGen.GetTvByInfo(_T("날개벽정면끝단하부"), tvLower);
	CDPoint vAng = GetAngleWingWallBetweenWall(bStt, bLeft);
	double dCoverWall = (!bSide)? m_dCoverWallIn[0]/vAng.y : 0.0;

	GetTvArrayRebarWingWallHunchWallPlane(tvArrHu, bStt, bLeft, TRUE);
	CDPoint xyHu1 = tvArrHu.GetAt(0).m_v1;
	CDPoint xyHu2 = tvArrHu.GetAt(2).m_v2;
	CDPoint vHu1 = tvArrHu.GetAt(0).GetXyDir();
	CDPoint vHu2 = tvArrHu.GetAt(2).GetXyDir();
	double dLenHunch = 0;

	if(!bSide) GetXyMatchLineAndLine(xyHu1, vHu1, xyHu2, vHu2, xyHu2);
	else GetXyMatchLineAndLine(xyHu1, vHu1, xyHu2, vHu1.Rotate90(), xyHu2);
	dLenHunch = ~(xyHu1-xyHu2);

	double dSpacing = 30l ;
	double se = bStt ? -1.0 : 1.0;
	CDPoint vX(1, 0), vY(0, 1);

	long nDan = 0;
	GetDimArrayRebarWingWallSttSide(xyArr, bStt, bLeft, nOut, nDan);

	int nSize = xyArr.GetSize();
	CDPoint xyR(0, 0), xyHunch(0, 0);
	xyHunch.x = tvUpper.m_v1.x + dCoverWall*se;
	xyHunch.y = tvLower.m_v2.y;

	double dHgtB = tvLower.m_v2.y + GetLengthWingWallBlockBC(bStt, bLeft);	// B구간의 높이

	double dSettleA(0), dSettleB(0), dSettleD(0);
	if(m_pARcBridgeDataStd->IsLsdDesign())
	{
		SRebarEnvOption LsdRebarOpt;
		SetRebarLsdOptionWingWall(&LsdRebarOpt, bStt, bLeft, nOut==0, WINGWALL_SECTA, TRUE);
		dSettleA = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueSettle(pWing->m_dDiaMainA[nOut][nDan], &LsdRebarOpt);

		SetRebarLsdOptionWingWall(&LsdRebarOpt, bStt, bLeft, nOut==0, WINGWALL_SECTB, TRUE);
		dSettleB = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueSettle(pWing->m_dDiaMainB[nOut][nDan], &LsdRebarOpt);

		SetRebarLsdOptionWingWall(&LsdRebarOpt, bStt, bLeft, nOut==0, WINGWALL_SECTD, TRUE);
		dSettleD = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueSettle(pWing->m_dDiaMainD[nOut][nDan], &LsdRebarOpt);
	}
	else
	{
		dSettleA = pStd->GetValueSettle(pWing->m_dDiaMainA[nOut][nDan], SETTLE_TENS_NORMAL, toCm(m_dCoverWallOut[0]), toCm(pWing->m_dMainCTCA/2));
		dSettleB = pStd->GetValueSettle(pWing->m_dDiaMainB[nOut][nDan], SETTLE_TENS_NORMAL, toCm(m_dCoverWallOut[0]), toCm(pWing->m_dMainCTCB/2));
		dSettleD = pStd->GetValueSettle(pWing->m_dDiaMainD[nOut][nDan], SETTLE_TENS_NORMAL, toCm(m_dCoverWallOut[0]), toCm(pWing->m_dMainCTCA/2));
	}

	double dAngle	= vAng.GetAngleDegree();
	double dAngJijum = GetAngleJijum(bStt? 0 : m_nQtyJigan).GetAngleDegree();
	// double dAngA1 = dAngle - dAngJijum;
	double dAngA1 = (dAngle - dAngJijum) * (bLeft? -1 : 1);

	// 각도 계산이 잘못 됨
	// 예전에 수정하다가 잘못 수정한 코드인거 같아서 막음(modified by jaeho 2009.06.15)
	/*
	if((bStt && bLeft) || (!bStt && !bLeft))
	{
		dAngJijum = 180 - dAngJijum;
		dAngA1	= (dAngle - dAngJijum) * (bLeft ? 1 : -1);
	}
	*/

	tvUpperRebar = GetTvRebarWingWallUpper(bStt, bLeft, nOut);
	CDPoint xyUpperBound1 = bStt ? tvUpperRebar.m_v1 : tvUpperRebar.m_v2;
	CDPoint xyUpperBound2 = bStt ? tvUpperRebar.m_v2 : tvUpperRebar.m_v1;
	CDPoint xyTailUpper = GetXyRebarWingWallTailUpperCross(bStt, bLeft, 0);
	CDPoint xyTailLower = GetXyRebarWingWallTailLowerCross(bStt, bLeft, 0);
	CDPoint xyTailBound1 = xyTailLower; //bStt ? xyTailLower : xyTailUpper;
	CDPoint xyTailBound2 = xyTailUpper; //bStt ? xyTailUpper : xyTailLower;

	int i=0; for(i=0; i<nSize; i++)
	{
		xyR = xyArr.GetAt(i);
		int j=0; for(j=0; j<xyR.x; j++)
		{
			xyHunch += xyR.y*vY;
			if(bSide)
			{
				//{ 31384
				BOOL bPass = FALSE;
				if(dAngA1 < 0)
				{
					double dAngJi = dAngJijum;

					if(dAngJi > 0)
						dAngJi = -dAngJi;

					if(dAngJi < dAngA1)
						bPass = TRUE;
				}//}

				double dSettle = (xyHunch.y > dHgtB)? ((pWing->m_dL2==0)? dSettleD:dSettleA) : dSettleB;
				
				long nDirPlus = bLeft? -1 : +1;
				double d	= dAngA1-(90-dAngA1* nDirPlus);
				
				//#0032085 각도가 180에 가까우게 되면 angle값의 y로 dFactor를 나누게 되어 dFactor가 커지게 된다.
				if(d > 180) d -= 90;

				if(Compare(d, 0.0, "=") || Compare(fabs(d), 180.0, "=") || Compare(fabs(d), 360.0, "="))
					d	= 90;
				double dFactor	= fabs(ToDPointFrDegree(d).y);
				
				if(bPass == FALSE) //31384
					dSettle += m_dCoverWallOut[0]/dFactor;

				tv.m_v1 = xyHunch - dSpacing*vY - dSettle*vX*se;
				tv.m_v2 = tv.m_v1 + dLenHunch*vX*se;
			}
			else
			{
				tv.m_v1 = xyHunch - dSpacing*vY;
				tv.m_v2 = tv.m_v1 + dLenHunch*vX*se;
			}

			//GetDirPointByLine(tv.m_v2, xyTailBound1, xyTailBound2) 함수가 기존의 방향성이 있을때 오류가 있어서 수정
			CDPoint xyMat;
			BOOL bMatTailAndHunch = GetXyMatchSegAndSeg(tv.m_v1, tv.m_v2, xyTailBound1, xyTailBound2, xyMat);
			if((tv.m_v2.y > xyTailBound1.y) && bMatTailAndHunch) //
				continue;
			else if((tv.m_v2.y <= xyTailBound1.y) && ((tv.m_v2.x * se) > (xyTailBound1.x * se)))
				continue;
			if(!GetDirPointByLine(tv.m_v2, xyUpperBound1, xyUpperBound2))
				break;

			tv.m_sInfo = _T("벽체헌치");
			tvArr.Add(tv);
		}
	}
}

// 날개벽 기초부 헌치 철근 좌표(단면도)
void CRcBridgeRebar::GetTvArrayRebarWingWallHunchFootingSect(CTwinVectorArray &tvArr, BOOL bStt, BOOL bLeft)
{
	tvArr.RemoveAll();

	CWingWall* pWing = GetWingWall(bStt, bLeft);

	if(!pWing->m_bExist) return;

	CTwinVectorArray tvArrGen;
	CTwinVector tv, tvOut, tvLower, tvHunch;
	GetTvWingWallSection(bStt, bLeft, tvArrGen);

	tvArrGen.GetTvByInfo(_T("날개벽단면외측"), tvOut);
	tvArrGen.GetTvByInfo(_T("날개벽단면하단"), tvLower);
	tvArrGen.GetTvByInfo(_T("날개벽단면기초헌치"), tvHunch);

	double dCoverWingOut = m_dCoverWingOut[0];
	double dCoverWingIn = m_dCoverWingIn[0];
	double dCoverFootLower = GetCoverFooting(bStt, FALSE, 0);//m_dCoverLower_Footing[0]; 재호가 수정
	double dSettle = (tvHunch.GetLength() > 0)? 300 : 0;
	double lr = bLeft ? -1.0 : 1.0;
	CDPoint xyCrossOut(0, 0), xyCrossLow(0, 0), vX(1, 0), vY(0, 1);
	Offset(tvOut.m_v1, tvOut.m_v2, dCoverWingOut*lr);
	Offset(tvLower.m_v1, tvLower.m_v2, dCoverFootLower*lr);
	Offset(tvHunch.m_v1, tvHunch.m_v2, -dCoverWingIn*lr);

	GetXyMatchSegAndLine(tvOut.m_v1, tvOut.m_v2, tvHunch.m_v1, tvHunch.GetXyDir(), xyCrossOut);
	GetXyMatchSegAndLine(tvLower.m_v1, tvLower.m_v2, tvHunch.m_v2, tvHunch.GetXyDir(), xyCrossLow);

	tv.m_v1 = xyCrossOut + dSettle*vY;
	tv.m_v2 = xyCrossOut;
	tvArr.Add(tv);

	tv.m_v1 = xyCrossOut;
	tv.m_v2 = xyCrossLow;
	tvArr.Add(tv);

	tv.m_v1 = xyCrossLow;
	tv.m_v2 = xyCrossLow - dSettle*vX*lr;
	tvArr.Add(tv);
}

// 날개벽 벽체부 헌치 철근 좌표(평면도)
void CRcBridgeRebar::GetTvArrayRebarWingWallHunchWallPlane(CTwinVectorArray &tvArr, BOOL bStt, BOOL bLeft, BOOL bUpper)
{
	tvArr.RemoveAll();
	CRebarPlacing rp;
	CWingWall* pWing = GetWingWall(bStt, bLeft);

	if(!pWing->m_bExist) return;

	CTwinVectorArray tvArrGen;
	CTwinVector tv, tvWing, tvWall, tvHunch, tvWingEnd;
	GetTvWingWallPlane(bStt, TRUE, bUpper, bUpper);
	tvArrGen = m_tvArrPlaneWingWall;

	CString strDir = bLeft ? _T("좌측") : _T("우측");
	tvArrGen.GetTvByInfo(strDir+_T("날개벽외측"), tvWing);
	tvArrGen.GetTvByInfo(_T("슬래브끝단외측"), tvWall);
	tvArrGen.GetTvByInfo(strDir+_T("날개벽시점헌치"), tvHunch);
	tvArrGen.GetTvByInfo(strDir+_T("날개벽끝단"), tvWingEnd);

	BOOL bSide		= (pWing->m_nAttachPos == 0 )? FALSE : TRUE;
	CDPoint xyCrossWing(0, 0), xyCrossWall(0, 0), vX(1, 0);
	double lr = bLeft ? -1.0 : 1.0;
	double se = bStt ? -1.0 : 1.0;
	CDPoint xyOrigin = bLeft ? tvWall.m_v1 : tvWall.m_v2;
	CDPoint vAngWing = GetAngleAzimuthWingWall(bStt, bLeft);
	CDPoint vRotate = vAngWing.BetweenAngle(vX*se);

	double dCoverWingOut = m_dCoverWingOut[0];
	double dCoverWingIn = m_dCoverWingIn[0];
	double dCoverWallIn = m_dCoverWallIn[0];
	double dCoverWallOut = m_dCoverWallOut[0];

	if(bSide)
	{
		double dTickWall = (bStt)? m_dWS : m_dWE;
		Offset(tvWing.m_v1, tvWing.m_v2, -dCoverWingOut*lr);
		Offset(tvWall.m_v1, tvWall.m_v2, -(dTickWall-dCoverWallOut));
		Offset(tvHunch.m_v1, tvHunch.m_v2, -dCoverWingIn*lr);
	}
	else
	{
		Offset(tvWing.m_v1, tvWing.m_v2, -dCoverWingOut*lr);
		Offset(tvWall.m_v1, tvWall.m_v2, -dCoverWallIn);
		Offset(tvHunch.m_v1, tvHunch.m_v2, -dCoverWingIn*lr);
	}

	BOOL bMat1 = GetXyMatchSegAndLine(tvWing.m_v1, tvWing.m_v2, tvHunch.m_v1, tvHunch.GetXyDir(), xyCrossWing);
	BOOL bMat2 = GetXyMatchSegAndLine(tvWall.m_v1, tvWall.m_v2, tvHunch.m_v2, tvHunch.GetXyDir(), xyCrossWall);

	CDPoint xyMatCross;
	CTwinVector tvCrossLine;
	tvCrossLine.m_v1 = xyCrossWall;
	tvCrossLine.m_v2 = xyCrossWing;

	double dDist			= fabs(tvCrossLine.GetLength());
	double dWallLen	= tvWall.GetLength();
	BOOL bMatCrossWingEnd = GetXyMatchSegAndSeg(tvCrossLine.m_v1, tvCrossLine.m_v2, tvWingEnd.m_v1, tvWingEnd.m_v2, xyMatCross);

	if(Compare(dDist, dWallLen , _T(">"), 0.1) || bMatCrossWingEnd)
	{
		bMat1 = bMat2 = FALSE;
	}

	if(!bMat1 && !bMat2)
	{
		tv.m_v1 = xyCrossWall;
		tv.m_v2 = xyCrossWall;
		tvArr.Add(tv);

		tv.m_v1 = xyCrossWall;
		tv.m_v2 = xyCrossWall;
		tvArr.Add(tv);

		tv.m_v1 = xyCrossWall;
		tv.m_v2 = xyCrossWall;
		tvArr.Add(tv);
	}
	else
	{
		tv.m_v1 = xyCrossWing + 300*tvWing.GetXyDir();
		tv.m_v2 = xyCrossWing;
		tvArr.Add(tv);

		tv.m_v1 = xyCrossWing;
		tv.m_v2 = xyCrossWall;
		tvArr.Add(tv);

		tv.m_v1 = xyCrossWall;
		tv.m_v2 = xyCrossWall - 300*tvWall.GetXyDir()*lr;
		tvArr.Add(tv);
	}
	
}

// 날개벽 단면 변화부 포인트
void CRcBridgeRebar::GetXyRebarWingWallVarySect(CDPoint *xy, BOOL bStt, BOOL bLeft, long nDan)
{
	CWingWall* pWing = GetWingWall(bStt, bLeft);

	if(!pWing->m_bExist) return;

	CTwinVectorArray tvArrGen;
	CTwinVector tvOut, tvHuPrev, tvHuNext, tvHunch, tvUpper;
	GetTvWingWallSection(bStt, bLeft, tvArrGen);

	tvArrGen.GetTvByInfo(_T("날개벽단면외측"), tvOut);
	tvArrGen.GetTvByInfo(_T("날개벽단면내측헌치전"), tvHuPrev);
	tvArrGen.GetTvByInfo(_T("날개벽단면내측헌치후"), tvHuNext);
	tvArrGen.GetTvByInfo(_T("날개벽단면내측헌치"), tvHunch);
	tvArrGen.GetTvByInfo(_T("날개벽단면상단"), tvUpper);

	double dT1 = pWing->m_dT1;
	double dT2 = pWing->m_dT2;
	double dCoverWingOut = m_dCoverWingOut[0];
	double dCoverWingIn = m_dCoverWingIn[0];
	double dCoverWingTop = m_dCoverWingUpper;
	double lr = bLeft ? -1.0 : 1.0;
	Offset(tvOut.m_v1, tvOut.m_v2, dCoverWingOut*lr);
	Offset(tvHuPrev.m_v1, tvHuPrev.m_v2, -(dCoverWingIn + 100*nDan)*lr);
	Offset(tvHuNext.m_v1, tvHuNext.m_v2, -(dCoverWingIn + 100*nDan)*lr);
	Offset(tvHunch.m_v1, tvHunch.m_v2, -(dCoverWingIn + 100*nDan)*lr);
	Offset(tvUpper.m_v1, tvUpper.m_v2, -(dCoverWingTop + 100*nDan));
	tvUpper.m_v1.x -= dCoverWingOut*lr;
	tvUpper.m_v2.x += (dCoverWingIn + 100*nDan)*lr;

	int nDirHunch = pWing->m_nDirHunch;
	if(nDirHunch==2)
		dT1 = dT2;

	CDPoint vHu = tvHunch.GetXyDir(), vY(0, 1);

	if(dT1<dT2)
	{
		GetXyMatchLineAndLine(tvHuNext.m_v1, vY, tvHunch.m_v2, vHu, xy[0]);
		GetXyMatchLineAndLine(tvHuPrev.m_v1, vY, tvHunch.m_v1, vHu, xy[1]);
		if(!GetXyMatchSegAndLine(tvUpper.m_v1, tvUpper.m_v2, tvHunch.m_v1, vHu, xy[2]))
			GetXyMatchLineAndLine(tvOut.m_v1, vY, tvHunch.m_v1, vHu, xy[2]);
	}
	else if(dT1>dT2)
	{
		GetXyMatchLineAndLine(tvHuPrev.m_v1, vY, tvHunch.m_v2, vHu, xy[0]);
		GetXyMatchLineAndLine(tvHuNext.m_v1, vY, tvHunch.m_v1, vHu, xy[1]);
		GetXyMatchLineAndLine(tvOut.m_v1, vY, tvHunch.m_v1, vHu, xy[2]);
	}
	else
		xy[0] = xy[1] = xy[2] = tvHuNext.m_v1 - dCoverWingTop*CDPoint(0, 1);
}

// 날개벽 평면 변화부 포인트
void CRcBridgeRebar::GetXyRebarWingWallVaryPlane(CDPoint *xy, BOOL bStt, BOOL bLeft)
{
	CWingWall* pWing = GetWingWall(bStt, bLeft);

	if(!pWing->m_bExist) return;

	CTwinVectorArray tvArrGen;
	CTwinVector tvOut, tvHuPrev, tvHuNext, tvHunch;
	GetTvWingWallPlane(bStt, TRUE, TRUE);
	tvArrGen = m_tvArrPlaneWingWall;

	CString strDir = bLeft ? _T("좌측") : _T("우측");
	tvArrGen.GetTvByInfo(strDir+_T("날개벽외측"), tvOut);
	tvArrGen.GetTvByInfo(strDir+_T("날개벽내부헌치전"), tvHuPrev);
	tvArrGen.GetTvByInfo(strDir+_T("날개벽내부헌치"), tvHunch);
	tvArrGen.GetTvByInfo(strDir+_T("날개벽내부헌치후"), tvHuNext);

	double dT1 = pWing->m_dT1;
	double dT2 = pWing->m_dT2;
	double dCoverWingOut = m_dCoverWingOut[0];
	double dCoverWingIn = m_dCoverWingIn[0];
	double dCoverWingTop = m_dCoverWingUpper;
	double lr = bLeft ? -1.0 : 1.0;
	Offset(tvOut.m_v1, tvOut.m_v2, -dCoverWingOut*lr);
	Offset(tvHuPrev.m_v1, tvHuPrev.m_v2, -dCoverWingIn*lr);
	Offset(tvHuNext.m_v1, tvHuNext.m_v2, -dCoverWingIn*lr);
	Offset(tvHunch.m_v1, tvHunch.m_v2, -dCoverWingIn*lr);

	int nDirHunch = dT1==dT2 ? 1 : pWing->m_nDirHunch;
	if(nDirHunch==1)
		dT1 = dT2 = max(pWing->m_dT1, pWing->m_dT2);

	CDPoint vOut = tvOut.GetXyDir();
	CDPoint vHuPrev = tvHuPrev.GetXyDir();
	CDPoint vHuNext = tvHuNext.GetXyDir();
	CDPoint vHu = tvHunch.GetXyDir();

	if(dT1<dT2)
	{
		GetXyMatchLineAndLine(tvHuNext.m_v1, vHuNext, tvHunch.m_v2, vHu, xy[0]);
		GetXyMatchLineAndLine(tvHuPrev.m_v1, vHuPrev, tvHunch.m_v1, vHu, xy[1]);
		GetXyMatchLineAndLine(tvOut.m_v1, vOut, tvHunch.m_v1, vHu, xy[2]);
	}
	else if(dT1>dT2)
	{
		GetXyMatchLineAndLine(tvHuPrev.m_v1, vHuPrev, tvHunch.m_v2, vHu, xy[0]);
		GetXyMatchLineAndLine(tvHuNext.m_v1, vHuNext, tvHunch.m_v1, vHu, xy[1]);
		GetXyMatchLineAndLine(tvOut.m_v1, vOut, tvHunch.m_v1, vHu, xy[2]);
	}
	else
		xy[0] = xy[1] = xy[2] = tvHuNext.m_v1 + dCoverWingTop*vHuNext;
}

// 횡단면도 상부 슬래브 주철근
// dSta : 스테이션별로 모양이 다를 수도 있다
// 주철근이 선형방향으로 배치되면 수직으로 자른횡단면을 사용하지만
// 사보강배치방법으로 배근되면 시점각도로 자른횡단면을 사용한다.
// 이것은 주철근 배치를 위해 사용할대는 위와 같이 두가지 방법으로 사용하지만 
// BOOL bForDrawCrossSection : 횡단면도를 그리기 위해서 그릴때는 무조건 직각방향으로 자른 횡단면을 사용한다.
// BOOL bForRebarBM : 철근 집계용으로 그릴 것인지? : 다른건 없고 컨티레벨인 경우 철근이 분리가 되므로 거기에 대한 처리를 해준다.
// CTwinVectorArray &tvArrLeft, CTwinVectorArray &tvArrRight,  : 컨티레벨인 경우 좌우 끝에 하나씩 더 생기는 배력근.
// long nApplyAngle : 0이면 배근 방식에 따라 자동으로 각도 적용 여부를 결정하지만, -1이면 직방향, 1이면 사방향으로 강제적용한다.
// BOOL bMirror : 뒤집음 (시점은 기본으로 뒤집어야 되고, 나머진 강제로 뒤집을 때도 있음)
void CRcBridgeRebar::GetTvRebarSupport_CrossSection_UpperSlab(CTwinVectorArray &tvArr, CTwinVectorArray &tvArrLowerLeft, CTwinVectorArray &tvArrLowerRight, double dSta, BOOL bUpper, long nDan, long nDrawLeft, BOOL bForDrawCrossSection, BOOL bForRebarBM, BOOL bExp, long nApplyAngle, BOOL bMirror)
{
	if(!IsExp(dSta))
		bExp	= FALSE;

	tvArr.RemoveAll();
	tvArrLowerLeft.RemoveAll();
	tvArrLowerRight.RemoveAll();

	double dCoverUpper	= nDan > -1 ? m_dCoverUpper_UpperSlab[nDan] : 0;
	double dCoverLower	= nDan > -1 ? m_dCoverLower_UpperSlab[nDan] : 0;

	BOOL bVertDir	= IsVertDir();
	CDPoint vAng	= !bVertDir ? GetAngleJijum(0) : CDPoint(0, 1);
	if(bForDrawCrossSection)
		vAng	= CDPoint(0, 1);
	if(nApplyAngle == -1)
		vAng	= CDPoint(0, 1);
	else if(nApplyAngle == 1)
		vAng	= GetAngleJijum(GetJijumNumberByStation(dSta));

	double dCoverSideL	= nDan > -1 ? GetCoverSide_UpperSlab(nDan, dSta, vAng, TRUE, TRUE) : 0;
	double dCoverSideR	= nDan > -1 ? GetCoverSide_UpperSlab(nDan, dSta, vAng, TRUE, FALSE) : 0;

	double dStaSmallestWidth	= dSta;//GetStationSmallestWidthOfUpperSlab();
	GetTvCrossSection(tvArr, dStaSmallestWidth, vAng, FALSE, TRUE, FALSE, 0, FALSE, FALSE, FALSE, bExp);

	// 상,측,하면 좌표들 구함.
	long nSize	= tvArr.GetSize();
	CTwinVector tv;
	CTwinVectorArray tvArrUpper, tvArrLower, tvArrLeft, tvArrRight;
	CString sOldInfo	= "";
	long i = 0; for(i = 0; i < nSize; i++)
	{
		tv	= tvArr.GetAt(i);
		if(tv.m_sInfo == "")
			tv.m_sInfo	= sOldInfo;
		if(Compare(tv.GetLength(), 0.0, "=")) 
			continue;
			
		if(tv.m_sInfo.Find("슬래브상면", 0) != -1) 
			tvArrUpper.Add(tv);
		else if(tv.m_sInfo.Find("슬래브하부", 0) != -1) 
			tvArrLower.Add(tv);
		else if(tv.m_sInfo.Find("슬래브좌측면", 0) != -1) 
			tvArrLeft.Add(tv);
		else if(tv.m_sInfo.Find("슬래브우측면", 0) != -1) 
			tvArrRight.Add(tv);
		else if(tv.m_sInfo.Find("좌측슬래브모따기", 0) != -1) 
			tvArrLeft.Add(tv);
		else if(tv.m_sInfo.Find("우측슬래브모따기", 0) != -1) 
			tvArrRight.Add(tv);

		sOldInfo	= tv.m_sInfo;
	}
	CRebarPlacing rb;
	
	// 단에 맞게 offset
	rb.GetOffsetTvArray(tvArrUpper, dCoverUpper);
	rb.GetOffsetTvArray(tvArrLower, -dCoverLower, TRUE, 0.00001);	// 길이가 매우 짧은 철근이 sort되면서 뒤집힌 경우가 있었음
	rb.GetOffsetTvArray(tvArrLeft, -dCoverSideL);
	rb.GetOffsetTvArray(tvArrRight, dCoverSideR);

	if(tvArrUpper.GetSize() == 0 || tvArrLower.GetSize() == 0 || tvArrLeft.GetSize() == 0 || tvArrRight.GetSize() == 0)
		return;

	double dCoverMax	= max(dCoverUpper, dCoverLower);
	dCoverMax	= max(dCoverMax, dCoverSideL);
	dCoverMax	= max(dCoverMax, dCoverSideR);

	// offset 된 것들을 교차점 처리
	// 현재 방향 상 : 좌->우, 하 : 좌->우, 좌와우 : 상->하
	// 1. 상면과 양 측면 교차점 처리
	CTwinVector tv1, tv2;
	tv1	= tvArrUpper.GetAt(0);
	tv2	= tvArrLeft.GetAt(0);
	// 측면의 첫번째 선이 두개이고 첫번째 선이 직선인데 가장큰 피복보다 길이가 작으면 삭제
	if(tvArrLeft.GetSize() == 2 && Compare(tv2.GetLength(), dCoverMax, "<"))
	{
		tvArrLeft.RemoveAt(0);
		tv2	= tvArrLeft.GetAt(0);
		CDPointArray xyArrMatch;
		rb.GetXyMatchTvArrAndTvArr(tvArrUpper, tvArrLeft, xyArrMatch, FALSE);
		if(xyArrMatch.GetSize() > 0)
		{
			tv1.m_v1	= xyArrMatch.GetAt(0);
			tv2.m_v1.x	= tv1.m_v1.x;
			tv2.m_v1.y	= tv1.m_v1.y;

		}
	}
	else
	{
		GetXyMatchLineAndLine(tv1.m_v2, tv1.GetXyDir(TRUE), tv2.m_v2, tv2.GetXyDir(TRUE), tv1.m_v1);
		tv2.m_v1	= tv1.m_v1;
	}
	tvArrUpper.SetAt(0, tv1);
	tvArrLeft.SetAt(0, tv2);

	// 측면이 하나밖에 없을때는 하면과의 교차점도 찾아야 한다.
	if(tvArrLeft.GetSize() == 1)
	{
		CTwinVector *pTv	= tvArrLeft.GetPAt(0);
		CDPointArray xyArrMatch;
		rb.GetXyMatchTvArrAndTvArr(tvArrLower, tvArrLeft, xyArrMatch, FALSE);
		if(xyArrMatch.GetSize() > 0)
		{
			pTv->m_v2	= xyArrMatch.GetAt(0);
		}
	}

	tv1	= tvArrUpper.GetAt(tvArrUpper.GetSize()-1);
	tv2	= tvArrRight.GetAt(0);
	
	// 측면의 첫번째 선이 두개이고 첫번째 선이 직선인데 가장큰 피복보다 길이가 작으면 삭제
	if(tvArrRight.GetSize() == 2 && Compare(tv2.GetLength(), dCoverMax, "<"))
	{
		tvArrRight.RemoveAt(0);
		tv2	= tvArrRight.GetAt(0);
		CDPointArray xyArrMatch;
		rb.GetXyMatchTvArrAndTvArr(tvArrUpper, tvArrRight, xyArrMatch, FALSE);
		if(xyArrMatch.GetSize() > 0)
		{
			tv1.m_v2	= xyArrMatch.GetAt(0);
			tv2.m_v1.x	= tv1.m_v2.x;
			tv2.m_v1.y	= tv1.m_v2.y;

		}
	}
	else
	{
		GetXyMatchLineAndLine(tv1.m_v1, tv1.GetXyDir(), tv2.m_v2, tv2.GetXyDir(TRUE), tv1.m_v2);
		tv2.m_v1	= tv1.m_v2;
	}
	tvArrUpper.SetAt(tvArrUpper.GetSize()-1, tv1);
	tvArrRight.SetAt(0, tv2);

	// 측면이 하나밖에 없을때는 하면과의 교차점도 찾아야 한다.
	if(tvArrRight.GetSize() == 1)
	{
		CTwinVector *pTv	= tvArrRight.GetPAt(0);
		CDPointArray xyArrMatch;
		rb.GetXyMatchTvArrAndTvArr(tvArrLower, tvArrRight, xyArrMatch, FALSE);
		if(xyArrMatch.GetSize() > 0)
		{
			pTv->m_v2	= xyArrMatch.GetAt(0);
		}
	}
	
	
	// 2. 측면과 하면 피복이 다를 경우 좌우측 R을 조정할 필요가 있다.
	// 측면이 더 크면 
	// dDiff	= dCoverSide - dCoverLower 
	// R = R + (dDiff)
	// 하면선길이는 dDiff만큼 짧게 만듬
	BOOL bArcLeft	= FALSE;
	BOOL bArcRight	= FALSE;
	if(dCoverLower != dCoverSideL || dCoverLower != dCoverSideR)
	{
		double dDiffL	= dCoverSideL - dCoverLower;
		double dDiffR	= dCoverSideR - dCoverLower;

		// 왼쪽 R
		long i = 0; for(i = 0; i < tvArrLeft.GetSize(); i++)
		{
			tv	= tvArrLeft.GetAt(i);
			if(tv.m_v1.z == -1 || tv.m_v1.z == 1)
			{
				
				tv.m_v2.x += dDiffL;
				tv.m_v2.y -= dDiffL;
				double sw	= tv.m_v2.z > 0 ? 1 : -1;
				tv.m_v2.z  = (fabs(tv.m_v2.z) + dDiffL) * sw;
				tvArrLeft.SetAt(i, tv);
				bArcLeft	= TRUE;
			}
		}

		// 오른쪽 R
		for(i = 0; i < tvArrRight.GetSize(); i++)
		{
			tv	= tvArrRight.GetAt(i);
			if(tv.m_v1.z == -1 || tv.m_v1.z == 1)
			{
				
				tv.m_v2.x -= dDiffR;
				tv.m_v2.y -= dDiffR;
				double sw	= tv.m_v2.z > 0 ? 1 : -1;
				tv.m_v2.z  = (fabs(tv.m_v2.z) + dDiffR) * sw;
				tvArrRight.SetAt(i, tv);
				bArcRight	= TRUE;
			}
		}

		if(tvArrLower.GetSize() > 0)
		{
			// 하면 왼쪽
			tv	= tvArrLower.GetAt(0);
			tv.m_v1 = tv.m_v1 + tv.GetXyDir() * dDiffL;
			tvArrLower.SetAt(0, tv);

			// 하면 오른쪽
			tv	= tvArrLower.GetAt(tvArrLower.GetSize() - 1);
			tv.m_v2	= tv.m_v2 + tv.GetXyDir(TRUE) * dDiffR;
			tvArrLower.SetAt(tvArrLower.GetSize() - 1, tv);
		}
	}

	// 3. 하면과 양 측면 교차점 처리(좌측이나 우측에 라운드가 있는쪽은 교차점 안 찾아도 됨)
	CDPointArray xyArrMatch;

	// 좌
	tv1	= tvArrLower.GetAt(0);
	if(tvArrLower.GetSize() > 0)
	{
		rb.GetXyMatchTvArrAndLine(tvArrLeft, tv1.m_v1, tv1.GetXyDir(), xyArrMatch);
		if(xyArrMatch.GetSize() > 0)
		{
			if(!bArcLeft)
			{
				if(tvArrLeft.GetSize() == 1 && Compare(tvArrLeft.GetAt(0).GetHorLength(), 0.0, "="))
				{
					CTwinVector *pTv	= &tvArrLeft.GetAt(0);
					pTv->m_v2	= xyArrMatch.GetAt(0);
				}
				else if(tvArrLeft.GetSize() > 0 && tvArrLeft.GetAt(0).GetHorLength() > 0)
				{
					CDRect rect	= tvArrLeft.GetRect();
					rb.TrimTvArrayByLine(tvArrLowerLeft, CDPoint(rect.left, 0), CDPoint(0, 1), FALSE, TRUE, FALSE);
				}		
			}

			tv1.m_v1	= xyArrMatch.GetAt(0);
			if(tv1.GetLength() > 0)
				tvArrLower.SetAt(0, tv1);

			double dX	= tv1.m_v1.x;
			long i = 0; for(i = 0; i < tvArrLower.GetSize(); i++)
			{
				tv	= tvArrLower.GetAt(i);
				if(Compare(tv.GetXyRight().x, dX, "<="))
				{
					tvArrLower.RemoveAt(i);
					i--;
				}
				else if(Compare(tv.GetXyLeft().x, dX, "<="))
				{
					GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), CDPoint(dX, 0), CDPoint(0, 1), tv.m_v1);
					tvArrLower.SetAt(i, tv);
				}
			}
		}
	}

	// 우
	if(tvArrLower.GetSize() > 0)
	{
		tv1	= tvArrLower.GetAt(tvArrLower.GetSize()-1);
		rb.GetXyMatchTvArrAndLine(tvArrRight, tv1.m_v1, tv1.GetXyDir(), xyArrMatch);
		if(xyArrMatch.GetSize() > 0)
		{
			if(!bArcRight)
			{
				if(tvArrRight.GetSize() > 0 && tvArrRight.GetAt(0).GetHorLength() > 0)
				{
					CDRect rect	= tvArrRight.GetRect();
					rb.TrimTvArrayByLine(tvArrLowerRight, CDPoint(rect.right, 0), CDPoint(0, 1), TRUE, TRUE, FALSE);
				}
				else if(tvArrRight.GetSize() == 1 && tvArrRight.GetAt(0).GetHorLength() == 0)
				{
					CTwinVector *pTv	= &tvArrRight.GetAt(0);
					pTv->m_v2	= xyArrMatch.GetAt(0);
				}
			}

			tv1.m_v2	= xyArrMatch.GetAt(0);
			if(tv1.GetLength() > 0)
				tvArrLower.SetAt(tvArrLower.GetSize()-1, tv1);

			double dX	= tv1.m_v2.x;
			long i = 0; for(i = 0; i < tvArrLower.GetSize(); i++)
			{
				tv	= tvArrLower.GetAt(i);
				if(Compare(tv.GetXyLeft().x, dX, ">="))
				{
					tvArrLower.RemoveAt(i);
					i--;
				}
				else if(Compare(tv.GetXyRight().x, dX, ">="))
				{
					GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), CDPoint(dX, 0), CDPoint(0, 1), tv.m_v2);
					tvArrLower.SetAt(i, tv);
				}
			}
		}
	}


	
	// 우측은 순서를 뒤집어 줌.
	rb.ReverseRebar(tvArrRight);


	if(bUpper)
		tvArr	= tvArrUpper;
	else
	{
		tvArr.RemoveAll();
		if(bForRebarBM)
		{
			CPlaceRebarByBlock *pPlace	= &m_placeByBlock_SupportRebar_UpperSlab[iLOWER][0];
			long nSize		= pPlace->m_xyArr.GetSize();
			double dCover	= m_dCoverLower_UpperSlab[0];
			double dSpace	= nSize > 0 ? pPlace->m_xyArr.GetAt(nSize/2).y : 0;
			double dDia		= pPlace->m_dDia;
			double dSettle(0);
			if(m_pARcBridgeDataStd->IsLsdDesign())
			{
				SRebarEnvOption LsdRebarOpt;
				SetRebarLsdOptionSlab(&LsdRebarOpt, TRUE, bUpper, FALSE, 0, 0);
				dSettle = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueSettle(dDia, &LsdRebarOpt);
			}
			else
			{
				dSettle = m_pARcBridgeDataStd->GetValueSettle(dDia, SETTLE_TENS_NORMAL, toCm(dCover), toCm(dSpace));
			}

			CDPointArray xyArrMatch;
			if(tvArrLeft.GetSize() > 4)
			{
				tvArrLowerLeft.Add(tvArrLeft.GetAt(0));
				tvArrLowerLeft.Add(tvArrLeft.GetAt(1));
				tv	= tvArrLeft.GetAt(2);
				tv.m_v2	+= (tv.GetXyDir() * dSettle);
				tvArrLowerLeft.Add(tv);

				tv	= tvArrLeft.GetAt(3);
				tv.m_v1 += (CDPoint(0, 1) * dSettle);
				rb.GetXyMatchTvArrAndSeg(tvArrUpper, tv.m_v1, tv.m_v2, xyArrMatch, TRUE);
				if(xyArrMatch.GetSize() > 0)
					tv.m_v1 = xyArrMatch.GetAt(0);
				tvArr.Add(tv);
				tvArr.Add(tvArrLeft.GetAt(4));
			}
			else if(tvArrLeft.GetSize() == 4)
			{
				tvArrLowerLeft.Add(tvArrLeft.GetAt(0));
				tv	= tvArrLeft.GetAt(1);
				tv.m_v2 += (tv.GetXyDir() * dSettle);
				tvArrLowerLeft.Add(tv);

				tv	= tvArrLeft.GetAt(2);
				tv.m_v1 += (CDPoint(0, 1) * dSettle);
				rb.GetXyMatchTvArrAndSeg(tvArrUpper, tv.m_v1, tv.m_v2, xyArrMatch, TRUE);
				if(xyArrMatch.GetSize() > 0)
					tv.m_v1 = xyArrMatch.GetAt(0);
				tvArr.Add(tv);
				tvArr.Add(tvArrLeft.GetAt(3));
				
			}
			else if(tvArrLeft.GetSize() == 3)
			{
				tvArrLowerLeft.Add(tvArrLeft.GetAt(0));
				tv	= tvArrLeft.GetAt(1);
				tv.m_v2 += tv.GetXyDir() * dSettle;
				tvArrLowerLeft.Add(tv);
				
				tv	= tvArrLeft.GetAt(2);
				tv.m_v1 += CDPoint(0, 1) * dSettle;
				rb.GetXyMatchTvArrAndSeg(tvArrUpper, tv.m_v1, tv.m_v2, xyArrMatch, TRUE);
				if(xyArrMatch.GetSize() > 0)
					tv.m_v1	= xyArrMatch.GetAt(0);
				tvArr.Add(tv);
			}
			else
			{
				tvArr.AddFromTvArray(tvArrLeft);
			}

			tvArr.AddFromTvArray(tvArrLower);
			
			if(tvArrRight.GetSize() > 4)
			{
				tv	= tvArrRight.GetAt(2);
				tv.m_v1 += (tv.GetXyDir(TRUE) * dSettle);
				tvArrLowerRight.Add(tv);
				tvArrLowerRight.Add(tvArrRight.GetAt(3));
				tvArrLowerRight.Add(tvArrRight.GetAt(4));

				tv	= tvArrRight.GetAt(1);
				tv.m_v2 += (CDPoint(0, 1) * dSettle);
				rb.GetXyMatchTvArrAndSeg(tvArrUpper, tv.m_v1, tv.m_v2, xyArrMatch, TRUE);
				if(xyArrMatch.GetSize() > 0)
					tv.m_v2 = xyArrMatch.GetAt(0);
				tvArr.Add(tvArrRight.GetAt(0));
				tvArr.Add(tv);
			}
			else if(tvArrRight.GetSize() == 4)
			{
				tv	= tvArrRight.GetAt(2);
				tv.m_v1 += (tv.GetXyDir(TRUE) * dSettle);
				tvArrLowerRight.Add(tv);
				tv	= tvArrRight.GetAt(3);
				tvArrLowerRight.Add(tv);

				tv	= tvArrRight.GetAt(1);
				tv.m_v2 += (CDPoint(0, 1) * dSettle);
				rb.GetXyMatchTvArrAndSeg(tvArrUpper, tv.m_v1, tv.m_v2, xyArrMatch, TRUE);
				if(xyArrMatch.GetSize() > 0)
					tv.m_v2 = xyArrMatch.GetAt(0);
				tvArr.Add(tvArrRight.GetAt(0));
				tvArr.Add(tv);
			}
			else if(tvArrRight.GetSize() == 3)
			{
				tv	= tvArrRight.GetAt(1);
				tv.m_v1 += tv.GetXyDir(TRUE) * dSettle;
				tvArrLowerRight.Add(tv);

				tv	= tvArrRight.GetAt(2);
				tvArrLowerRight.Add(tv);

				tv	= tvArrRight.GetAt(0);
				tv.m_v2 += CDPoint(0, 1) * dSettle;
				rb.GetXyMatchTvArrAndSeg(tvArrUpper, tv.m_v1, tv.m_v2, xyArrMatch, TRUE);
				if(xyArrMatch.GetSize() > 0)
					tv.m_v2	= xyArrMatch.GetAt(0);
				tvArr.Add(tv);
			}
			else
			{
				tvArr.AddFromTvArray(tvArrRight);
			}
		}
		else
		{
			tvArr.AddFromTvArray(tvArrLeft);
			tvArr.AddFromTvArray(tvArrLower);
			tvArr.AddFromTvArray(tvArrRight);
		}
	}

	// mirror
	// 시점에서 본 모양데로 그리기 위해.
	long nJ	= GetJijumNumberByStation(dSta);
	if(nJ == 0 || bMirror)
	{
		CTwinVectorArray tvArrCross;
		GetTvCrossSection(tvArrCross, dStaSmallestWidth, vAng, FALSE, TRUE, FALSE, 0, FALSE, FALSE);
		CDRect rect	= tvArrCross.GetRect();
		rb.Mirror(tvArr, CDPoint(rect.left, 0), TRUE);
		rb.Mirror(tvArrLowerLeft, CDPoint(rect.left, 0), TRUE);
		rb.Mirror(tvArrLowerRight, CDPoint(rect.left, 0), TRUE);
		rb.MoveRebar(tvArr, CDPoint(rect.Width(), 0));
		rb.MoveRebar(tvArrLowerLeft, CDPoint(rect.Width(), 0));
		rb.MoveRebar(tvArrLowerRight, CDPoint(rect.Width(), 0));
	}
	
		
	// nDrawLeft에 따라서 잘라냄
	if(nDrawLeft != 0)
	{
		CDRect rect	= tvArr.GetRect();
		double dMid	= GetMidCrossSection(TRUE);		// (ARCBRIDGE-2898) 좌우측을 잘라서 그릴때 주철근등 나머지 부분들은 다 TRUE를 줬다.
		BOOL bLeft	= nDrawLeft == -1 ? FALSE : TRUE;
		CDPoint xy1	= CDPoint(dMid, rect.bottom-100);
		CDPoint xy2	= CDPoint(dMid, rect.top+100);
		rb.TrimTvArrayByLine(tvArr, xy1, xy2, bLeft, TRUE, FALSE);
		rb.TrimTvArrayByLine(tvArrLowerLeft, xy1, xy2, bLeft, TRUE, FALSE);
		rb.TrimTvArrayByLine(tvArrLowerRight, xy1, xy2, bLeft, TRUE, FALSE);
	}
}

// 횡단면 상부 슬래브 주철근...
// CDPointArray &xyArrHunch : 헌치부 주철근
// 이 함수는 횡단면도를 그리기 위해 사용하지는 않는다.
// 단지, 평면상의 주철근을 배치하기 위해서만 사용한다.
// 횡단면도를 그릴때는 평면상의 주철근 좌표를 그대로 투영해서 그린다.
// BOOL bCheckRebar : dSta에 철근이 존재 하는지 체크해서 존재할 경우에만 간격을 구함.
void CRcBridgeRebar::GetXyRebarMain_CrossSection_SlabForPlacingMainRebar(BOOL bUpperSlab, CDPointArray &xyArr1, CDPointArray &xyArrHunch1, CDPointArray &xyArr2, CDPointArray &xyArrHunch2, CDPointArray &xyArr3, CDPointArray &xyArrHunch3, CDPointArray &xyArr4, CDPointArray &xyArrHunch4, double dSta, BOOL bUpper, long nDan, BOOL bForRightAngleRebar, BOOL bCheckRebar, BOOL bForArrangePlane)
{
	xyArr1.RemoveAll();
	xyArrHunch1.RemoveAll();
	xyArr2.RemoveAll();
	xyArrHunch2.RemoveAll();
	xyArr3.RemoveAll();
	xyArrHunch3.RemoveAll();
	xyArr4.RemoveAll();
	xyArrHunch4.RemoveAll();
	CRebarPlacing rbPlacing;

	// 주철근(점)이 높여질 배력철근 좌표 구함.(하면에 라운드가 있을 경우가 있으므로 상면철근을 기준으로 구한 다음에
	// 하면 철근에 포함 되는 것만 골라내야됨.
	CTwinVector tvSup, tvSupOrg;
	double dCoverSideL	= GetCoverSide_UpperSlab(0);
	double dCoverSideR	= dCoverSideL;

	// 사보강시 사방향 철근 피복을 맞춰 주기 위한 슬래브 끝단 스테이션의 폭
	double dStaOrg	= GetStationByTarget(BRIDGE_OFF_STT_SLAB, 0, FALSE);
	///////////////////////////////////////////////////////////////////

	BOOL bVertDir	= IsVertDir();
	CDPoint vAng	= (bVertDir || !bForRightAngleRebar) ? GetAngleByStation(dSta) : CDPoint(0, 1);

	if(/*bVertDir == FALSE &&*/ bForRightAngleRebar == FALSE)
	{
		// 사보강이나 확폭부 철근은 폭이 좁은 단면이 아니라 시점 위치폭을 기준으로 배치 해야 오른쪽 끝단이 맞는다.
		dSta = GetStationByTarget(BRIDGE_OFF_STT_SLAB, 0, FALSE);
		vAng = GetAngleByTarget(BRIDGE_OFF_STT_SLAB, 0);
	}

	// 곡선선형일경우 같은 각도를 주면 방위각은 서로 다른 방향이다. 선형의 Station에서의 방위각을 맞춰줘야 한다.
	// 그런데 여기서 맞춰줘도 다른데서 안맞고 있다. 곡선선형에서 확폭또는 직각방향 배치는 안되고 있다.
	if(bForArrangePlane && IsExtLine() && bForRightAngleRebar && bVertDir)
	{
		// (ARCBRIDGE-3495) 확폭이고 사각이 있는경우 좌측과 우측의 Slab 끝단 Station이 다르다. 각각 끝단 Station에서의 폭을 적용해야 슬래브 전체에 배치된다.
		BOOL bBridgeStt = dSta < (m_dStationBridgeStt + GetLengthBridge(FALSE) / 2) ? TRUE : FALSE;
		double dStaTemp = GetStationByTarget(bBridgeStt ? BRIDGE_OFF_STT_SLABCOVER : BRIDGE_OFF_END_SLABCOVER, 0, FALSE);
		CDPoint xyAngTemp = GetAngleJijum(bBridgeStt ? 0 : m_nQtyJigan);
		CDPoint xyL = GetXySlabEdgeAct(dStaTemp, xyAngTemp, TRUE);
		CDPoint xyR = GetXySlabEdgeAct(dStaTemp, xyAngTemp, FALSE);
		
		tvSup.m_v1.x = m_pLineApp->GetDisMatchVerticalByXy(xyL);
		tvSup.m_v2.x = m_pLineApp->GetDisMatchVerticalByXy(xyR);
	}
	else
	{
		tvSup.m_v1.x	= GetWidthSlabAct(dSta, vAng, -1)*-1;
		tvSup.m_v2.x	= GetWidthSlabAct(dSta, vAng, 1);
	}

	tvSup.m_v1.x	+= dCoverSideL;
	tvSup.m_v2.x	-= dCoverSideR;

	tvSupOrg.m_v1.x	= GetWidthSlabAct(dStaOrg, vAng, -1)*-1;
	tvSupOrg.m_v2.x	= GetWidthSlabAct(dStaOrg, vAng, +1);
	tvSupOrg.m_v1.x	+= dCoverSideL;
	tvSupOrg.m_v2.x	-= dCoverSideR;
	CTwinVector tvHunch;
	// 평면 배근을 위한 좌표를 구하기 때문에 dSta에 혹시나 철근이 없더라도 어딘가에 있다면
	// 있는것으로 판단하고 좌표를 구해준다.
	BOOL bHunch		= TRUE;//IsHunchRebarPlane(dSta);
	
	double dHeightHunch	= 0;
	if(bHunch)
	{
//		dHeightHunch	= GetHeightUpperSlab(dSta) - m_dTS;
		if(bUpperSlab)
			dHeightHunch	= GetHeightUpperSlab(GetJijumNumberByStation(dSta), 0, vAng) - m_dTS;
		else
			dHeightHunch	= GetHeightLowerSlab(GetJijumNumberByStation(dSta), 0, vAng) - m_dTS_Lower;

		tvHunch.m_v1.x	= GetWidthSlabAct(dSta, vAng, -1, TRUE) * -1;
		tvHunch.m_v2.x	= GetWidthSlabAct(dSta, vAng, 1, TRUE);
		tvHunch.m_v1.x += dCoverSideL;
		tvHunch.m_v2.x -= dCoverSideR;
	}

	// 사보강일 경우 피복은 사거리로 적용됨.(시점기준) //////
	CDPoint vAngStt		= GetAngleJijum(0);
	if(IsVertDir() || !bForRightAngleRebar)
	{
		tvSup.m_v1.x	-= dCoverSideL;
		tvSup.m_v2.x	+= dCoverSideR;
		tvSupOrg.m_v1.x	-= dCoverSideL;
		tvSupOrg.m_v2.x	+= dCoverSideR;
		tvHunch.m_v1.x	-= dCoverSideL;
		tvHunch.m_v2.x	+= dCoverSideR;

		CTwinVectorArray tvArrPlane;
		CTwinVectorArray tvArrPlane1Dan;
		GetTvRebarOut_Plane_UpperSlabStd(tvArrPlane, -1, FALSE);
		GetTvRebarOut_Plane_UpperSlabStd(tvArrPlane1Dan, 0, FALSE);

		CTwinVector tv;
		CTwinVectorArray tvArrStt;
		CTwinVector tvStt, tvStt1Dan;
		long i = 0; for(i = 0; i < tvArrPlane.GetSize(); i++)
		{
			tv	= tvArrPlane.GetAt(i);
			if(tv.m_sInfo == "시점") tvArrStt.Add(tv);
		}
		tvStt.m_v1	= tvArrStt.GetAt(0).m_v1;
		tvStt.m_v2	= tvArrStt.GetAt(tvArrStt.GetSize()-1).m_v2;

		tvArrStt.RemoveAll();
		for(i = 0; i < tvArrPlane1Dan.GetSize(); i++)
		{
			tv	= tvArrPlane1Dan.GetAt(i);
			if(tv.m_sInfo == "시점") tvArrStt.Add(tv);
		}
		tvStt1Dan.m_v1	= tvArrStt.GetAt(0).m_v1;
		tvStt1Dan.m_v2	= tvArrStt.GetAt(tvArrStt.GetSize()-1).m_v2;

		// 피복 구함. 
		CDPoint xyDirLeft	= GetXyDirRebarMainPlaneForSabogang(-1);
		CDPoint xyDirRight	= GetXyDirRebarMainPlaneForSabogang(1);
		CDPoint xyMatch(0, 0);
		GetXyMatchLineAndLine(tvStt.m_v2, tvStt.GetXyDir(), tvStt1Dan.m_v2, xyDirLeft, xyMatch);
		dCoverSideL	= Round(~(xyMatch - tvStt.m_v2), 0);

		GetXyMatchLineAndLine(tvStt.m_v1, tvStt.GetXyDir(), tvStt1Dan.m_v1, xyDirRight, xyMatch);
		dCoverSideR	= Round(~(xyMatch - tvStt.m_v1), 0);

		tvSup.m_v1.x	+= dCoverSideL;
		tvSup.m_v2.x	-= dCoverSideR;
		tvSupOrg.m_v1.x	+= dCoverSideL;
		tvSupOrg.m_v2.x	-= dCoverSideR;
		tvHunch.m_v1.x	+= dCoverSideL;
		tvHunch.m_v2.x	-= dCoverSideR;
	}
	//////////////////////////////////////////////////////////

	// 차후에 확폭인 경우 사정이 어떻게 될지 모르겠으나 일단은 가장 작은 폭을 기준으로 배근 하도록 하자!!!! ////
	// (ARCBRIDGE-3019) 확폭부 철근 구할때는 좁은폭 기준이 아니라 시점 기준폭으로 구한다.
	if(bForRightAngleRebar == TRUE)
	{
		// (RCBRIDGE-3533) 주철근이 직각방향일때는 좁은폭 기준이 맞다.
		// (ARCBRIDGE-3533) 선형직각방향으로 최소폭을 구하는거는 주철근이 선형 방향일때 적용할수 있지~ 직각방향일때 안맞음
// 		if(bVertDir)
// 		{
// 			tvSup.m_v1.x	+= m_dDistLeftDirPlacing;
// 			tvSup.m_v2.x	-= m_dDistRightDirPlacing;
// 		}
// 		else
		{
			double dWidthLOrg	= GetWidthSlabAct(dSta, CDPoint(0, 1), -1);
			double dWidthROrg	= GetWidthSlabAct(dSta, CDPoint(0, 1), 1);
			double dStaSmallestWidthL	= GetStationSmallestWidthOfUpperSlab(bVertDir ? TRUE : FALSE, -1, !bVertDir);	
			double dStaSmallestWidthR	= dStaSmallestWidthL;
			if(IsExtLine())
				dStaSmallestWidthR	= GetStationSmallestWidthOfUpperSlab(IsVertDir() ? TRUE : FALSE, 1, !bVertDir);	
			double dWidthL	= GetWidthSlabAct(dStaSmallestWidthL, CDPoint(0, 1), -1);
			double dWidthR	= GetWidthSlabAct(dStaSmallestWidthR, CDPoint(0, 1), 1);
			
			tvSup.m_v1.x	+= (dWidthLOrg - dWidthL);
			tvSup.m_v2.x	-= (dWidthROrg - dWidthR);
		}
	}
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if(!bUpper)
	{
		double dDiff	= 0;
		if(bUpperSlab)
			dDiff	= m_dTS - m_dCoverUpper_UpperSlab[nDan] - m_dCoverLower_UpperSlab[nDan];
		else
			dDiff	= m_dTS_Lower - m_dCoverUpper_LowerSlab[nDan] - m_dCoverLower_LowerSlab[nDan];
		tvSup.m_v1.y -= dDiff;
		tvSup.m_v2.y -= dDiff;
		tvSupOrg.m_v1.y -= dDiff;
		tvSupOrg.m_v2.y -= dDiff;
	}

	// 사보강 배치라도 양 끝에 정확하게 피복을 넣어 주기 위해 실제 횡단 배력근이 필요하다.
	///tvSupOrg	= tvSup;	// 최대길이가 아닌 실제 길이의 횡단 배력근

	// 주철근이 사보강 배치인 경우 횡단면 최대길이를 고려해서 배근해야 됨 ///////
	long nOldTypePlacingMainRebar	= m_nTypePlacingMainRebar_UpperSlab;
	double dOldDistLeftDirPlacing	= m_dDistLeftDirPlacing;
	double dOldDistRightDirPlacing	= m_dDistRightDirPlacing;
	if(IsVertDir() && bForRightAngleRebar)
	{
		SetDataDefaultDistLeftDirPlacing();

		double dAng	= GetAngleJijum(0).GetAngleDegree();
		if(dAng < 90)
		{
			tvSup.m_v1.x -= m_dDistLeftDirPlacing;
			tvHunch.m_v1.x	-= m_dDistLeftDirPlacing;
		}
		if(dAng > 90) 
		{
			tvSup.m_v2.x += m_dDistRightDirPlacing;
			tvHunch.m_v2.x += m_dDistRightDirPlacing;
		}
	}
	//////////////////////////////////////////////////////////////////////////////

	CDPointArray xyArrOffset;
	BOOL bSttRebar = TRUE;
	BOOL bEndRebar = FALSE;
	if(bForRightAngleRebar == FALSE)
	{
		// (ARCBRIDGE-2661) 사보강배치가 아니더라도 확폭이 있을때 확폭이 있는 쪽에 사보강철근 배치
		// 사보강배치 일때는 전체구간에 배치 하고 절반씩 좌우측 선형을 따라가지만 확폭일때는 확폭넓이에 의한 좌우측 배치 구간을 구해준다.
		double dWidthExtLeft = m_dDistLeftDirPlacing;	//GetMaxDiffWidthByExtLine(TRUE)/vAng.y;
		double dWidthExtRight = m_dDistRightDirPlacing;	//GetMaxDiffWidthByExtLine(FALSE)/vAng.y;

		double dCtcLower	= GetCtcRebarMain(TRUE)/vAng.y;	// 하면 ctc
		double dCtcUpper	= GetCtcRebarMain(TRUE)/vAng.y;		// 상면 ctc
		double dCtc			= GetCtcRebarMain(TRUE)/vAng.y;	// 현재 ctc
		double dLen			= tvSup.GetHorLength();

		// 횡단에서 간격을 유지해주기 위해서 
		// 좌우 확폭에 대해서 넓이 만큼 갯수를 구해서 배치한다.
		long nCountLeft	= (long)(dWidthExtLeft / dCtc);
		long nCountRight	= (long)(dWidthExtRight / dCtc);
		double dRemain		= dLen - (dCtc * (nCountLeft + nCountRight));
		 
		// 선형방향 배치 일때 확폭에 의한 사보강 - 왼쪽에서 오른쪽으로
		if(nCountLeft > 0)
			xyArrOffset.Add(CDPoint(nCountLeft, dCtc));

		if(nCountRight > 0)
		{
			xyArrOffset.Add(CDPoint(1, dRemain));
			xyArrOffset.Add(CDPoint(nCountRight, dCtc));
		}

		// (ARCBRIDGE-3579) dWidthExtLeft > dCoverSideL 조건 이었는데 확폭폭이 조금이라도 있으면 철근은 무조건 들어가 줘야 하기 때문에 25보다 크면 들어가는걸로..
		bSttRebar = dWidthExtLeft > 25. ? TRUE : FALSE;
		bEndRebar = dWidthExtRight > 25. && nCountRight == 0 ? TRUE : FALSE;
	}
	else
	{
		// 횡단면 상부 슬래브 주철근 간격 구함 ///////////////////////////////////////////////////////////////////
		vAng		= CDPoint(0, 1);
		double dCtcLower	= GetCtcRebarMain(TRUE)/vAng.y;	// 하면 ctc
		double dCtcUpper	= GetCtcRebarMain(TRUE)/vAng.y;		// 상면 ctc
		double dCtc			= GetCtcRebarMain(TRUE)/vAng.y;	// 현재 ctc
		double dLen			= tvSup.GetHorLength();
		long nCount			= (long)((dLen-(dCtcLower*2)) / dCtc);
		double dRemain		= (dLen-(dCtcLower*2)) - (dCtc * nCount);

		// 하면일때는 nCount가 상면일때의 2배가 되는지 체크해야 된다.
		if((bUpper != bUpperSlab) && !Compare(dCtcLower, dCtcUpper, "="))
		{
			long nCountUpper	= (long)((dLen-(dCtcLower*2)) / dCtcUpper);
			if(nCountUpper*2 != nCount)
			{
				dRemain	+= dCtcLower;
				nCount -= 1;
			}
		}

		xyArrOffset.Add(CDPoint(1, dRemain/2 + dCtcLower));
		xyArrOffset.Add(CDPoint(nCount, dCtc));
		xyArrOffset.Add(CDPoint(1, dRemain/2 + dCtcLower));
	}
	
	CDPointArray xyArr;
	rbPlacing.GetXyDivideLine(xyArr, tvSup.m_v1, CDPoint(tvSup.m_v2.x, tvSup.m_v1.y), xyArrOffset, bSttRebar, bEndRebar, FALSE);


	long cycle = 0; for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
	{
		if(GetCountCycleMainRebar() <= cycle) continue;
		CDPointArray *pXyArr, *pXyArrHunch;
		switch(cycle)
		{
			case 0: pXyArr = &xyArr1; pXyArrHunch = &xyArrHunch1; break;
			case 1: pXyArr = &xyArr2; pXyArrHunch = &xyArrHunch2; break;
			case 2: pXyArr = &xyArr3; pXyArrHunch = &xyArrHunch3; break;
			case 3: pXyArr = &xyArr4; pXyArrHunch = &xyArrHunch4; break;
		}
		*pXyArr	= xyArr;


		// 2cycle인 경우 1cycle로 구해진 철근들 사이에 하나씩 들어감.
		
		
		if(cycle == 1 || cycle == 3)
		{
			long nSize	= 0;
			long i		= 0;
			// sta에 따라 2cycle이 있을 수도 있고, 없을 수도 있다..
			// 해당 cycle과 단의 철근이 하나라도 있으면 구함.
			if(!bCheckRebar || GetRCMain_Slab(bUpperSlab, dSta, bUpper, nDan, cycle, TRUE))
			{
				// 상/하부 철근
				CDPointArray xyArrTmp;
				
				nSize	= pXyArr->GetSize();
				
				for(i = 0; i < nSize-1; i++)
					xyArrTmp.Add((pXyArr->GetAt(i)+pXyArr->GetAt(i+1))/2);

				pXyArr->RemoveAll();
				*pXyArr	= xyArrTmp;
			}
			else
				pXyArr->RemoveAll();

			if(!bCheckRebar || GetRCMain_SlabHunch(bUpperSlab, dSta, cycle, TRUE))
			{
				// 헌치 철근
				CDPointArray xyArrTmp;
				nSize	= pXyArrHunch->GetSize();
				for(i = 0; i < nSize-1; i++)
					xyArrTmp.Add((pXyArrHunch->GetAt(i)+pXyArrHunch->GetAt(i+1))/2);

				pXyArrHunch->RemoveAll();
				*pXyArrHunch	= xyArrTmp;
			}
			else
				pXyArrHunch->RemoveAll();
		}



		// 4cycle까지 지원되는 경우
		// 1, 2cycle인경우 짝수번째를, 3,4cycle인경우 홀수번째를 번째좌표를 지우면 된다.
		if(GetCountCycleMainRebar() == 4)
		{
			BOOL bDeleteOdd	= cycle==2||cycle==3 ? TRUE : FALSE;
			long i = 0; for(i = 0; i < pXyArr->GetSize(); i++)
			{
				if(bDeleteOdd)
				{
					pXyArr->RemoveAt(i);
					i--;
				}

				bDeleteOdd	= !bDeleteOdd;
			}
		}



		// 하면일 경우 상면 기준으로 구했으므로 하면에 포함되는 철근만 다시 골라내야 됨.
		if(bUpper != bUpperSlab)
		{
			CTwinVector tv	= tvSup;

			CDPoint xy(0, 0);
			long i = 0; for(i = 0; i < pXyArr->GetSize(); i++)
			{
				xy	= pXyArr->GetAt(i);
				if(Compare(xy.x, tv.m_v1.x, "<") || Compare(xy.x, tv.m_v2.x, ">"))
				{
					pXyArr->RemoveAt(i);
					i--;
				}
			}

			// 하면일 경우 헌치부가 있을 수도 있다.
			if(bHunch)
			{
				CDPoint xy(0, 0);
				long nSize	= pXyArr->GetSize();
				long i = 0; for(i = 0; i < nSize; i++)
				{
					xy	= pXyArr->GetAt(i);
					if(Compare(xy.x, tvHunch.m_v1.x, ">=") && Compare(xy.x, tvHunch.m_v2.x, "<="))
						pXyArrHunch->Add(CDPoint(xy.x, xy.y-dHeightHunch));
				}
			}
		}
	}


	// 위치를 구했으면 실제 배력근 안쪽의 철근중에 가장 양끝단과 가장 근접한 넘들을 피복간격으로 맞춰줘야 한다.
	// 그래야 사보강배치할경우 좌우 양쪽 모두 피복에 철근이 하나씩 정확하게 들어간다.(아주 중요한 부분임)
	// 사보강시 직철근은 일부러 피복에 맞출 필요 없으나, 사철근은 반드시 피복에 맞춰야 된다.
	// 1cycle은 피복으로 만들고 나머지는 양 끝과 피복거리보다 가까운 넘들은 제거
	// 단, 배근시 시점 슬래브 끝단을 기준으로 배근하므로 시점 슬래브 끝단의 폭에 맞춰야 할 것임.
	if((IsVertDir() && !bForRightAngleRebar) || !IsVertDir())
	{
		double dCover	= GetCoverSide_UpperSlab(0);
		long nIdxLeft	= -1;
		long nIdxRight	= -1;
		long nCycleLeft		= 0;
		long nCycleRight	= 0;
		if((IsExtLine() || IsExp(dSta)) )
		{
			tvSupOrg =tvSup;			
			tvSupOrg.m_v1.x -= dCover;
			tvSupOrg.m_v2.x += dCover;
		}
		else
		{
			tvSupOrg.m_v1.x -= dCover;
			tvSupOrg.m_v2.x += dCover;
		}		
		tvHunch.m_v1.x -= dCover;
		tvHunch.m_v2.x += dCover;

		// 찾자
		double dMinDistLeft		= tvSupOrg.GetHorLength();
		double dMinDistRight	= tvSupOrg.GetHorLength();
		if(!IsVertDir())
		{
			dMinDistLeft = GetMaxDiffWidthByExtLine(TRUE) + 30;
			dMinDistRight = GetMaxDiffWidthByExtLine(FALSE) + 30;
			// (ARCBRIDGE-3641) 확실하게 찾아주기 위해서  +200을 줬었는데 불필요한 철근이 생긴다.
		}

		CDPoint xy(0, 0);
		long cycle = 0; for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
		{
			// 2, 4사이클은 피복에 붙을 수 없는 철근임
			if(cycle == 1 || cycle == 3) continue;

			CDPointArray *pXyArr;
			switch(cycle)
			{
				case 0: pXyArr = &xyArr1; break;
				case 1: pXyArr = &xyArr2; break;
				case 2: pXyArr = &xyArr3; break;
				case 3: pXyArr = &xyArr4; break;
			}

			long i = 0; for(i = 0; i < pXyArr->GetSize(); i++)
			{
				xy	= pXyArr->GetAt(i);
				if(xy.x >= tvSupOrg.m_v1.x && xy.x <= tvSupOrg.m_v2.x)
				{
					if(dMinDistLeft > (xy.x-tvSupOrg.m_v1.x))
					{
						nIdxLeft		= i;
						nCycleLeft		= cycle;
						dMinDistLeft	= xy.x-tvSupOrg.m_v1.x;
					}

					if(dMinDistRight > (tvSupOrg.m_v2.x - xy.x))
					{
						nIdxRight		= i;
						nCycleRight		= cycle;
						dMinDistRight	= tvSupOrg.m_v2.x - xy.x;
					}
				}
			}
		}

		// 찾았으면 보정하자
		// 사보강일땐 시점각도를 기준으로 배근한다.
		if(nIdxLeft > -1)
		{
			xy	= CDPoint(tvSupOrg.m_v1.x+dCover, tvSupOrg.m_v1.y);			
			
			CDPointArray *pXyArr;
			switch(nCycleLeft)
			{
				case 0: pXyArr = &xyArr1; break;
				case 1: pXyArr = &xyArr2; break;
				case 2: pXyArr = &xyArr3; break;
				case 3: pXyArr = &xyArr4; break;
			}

			CDPoint xyFirst			= pXyArr->GetSize() > 0? pXyArr->GetAt(0) : CDPoint(0,0);
			BOOL bRebarDirExt	= !bForRightAngleRebar && IsExtLine() && !IsVertDir()? TRUE : FALSE; //m_nTypePlacingMainRebar_UpperSlab == 0
			BOOL bFristAddSabo	= bRebarDirExt && Compare(xy.x , xyFirst.x,  _T("<"), 1) && pXyArr->GetSize() > 0? TRUE : FALSE;

			if(bFristAddSabo) 
			{
				CDPointArray xyArrCopy;
				xyArrCopy.Add(xy);

				CDPoint xyVal;				
				long nIdx =0;				
				for (nIdx =0; nIdx < pXyArr->GetSize(); nIdx++)
				{
					xyVal = pXyArr->GetAt(nIdx);
					xyArrCopy.Add(xyVal);
				}

				pXyArr->RemoveAll();
				for (nIdx =0; nIdx < xyArrCopy.GetSize(); nIdx++)
				{
					xyVal = xyArrCopy.GetAt(nIdx);
					pXyArr->Add(xyVal);
				}
			}
			else
			{
				pXyArr->SetAt(nIdxLeft, xy);
			}			

			// 최외측 주철근 1사이클로 고정
			if(m_bFixOutSideMainRebarBy1Cyle)
			{
				if(nCycleLeft == 1 || nCycleLeft == 3)
				{
					pXyArr->RemoveAt(nIdxLeft);
					xyArr1.InsertAt(0, xy);
				}
			}
		}

		if(nIdxRight > -1)
		{
			CDPointArray *pXyArr;
			switch(nCycleRight)
			{
				case 0: pXyArr = &xyArr1; break;
				case 1: pXyArr = &xyArr2; break;
				case 2: pXyArr = &xyArr3; break;
				case 3: pXyArr = &xyArr4; break;
			}
			xy	= CDPoint(tvSupOrg.m_v2.x-dCover, tvSupOrg.m_v2.y);


			CDPoint xyFirst			= pXyArr->GetSize() > 0? pXyArr->GetAt(0) : CDPoint(0,0);
			BOOL bRebarDirExt	= !bForRightAngleRebar && IsExtLine() && !IsVertDir()? TRUE : FALSE; //m_nTypePlacingMainRebar_UpperSlab == 0
			BOOL bFristAddSabo	= bRebarDirExt && Compare(xy.x , xyFirst.x,  _T("<"), 1) && pXyArr->GetSize() > 0? TRUE : FALSE;

			if(bFristAddSabo) 
			{
				CDPointArray xyArrCopy;
				xyArrCopy.Add(xy);

				CDPoint xyVal;				
				long nIdx =0;				
				for (nIdx =0; nIdx < pXyArr->GetSize(); nIdx++)
				{
					xyVal = pXyArr->GetAt(nIdx);
					xyArrCopy.Add(xyVal);
				}

				pXyArr->RemoveAll();
				for (nIdx =0; nIdx < xyArrCopy.GetSize(); nIdx++)
				{
					xyVal = xyArrCopy.GetAt(nIdx);
					pXyArr->Add(xyVal);
				}
			}
			else
			{
				pXyArr->SetAt(nIdxRight, xy);
			}
			

			// 최외측 주철근 1사이클로 고정
			if(m_bFixOutSideMainRebarBy1Cyle)
			{
				if(nCycleRight == 1 || nCycleRight == 3)
				{
					pXyArr->RemoveAt(nIdxRight);
					xyArr1.Add(xy);
				}
			}
		}


		///////////////////////////////////////////////
		// 헌치
		// 찾자
		nIdxLeft	= -1;
		nIdxRight	= -1;
		nCycleLeft	= 0;
		nCycleRight	= 0;
		dMinDistLeft	= tvHunch.GetHorLength();
		dMinDistRight	= tvHunch.GetHorLength();
		for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
		{
			// 2, 4사이클은 피복에 붙을 수 없는 철근임
			if(cycle == 1 || cycle == 3) continue;

			CDPointArray *pXyArrHunch;
			switch(cycle)
			{
				case 0: pXyArrHunch = &xyArrHunch1; break;
				case 1: pXyArrHunch = &xyArrHunch2; break;
				case 2: pXyArrHunch = &xyArrHunch3; break;
				case 3: pXyArrHunch = &xyArrHunch4; break;
			}

			long i = 0; for(i = 0; i < pXyArrHunch->GetSize(); i++)
			{
				xy	= pXyArrHunch->GetAt(i);
				if(xy.x >= tvHunch.m_v1.x && xy.x <= tvHunch.m_v2.x)
				{
					if(dMinDistLeft > (xy.x-tvHunch.m_v1.x))
					{
						nIdxLeft		= i;
						nCycleLeft		= cycle;
						dMinDistLeft	= xy.x-tvHunch.m_v1.x;
					}

					if(dMinDistRight > (tvHunch.m_v2.x - xy.x))
					{
						nIdxRight		= i;
						nCycleRight		= cycle;
						dMinDistRight	= tvHunch.m_v2.x - xy.x;
					}
				}
			}
		}

		// 찾았으면 보정하자
		// 사보강일땐 시점각도를 기준으로 배근한다.
		if(nIdxLeft > -1)
		{
			xy	= CDPoint(tvHunch.m_v1.x+dCover, tvHunch.m_v1.y);
			CDPointArray *pXyArrHunch;
			switch(nCycleLeft)
			{
				case 0: pXyArrHunch = &xyArrHunch1; break;
				case 1: pXyArrHunch = &xyArrHunch2; break;
				case 2: pXyArrHunch = &xyArrHunch3; break;
				case 3: pXyArrHunch = &xyArrHunch4; break;
			}
			pXyArrHunch->SetAt(nIdxLeft, xy);

			// 최외측 주철근 1사이클로 고정
			if(m_bFixOutSideMainRebarBy1Cyle)
			{
				if(nCycleLeft == 1 || nCycleLeft == 3)
				{
					pXyArrHunch->RemoveAt(nIdxLeft);
					xyArr1.InsertAt(0, xy);
				}
			}
		}

		if(nIdxRight > -1)
		{
			CDPointArray *pXyArrHunch;
			switch(nCycleRight)
			{
				case 0: pXyArrHunch = &xyArrHunch1; break;
				case 1: pXyArrHunch = &xyArrHunch2; break;
				case 2: pXyArrHunch = &xyArrHunch3; break;
				case 3: pXyArrHunch = &xyArrHunch4; break;
			}
			xy	= CDPoint(tvHunch.m_v2.x-dCover, tvHunch.m_v2.y);
			pXyArrHunch->SetAt(nIdxRight, xy);

			// 최외측 주철근 1사이클로 고정
			if(m_bFixOutSideMainRebarBy1Cyle)
			{
				if(nCycleRight == 1 || nCycleRight == 3)
				{
					pXyArrHunch->RemoveAt(nIdxRight);
					xyArr1.Add(xy);
				}
			}
		}
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////////////

	m_nTypePlacingMainRebar_UpperSlab	= nOldTypePlacingMainRebar;
	m_dDistLeftDirPlacing				= dOldDistLeftDirPlacing;
	m_dDistRightDirPlacing				= dOldDistRightDirPlacing;
}


// GetXyRebarMain_CrossSection_UpperSlabForPlacingMainRebar 는
// 평면에 주철근을 배근하기 위해 위치를 구하는 함수인데 반해, 이 함수는
// 평면에 배근된 주철근을 토대로 횡단면에 그려질 주철근의 위치를 구하는 함수이다.
// 따라서, 횡단면에 그려질 주철근의 위치를 찾기 위해서는 반드시 이 함수를 써야 된다.
// 위치 구하는 방법
// 1. 평면상의 주철근위치를 구한다(헌치도 포함)
// 2. 주철근을 시점이 90도가 되도록 회전한다
// 3. 주철근 시작점의 y 좌표를 모두 보관한다.
// 4. 보관된 y좌표로 횡단면에 그려질 간격을 구한다.
// 5. 횡단면 상에 그려지는 좌표를 구한다.
// CVectorArray로 한 이유 : z가 0이면 정상 철근, -1이면 좌측 사방향 철근, 1이면 우측 사방향 철근임을 표시
// BOOL bUseMatchSta : sta와 일치하는 위치의 철근들을 사용함(확폭의 경우 실제 sta 횡단면을 그리기 때문)
// 확폭이 아니라면 어딜 그리나 마찬가지 이므로 미리 구해진 시점부 철근을 사용한다. 
void CRcBridgeRebar::GetXyRebarMain_CrossSection_UpperSlab(CVectorArray &xyArr, CVectorArray &xyArrHunch, double dSta, BOOL bUpper, long nDan, long nCycle, BOOL bMirror, BOOL bUseMatchSta)
{
	xyArr.RemoveAll();
	xyArrHunch.RemoveAll();
	if(GetCountCycleMainRebar() <= nCycle) return;

	long i = 0;
	BOOL bVertDir	= IsVertDir();
	BOOL bExtLine	= IsExtLine();
	double dStaOld	= dSta;

	double dStaCheck	= GetStationModifyForRebarCheck(dSta);

	// 철근이 없다면 그냥 리턴
	long nIdxFind	= -1;
	BOOL bFind	= IsRebarMainBySta(TRUE, dStaCheck, nCycle, bUpper, nDan, nIdxFind);
	if(!bFind) return;
	////////////////////////////////////////////////////////////////

	
	CLineInfo *pLine	= bUseMatchSta ? GetLineBase() : GetLineBase(bVertDir, FALSE);
	CRebarPlacing rb;

	// 1. 평면상의 주철근 위치를 구한다.
	CTwinVectorArray tvArrMain, tvArrHunch;
	CTwinVectorArray tvArrMainLeftAng, tvArrMainRightAng;
	CTwinVectorArray tvArrHunchLeftAng, tvArrHunchRightAng;
	CTwinVectorArray tvArrMainTmp, tvArrHunchTmp;
	CTwinVectorArray tvArrJoint, tvArrHidden;	// 이 두 변수는 사용하지 않음
	GetTvRebarMain_Plane_UpperSlab_TypeNormal_Std(tvArrMainTmp, tvArrMainLeftAng, tvArrMainRightAng, bUpper, nCycle, nDan, 0, bUseMatchSta ? nIdxFind : 0, FALSE, FALSE, FALSE, tvArrJoint, tvArrHidden, tvArrHidden, tvArrHidden, TRUE);
	if(!bUpper)
		GetTvRebarMain_Plane_SlabHunch(tvArrHunchTmp, tvArrHunchLeftAng, tvArrHunchRightAng, nCycle, dSta, -1, 0);
	CTwinVectorArray tvArrCen, tvArrCenTmp;
	GetTvCenterPlane_UpperSlab(tvArrCenTmp, TRUE, FALSE, 0, bVertDir);

	CTwinVectorArray tvArrStt;
	GetTvPlaneSttEndLine(tvArrStt, TRUE, TRUE, 0, FALSE);
	CDPoint xyStt	= bUseMatchSta ? pLine->GetXyLineDis(dStaOld, 0)
									: pLine->GetXyLineDis(bVertDir ? (IsOutWall(TRUE) ? -m_dWS : 0) : m_dStationBridgeStt, 0);

	if(0)//bVertDir)
	{
		CDPointArray xyArrMatch;
		rb.GetXyMatchTvArrAndLine(tvArrCenTmp, xyStt, tvArrCenTmp.GetAt(0).GetXyDir().Rotate90(), xyArrMatch);
		if(xyArrMatch.GetSize() > 0)
			xyStt	= xyArrMatch.GetAt(0);
	}	

	long nJ	= bUseMatchSta ? GetJijumNumberByStation(dStaOld) : 0;
	// 주철근들을 tv정보로 변경 ////////////////////////
	// 교차점을 찾아야 되므로 끊어진 철근없이 무조건 시점부터 종점까지 그어버린다.
	CLineInfoApp *pLineOrg	= static_cast<CLineInfoApp*>(GetLineBase(FALSE));
	double dStaStt	= bUseMatchSta ? dStaOld : GetStationByTarget(BRIDGE_OFF_STT_SLAB, 0, FALSE);//m_dStationBridgeStt-dExtStt;
	
	CTwinVector tv;
	
	if(bVertDir || bExtLine)
	{
		CDPoint vAng	= bUseMatchSta ? pLine->GetAngleAzimuth(dStaOld).Rotate90() : GetAngleAzimuthJijum(nJ);
		CDPoint xyMatch(0, 0);
		for(i = 0; i < tvArrMainTmp.GetSize(); i++)
		{
			tv	= tvArrMainTmp.GetAt(i);
			if(GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), xyStt, vAng, tv.m_v1))
				tvArrMain.Add(tv);
		}

		// 확폭이면 좌우측 사방향 철근도 교차점 찾아야됨.
		// 속도때문에 교차점 찾지 않으려 했으나,
		// 확폭이 아니고 직선사보강일때도 1,2사이클의 직경이 다르면
		// 곡선구간때문에 교차점을 찾기 시작하는 위치가 달라서 Y값만으로는 정확한 위치를 찾을 수 없어서
		// 무조건 교차점 찾도록 함.
		if(1)//IsExtLine() || m_nTypeSideRebarMain_UpperSlabSabogang == 1)
		{
			if(m_nTypeSideRebarMain_UpperSlabSabogang == 0 && !bExtLine)
			{
				for(i = 0; i < tvArrMainLeftAng.GetSize(); i++)
				{
					tv	= tvArrMainLeftAng.GetAt(i);
					if(GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), xyStt, vAng, tv.m_v1))
						tvArrMainLeftAng.SetAt(i, tv);
				}

				for(i = 0; i < tvArrMainRightAng.GetSize(); i++)
				{
					tv	= tvArrMainRightAng.GetAt(i);
					if(GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), xyStt, vAng, tv.m_v1))
						tvArrMainRightAng.SetAt(i, tv);
				}
			}
			else if(m_nTypeSideRebarMain_UpperSlabSabogang == 1 || bExtLine)
			{
				CTwinVector *pTv	= NULL;

				CLineInfo *pLineL	= GetLineLeftRight(TRUE);
				for(i = 0; i < tvArrMainLeftAng.GetSize(); i++)
				{
					pTv	= &tvArrMainLeftAng.GetAt(i);
					double dDist	= pLineL->GetDisMatchVerticalByXy(pTv->m_v1);
					double sta		= 0;
					pLineL->GetStationMatchByXyAndAngle(xyStt, vAng, sta, dDist);
					pTv->m_v1	= pLineL->GetXyLineDis(sta, dDist);
				}

				CLineInfo *pLineR	= GetLineLeftRight(FALSE);
				for(i = 0; i < tvArrMainRightAng.GetSize(); i++)
				{
					pTv	= &tvArrMainRightAng.GetAt(i);
					double dDist	= pLineR->GetDisMatchVerticalByXy(pTv->m_v1);
					double sta		= 0;
					pLineR->GetStationMatchByXyAndAngle(xyStt, vAng, sta, dDist);
					pTv->m_v1	= pLineR->GetXyLineDis(sta, dDist);
				}
			}
		}

		for(i = 0; i < tvArrHunchTmp.GetSize(); i++)
		{
			tv	= tvArrHunchTmp.GetAt(i);
			if(GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), xyStt, vAng, tv.m_v1))
				tvArrHunch.Add(tv);
		}

		// 확폭이면 좌우측 사방향 철근도 교차점 찾아야됨.
		if(bExtLine)
		{
			for(i = 0; i < tvArrHunchLeftAng.GetSize(); i++)
			{
				tv	= tvArrHunchLeftAng.GetAt(i);
				if(GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), xyStt, vAng, tv.m_v1))
					tvArrHunchLeftAng.SetAt(i, tv);
			}

			for(i = 0; i < tvArrHunchRightAng.GetSize(); i++)
			{
				tv	= tvArrHunchRightAng.GetAt(i);
				if(GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), xyStt, vAng, tv.m_v1))
					tvArrHunchRightAng.SetAt(i, tv);
			}
		}

	}
	else
	{
		for(i = 0; i < tvArrMainTmp.GetSize(); i++)
		{
			tv	= tvArrMainTmp.GetAt(i);
			double dDist	= pLine->GetDisMatchVerticalByXy(tv.m_v1);
			tv.m_v1 = tv.m_v2 = pLineOrg->GetXyLineDis(dStaStt, dDist);
			tvArrMain.Add(tv);
		}
		for(i = 0; i < tvArrHunchTmp.GetSize(); i++)
		{
			tv	= tvArrHunchTmp.GetAt(i);
			double dDist	= pLine->GetDisMatchVerticalByXy(tv.m_v1);
			tv.m_v1 = tv.m_v2 = pLineOrg->GetXyLineDis(dStaStt, dDist);
			tvArrHunch.Add(tv);
		}
		for(i = 0; i < tvArrCenTmp.GetSize(); i++)
		{
			tv	= tvArrCenTmp.GetAt(i);
			double dDist	= pLine->GetDisMatchVerticalByXy(tv.m_v1);
			tv.m_v1 = tv.m_v2 = pLineOrg->GetXyLineDis(dStaStt, dDist);
			tvArrCen.Add(tv);
		}
	}
	// 주철근들을 tv정보로 변경 ////////////////////////

	
	
	// 2. bUseMatchSta일때는 해당 sta이 90도가 되도록 하고, 아닐땐 주철근을 시점이 90도가 되도록 회전한다.
	double dAngJijum	= GetAngleJijum(nJ).GetAngleDegree();
	double dAngAzJijum	= GetAngleAzimuthJijum(nJ).GetAngleDegree();
	double dAng		= (180+dAngJijum)-dAngAzJijum;
	if(bUseMatchSta)
	{
		dAngAzJijum	= pLine->GetAngleAzimuth(dStaOld).GetAngleDegree();
		dAng = 360 - dAngAzJijum;
	}
	CDPoint xyOrg	= CDPoint(0, 0);
	rb.RotateTvArr(tvArrMain, xyOrg, dAng);
	rb.RotateTvArr(tvArrHunch, xyOrg, dAng);
	rb.RotateTvArr(tvArrMainLeftAng, xyOrg, dAng);
	rb.RotateTvArr(tvArrMainRightAng, xyOrg, dAng);
	rb.RotateTvArr(tvArrHunchLeftAng, xyOrg, dAng);
	rb.RotateTvArr(tvArrHunchRightAng, xyOrg, dAng);
	rb.RotateTvArr(tvArrCen, xyOrg, dAng);
	rb.RotateTvArr(tvArrStt, xyOrg, dAng);
	rb.RotateXy(xyStt, xyOrg, dAng);

	// 3. 주철근 시작점의 y좌표를 모두 보관한다.
	CDoubleArray dArrMainY[3], dArrHunchY[3];
	CDPoint xyMatch(0, 0);
	CDPoint vAng	= GetAngleJijum(0);
	// 중심선에서 시점과 교차되는 부분을 찾는다.(어쨋든 시점을 기준으로 회전했으므로 
	// 시점을 기준으로 배근을 하자!!)
	// 사보강일 때만 찾으면 됨. 아닐땐 그냥 실제 y좌표 사용하자.!!!!
	for(i = 0; i < tvArrMain.GetSize(); i++)
		dArrMainY[0].Add(tvArrMain.GetAt(i).m_v1.y);

	for(i = 0; i < tvArrMainLeftAng.GetSize(); i++)
		dArrMainY[1].Add(tvArrMainLeftAng.GetAt(i).m_v1.y);

	for(i = 0; i < tvArrMainRightAng.GetSize(); i++)
		dArrMainY[2].Add(tvArrMainRightAng.GetAt(i).m_v1.y);

	for(i = 0; i < tvArrHunch.GetSize(); i++)
		dArrHunchY[0].Add(tvArrHunch.GetAt(i).m_v1.y);
	
	for(i = 0; i < tvArrHunchLeftAng.GetSize(); i++)
		dArrHunchY[1].Add(tvArrHunchLeftAng.GetAt(i).m_v1.y);
	
	for(i = 0; i < tvArrHunchRightAng.GetSize(); i++)
		dArrHunchY[2].Add(tvArrHunchRightAng.GetAt(i).m_v1.y);


	// 소트후 중복되는건 제거
	long s = 0; for(s = 0; s < 3; s++)
	{
		dArrMainY[s].Sort(TRUE);
		dArrHunchY[s].Sort(TRUE);
		
		for(i = 0; i < dArrMainY[s].GetSize()-1; i++)
		{
			if(Compare(dArrMainY[s].GetAt(i), dArrMainY[s].GetAt(i+1), "="))
				dArrMainY[s].RemoveAt(i+1);
		}
		for(i = 0; i < dArrHunchY[s].GetSize()-1; i++)
		{
			if(Compare(dArrHunchY[s].GetAt(i), dArrHunchY[s].GetAt(i+1), "="))
				dArrHunchY[s].RemoveAt(i+1);
		}
	}
	


	// 시점에서의 좌우측 점도 추가해줌
	// 폭이 가장 작은 부분을 기준으로 삼아야 됨. ///////
	CTwinVector tvStt;
	tvStt.m_v2	= tvArrStt.GetAt(0).m_v1;
	tvStt.m_v1	= tvArrStt.GetAt(tvArrStt.GetSize()-1).m_v2;
	double dStaSmallest	= dStaOld;
	double dW	= GetWidthSlabAct(dStaSmallest, CDPoint(0, 1), 0);
	if(bUseMatchSta)
	{
		tvStt.m_v1	= GetXySlabEdgeAct(dStaOld, CDPoint(0, 1), FALSE);
		tvStt.m_v2	= GetXySlabEdgeAct(dStaOld, CDPoint(0, 1), TRUE);
		rb.RotateXy(tvStt.m_v1, xyOrg, dAng);
		rb.RotateXy(tvStt.m_v2, xyOrg, dAng);
	}

	GetXyMatchLineAndLine(tvStt.m_v1, tvStt.GetXyDir(), CDPoint(0, tvStt.GetXyMid().y+dW/2), CDPoint(1, 0), xyMatch);
	tvStt.m_v2	= xyMatch;
	GetXyMatchLineAndLine(tvStt.m_v1, tvStt.GetXyDir(), CDPoint(0, tvStt.GetXyMid().y-dW/2), CDPoint(1, 0), xyMatch);
	tvStt.m_v1	= xyMatch;
	////////////////////////////////////////////////////

	for(s = 0; s < 3; s++)
	{
		dArrMainY[s].Add(tvStt.m_v1.y);
		dArrMainY[s].Add(tvStt.m_v2.y);
		if(!bUpper)
		{
			dArrHunchY[s].Add(tvStt.m_v1.y);
			dArrHunchY[s].Add(tvStt.m_v2.y);
		}
	}
	

	// y좌표 정렬 위에서 아래로
	for(s = 0; s < 3; s++)
	{
		dArrMainY[s].Sort(FALSE);
		dArrHunchY[s].Sort(FALSE);

		// 중복좌표 제거
		for(i = 0; i < dArrMainY[s].GetSize()-1; i++)
		{
			if(Compare(dArrMainY[s].GetAt(i), dArrMainY[s].GetAt(i+1), "="))
			{
				dArrMainY[s].RemoveAt(i+1);
				i--;
			}
		}
		for(i = 0; i < dArrHunchY[s].GetSize()-1; i++)
		{
			if(Compare(dArrHunchY[s].GetAt(i), dArrHunchY[s].GetAt(i+1), "="))
			{
				dArrHunchY[s].RemoveAt(i+1);
				i--;
			}
		}
	}

	// 4. 보관된 y좌표로 횡단면에 그려질 간격을 구한다.
	// 중심선시작점에서의 떨어진 거리임.
	CDoubleArray dArrMainDist[3], dArrHunchDist[3];
	
	for(s = 0; s < 3; s++)
	{
		for(i = 0; i < dArrMainY[s].GetSize(); i++)
		{
			double dY	= dArrMainY[s].GetAt(i);
			dArrMainDist[s].Add(tvStt.m_v1.y-dY);
		}
		for(i = 0; i < dArrHunchY[s].GetSize(); i++)
			dArrHunchDist[s].Add(tvStt.m_v1.y-dArrHunchY[s].GetAt(i));
	}

	// 떨어진 거리를 이용해 실제 위치로 옮김
	CTwinVectorArray tvArrCross;
	GetTvCrossSection(tvArrCross, dStaOld, CDPoint(0, 1), FALSE, FALSE, FALSE, 0, TRUE, FALSE, FALSE, FALSE, TRUE);
	CDRect rect	= tvArrCross.GetRect();
	for(s = 0; s < 3; s++)
	{
		for(i = 0; i < dArrMainDist[s].GetSize(); i++)
			dArrMainDist[s].SetAt(i, rect.left-dArrMainDist[s].GetAt(i));
		for(i = 0; i < dArrHunchDist[s].GetSize(); i++)
			dArrHunchDist[s].SetAt(i, rect.left-dArrHunchDist[s].GetAt(i));
	}

	// 5. 횡단면에 그려지는 좌표를 구하자.
	// 실제 횡단면 배력근에 수직으로 뻗어서 붙이면 끝.
	CTwinVectorArray tvArrSup, tvArrSupLeft, tvArrSupRight, tvArrSupHunch;
	GetTvRebarSupport_CrossSection_UpperSlab(tvArrSup, tvArrSupLeft, tvArrSupRight, dStaOld, bUpper, nDan, 0, TRUE, FALSE, FALSE, 0, bMirror);
	GetTvRebarSupport_CrossSection_UpperSlabHunch(tvArrSupHunch, dStaOld, nDan, 0, TRUE, FALSE, FALSE, 0, bMirror);

	// 곡선일 경우 교차점 안 찾아 지는 경우 있다.
	// 피복 보다 작을 정도로 늘려주자.
	CDRect rectSup	= tvArrSup.GetRect();
	CDRect rectStrecth	= rectSup;
	rectStrecth.top += 10;
	rectStrecth.bottom -= 10;
	
	rectStrecth.left	= rectSup.right - 10;
	rectStrecth.right	= rectSup.right + 10;
	rb.StretchTvArr(tvArrSup, rectStrecth, CDPoint(20, 0));		// 32493 : Stretch 값 조정

	rectStrecth.left	= rectSup.left - 10;
	rectStrecth.right	= rectSup.left + 10;
	rb.StretchTvArr(tvArrSup, rectStrecth, CDPoint(-25, 0));	// 32493 : Stretch 값 조정

	for(s = 0; s < 3; s++)
	{
		long nType	= 0;
		switch(s)
		{
		case 0: nType = 0; break;
		case 1: nType = -1; break;
		case 2: nType = 1; break;
		}
		if(tvArrSup.GetSize() > 0)
		{
			CDPointArray xyArrMatch;
			long i = 0; for(i = 0; i < dArrMainDist[s].GetSize(); i++)
			{
				rb.GetXyMatchTvArrAndLine(tvArrSup, CDPoint(dArrMainDist[s].GetAt(i), 0), CDPoint(0, 1), xyArrMatch);
				if(xyArrMatch.GetSize() > 0)
				{
					CVector xy	= xyArrMatch.GetAt(0);
					xy.z	= nType;
					
					xyArr.Add(xy);
				}
			}
		}

		if(tvArrSupHunch.GetSize() > 0)
		{
			CDPointArray xyArrMatch;
			long i = 0; for(i = 0; i < dArrHunchDist[s].GetSize(); i++)
			{
				rb.GetXyMatchTvArrAndLine(tvArrSupHunch, CDPoint(dArrHunchDist[s].GetAt(i), 0), CDPoint(0, 1), xyArrMatch);
				if(xyArrMatch.GetSize() > 0)
				{
					CVector xy	= xyArrMatch.GetAt(0);
					xy.z	= nType;
					xyArrHunch.Add(xy);
				}

			}
		}
	}


	// 철근반지름만큼 상하로 이동
	if(bUpper)
		rb.MoveRebar(xyArr, CDPoint(0, 1)*REBAR_RADIUS);
	else
	{
		rb.MoveRebar(xyArr, CDPoint(0, -1)*REBAR_RADIUS);
		rb.MoveRebar(xyArrHunch, CDPoint(0, -1)*REBAR_RADIUS);
	}
}

// 상부 슬래브 주철근 CTC 리턴
double CRcBridgeRebar::GetCtcRebarMain(BOOL bForUpperSlab)
{
	double dCTC	= m_dCTC_MainRebar;

	// 이 옵션은 선형방향 배치일 때만 변화가 있음
	if(m_nTypePlacingMainRebar_UpperSlab != 0) return dCTC;
	
	// 벽체 기준일 경우 상부슬래브배근시 CTC를 시점각도에 따라 변경 해줘야 된다.
	if(bForUpperSlab)
	{
		if(m_nTypeStandardCTCRebarMain == 1)
		{
			CDPoint vAng	= GetAngleJijum(0);
			dCTC	= dCTC * vAng.y;
		}
	}
	return dCTC;	// index방식에서 double형으로 변경 index는 사용하지 않음(2005.04.25)
}

// 횡단면도 상부 슬래브 전단철근 좌표
// 주철근 몇개 씩 감싸는 지는 변수로 받음.. 으하하
// 상면 철근 두번째 부터 배근하며, 라운드로 인하며 배근시작위치에 하면 철근이 없는 경우 다음 철근을 찾음.
// BOOL bForMarkRebar : 철근 마킹 용이면 모든 철근이 길이가 같아야 된다.(그래야 이쁘게 나옴)
// CTwinVectorArray &tvArr : 정상길이의 철근
// CTwinVectorArray &tvArr2 : 모서리 부분의 변화길이 철근
// BOOL bNotHunch : 헌치를 전혀 적용하지 않음
void CRcBridgeRebar::GetTvRebarShear_CrossSection_UpperSlab(CTwinVectorArray &tvArr, CTwinVectorArray &tvArr2, double dSta, long nDrawLeft, BOOL bForMarkRebar, BOOL bNotHunch, BOOL bGagak, BOOL bMirror)
{
	tvArr.RemoveAll();
	tvArr2.RemoveAll();

	// 전단철근 간격
	double dCTC	= GetCTCRebarShear_UpperSlab();
	// 주철근이 사보강배치인 경우 시점각도가 적용된 거리를 구해야 됨.
	if(IsVertDir())
		dCTC	= dCTC / GetAngleJijum(0).y;
	else
	{
		// 만약 벽체 기준이라면 간격이 작아짐
		if(m_nTypeStandardCTCRebarMain == 1)
			dCTC	= dCTC * GetAngleJijum(0).y;
	}
	if(Compare(dCTC, 0.0, "=")) return;

	// 전단철근은 하면 철 근 좌측끝에서 우측 끝으로 배근함(하면철근에서 시작)
	CTwinVectorArray tvArrUpper, tvArrLower, tvArrSupLeft, tvArrSupRight;
	CTwinVector tvUpper, tvLower;
	GetTvRebarSupport_CrossSection_UpperSlab(tvArrUpper, tvArrSupLeft, tvArrSupRight, dSta, TRUE, 0, 0, TRUE, FALSE, FALSE, 0, bMirror);
	GetTvRebarSupport_CrossSection_UpperSlab(tvArrLower, tvArrSupLeft, tvArrSupRight, dSta, FALSE, 0, 0, TRUE, FALSE, FALSE, 0, bMirror);
	tvUpper.m_v1	= tvArrUpper.GetAt(0).m_v1;
	tvUpper.m_v2	= tvArrUpper.GetAt(tvArrUpper.GetSize()-1).m_v2;
	tvLower.m_v1	= tvArrLower.GetAt(0).m_v1;
	tvLower.m_v2	= tvArrLower.GetAt(tvArrLower.GetSize()-1).m_v2;

	// 배력근 위치를 참조해야 되므로 주철근 위치 구함.
	CVectorArray xyArrUpper, xyArrLower, xyArrHunch;
	// 세로로 세워진 형태
	GetXyRebarMain_CrossSection_UpperSlab(xyArrUpper, xyArrHunch, dSta, TRUE, 0, 0, bMirror, TRUE);
	GetXyRebarMain_CrossSection_UpperSlab(xyArrLower, xyArrHunch, dSta, FALSE, 0, 0, bMirror, TRUE);

	if(GetCountCycleMainRebar() == 4)
	{
		// 배력근 위치를 참조해야 되므로 주철근 위치 구함.
		CVectorArray xyArrUpper2, xyArrLower2, xyArrHunch2;
		// 세로로 세워진 형태
		GetXyRebarMain_CrossSection_UpperSlab(xyArrUpper2, xyArrHunch2, dSta, TRUE, 0, 2, bMirror, TRUE);
		GetXyRebarMain_CrossSection_UpperSlab(xyArrLower2, xyArrHunch2, dSta, FALSE, 0, 2, bMirror, TRUE);
		if(xyArrUpper2.GetSize() > 0)
			xyArrUpper.Add(xyArrUpper2.GetAt(xyArrUpper2.GetSize()-1));
		if(xyArrLower2.GetSize() > 0)
			xyArrLower.Add(xyArrLower2.GetAt(xyArrLower2.GetSize()-1));
	}

	CRebarPlacing rb;
	rb.ReverseRebar(xyArrUpper);
	rb.ReverseRebar(xyArrLower);
	rb.ReverseRebar(xyArrHunch);

		

	// 가로로 눞혀야 된다.
	// 배력근 위치는 전단철근 시작위치 찾는데만 참조한다.
	CDPoint xy(0, 0);
	long i	= 0;
	long nSize	= xyArrUpper.GetSize();
	if(nSize < 2) return;

	// xyArrUpper 소트
	// 사보강시 순서대로 안 구해져잇음
	for(i = 0; i < xyArrUpper.GetSize()-1; i++)
	{
		CDPoint xy1	= xyArrUpper.GetAt(i);
		long j = 0; for(j = i + 1; j < xyArrUpper.GetSize(); j++)
		{
			CDPoint xy2	= xyArrUpper.GetAt(j);

			if(xy1.x > xy2.x)
			{
				GetSwap(xy1, xy2);
				xyArrUpper.SetAt(i, xy1);
				xyArrUpper.SetAt(j, xy2);
			}
		}
	}

	// 배근 시작위치 찾음
	// 상면 두번째 주철근부터를 기본으로 하고 만약 시작 위치에 하면배력근이 없는 위치라면 다음 위치를 찾음
	nSize	= xyArrUpper.GetSize();
	CDPoint xyStt	= xyArrUpper.GetAt(0);
	CDPoint xyEnd	= xyArrUpper.GetAt(nSize-2);	// 마지막 두번째 철근까지로 범위를 조정한다 (11818 2010.05.11 홍석현)
	
	BOOL bFindStt	= FALSE;
	for(i = 1; i < nSize; i++)
	{
		xyStt	= xyArrUpper.GetAt(i);
		if(tvLower.m_v1.x <= xyStt.x && tvLower.m_v2.x >= xyStt.x)
		{
			bFindStt	= TRUE;
			break;
		}
	}
	if(!bFindStt) return;	// 시작위치를 못 찾으면 리턴

	// 전단철근 위치 찾음
	CDPointArray xyArrShear;
	CTwinVector tv;
	xyStt	= xyArrUpper.GetAt(i);
	nSize	= tvArrUpper.GetSize();
	while(1)
	{
		if(xyStt.x >= tvLower.m_v1.x && xyStt.x <= tvLower.m_v2.x)
		{
			long i = 0; for(i = 0; i < nSize; i++)
			{
				tv	= tvArrUpper.GetAt(i);
				if(GetXyMatchSegAndLine(tv.m_v1, tv.m_v2, xyStt, CDPoint(0, 1), xyStt))
					break;
			}
			xyArrShear.Add(CDPoint(xyStt.x, xyStt.y));
		}
				
		xyStt.x += dCTC;
		if((xyStt.x > tvLower.m_v2.x) || Compare(xyStt.x, xyEnd.x, _T(">"), 10))break;
	}
	
	// 다 구한뒤에 nDrawLeft에 따라서 걸러낸다.
	if(nDrawLeft == -1 || nDrawLeft == 1)
	{
		double dDistMid	= GetDistMidOfSlab(dSta);
		if(nDrawLeft == -1)
		{
			long i = 0; for(i = 0; i < xyArrShear.GetSize(); i++)
			{
				if(xyArrShear.GetAt(i).x > dDistMid)
				{
					xyArrShear.RemoveAt(i);
					i--;
				}
			}
		}
		else
		{
			long i = 0; for(i = 0; i < xyArrShear.GetSize(); i++)
			{
				if(xyArrShear.GetAt(i).x < dDistMid)
				{
					xyArrShear.RemoveAt(i);
					i--;
				}
			}
		}
	}

	

	// 저장 한거 하부 배력근 기준으로 잘라냄.
	CTwinVectorArray tvArrMid, tvArrLeft, tvArrRight;
	CTwinVectorArray tvArrHunch;
	// 슬래브하부 기준으로 자른뒤, 헌치하부에 포함되는건 헌치하부까지 뻗음
	GetTvRebarSupport_CrossSection_UpperSlab(tvArrMid, tvArrLeft, tvArrRight, dSta, FALSE, 0, 0, TRUE, FALSE, bGagak, 0, bMirror);
	GetTvRebarSupport_CrossSection_UpperSlabHunch(tvArrHunch, dSta, 0, 0, TRUE, bGagak, FALSE, 0, bMirror);
	CDRect rectHunch	= tvArrHunch.GetRect();
	CDPointArray xyArrMatch;
	for(i = 0; i < xyArrShear.GetSize(); i++)
	{
		xy	= xyArrShear.GetAt(i);
		CTwinVector tvMatch;
		if(!bNotHunch && (rectHunch.left <= xy.x && rectHunch.right >= xy.x))
		{
			rb.GetXyMatchTvArrAndLine(tvArrHunch, xy, CDPoint(0, -1), xyArrMatch);
		}
		else
		{
			long nIdx	= rb.GetXyMatchTvArrAndLine(tvArrMid, xy, CDPoint(0, -1), xyArrMatch);
			if(nIdx > -1)
				tvMatch	= tvArrMid.GetAt(nIdx);
		}

		if(xyArrMatch.GetSize() > 0)
		{
			if(bForMarkRebar)
			{
				tv.m_v1	= xy;
				tv.m_v2	= xy + CDPoint(0, -m_dTS);
			}
			else
			{
				tv.m_v1	= xy;
				tv.m_v2	= xyArrMatch.GetAt(0);
			}
			if(tvMatch.m_sInfo.Find("좌측", 0) == -1 && tvMatch.m_sInfo.Find("우측", 0) == -1)
				tvArr.Add(tv);
			else
			{
				if(!m_bRemoveShearRebarAtSlabYundan)
					tvArr2.Add(tv);
			}
		}
	}
}

// 전단철근 
double CRcBridgeRebar::GetCTCRebarShear_UpperSlab()
{
	double dCtc	= m_dCTC_MainRebar/2 * m_nCountWrapMainRebarUpperSlab;

	return dCtc;
}

double CRcBridgeRebar::GetCTCRebarShear_LowerSlab()
{
	double dCtc	= m_dCTC_MainRebar/2 * m_nCountWrapMainRebarLowerSlab;

	return dCtc;
}

// 전단철근 
// double CRcBridgeRebar::GetCTCRebarShear_OutWall(BOOL bStt)
// {
// 	double dCtc	= m_dCTC_MainRebar/2 * m_nCountWrapMainRebarForOutWall[bStt ? iSTT : iEND];
// 
// 	return dCtc;
// }

// 전단철근 
// double CRcBridgeRebar::GetCTCRebarShear_Bracket(BOOL bStt)
// {
// 	double dCtc	= m_dCTC_MainRebar/2 * m_nCountWrapMainRebarForBracket[bStt ? iSTT : iEND];
// 
// 	return dCtc;
// }
// 전단철근 
double CRcBridgeRebar::GetCTCRebarShear_ArchRib()
{
	double dCtc	= m_dCTC_MainRebar/2 * m_nCountWrapMainRebarForArchRib;

	return dCtc;
}

// 전단철근 
double CRcBridgeRebar::GetCTCRebarShear_DanbuStirrup(BOOL bUpper, BOOL bStt)
{
	double dCtc	= m_dCTC_MainRebar/2 * m_nCountStirrupCtcMainRebar[bUpper? iUPPER : iLOWER][bStt? iSTT : iEND];

	return dCtc;
}

// 상부 슬래브 헌치부 배력철근
// sta에 따라 있을수도 없을 수도 있다.
// 주철근이 선형방향으로 배치되면 수직으로 자른횡단면을 사용하지만
// 사보강배치방법으로 배근되면 시점각도로 자른횡단면을 사용한다.
// 이것은 주철근 배치를 위해 사용할대는 위와 같이 두가지 방법으로 사용하지만 
// BOOL bForDrawCrossSection : 횡단면도를 그리기 위해서 그릴때는 무조건 직각방향으로 자른 횡단면을 사용한다.
// BOOL bForRebarBM : 집계용으로 무조건 sta의 지점 각도길이로 그린다.
void CRcBridgeRebar::GetTvRebarSupport_CrossSection_UpperSlabHunch(CTwinVectorArray &tvArr, double dSta, long nDan, long nDrawLeft, BOOL bForDrawCrossSection, BOOL bExp, BOOL bForRebarBM, long nApplyAngle, BOOL bMirror)
{
	if(!IsExp(dSta))
		bExp	= FALSE;

	tvArr.RemoveAll();
	double dThickHunch	= GetHeightUpperSlab(GetJijumNumberByStation(dSta), 0, CDPoint(0,1)) - m_dTS;
	double dCover		= m_dCoverLower_UpperSlab[nDan];
	BOOL bVertDir	= IsVertDir();
	if(dThickHunch <= 0) return;
	if(!m_bPlacingSupportAtHunchRebar)	return;
	



	// 헌치 철근이 존재 하는지 검사
	double dStaCheck	= GetStationModifyForRebarCheck(dSta);
	/*
	long nJ	= GetJijumNumberByStation(dSta);
	if(nJ == 0 || nJ == m_nQtyJigan)
	{
		CDPoint vAng	= GetAngleJijum(nJ, bVertDir);
		double dStaStt	= GetStationByTarget(BRIDGE_OFF_STT_SLAB, 0, FALSE);
		double dLenBri	= GetStationByTarget(BRIDGE_OFF_END_SLAB, 0, FALSE) - GetStationByTarget(BRIDGE_OFF_STT_SLAB, 0, FALSE);
		if(nJ == 0 && dSta <= dStaStt + m_dCoverWallOut[0]/vAng.y)
			dSta = dStaStt + m_dCoverWallOut[0]/vAng.y;
		else if(nJ == m_nQtyJigan && dSta >= dStaStt + dLenBri - m_dCoverWallOut[0]/vAng.y)
			dSta	= dStaStt + dLenBri - m_dCoverWallOut[0]/vAng.y;
	}
	*/

	BOOL bFind	= FALSE;
	long i = 0; for(i = 0; i < m_pArrRCMainUpperSlabHunch[0].GetSize(); i++)
	{
		CRebarInfoCycle *pRC	= m_pArrRCMainUpperSlabHunch[0].GetAt(i);
		double dLeft	= pRC->m_tvArrRebar.GetXyLeft().x;
		double dRight	= pRC->m_tvArrRebar.GetXyRight().x;
		if((fabs(dStaCheck-dLeft) <= 100 || Compare(dStaCheck, dLeft, ">=")) && (fabs(dStaCheck-dRight) <= 100 || Compare(dStaCheck, dRight, "<=")))
		//if(pRC->m_tvArrRebar.GetXyLeft().x <= dSta && pRC->m_tvArrRebar.GetXyRight().x >= dSta)
		{
			bFind	= TRUE;
			break;
		}
	}
	if(!bFind) return;

	
	CDPoint vAng	= bVertDir ? CDPoint(0, 1) : GetAngleJijum(0);
	if(bForDrawCrossSection)
		vAng	= CDPoint(0, 1);

	if(bForRebarBM)
		vAng	= GetAngleJijum(GetJijumNumberByStation(dSta), FALSE);

	if(nApplyAngle == -1)
		vAng	= CDPoint(0, 1);
	else if(nApplyAngle == 1)
		vAng	= GetAngleJijum(GetJijumNumberByStation(dSta));

	// 헌치 상단 좌표들
	double dStaSmallestWidth	= dSta;//GetStationSmallestWidthOfUpperSlab();
	CDPointArray xyArr;
	GetPointArraySlabHunchAct(dStaSmallestWidth, vAng, xyArr, bExp);
	CTwinVector tv;
	long nSize	= xyArr.GetSize();
	for(i = 0; i < nSize-1; i++)
	{
		tv.m_v1 = CDPoint(xyArr.GetAt(i).x, xyArr.GetAt(i).y-dThickHunch+dCover);
		tv.m_v2 = CDPoint(xyArr.GetAt(i+1).x, xyArr.GetAt(i+1).y-dThickHunch+dCover);
		tv.m_sInfo	= "슬래브헌치하부";
		tvArr.Add(tv);
	}

	// 좌우측을 피복 고려
	CRebarPlacing rb;
	if(tvArr.GetSize() > 0)
	{
		double dCoverSide	= m_dCoverUpper_UpperSlab[0];
		CDRect rect	= tvArr.GetRect();
		
		tv	= tvArr.GetAt(0);
		rb.TrimTvArrayByLine(tvArr, CDPoint(tv.m_v1.x+dCoverSide, rect.bottom-100), CDPoint(tv.m_v1.x+dCoverSide, rect.top+100), TRUE, TRUE, FALSE);

		if(tvArr.GetSize() > 0)
		{
			tv	= tvArr.GetAt(tvArr.GetSize()-1);
			rb.TrimTvArrayByLine(tvArr, CDPoint(tv.m_v2.x-dCoverSide, rect.bottom-100), CDPoint(tv.m_v2.x-dCoverSide, rect.top+100), FALSE, TRUE, FALSE);

			// 좌측 선 넣어줌
			if(tvArr.GetSize() > 0)
			{
				tv	= tvArr.GetAt(0);
				tv.m_v2	= tv.m_v1;
				tv.m_v1	= tv.m_v2 + CDPoint(0, dThickHunch);
				tv.m_sInfo	= "슬래브헌치좌측";
				tvArr.InsertAt(0, tv);

				// 우측 선 넣어줌
				tv	= tvArr.GetAt(tvArr.GetSize()-1);
				tv.m_v1	= tv.m_v2;
				tv.m_v2	= tv.m_v2 + CDPoint(0, dThickHunch);
				tv.m_sInfo	= "슬래브헌치우측";
				tvArr.Add(tv);
			}
		}

		// mirror
		// 시점에서 본 모양데로 그리기 위해.
		long nJ	= GetJijumNumberByStation(dSta);
		if(nJ == 0 || bMirror)
		{
			CTwinVectorArray tvArrCross;
			GetTvCrossSection(tvArrCross, dStaSmallestWidth, vAng, FALSE, TRUE, FALSE, 0, FALSE, FALSE);
			rect	= tvArrCross.GetRect();
			rb.Mirror(tvArr, CDPoint(rect.left, 0), TRUE);
			rb.MoveRebar(tvArr, CDPoint(rect.Width(), 0));
		}

		// nDrawLeft에 따라서 잘라냄
		if(nDrawLeft != 0)
		{
			rect	= tvArr.GetRect();
			double dMid	= GetMidCrossSection(TRUE);
			BOOL bLeft	= nDrawLeft == -1 ? FALSE : TRUE;
			CDPoint xy1	= CDPoint(dMid, rect.bottom-100);
			CDPoint xy2	= CDPoint(dMid, rect.top+100);
			rb.TrimTvArrayByLine(tvArr, xy1, xy2, bLeft, TRUE, FALSE);
		}
	}
}

void CRcBridgeRebar::GetTvRebarMain_Plane_UpperSlab_TypeNormal_Std(CTwinVectorArray &tvArr, CTwinVectorArray &tvArrAngLeft, CTwinVectorArray &tvArrAngRight, BOOL bUpper, long nCycle, long nDan, long nDrawLeft, long nIdx, BOOL bHunch, BOOL bSttBracket, BOOL bEndBracket, CTwinVectorArray &tvArrJoint, CTwinVectorArray &tvArrHidden, CTwinVectorArray &tvArrHiddenLeft, CTwinVectorArray &tvArrHiddenRight, BOOL bForDrawing, CTwinVectorArray &tvArrAngLeftHalf, CTwinVectorArray &tvArrAngRightHalf, BOOL bCalDistRebarMain)
{
	tvArr.RemoveAll();
	tvArrAngLeft.RemoveAll();
	tvArrAngRight.RemoveAll();
	tvArrJoint.RemoveAll();
	tvArrHidden.RemoveAll();
	tvArrHiddenLeft.RemoveAll();
	tvArrHiddenRight.RemoveAll();
	tvArrAngLeftHalf.RemoveAll();
	tvArrAngRightHalf.RemoveAll();

	CTwinVectorArray tvArrTmp;
	CTwinVectorArray tvArrAngLeftTmp;
	CTwinVectorArray tvArrAngRightTmp;
	CTwinVectorArray tvArrJointTmp;
	CTwinVectorArray tvArrHiddenTmp;
	CTwinVectorArray tvArrHiddenLeftTmp;
	CTwinVectorArray tvArrHiddenRightTmp;
	CTwinVectorArray tvArrAngLeftHalfTmp;
	CTwinVectorArray tvArrAngRightHalfTmp;

	// 철근 새로 만들기
	// TEST CODE
	if(!m_bCaledRebarMain_Plane)
	{
		SettingTvArrRebarMainPlane();
	}

	long upper	= bUpper ? iUPPER : iLOWER;
	long nIdxSttCycle	= nCycle == -1 ? 0 : nCycle;
	long nIdxEndCycle	= nCycle == -1 ? MAX_REBAR_CYCLE : nCycle+1;
	long cycle = 0; for(cycle = nIdxSttCycle; cycle < nIdxEndCycle; cycle++)
	{
		if(bHunch)
		{
			m_Util.AddFromTvArray(tvArrTmp, &m_tvArr_RebarMain_PlaneHunch[cycle], nIdx);	
			m_Util.AddFromTvArray(tvArrAngLeftTmp, &m_tvArrAngLeft_RebarMain_PlaneHunch[cycle], nIdx);
			m_Util.AddFromTvArray(tvArrAngRightTmp, &m_tvArrAngRight_RebarMain_PlaneHunch[cycle], nIdx);
			m_Util.AddFromTvArray(tvArrHiddenTmp, &m_tvArrHidden_RebarMain_PlaneHunch[cycle], nIdx);
			m_Util.AddFromTvArray(tvArrHiddenLeftTmp, &m_tvArrHiddenLeft_RebarMain_PlaneHunch[cycle], nIdx);
			m_Util.AddFromTvArray(tvArrHiddenRightTmp, &m_tvArrHiddenRight_RebarMain_PlaneHunch[cycle], nIdx);
			m_Util.AddFromTvArray(tvArrAngLeftHalfTmp, &m_tvArrAngLeftHalf_RebarMain_PlaneHunch[cycle], nIdx);
			m_Util.AddFromTvArray(tvArrAngRightHalfTmp, &m_tvArrAngRightHalf_RebarMain_PlaneHunch[cycle], nIdx);
		}
		else if(bSttBracket)
		{
			tvArrTmp.AddFromTvArray(m_tvArrSttBracket_RebarMain_Plane);
		}
		else if(bEndBracket)
		{
			tvArrTmp.AddFromTvArray(m_tvArrEndBracket_RebarMain_Plane);
		}
		else
		{
			m_Util.AddFromTvArray(tvArrTmp, &m_tvArr_RebarMain_Plane[cycle][nDan][upper], nIdx);
			m_Util.AddFromTvArray(tvArrAngLeftTmp, &m_tvArrAngLeft_RebarMain_Plane[cycle][nDan][upper], nIdx);
			m_Util.AddFromTvArray(tvArrAngRightTmp, &m_tvArrAngRight_RebarMain_Plane[cycle][nDan][upper], nIdx);
			m_Util.AddFromTvArray(tvArrJointTmp, &m_tvArrJoint_RebarMain_Plane[cycle][nDan][upper], nIdx);
			m_Util.AddFromTvArray(tvArrHiddenTmp, &m_tvArrHidden_RebarMain_Plane[cycle][nDan][upper], nIdx);
			m_Util.AddFromTvArray(tvArrHiddenLeftTmp, &m_tvArrHiddenLeft_RebarMain_Plane[cycle][nDan][upper], nIdx);
			m_Util.AddFromTvArray(tvArrHiddenRightTmp, &m_tvArrHiddenRight_RebarMain_Plane[cycle][nDan][upper], nIdx);
			m_Util.AddFromTvArray(tvArrAngLeftHalfTmp, &m_tvArrAngLeftHalf_RebarMain_Plane[cycle][nDan][upper], nIdx);
			m_Util.AddFromTvArray(tvArrAngRightHalfTmp, &m_tvArrAngRightHalf_RebarMain_Plane[cycle][nDan][upper], nIdx);
		}
	}

	BOOL bVertDir	= IsVertDir();
	BOOL bExtLine	= IsExtLine();
	if(nDrawLeft != 0 || m_nTypePlacingMainRebar_UpperSlab == 2)
	{
		// 바로 rb에 넘기면 시간이 오래 걸리므로 일단 스테이션으로 판단하는 곳에 넘겨서 살짝 걸러냄.
		if(!bVertDir)
		{
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrTmp, nDrawLeft);
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrAngLeftTmp, nDrawLeft);
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrAngRightTmp, nDrawLeft);
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrJointTmp, nDrawLeft);
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrHiddenTmp, nDrawLeft);
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrHiddenLeftTmp, nDrawLeft);
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrHiddenRightTmp, nDrawLeft);
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrAngLeftHalfTmp, nDrawLeft);
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrAngRightHalfTmp, nDrawLeft);

			if(bExtLine)
			{
				CRebarPlacing rb;
				CLineInfo *pLineL	= GetLineLeftRight(TRUE);
				CLineInfo *pLineR	= GetLineLeftRight(FALSE);
				CTwinVectorArray tvArrPlaneOut;
				GetTvRebarOut_Plane_UpperSlabStd(tvArrPlaneOut, -1, TRUE, nDrawLeft==-1?iLEFT:(nDrawLeft==1?iRIGHT:2), bVertDir);

				rb.m_pLine	= pLineL;
				rb.GetTvArrayByCrossTvArrayArea(tvArrAngLeftTmp, tvArrPlaneOut, TRUE);
				rb.m_pLine	= pLineR;
				rb.GetTvArrayByCrossTvArrayArea(tvArrAngRightTmp, tvArrPlaneOut, TRUE);
// 				rb.m_pLine	= pLineL;
// 				StretchTvOfTvArr(tvArrHiddenLeftTmp, -1, -1);
// 				rb.GetTvArrayByCrossTvArrayArea(tvArrHiddenLeftTmp, tvArrPlaneOut, TRUE);
// 				rb.m_pLine	= pLineR;
// 				StretchTvOfTvArr(tvArrHiddenRightTmp, -1, -1);
// 				rb.GetTvArrayByCrossTvArrayArea(tvArrHiddenRightTmp, tvArrPlaneOut, TRUE);
			}
		}
		else
		{
			// 바로 rb에 넘기면 시간이 오래 걸리므로 일단 스테이션으로 판단하는 곳에 넘겨서 살짝 걸러냄.
			// 걸러낼 수 있는거만.
			/*
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArr, nDrawLeft);
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrJoint, nDrawLeft);
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrHidden, nDrawLeft);
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrAngLeft, nDrawLeft);
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrAngRight, nDrawLeft);
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrHiddenLeft, nDrawLeft);
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrHiddenRight, nDrawLeft);
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrAngLeftHalf, nDrawLeft);
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrAngRightHalf, nDrawLeft);
			*/

			// 계산해서 잘라내기
			CTwinVectorArray tvArrPlane;
			GetTvRebarOut_Plane_UpperSlabStd(tvArrPlane, 0, TRUE, nDrawLeft==-1?iLEFT:(nDrawLeft==1?iRIGHT:2), bVertDir);

			CTwinVectorArray tvArrPlane9Dan;
			GetTvRebarOut_Plane_UpperSlabStd(tvArrPlane9Dan, 9, TRUE, nDrawLeft==-1?iLEFT:(nDrawLeft==1?iRIGHT:2), bVertDir);

			CTwinVectorArray tvArrPlaneOut;
			GetTvRebarOut_Plane_UpperSlabStd(tvArrPlaneOut, -1, TRUE, nDrawLeft==-1?iLEFT:(nDrawLeft==1?iRIGHT:2), bVertDir);

			CRebarPlacing rb;
			CLineInfo *pLineL	= GetLineLeftRight(TRUE);
			CLineInfo *pLineR	= GetLineLeftRight(FALSE);
 			rb.GetTvArrayByCrossTvArrayArea(tvArrTmp, tvArrPlane, TRUE);
 			rb.GetTvArrayByCrossTvArrayArea(tvArrJointTmp, tvArrPlaneOut, TRUE);
 			rb.GetTvArrayByCrossTvArrayArea(tvArrHiddenTmp, tvArrPlane9Dan, TRUE);
			
			rb.m_pLine	= pLineL;
			rb.GetTvArrayByCrossTvArrayArea(tvArrAngLeftTmp, tvArrPlaneOut, TRUE);
			rb.m_pLine	= pLineR;
			rb.GetTvArrayByCrossTvArrayArea(tvArrAngRightTmp, tvArrPlaneOut, TRUE);
			rb.m_pLine	= NULL;
			StretchTvOfTvArr(tvArrHiddenLeftTmp, -1, -1);
			rb.GetTvArrayByCrossTvArrayArea(tvArrHiddenLeftTmp, tvArrPlane9Dan, TRUE);
			StretchTvOfTvArr(tvArrHiddenRightTmp, -1, -1);
			rb.GetTvArrayByCrossTvArrayArea(tvArrHiddenRightTmp, tvArrPlane9Dan, TRUE);
			rb.GetTvArrayByCrossTvArrayArea(tvArrAngLeftHalfTmp, tvArrPlane, TRUE);
			rb.GetTvArrayByCrossTvArrayArea(tvArrAngRightHalfTmp, tvArrPlane, TRUE);
		}
	}




	ConvertPlaneLineToTv(tvArrTmp);
	ConvertPlaneLineToTv(tvArrAngLeftTmp);
	ConvertPlaneLineToTv(tvArrAngRightTmp);
	ConvertPlaneLineToTv(tvArrJointTmp);
	ConvertPlaneLineToTv(tvArrHiddenTmp);
	ConvertPlaneLineToTv(tvArrHiddenLeftTmp);
	ConvertPlaneLineToTv(tvArrHiddenRightTmp);
	ConvertPlaneLineToTv(tvArrAngLeftHalfTmp);
	ConvertPlaneLineToTv(tvArrAngRightHalfTmp);

	
	tvArr.AddFromTvArray(tvArrTmp);
	tvArrAngLeft.AddFromTvArray(tvArrAngLeftTmp);
	tvArrAngRight.AddFromTvArray(tvArrAngRightTmp);
	tvArrJoint.AddFromTvArray(tvArrJointTmp);
	tvArrHidden.AddFromTvArray(tvArrHiddenTmp);
	tvArrHiddenLeft.AddFromTvArray(tvArrHiddenLeftTmp);
	tvArrHiddenRight.AddFromTvArray(tvArrHiddenRightTmp);
	tvArrAngLeftHalf.AddFromTvArray(tvArrAngLeftHalfTmp);
	tvArrAngRightHalf.AddFromTvArray(tvArrAngRightHalfTmp);
}


// 평면도 주철근(모든 dan, cycle)
// 평범한 형태(확폭아님) - 확폭은 나중에 지원예정.
// long nDrawLeft : -1 : 진행방향 좌측 라인좌표만 구함, 0 : 진행방향 좌우측 라인 모두 구함, 1 : 진행방향 우측 라인만 구함.
// BOOL bHunch : 헌치주철근인지? (헌치 주철근인 경우, ctc등의 정보는 하부정보를 이용한다)
// BOOL bSttBracket, BOOL bEndBracket : 시점이나 종점 브라켓 주철근인지?(브라켓 주철근은 ctc등의 정보를 하부의 정보를 이용한다)
// BOOL bGirder : 거더 스터럽 철근 배근방식이 주철근과 동일하므로 여기서 처리함. (nIdx는 거더의 지점으로 이용함)
// bHunch, bStt나 bEndBracket은 중복될 수 없고, 중복될경우 우선순위는 hunch, stt, end가 된다.
// tvArrJoint : 이음 좌표
// tvArrHidden은 시종점벽체에 R로 꺽이는 철근에 대해서 점선으로 그리기 위한 좌표임
// bForDrawing : tvArrHidden을 구하면 tvArr과 tvArrAngLeft, tvArrAngRight에 대해서 tvArrHidden만큼 짧게 만들어야 됨
// CTwinVectorArray &tvArrVertTotLen : 사보강(절반)배치 일 경우 변화구간 직거리 철근은 라운드 없는 길이가 필요하다.
// BOOL bCalDistRebarMain : 시간 단축을 위함.
void CRcBridgeRebar::GetTvRebarMain_Plane_UpperSlab_TypeNormal(CTwinVectorArray &tvArr, CTwinVectorArray &tvArrAngLeft, CTwinVectorArray &tvArrAngRight, BOOL bUpper, long nCycle, long nDan, long nDrawLeft, long nIdx, BOOL bHunch, BOOL bSttBracket, BOOL bEndBracket, CTwinVectorArray &tvArrJoint, CTwinVectorArray &tvArrHidden, CTwinVectorArray &tvArrHiddenLeft, CTwinVectorArray &tvArrHiddenRight, BOOL bForDrawing, CTwinVectorArray &tvArrAngLeftHalf, CTwinVectorArray &tvArrAngRightHalf, BOOL bCalDistRebarMain)
{
	tvArr.RemoveAll();
	tvArrAngLeft.RemoveAll();
	tvArrAngRight.RemoveAll();
	tvArrJoint.RemoveAll();
	tvArrHidden.RemoveAll();
	tvArrHiddenLeft.RemoveAll();
	tvArrHiddenRight.RemoveAll();
	tvArrAngLeftHalf.RemoveAll();
	tvArrAngRightHalf.RemoveAll();

	CTwinVectorArray tvArrPlane, tvArrPlaneRebar;
	GetTvRebarOut_Plane_UpperSlabStd(tvArrPlane, 0, TRUE, nDrawLeft == -1 ? iUPPER : (nDrawLeft == 1 ? iLOWER : 2));
	GetTvRebarOut_Plane_UpperSlabStd(tvArrPlaneRebar, 0, TRUE, 2);
	tvArrPlane	= m_tvArrPlane1DanOrg;
	tvArrPlaneRebar	= m_tvArrPlane1DanOrg;
	
	// 2005.06.16 부로 주철근 사보강 배치(절반) 옵션 없어짐 /////////
	// 하부장님 정차장님과 상의 함.
	// 2006.1.2부로 다시 작업함.
	/*
	if(m_nTypePlacingMainRebar_UpperSlab == 2) 
		m_nTypePlacingMainRebar_UpperSlab	= 1;
		*/
	////////////////////////////////////////////////////////////////

	SetDataDefaultDistLeftDirPlacing(bHunch);


	CTwinVectorArray tvArrHiddenAngLeftTmp, tvArrHiddenAngRightTmp, tvArrHiddenOrgTmp;

	BOOL bVertDir	= IsVertDir();
	BOOL bExtLine	= IsExtLine();
	
	CLineInfoApp *pLineBase		= static_cast<CLineInfoApp*>(GetLineBase(bVertDir));
	CLineInfoApp *pLineLeft		= static_cast<CLineInfoApp*>(GetLineLeftRight(TRUE));
	CLineInfoApp *pLineRight	= static_cast<CLineInfoApp*>(GetLineLeftRight(FALSE));
	double dDistMid				= GetDistMidOfSlab(GetStationByTarget(BRIDGE_OFF_STT_SLAB, 0, FALSE), FALSE, FALSE);

	// 배근에 필요한 rebarinfocycle 고름
	long upper	= bUpper ? iUPPER : iLOWER;
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC	= &m_pArrRCMainUpperSlab[nCycle==-1?0:nCycle][upper][nDan];

	// 
	long nTypePlacing	= m_nTypePlacingMainRebar_UpperSlab;
	if(bHunch)
	{
		pArrRC	= &m_pArrRCMainUpperSlabHunch[nCycle==-1?0:nCycle];
		upper	= iLOWER;
	}
	else if(bSttBracket)
	{
		pArrRC	= nCycle == -1 || nCycle == 0 ? &m_pArrRCMainOutWallBracket_Cycle1[iSTT] : &m_pArrRCMainOutWallBracket_Cycle2[iSTT];
		upper	= iLOWER;
		nTypePlacing	= 1;
	}
	else if(bEndBracket)
	{
		pArrRC	= nCycle == -1 || nCycle == 0 ? &m_pArrRCMainOutWallBracket_Cycle1[iEND] : &m_pArrRCMainOutWallBracket_Cycle2[iEND];
		upper	= iLOWER;
		nTypePlacing	= 1;
	}

	long nSize	= pArrRC->GetSize();
	if(nSize == 0) return;
	if(nIdx != -1 && nIdx >= nSize) return;
	long nIdxStt	= nIdx == -1 ? 0 : nIdx;
	long nIdxEnd	= nIdx == -1 ? nSize : nIdx+1;


	// 철근들어가는 평면 좌표들 ////////
	CTwinVectorArray tvArrStt[2];
	CTwinVectorArray tvArrSttRebar[2];
	CTwinVectorArray tvArrLeft[2];

	CTwinVector tv;
	long i = 0; for(i = 0; i < tvArrPlane.GetSize(); i++)
	{
		tv	= tvArrPlane.GetAt(i);
		if(tv.m_sInfo == "시점") tvArrStt[iSTT].Add(tv);
		else if(tv.m_sInfo == "종점") tvArrStt[iEND].Add(tv);
	}
	for(i = 0; i < tvArrPlane.GetSize(); i++)
	{
		tv	= tvArrPlane.GetAt(i);
		if(tv.m_sInfo == "좌측") tvArrLeft[iLEFT].Add(tv);
		else if(tv.m_sInfo == "우측") tvArrLeft[iRIGHT].Add(tv);
	}

	for(i = 0; i < tvArrPlaneRebar.GetSize(); i++)
	{
		tv	= tvArrPlaneRebar.GetAt(i);
		if(tv.m_sInfo == "시점") tvArrSttRebar[iSTT].Add(tv);
		else if(tv.m_sInfo == "종점") tvArrSttRebar[iEND].Add(tv);
	}

	// 사보강 배근시 시점과 종점의 각도가 다를 경우 종점철근의 끝을 늘려주기 위한 기준점 잡기.
	tvArrStt[iSTT].Sort();
	tvArrStt[iEND].Sort();
	tvArrSttRebar[iSTT].Sort();
	tvArrSttRebar[iEND].Sort();
	CTwinVector tvStt, tvEnd;
	CTwinVector tvSttRebar, tvEndRebar;
	tvStt.m_v1	= tvArrStt[iSTT].GetAt(0).m_v1;
	tvStt.m_v2	= tvArrStt[iSTT].GetAt(tvArrStt[iSTT].GetSize()-1).m_v2;
	tvEnd.m_v1	= tvArrStt[iEND].GetAt(0).m_v1;
	tvEnd.m_v2	= tvArrStt[iEND].GetAt(tvArrStt[iEND].GetSize()-1).m_v2;
	tvSttRebar.m_v1	= tvArrSttRebar[iSTT].GetAt(0).m_v1;
	tvSttRebar.m_v2	= tvArrSttRebar[iSTT].GetAt(tvArrSttRebar[iSTT].GetSize()-1).m_v2;
	tvEndRebar.m_v1	= tvArrSttRebar[iEND].GetAt(0).m_v1;
	tvEndRebar.m_v2	= tvArrSttRebar[iEND].GetAt(tvArrSttRebar[iEND].GetSize()-1).m_v2;
	

	CDPoint xyMatch1(0, 0), xyMatch2(0, 0);
	GetXyMatchLineAndLine(tvStt.m_v1, tvStt.GetXyDir(), tvEnd.m_v1, tvEnd.GetXyDir().Rotate90(), xyMatch1);
	GetXyMatchLineAndLine(tvStt.m_v1, tvStt.GetXyDir(), tvEnd.m_v2, tvEnd.GetXyDir().Rotate90(), xyMatch2);

	CDPoint xyEnd1	= tvEndRebar.m_v1;
	CDPoint xyEnd2	= tvEndRebar.m_v2;
	CDPoint xyEndLeft	= xyEnd1;
	//////////////////////////////////////

	CTwinVectorArray tvArrCenter;
	GetTvCenterPlane_UpperSlab(tvArrCenter, TRUE, TRUE , 0, IsVertDir());




	// rebarinfocycle들의 끝 좌표를 offset함.
	// 1,3 사이클은 이음이 없는 부분은 그냥 직각방향으로 offset하고
	// 이음이 있는 부분은 이음위치를 offset하고 거기서 이음 길이만큼 더 증가시킴
	
	// 2,4 사이클은 시작과 끝은 좌우측 offset한 다음 철근 길이를 줘서 좌표를 구하고, 
	// 나머지는 각 지점위치에서 각 지점 각도방향으로 offset을 한다.
	CRebarPlacing rb;
	CRebarInfoCycle *pRC		= NULL;
	CRebarInfoCycle *pRCNext	= NULL;
	CRebarInfoCycle *pRCPrev	= NULL;
	CDPointArray xyArrStt, xyArrEnd, xyArrTmp;
	static CDoubleArray dArrSttOrg, dArrEndOrg, dArrTmp;
	static CDoubleArray dArrSttAng, dArrEndAng;
	double	dStaStt	= 0,
			dStaEnd	= 0,
			dAngStt	= 90,
			dAngEnd	= 90;
	double dStaSttParalOfHunch	= 0;	// 헌치일 경우 수평인 스테이션의 시작(수평구간은 최대 한곳밖에 없으므로 수평구간을 파악함)
	double dStaEndParalOfHunch	= 0;	// 헌치일 경우 수평인 스테이션의 끝(수평구간은 최대 한곳밖에 없으므로 수평구간을 파악함)

	dArrSttOrg.RemoveAll();
	dArrEndOrg.RemoveAll();
	dArrTmp.RemoveAll();
	dArrSttAng.RemoveAll();
	dArrEndAng.RemoveAll();
			
	double dStaSttNext	= 0;
	double dStaEndPrev	= 0;
	tv.m_v1.z	= 3;
	tv.m_v1.y	= 90;
	tv.m_v2.y	= 90;
	for(long rc = nIdxStt; rc < nIdxEnd; rc++)
	{
		pRC		= pArrRC->GetAt(rc);
		if(!pRC->m_bExist) continue;
		pRCNext	= rc < nSize-1 ? pArrRC->GetAt(rc+1) : NULL;
		if(pRCNext)
		{
			if(!pRCNext->m_bExist)
				pRCNext	= NULL;
		}
		pRCPrev	= rc > 0 ? pArrRC->GetAt(rc-1) : NULL;

		// 철근이 들어가는 sta //////////////////////////////////////
		if(pRC->m_bUseTvArrRebar) 	// 기둥식 벽체 위 헌치철근은 tvArr로 구성되어 있다.
		{
			dStaStt	= pRC->m_tvArrRebar.GetXyLeft().x;
			dStaEnd	= pRC->m_tvArrRebar.GetXyRight().x;

			//
			if(bHunch)
			{
				BOOL bHunchRebarV	= FALSE;
				long nType	= GetTypeMainRebarSlabUpperHunch(pRC->m_nPosHunch);

				long nJ	= pRC->m_nPosHunch;
				CWallApp *pWall	= GetInWall(nJ-1);
				if(pWall) bHunchRebarV	= pWall->m_bTopIsColumn;
					
				// V형일때만 수평구간이 있다.
				if((bHunchRebarV || nType == 1) && pRC->m_tvArrRebar.GetSize() > 1)
				{
					CTwinVector tvParal	= pRC->m_tvArrRebar.GetAt(1);
					dStaSttParalOfHunch	= tvParal.m_v1.x;
					dStaEndParalOfHunch	= tvParal.m_v2.x;
					if(dStaSttParalOfHunch > dStaEndParalOfHunch)
						GetSwap(dStaSttParalOfHunch, dStaEndParalOfHunch);
				}
			}

			dStaSttNext	= pRCNext ? pRCNext->m_tvArrRebar.GetXyLeft().x : dStaEnd;
			dStaEndPrev	= pRCPrev ? pRCPrev->m_tvArrRebar.GetXyRight().x : dStaEnd;
		}
		else
		{
			if(pRC->m_nPosStt == pRC->m_nPosEnd)
			{
				dStaStt	= pRC->m_xyStt.x;
				dStaEnd	= pRC->m_xyMid1.x;

				dStaSttNext	= pRCNext ? pRCNext->m_xyStt.x : dStaEnd;
				dStaEndPrev	= pRCPrev ? pRCPrev->m_xyMid1.x : dStaEnd;
			}
			else
			{
				BOOL bSttRebar	= TRUE;
				if(IsMainRebarJointUpperSlabAndOutWall(pRC, bSttRebar))
				{
					dStaStt	= bSttRebar ? pRC->m_xyMid2.x : pRC->m_xyStt.x;
					dStaEnd	= bSttRebar ? pRC->m_xyEndExt.x : pRC->m_xyMid2.x;
				}
				else if(IsMainRebarJointUpperSlabAndUpperSlab(pRC))
				{
					dStaStt	= pRC->m_xyStt.x;
					dStaEnd	= pRC->m_xyEndExt.x;
				}
				else
				{
					dStaStt	= pRC->m_xyStt.x;
					dStaEnd	= pRC->m_xyEnd.x;
					if(!bUpper && IsBlockOut(TRUE) && pRC->m_nPosStt == REBARINFO_POS_UPPERSLAB_SIDE && pRC->m_nPosEnd == REBARINFO_POS_UPPERSLAB_LOWER)
					{
						dStaStt	= pRC->m_xyMid1.x;
					}
					else if(!bUpper && IsBlockOut(FALSE) && pRC->m_nPosStt == REBARINFO_POS_UPPERSLAB_LOWER && pRC->m_nPosEnd == REBARINFO_POS_UPPERSLAB_SIDE)
					{
						dStaEnd	= pRC->m_xyMid2.x;
					}
				}

				if(IsMainRebarJointUpperSlabAndOutWall(pRCNext, bSttRebar))
				{
					dStaSttNext	= pRCNext ? (bSttRebar ? pRCNext->m_xyMid2.x : pRCNext->m_xyStt.x) : dStaEnd;
				}
// 				else if(IsMainRebarJointUpperSlabAndUpperSlab(pRCNext))	// 사실 이 부분은 안 쓰임.
// 				{
// 					dStaSttNext	= pRCNext ? pRCNext->m_xyStt.x : dStaEnd;
// 				}
				else
				{
					dStaSttNext	= pRCNext ? pRCNext->m_xyStt.x : dStaEnd;
				}

				if(IsMainRebarJointUpperSlabAndOutWall(pRCPrev, bSttRebar))
				{
					dStaEndPrev	= pRCPrev ? (bSttRebar ? pRCPrev->m_xyEndExt.x : pRCPrev->m_xyMid2.x) : dStaEnd;
				}
				else if(IsMainRebarJointUpperSlabAndUpperSlab(pRCPrev))	// 사실 이 부분은 안 쓰임.
				{
					dStaEndPrev	= pRCPrev ? pRC->m_xyEndExt.x : dStaEnd;
				}
				else
				{
					dStaEndPrev	= pRCPrev ? pRCPrev->m_xyEnd.x : dStaEnd;
				}
			}
		}
		////////////////////////////////////////////////////////////////

				
		// 이음길이 : 다음 철근이 이번 철근과 겹치는 경우에만 있다.
		double dLenJoint	= dStaEnd - dStaSttNext;
		
		// 이전 철근과의 이음길이
		// 있을 수도 있고 없을 수도 있음
		// 사보강 절반 배치시 직방향 절단되는 철근이 이전 이음보다 짧아질경우 철근을 없애 버리기 위함.
		double dLenJointPrev	= rc > 0 && pRCPrev->m_bExist ? dStaEndPrev - dStaStt : 0;
	
		
		BOOL bJoint			= dLenJoint > 0 ? TRUE : FALSE;
		BOOL bJointPrev		= dLenJointPrev > 0 ? TRUE : FALSE;
		
		// 기준sta에서의 주철근 간격
		// 선형방향일땐 시점기준으로 하고, 사보강일댄 구체 시작sta을 기준으로 한다.
		CDPoint vAng(0, 1);

		// 직철근밎 선형방향 배치용 간격
		// 확폭 지원은 안되므로 처음 철근일 경우 한번만 구해 주면 된다.
		// 단, 사보강배치인 경우, 중심선형 좌우측 모두 구해야 된다.
		// 그런후 상하면에 따라 잘라내는 방식으로 함.
		if(rc == nIdxStt/* && bCalDistRebarMain*/)
		{
			if(bHunch && IsHunchRebarPlane((dStaStt+dStaEnd)/2))
			{
				// 시,종점 지점에서는 헌치부만이 아닌 슬래브하면과 동일하게 배근되어 들어간다. 
				// 철근 마킹하는 부분에는 => 같이 변경되어 있어서 맞춰 준다. (39755) 시종점 현치도 헌치 거리 고려...
				//if(pRC->m_nPosHunch == 0 || pRC->m_nPosHunch == m_nQtyJigan)
				//	dArrSttOrg	= m_dArrDist_RebarMain_Plane[nCycle][nDan][upper][0];
				//else
				dArrSttOrg	= m_dArrDist_RebarMain_PlaneHunch[nCycle][0];

				// 사철근용 간격 (피복을 맞춰줌)
				if(bVertDir || bExtLine)
				{
					//if(pRC->m_nPosHunch == 0 || pRC->m_nPosHunch == m_nQtyJigan)
					//	dArrSttAng	= m_dArrDist_RebarMain_Plane[nCycle][nDan][upper][1];
					//else
					dArrSttAng	= m_dArrDist_RebarMain_PlaneHunch[nCycle][1];
				}
			}
			else
			{
				dArrSttOrg	= m_dArrDist_RebarMain_Plane[nCycle][nDan][upper][0];

				// 사철근용 간격 (피복을 맞춰줌)
				if(bVertDir || bExtLine)
				{
					dArrSttAng	= m_dArrDist_RebarMain_Plane[nCycle][nDan][upper][1];
				}
			}
		}

		// 사보강배치일 경우 시점0을 기준으로하는 직방향 선형을 사용하기 때문에 실제로 그려진 종단면상의 철근에서일부 수정이 있어야 함.
		// 철근배치를 하기 위해선 직방향용 선형의 sta으로 변경
		if(bVertDir)
		{
 			double dDiff	= m_dStationBridgeStt;
			dStaStt			-= dDiff;
			dStaEnd			-= dDiff;

			dStaSttParalOfHunch	-= dDiff;
			dStaEndParalOfHunch	-= dDiff;

			// 중심선형을 기준으로 그려지지 않는 철근들..(브라켓,헌치)은
			// 철근의 sta에서의 기준선형과 수직선형과의 차이를 dist정보에서 보완을 해 주어야 한다.
			if(bSttBracket || bEndBracket)
			{
				CDPoint xyMidVert	= pLineBase->GetXyLineByLengthAndAngle(dStaStt, 0, CDPoint(0, 1));
				CDPointArray xyArrMatch;
				CTwinVectorArray tvArrCenter;
				GetTvCenterPlane_UpperSlab(tvArrCenter, FALSE, TRUE, 0, FALSE);
				rb.GetXyMatchTvArrAndLine(tvArrCenter, xyMidVert, GetAngleJijum(0), xyArrMatch);
				if(xyArrMatch.GetSize() > 0)
				{
					CDPoint xyMatch	= xyArrMatch.GetAt(0);
					double dDist	= ~(xyMatch - xyMidVert);
					long i = 0; for(i = 0; i < dArrSttOrg.GetSize(); i++)
						dArrSttOrg.SetAt(i, dArrSttOrg[i]-dDist);
					
					for(i = 0; i < dArrEndOrg.GetSize(); i++)
						dArrEndOrg.SetAt(i, dArrEndOrg[i]-dDist);

					for(i = 0; i < dArrSttAng.GetSize(); i++)
						dArrSttAng.SetAt(i, dArrSttAng[i]-dDist);
					
					for(i = 0; i < dArrEndAng.GetSize(); i++)
						dArrEndAng.SetAt(i, dArrEndAng[i]-dDist);
				}
			}
		}

		

		
		// 배근되는 각도 설정 ////////////////////////////////////////////////
		if(bHunch || bSttBracket || bEndBracket)	// 헌치,브라켓철근의 경우 각 지점의 각도를 따라서 배근된다.
		{
			dAngStt	= 90;
			dAngEnd	= 90;

			// 현재 헌치철근의 지점 번호를 알아야 됨.
			long nJ	= pRC->m_nPosHunch;
			if(bHunch)
				nJ	= pRC->m_nPosHunch;
			else if(bSttBracket)
				nJ	= 0;
			else if(bEndBracket)
				nJ	= m_nQtyJigan;

			if(nJ > -1)
			{
				CDPoint xyDir	= GetAngleJijum(nJ, bVertDir);
				dAngStt	= xyDir.GetAngleDegree();
				dAngEnd	= xyDir.GetAngleDegree();
			}
		}
		else
		{
			// 시종점이 아닌 철근은 중심sta이가장 가까운 지점의 각도를 따라간다.
			long nNearestJijumStt	= GetJijumNumberByStation(dStaStt);
			long nNearestJijumEnd	= GetJijumNumberByStation(dStaEnd);
			dAngStt		= GetAngleJijum(nNearestJijumStt).GetAngleDegree();
			dAngEnd		= GetAngleJijum(nNearestJijumEnd).GetAngleDegree();
			if(dStaStt < m_dStationBridgeStt)
				dAngStt	= GetAngleByTarget(BRIDGE_OFF_STT_SLABCOVER, 0).GetAngleDegree();
			if(dStaEnd > m_dStationBridgeStt + m_dLengthBridge)
				dAngEnd	= GetAngleByTarget(BRIDGE_OFF_END_SLABCOVER, 0).GetAngleDegree();
		}

		if(bVertDir)
		{
			dAngStt	= 90;
			dAngEnd	= 90;
		}

		// 구해진 간격들을 tvArr에 보관
		// 주철근 배치 방법에 따라서 여러가지로 보관될 수가 있다.
		// m_nTypePlacingMainRebar_UpperSlab 
		// 0 : 일반 선형방향
		// 1 : 사보강배치(전체)
		// 2 : 사보강배치(절반)
		// 1, 2의 배치는 선형이 곡선일 경우 매우 이상하게 나올 수 있다.. 주의해서 사용바람 

		// 시점과 종점라인에 교차되는 철근은 옵션에 따라 사방향 철근으로 빼던지, 그냥 배근하던지 한다. ///
		// 그래서 시종점 라인을 구함. 
		
// 		double dStaMid		= GetStationBridgeStt(bVertDir)+GetLengthBridge(bVertDir)/2;
//		double dStaOrg		= GetStationBridgeStt(bVertDir);
		// 사보강 배치일 경우 사방향 철근 구간을 정확히 판단하기 위해서 시점벽체를 기준으로 배근한다.
		if(bVertDir)
		{
// 			dStaMid			= dStaOrg;
			if(IsOutWall(TRUE))
			{
//				dStaMid	-= m_dWS;
//				dStaOrg	-= m_dWS;
			}
		}

		CDPoint xyDirLeft	= GetXyDirRebarMainPlaneForSabogang(-1);
		CDPoint xyDirRight	= GetXyDirRebarMainPlaneForSabogang(1);

		CDPointArray xyArrMatch[2];
		CTwinVector tv;
		///////////////////////////////////////////////////////////////////////////////////////////////////

		CTwinVector tvHidden;
		double dLenRound		= bUpper ? fabs(pRC->m_xyMid1.x-pRC->m_xyMid2.x) : 0;
		double dStaSttSolid		= dStaStt;
		double dStaEndSolid		= dStaEnd;
		double dStaSttHidden	= dStaStt;
		double dStaEndHidden	= dStaStt;
		double dStaSttHidden2	= dStaStt;	// 상부슬래브 일체형 철근일 경우만 생길 수 있다. 양쪽에 점선.
		double dStaEndHidden2	= dStaStt;	// 상부슬래브 일체형 철근일 경우만 생길 수 있다. 양쪽에 점선.
		// 원래 sta를 변경하지 않는건 일단 좌표를 구하면 외곽선과 교차점 체크를 해야 되기 때문에 
		// 일단 그냥 구하고, bForDrawing일때는 교차점까지 체크후 다시 구한다.
		if(bForDrawing)
		{
			if(rc == 0)
			{
				dStaSttSolid	= dStaSttSolid + dLenRound;
				dStaEndHidden	= dStaSttSolid;

				if(IsMainRebarJointUpperSlabAndUpperSlab(pRC))
				{
					dStaEndHidden2	= dStaEndSolid;
					dStaSttHidden2	= dStaEndSolid - dLenRound;
					dStaEndSolid	= dStaSttHidden2;
				}
			}
			else if(rc == nSize-1)
			{
				dStaEndSolid	= dStaEndSolid - dLenRound;
				dStaSttHidden	= dStaEndSolid;
				dStaEndHidden	= dStaEnd;
			}
			else
			{
				dStaEndHidden	= dStaSttHidden;
			}
		}

		double dStaSttTmp	= dStaStt;
		double dStaEndTmp	= dStaEnd;
		double dAngSttTmp	= dAngStt;
		double dAngEndTmp	= dAngEnd;
		double dStaSttSolidTmp	= dStaSttSolid;
		double dStaEndSolidTmp	= dStaEndSolid;
		double dStaSttHiddenTmp	= dStaSttHidden;
		double dStaEndHiddenTmp	= dStaEndHidden;
		double dStaSttHiddenTmp2	= dStaSttHidden2;
		double dStaEndHiddenTmp2	= dStaEndHidden2;
		double dStaSttParalOfHunchTmp	= dStaSttParalOfHunch;
		double dStaEndParalOfHunchTmp	= dStaEndParalOfHunch;

		dAngStt	= 90;
		dAngEnd	= 90;

		CDPoint vAngStt				= GetAngleByTarget(BRIDGE_OFF_STT_SLAB, 0); //GetAngleJijum(0);
		double dStaTmp				= IsOutWall(TRUE) ? m_dStationBridgeStt - m_dWS/vAngStt.y : m_dStationBridgeStt;
		double dDistLeft			= -(dDistMid + GetWidthSlabAct(dStaTmp, vAngStt, -1));
		double dDistRight			= GetWidthSlabAct(dStaTmp, vAngStt, 1) - dDistMid;
		double dDistLeftAngleRebar	= m_dDistLeftDirPlacing;
		double dDistRightAngleRebar	= m_dDistRightDirPlacing;
		double dDistDiff			= GetDistDiffOfMidInVert();// 사보강일경우 기준sta에서의 직방향중심과 선형방향 중심의 차이를 알아야 된다.

		// 폭이 가장 큰 스테이션(사보강시 직방향 철근은 폭이 가장 큰 것을 기준으로 한다)
		double dStaTmpBigestL			= GetStationSmallestWidthOfUpperSlab(TRUE, -1);
		double dStaTmpBigestR			= IsExtLine() ? GetStationSmallestWidthOfUpperSlab(TRUE, 1) : dStaTmpBigestL;
		double dDistLeftBigest			= -(dDistMid + GetWidthSlabAct(dStaTmpBigestL, vAngStt, -1));
		double dDistRightBigest			= GetWidthSlabAct(dStaTmpBigestR, vAngStt, 1) - dDistMid;
		double dDistLeftMaxBigest		= dDistLeftBigest;	// 횡단면 최대 길이
		double dDistRightMaxBigest		= dDistRightBigest;	// 횡단면 최대길이

		double dStaMax_L		= GetStationSmallestWidthOfUpperSlab(TRUE, -1);
		double dStaMax_R		= GetStationSmallestWidthOfUpperSlab(TRUE, +1);
		double dWidEnd_L		= GetWidthSlabAct(dStaMax_L, CDPoint(0, 1), -1, FALSE, FALSE, FALSE);
		double dWidEnd_R		= GetWidthSlabAct(dStaMax_R, CDPoint(0, 1), +1, FALSE, FALSE, FALSE);
		double dMaxWid = fabs(dWidEnd_R) + fabs(dWidEnd_L);

		if(bVertDir)	// 사보강인 경우 횡단면 최대길이 구해줌
		{
			long nOldTypePlacingMainRebar	= m_nTypePlacingMainRebar_UpperSlab;
			double dOldDistLeftDirPlacing	= m_dDistLeftDirPlacing;
			double dOldDistRightDirPlacing	= m_dDistRightDirPlacing;

			m_nTypePlacingMainRebar_UpperSlab	= 1;
			SetDataDefaultDistLeftDirPlacing();

			double dAng	= GetAngleJijum(0).GetAngleDegree();
			if(dAng < 90)
			{
				dDistLeftMaxBigest -= m_dDistLeftDirPlacing;
			}
			if(dAng > 90)
			{
				dDistRightMaxBigest += m_dDistRightDirPlacing;
			}

			m_nTypePlacingMainRebar_UpperSlab	= nOldTypePlacingMainRebar;
			m_dDistLeftDirPlacing				= dOldDistLeftDirPlacing;
			m_dDistRightDirPlacing				= dOldDistRightDirPlacing;
		}

		CTwinVector tvTmp;
		double dDiffRad	= 0;	// 사보강인데 시점과 종점이 각도가 다른 경우를 대비해서 미리 구해둠
		if(bVertDir)
		{
			double dAngSttJi	= GetAngleJijum(0, TRUE).GetAngleDegree();
			double dAngEndJi	= GetAngleJijum(m_nQtyJigan, TRUE).GetAngleDegree();
			dDiffRad	= ToRadian(90 - (dAngSttJi - dAngEndJi));
		}

		// 혹시나 사방향 철근이 겹체게 되는 경우를 판단 //////////////////
		double dWMax	= GetWidthSlabAct(m_dStationBridgeStt, GetAngleJijum(0), 0);
		if(dDistLeftAngleRebar + dDistRightAngleRebar > dWMax)
		{
			dDistLeftAngleRebar		= dWMax/2;
			dDistRightAngleRebar	= dWMax/2;
		}

		//////////////////////////////////////////////////////////////////////

		// 사보강 배치일 경우 직방향 철근이 들어가는 범위를 구한다.
		double dDistLeftRangeVertRebar	= 0;
		double dDistRightRangeVertRebar	= 0;
		if(bVertDir)
		{
			GetTvSttEndOfSlab(tvStt, tvEnd);

			if(m_nTypePlacingMainRebar_UpperSlab == 1)
			{
				dDistLeftRangeVertRebar		= max(pLineBase->GetDisMatchVerticalByXy(tvStt.m_v2), pLineBase->GetDisMatchVerticalByXy(tvEnd.m_v2));
				dDistRightRangeVertRebar	= min(pLineBase->GetDisMatchVerticalByXy(tvStt.m_v1), pLineBase->GetDisMatchVerticalByXy(tvEnd.m_v1));
			}
			else if(m_nTypePlacingMainRebar_UpperSlab == 2)
			{
				dDistLeftRangeVertRebar		= min(pLineBase->GetDisMatchVerticalByXy(tvStt.m_v2), pLineBase->GetDisMatchVerticalByXy(tvEnd.m_v2)) + m_dDistLeftDirPlacing;
				dDistRightRangeVertRebar	= max(pLineBase->GetDisMatchVerticalByXy(tvStt.m_v1), pLineBase->GetDisMatchVerticalByXy(tvEnd.m_v1)) - m_dDistRightDirPlacing;
			}
		}

		// 가각 있고 전체사보강이면 dDist를 최대로 넓힌다.
		// 단 직방향 철근을 뻗어서 가각의 어느 부분이라도 닿으면 배근하지 않음
		
		if(m_nTypePlacingMainRebar_UpperSlab == 1)
		{
			// 우측 거리 조정
			double dDiff	= GetDiffLeftRightDistForGagakSabogang(TRUE, FALSE);
			if(dDiff > 0)
			{
				dDistRightRangeVertRebar += dDiff;
				m_dDistRightDirPlacing	-= dDiff;
				dDistRightAngleRebar	-= dDiff;
			}
			// 좌측 거리 조정
			dDiff	= GetDiffLeftRightDistForGagakSabogang(FALSE, TRUE);
			if(dDiff > 0)
			{
				dDistLeftRangeVertRebar += dDiff;
				m_dDistLeftDirPlacing -= dDiff;
				dDistLeftAngleRebar	-= dDiff;
			}
			// 좌측 거리 조정
			dDiff	= GetDiffLeftRightDistForGagakSabogang(TRUE, TRUE);
			if(dDiff > 0)
			{
				dDistLeftRangeVertRebar += dDiff;
				m_dDistLeftDirPlacing -= dDiff;
				dDistLeftAngleRebar	-= dDiff;
			}
			// 우측 거리 조정
			dDiff	= GetDiffLeftRightDistForGagakSabogang(FALSE, FALSE);
			if(dDiff > 0)
			{
				dDistRightRangeVertRebar += dDiff;
				m_dDistRightDirPlacing -= dDiff;
				dDistRightAngleRebar -= dDiff;
			}
		}
		
		static BOOL bLeftDeleteNextRebar	= TRUE;
		static BOOL bDeleteNextRebar		= FALSE;
		
		
		// 모든 철근이 필요한건 아니지만, 
		// 헌치 철근의 경우 경사진부분과 수평부분의 철근이 실제 1개이면서 2개나 3개로 나눠져서 보관된다.
		// 따라서 철근집계시 개수파악에 문제가 있기 때문에 
		// 같은 철근임을 알려주는 인덱스를 달아주자.
		// m_sInfoVer에 달아줌.
		

		// 사보강 배치일때만 사용함.
		CTwinVectorArray tvArrCenterVert;
		GetTvCenterPlane_UpperSlab(tvArrCenterVert, FALSE, TRUE, 0, TRUE);
		CTwinVector tvCenVert;
		if(tvArrCenterVert.GetSize() > 0)
			tvCenVert	= tvArrCenterVert.GetAt(0);

		if(dArrSttOrg.GetSize() > 0)// == dArrEndOrg.GetSize())
		{
			// 사보강배치(절반)인 경우 직철근의 범위에 드는지 검사하기 위함. /////
			// 1. 직철근을 뻣어서 시점에 교차되는 경우
			//   - 왼쪽에 포함되는지 오른쪽에 포함되는지 판단
			//   - 포함되는 좌우측에 교차점을 찾아서 교차점과 종점과의 거리가 dLenLeft/2보다 작은 경우 철근생성
			// 2. 직철근을 뻣어서 종점에 교차되는 경우
			//   - 위의 경우와 반대로 체크
			CDPoint xyMatch(0, 0);
			double dLenLefft	= ~(tvStt.m_v2 - tvEnd.m_v2);
			double dLenRight	= ~(tvStt.m_v1 - tvEnd.m_v1);
			//////////////////////////////////////////////////////////////////////
			


			
			double dOffsetAng	= 0;	// 사철근 배치용 거리
			long nSizeArr		= dArrSttOrg.GetSize();
			double dDistCen		= bVertDir ? 0 : GetDistMidOfSlab(m_dStationBridgeStt-m_dWS, TRUE, FALSE);
			// 사보강 배치시 사방향 철근은 직방향 철근 간격보다 적을 수 잇다.
			// (ARCBRIDGE-2661) 사보강 배치에의한 사보강은 중간(MID)를 기준으로 좌우를 나누지만 확폭에 의한 사보강이라면
			// 확폭에의한 넓이를 고려해야한다.
			BOOL bSttAngForVert	= TRUE;
			double dMid	= 0;
			if(bVertDir)
			{
				dMid	= GetMidCrossSection(FALSE) + dDistDiff;
			}
			else
			{
				// 우측 확폭의 넓이를 기준으로 좌우 분할 위치를 정해주자.
				double dWidLine =  GetMaxDiffWidthByExtLine(FALSE);
				if(IsExtLine() && Compare(dWidLine*2, dMaxWid, _T("<"),0.1))
					dMid	= dDistCen - dWidLine*2;
				else
					dMid = dWidLine + dDistCen;
			}
			
			long nIdx	= 0;	

			long i = 0;
			static long nIdxDeleteNextRebarRC	= 0;

			for(i = 0; i < nSizeArr; i++)
			{
				double dOffsetOrg	= 0;	// 직철근 및 선형방향 철근배치용 거리
				dOffsetOrg		= dArrSttOrg.GetAt(i);
				if(dArrSttAng.GetSize() > i)
				{
					bSttAngForVert	= TRUE;
					dOffsetAng		= dArrSttAng.GetAt(i);
				}
				else
					bSttAngForVert	= FALSE;

				
				dOffsetOrg		+= dDistDiff;
				dOffsetAng		+= dDistDiff;

				// dStaSttTmp가 기준위치에서의 철근 시작 Station이고 dStaStt는 dOffsetOrg만큼 dAngSttTmp의 각도로 이동한위치의 Station이다.
				// dOffsetOrg와 dOffsetAng이 다르다면 철근 시작위치를 따로 구해줘야하지 않을까?
				dStaStt			= pLineBase->GetStationByScInLine(dStaSttTmp, dOffsetOrg, ToDPointFrDegree(dAngSttTmp));
				dStaEnd			= pLineBase->GetStationByScInLine(dStaEndTmp, dOffsetOrg, ToDPointFrDegree(dAngEndTmp));
				dStaSttSolid	= pLineBase->GetStationByScInLine(dStaSttSolidTmp, dOffsetOrg, ToDPointFrDegree(dAngSttTmp));
				dStaEndSolid	= pLineBase->GetStationByScInLine(dStaEndSolidTmp, dOffsetOrg, ToDPointFrDegree(dAngEndTmp));

				// Hidden은 주철근의 앞에 생기는지 뒤에 생기는지 판단해서 
				// dAngSttTmp나 dAngEndTmp을 통일해서 사용함
				if(!Compare(dStaSttHiddenTmp, dStaEndHiddenTmp, "="))
				{
					BOOL bStt	= (dStaSttHiddenTmp + dStaEndHiddenTmp)/2 < (dStaSttSolidTmp + dStaEndSolidTmp)/2;
					dStaSttHidden	= pLineBase->GetStationByScInLine(dStaSttHiddenTmp, dOffsetOrg, ToDPointFrDegree(bStt ? dAngSttTmp : dAngEndTmp));
					dStaEndHidden	= pLineBase->GetStationByScInLine(dStaEndHiddenTmp, dOffsetOrg, ToDPointFrDegree(bStt ? dAngSttTmp : dAngEndTmp));
				}
				// Hidden은 주철근의 앞에 생기는지 뒤에 생기는지 판단해서 
				// dAngSttTmp나 dAngEndTmp을 통일해서 사용함
				if(!Compare(dStaSttHiddenTmp2, dStaEndHiddenTmp2, "="))
				{
					BOOL bStt	= (dStaSttHiddenTmp2 + dStaEndHiddenTmp2)/2 < (dStaSttSolidTmp + dStaEndSolidTmp)/2;
					dStaSttHidden2	= pLineBase->GetStationByScInLine(dStaSttHiddenTmp2, dOffsetOrg, ToDPointFrDegree(bStt ? dAngSttTmp : dAngEndTmp));
					dStaEndHidden2	= pLineBase->GetStationByScInLine(dStaEndHiddenTmp2, dOffsetOrg, ToDPointFrDegree(bStt ? dAngSttTmp : dAngEndTmp));
				}
				if(!Compare(dStaSttParalOfHunchTmp, dStaEndParalOfHunchTmp, "="))
				{
					dStaSttParalOfHunch	= pLineBase->GetStationByScInLine(dStaSttParalOfHunchTmp, dOffsetOrg, ToDPointFrDegree(dAngSttTmp));
					dStaEndParalOfHunch	= pLineBase->GetStationByScInLine(dStaEndParalOfHunchTmp, dOffsetOrg, ToDPointFrDegree(dAngEndTmp));
				}

				// 1. 직방향 철근
				// 브라켓이면 무조건 직방향으로 인정
				// dDistMid	0에서 슬래브 중심까지의 거리
				double dDistRealOrg	= dArrSttOrg.GetAt(i);
				double dDistRealAng	= dArrSttAng.GetSize() > i ? dArrSttAng.GetAt(i) : 0;
				dDistRealOrg	-= dDistMid;
				dDistRealAng	-= dDistMid;
				
				// long nDrawLeft에 따라서 필요한 경우에만 진행
				BOOL bDebugging	= FALSE;
				long drawLeft	= dOffsetOrg < dDistCen ? -1 : 1;
				if(drawLeft == nDrawLeft || nDrawLeft == 0 || bVertDir)
				{
					tv.m_sInfoHor.Format("%f", dOffsetOrg);
					tv.m_v1.x	= dStaStt;
					tv.m_v2.x	= dStaEnd;
					tv.m_v2.z	= drawLeft;
					if(bDebugging)
					{
						tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaStt, dOffsetOrg, ToDPointFrDegree(dAngStt));
						tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEnd, dOffsetOrg, ToDPointFrDegree(dAngEnd));
					}

					if(nTypePlacing == 0)
					{
						tv.m_v1.z	= 6;
						tv.m_v1.y	= dOffsetOrg;
						if(bDebugging)
						{
							tv.m_v1.z	= 4;
							tv.m_v2.z	= dOffsetOrg;
						}

						// 그리기 위한 좌표라면 점선부와 실선부를 나눠야 됨
						if(bForDrawing && dLenRound > 0)
						{
							// 실선부 다시 구함
							tv.m_v1.x	= dStaSttSolid;
							tv.m_v2.x	= dStaEndSolid;
							tv.m_v1.z	= 6;
							tv.m_v1.y	= dOffsetOrg;
							if(bDebugging)
							{
								tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaSttSolid, dOffsetOrg, ToDPointFrDegree(dAngStt));
								tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEndSolid, dOffsetOrg, ToDPointFrDegree(dAngEnd));
								tv.m_v1.z	= 4;
								tv.m_v2.z	= dOffsetOrg;
							}
							tv.m_sInfo	= "SOLID";

							tvArr.Add(tv);

							// 점선부 구함
							if(!Compare(dStaSttHidden, dStaEndHidden, "="))
							{
								tv.m_v1.x	= dStaSttHidden;
								tv.m_v2.x	= dStaEndHidden;
								tv.m_v1.z	= 6;
								tv.m_v1.y	= dOffsetOrg;
								if(bDebugging)
								{
									tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaSttHidden, dOffsetOrg, ToDPointFrDegree(dAngStt));
									tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEndHidden, dOffsetOrg, ToDPointFrDegree(dAngEnd));
									tv.m_v1.z	= 4;
									tv.m_v2.z	= dOffsetOrg;
								}
								tv.m_sInfo	= "HIDDEN";
								tvArrHiddenOrgTmp.Add(tv);
							}

							// 점선부2 구함
							if(!Compare(dStaSttHidden2, dStaEndHidden2, "="))
							{
								tv.m_v1.x	= dStaSttHidden2;
								tv.m_v2.x	= dStaEndHidden2;
								tv.m_v1.z	= 6;
								tv.m_v1.y	= dOffsetOrg;
								if(bDebugging)
								{
									tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaSttHidden2, dOffsetOrg, ToDPointFrDegree(dAngStt));
									tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEndHidden2, dOffsetOrg, ToDPointFrDegree(dAngEnd));
									tv.m_v1.z	= 4;
									tv.m_v2.z	= dOffsetOrg;
								}
								tv.m_sInfo	= "HIDDEN";
								tvArrHiddenOrgTmp.Add(tv);
							}

							
						}
						// 그리기 위한 좌표이면서 헌치용이라면 점선부와 실선부를 나눠야 됨.
						else if(bForDrawing && bHunch)
						{
							tv.m_sInfoVer.Format("%d", nIdx++);
							if(Compare(dStaSttParalOfHunch, dStaEndParalOfHunch, "="))
							{
								// 점선부 전체
								tv.m_v1.x	= dStaStt;
								tv.m_v2.x	= dStaEnd;
								tv.m_v1.z	= 6;
								tv.m_v1.y	= dOffsetOrg;
								if(bDebugging)
								{
									tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaStt, dOffsetOrg, ToDPointFrDegree(dAngStt));
									tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEnd, dOffsetOrg, ToDPointFrDegree(dAngEnd));
									tv.m_v1.z	= 4;
									tv.m_v2.z	= dOffsetOrg;
								}
								tv.m_sInfo	= "HIDDEN";
								tvArr.Add(tv);
							}
							else
							{
								// 점선부 첫번째 
								tv.m_v1.x	= dStaStt;
								tv.m_v2.x	= dStaSttParalOfHunch;
								tv.m_v1.z	= 6;
								tv.m_v1.y	= dOffsetOrg;
								if(bDebugging)
								{
									tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaStt, dOffsetOrg, ToDPointFrDegree(dAngStt));
									tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaSttParalOfHunch, dOffsetOrg, ToDPointFrDegree(dAngEnd));
									tv.m_v1.z	= 4;
									tv.m_v2.z	= dOffsetOrg;
								}
								tv.m_sInfo	= "HIDDEN";
								tvArr.Add(tv);

								// 중앙 실선부
								tv.m_v1.x	= dStaSttParalOfHunch;
								tv.m_v2.x	= dStaEndParalOfHunch;
								tv.m_v1.z	= 6;
								tv.m_v1.y	= dOffsetOrg;
								if(bDebugging)
								{
									tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaSttParalOfHunch, dOffsetOrg, ToDPointFrDegree(dAngStt));
									tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEndParalOfHunch, dOffsetOrg, ToDPointFrDegree(dAngEnd));
									tv.m_v1.z	= 4;
									tv.m_v2.z	= dOffsetOrg;
								}
								tv.m_sInfo	= "SOLID";
								tvArr.Add(tv);

								// 점선부 첫번째 
								tv.m_v1.x	= dStaEndParalOfHunch;
								tv.m_v2.x	= dStaEnd;
								tv.m_v1.z	= 6;
								tv.m_v1.y	= dOffsetOrg;
								if(bDebugging)
								{
									tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaEndParalOfHunch, dOffsetOrg, ToDPointFrDegree(dAngStt));
									tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEnd, dOffsetOrg, ToDPointFrDegree(dAngEnd));
									tv.m_v1.z	= 4;
									tv.m_v2.z	= dOffsetOrg;
								}
								tv.m_sInfo	= "HIDDEN";
								tvArr.Add(tv);
							}
						}
						else
						{
							tv.m_sInfo	= "SOLID";
							tvArr.Add(tv);
						}

						// 이음 구함
						if(bJoint)
						{
							dStaStt	= pLineBase->GetStationByScInLine(dStaEndTmp-dLenJoint, dOffsetOrg+m_dGapJoint, ToDPointFrDegree(dAngSttTmp));
							dStaEnd	= pLineBase->GetStationByScInLine(dStaEndTmp, dOffsetOrg+m_dGapJoint, ToDPointFrDegree(dAngEndTmp));

							tv.m_v1.x	= dStaEnd-dLenJoint;
							tv.m_v2.x	= dStaEnd;
							tv.m_v1.z	= 6;
							tv.m_v1.y	= dOffsetOrg+m_dGapJoint;
							if(bDebugging)
							{
								tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaEnd-dLenJoint, (dOffsetOrg+m_dGapJoint), ToDPointFrDegree(dAngStt));
								tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEnd, (dOffsetOrg+m_dGapJoint), ToDPointFrDegree(dAngEnd));
								tv.m_v1.z	= 4;
								tv.m_v2.z	= (dOffsetOrg+m_dGapJoint);
							}
							tv.m_sInfo	= "SOLID";

							tvArrJoint.Add(tv);
						}
					}
					else if(nTypePlacing == 1 || nTypePlacing == 2)	// 사보강 배치
					{
						tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaStt, dOffsetOrg, ToDPointFrDegree(dAngStt));
						tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEnd, dOffsetOrg, ToDPointFrDegree(dAngEnd));
						tv.m_v1.z	= 0;
						tv.m_v2.z	= drawLeft;
						
						// 여기서 m_dDistLeftDirPlacing, m_dDistRightDirPlacing는 직방향 철근에 대해서만 적용
						// 단 사방향 철근은 최대 길이보다 무조건 작게 구한 dDistLeftAngleRebar, dDistRightAngleRebar로 체크함.(휴 복잡다.ㅠㅠ)
						BOOL bOKAll	= (dDistRealOrg > (dDistLeftMaxBigest+m_dDistLeftDirPlacing) && dDistRealOrg < (dDistRightMaxBigest-m_dDistRightDirPlacing)) || bSttBracket || bEndBracket;
						BOOL bOKHalf	= bSttBracket || bEndBracket;
						if(!bOKHalf)
						{
							// 시종점에 한쪽에만 걸리면 일차 통과
							// 모두 걸리면 무조건 통과
							CDPoint xyMatchStt(0, 0), xyMatchEnd(0, 0);
							BOOL bMatchStt	= GetXyMatchSegAndLine(tvStt.m_v1, tvStt.m_v2, tv.m_v1, tv.GetXyDir(), xyMatchStt);
							BOOL bMatchEnd	= GetXyMatchSegAndLine(tvEnd.m_v1, tvEnd.m_v2, tv.m_v1, tv.GetXyDir(), xyMatchEnd);
							if(bMatchStt != bMatchEnd)
							{
								// 좌우측 판단
								BOOL bLeft	= GetDirPointByLine(tv.m_v1, tvCenVert.m_v1, tvCenVert.m_v2);
								CDPoint xyMatchLeft(0, 0), xyMatchRight(0, 0);
								
								GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), tvStt.m_v2, (tvEnd.m_v2 - tvStt.m_v2).Unit(), xyMatchLeft);
								GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), tvStt.m_v1, (tvEnd.m_v1 - tvStt.m_v1).Unit(), xyMatchRight);

								// 
								if(bMatchStt)
								{
									if(bLeft && ~(tvEnd.m_v2 - xyMatchLeft) <= dLenLefft/2)
										bOKHalf	= TRUE;
									else if(!bLeft && ~(tvStt.m_v1 - xyMatchRight) >= dLenRight/2)
										bOKHalf	= TRUE;
								}
								else
								{
									if(bLeft && ~(tvStt.m_v2 - xyMatchLeft) <= dLenLefft/2)
										bOKHalf	= TRUE;
									else if(!bLeft && ~(tvEnd.m_v1 - xyMatchRight) >= dLenRight/2)
										bOKHalf	= TRUE;
								}
							}
							else if(bMatchStt && bMatchEnd)
								bOKHalf	= TRUE;
						}

						if(nTypePlacing == 1 && bOKAll || nTypePlacing == 2 && bOKHalf)
						{
							// 브라켓의 경우 좌우측라인에 교차되지 않을때만 추가
							// 교차된다면 그냥 제낌.
							if(bSttBracket || bEndBracket)
							{

								rb.GetXyMatchTvArrAndSeg(tvArrLeft[iLEFT], tv.m_v1, tv.m_v2, xyArrMatch[iLEFT], FALSE);
								rb.GetXyMatchTvArrAndSeg(tvArrLeft[iRIGHT], tv.m_v1, tv.m_v2, xyArrMatch[iRIGHT], FALSE);
								tv.m_v1.z	= 0;
								if(xyArrMatch[iLEFT].GetSize() == 0 && xyArrMatch[iRIGHT].GetSize() == 0)
									tvArr.Add(tv);
							}
							// 헌치부 그릴때는 점선부 실선부 나눠줌
							else if(bForDrawing && bHunch)
							{
								tv.m_sInfoVer.Format("%d", nIdx++);
								if(Compare(dStaSttParalOfHunch, dStaEndParalOfHunch, "="))
								{
									// 실선부 전체
									tv.m_v1		= pLineBase->GetXyLineByLengthAndAngle(dStaStt, dOffsetOrg, ToDPointFrDegree(dAngStt));
									tv.m_v2		= pLineBase->GetXyLineByLengthAndAngle(dStaEnd, dOffsetOrg, ToDPointFrDegree(dAngEnd));
									tv.m_v1.z	= 0;
									tv.m_sInfo	= "HIDDEN";
									tvArr.Add(tv);							
								}
								else
								{
									// 점선부 앞
									tv.m_v1		= pLineBase->GetXyLineByLengthAndAngle(dStaStt, dOffsetOrg, ToDPointFrDegree(dAngStt));
									tv.m_v2		= pLineBase->GetXyLineByLengthAndAngle(dStaSttParalOfHunch, dOffsetOrg, ToDPointFrDegree(dAngEnd));
									tv.m_v1.z	= 0;
									tv.m_sInfo	= "HIDDEN";
									tvArr.Add(tv);							

									// 실선부 중앙
									tv.m_v1		= pLineBase->GetXyLineByLengthAndAngle(dStaSttParalOfHunch, dOffsetOrg, ToDPointFrDegree(dAngStt));
									tv.m_v2		= pLineBase->GetXyLineByLengthAndAngle(dStaEndParalOfHunch, dOffsetOrg, ToDPointFrDegree(dAngEnd));
									tv.m_v1.z	= 0;
									tv.m_sInfo	= "SOLID";
									tvArr.Add(tv);							

									// 실선부 중앙
									tv.m_v1		= pLineBase->GetXyLineByLengthAndAngle(dStaEndParalOfHunch, dOffsetOrg, ToDPointFrDegree(dAngStt));
									tv.m_v2		= pLineBase->GetXyLineByLengthAndAngle(dStaEnd, dOffsetOrg, ToDPointFrDegree(dAngEnd));
									tv.m_v1.z	= 0;
									tv.m_sInfo	= "HIDDEN";
									tvArr.Add(tv);							
								}
							}
							else	// 사보강배치 슬래브 주철근 그리는 부분
							{
								// 사보강 배치에다가 마지막 철근일 경우
								// 종점 각도가 시점 각도와 달라서 남거나 모자라는 경우가 생길 수 있다.
								// 이 경우를 대비해서 마지막 철근일 때는 종점에 교차점을 찾아서 철근길이에 변화를 준다.(에이 번거로워ㅡㅡ;)
								if(rc == nSize-1)
								{
									double dDiffSta	= Compare(dDiffRad, 1.0, "=") ? 0 : dOffsetOrg / tan(dDiffRad);
									dStaEndSolid -= dDiffSta;
									dStaSttHidden -= dDiffSta;
									dStaEndHidden -= dDiffSta;
									dStaSttHidden2 -= dDiffSta;
									dStaEndHidden2 -= dDiffSta;
								}

								// 실선부 다시 구함
								if(dStaEndSolid > dStaSttSolid)
								{
									tv.m_v1		= pLineBase->GetXyLineByLengthAndAngle(dStaSttSolid, dOffsetOrg, ToDPointFrDegree(dAngStt));
									tv.m_v2		= pLineBase->GetXyLineByLengthAndAngle(dStaEndSolid, dOffsetOrg, ToDPointFrDegree(dAngEnd));
									tv.m_v1.z	= 0;
									tv.m_sInfo	= "SOLID";

									// 철근을 뻗어서 시종점 피복에 교차 되어야 존재(전체일때만)
									CDPoint xyMatch(0, 0);
									BOOL bVert	= TRUE;
									if(m_nTypePlacingMainRebar_UpperSlab == 1)
									{
										if(!GetXyMatchSegAndLine(tvSttRebar.m_v1, tvSttRebar.m_v2, tv.m_v1, tv.GetXyDir(), xyMatch))
											bVert	= FALSE;
										if(!GetXyMatchSegAndLine(tvEndRebar.m_v1, tvEndRebar.m_v2, tv.m_v1, tv.GetXyDir(), xyMatch))
											bVert	= FALSE;
									}
	
									if(bVert)
									{

										tvArr.Add(tv);
										tvTmp	= tv;

										if(!Compare(dStaSttHidden, dStaEndHidden, "="))
										{
											if(dStaSttSolid > dStaSttHidden) tvTmp.m_v2	= tv.m_v2;
											else tvTmp.m_v1	= tv.m_v1;
										}

										// 이음구함
										BOOL bCutJoint	= FALSE;
										if(bJoint)
										{
											double dStaEndJo	= pLineBase->GetStationByScInLine(dStaEndTmp, dOffsetOrg+m_dGapJoint, ToDPointFrDegree(dAngEndTmp));

											tv.m_v1		= pLineBase->GetXyLineByLengthAndAngle(dStaEndJo-dLenJoint, (dOffsetOrg+m_dGapJoint), ToDPointFrDegree(dAngStt));
											tv.m_v2		= pLineBase->GetXyLineByLengthAndAngle(dStaEndJo, (dOffsetOrg+m_dGapJoint), ToDPointFrDegree(dAngEnd));

											// 사보강 배치(절반)에서 이음이 좌우측에 걸리면 존재 여부를 판단함 //////////
											if(m_nTypePlacingMainRebar_UpperSlab == 2)
											{
												CDPointArray xyArrMatch;
												rb.GetXyMatchTvArrAndTv(tvArrPlaneRebar, tv, xyArrMatch, TRUE);
												if(xyArrMatch.GetSize() > 0)
													bCutJoint	= TRUE;
											}

											tv.m_v1.z	= 0;
											tv.m_sInfo	= "SOLID";
											if(!bCutJoint)
												tvArrJoint .Add(tv);
										}

										// 점선부 구함
										if(!Compare(dStaSttHidden, dStaEndHidden, "="))
										{
											CDPoint xy1 = pLineBase->GetXyLine(dStaSttHidden);
											CDPoint xyAng1 = pLineBase->GetAngleAzimuth(dStaSttHidden);
											tv.m_v1		= pLineBase->GetXyLineByLengthAndAngle(dStaSttHidden, dOffsetOrg, ToDPointFrDegree(dAngStt));
											tv.m_v2		= pLineBase->GetXyLineByLengthAndAngle(dStaEndHidden, dOffsetOrg, ToDPointFrDegree(dAngEnd));
											tv.m_v1.z	= 0;
											tv.m_sInfo	= "HIDDEN";
											tvArrHiddenOrgTmp.Add(tv);

											if(dStaSttSolid > dStaSttHidden) tvTmp.m_v1	= tv.m_v1;
											else tvTmp.m_v2	= tv.m_v2;
										}
										if(!Compare(dStaSttHidden2, dStaEndHidden2, "="))
										{
											tv.m_v1		= pLineBase->GetXyLineByLengthAndAngle(dStaSttHidden2, dOffsetOrg, ToDPointFrDegree(dAngStt));
											tv.m_v2		= pLineBase->GetXyLineByLengthAndAngle(dStaEndHidden2, dOffsetOrg, ToDPointFrDegree(dAngEnd));
											tv.m_v1.z	= 0;
											tv.m_sInfo	= "HIDDEN";
											tvArrHiddenOrgTmp.Add(tv);

											tvTmp.m_v2	= tv.m_v2;
										}

										// tvTmp가 좌우측에 교차되는 선이라면 직방향 철근 변화구간에 있는 넘이다.
										// 그럼 tvArr와 tvArrHiddenOrgTmp에서 제거하고 tvArrAngLeftHalf나 tvArrAngRightHalf에 추가해 주자.
										// 대신 나중에 tvArr와 tvArrHiddenOrgTmp, tvArrAngLeftHalf, tvArrAngRightHalf는 외곽을 기준으로 걸러낸 필요가 없다.
										if(m_nTypePlacingMainRebar_UpperSlab == 2)
										{
											if(bDeleteNextRebar && rc > nIdxDeleteNextRebarRC)
												bDeleteNextRebar	= FALSE;

											CTwinVectorArray tvArrTmp;
											tvArrTmp.Add(tvTmp);
											rb.GetTvByCrossTvArrArea(tvArrTmp, tvArrPlane, TRUE, TRUE, FALSE);

											BOOL bCross	= tvArrTmp.GetSize() == 0;
											if(!bCross)
												bCross	= !Compare(tvArrTmp.GetAt(0).GetLength(), tvTmp.GetLength(), "=");
											
											if(bCross || bCutJoint)
											{
												if(tvArr.GetSize() > 0)
													tvArr.RemoveAt(tvArr.GetSize()-1);
												if(tvArrHiddenOrgTmp.GetSize() > 0)
													tvArrHiddenOrgTmp.RemoveAt(tvArrHiddenOrgTmp.GetSize()-1);
												if(tvArrTmp.GetSize() > 0)
												{
													static long nIdxDeleteNextRebar		= 0;

													BOOL bDelete	= FALSE;
													if(bDeleteNextRebar && rc == nIdxDeleteNextRebarRC)
													{
														if(bLeftDeleteNextRebar)
														{
															bDelete	= nIdxDeleteNextRebar >= i;
														}
														else
														{
															bDelete = nIdxDeleteNextRebar <= i;
														}
													}

													// 이음이 걸리는 철근 중 슬래브 밖에서 시작하는 철근은 완전히 제거
													// 단, 슬래브 안에서 시작하는 철근은 다음 철근이 제거 된다.
													if(bCutJoint)
													{
														if(rb.CheckXyByTvArrayArea(tvTmp.m_v1, tvArrPlaneRebar, FALSE))
														{
															bDeleteNextRebar	= FALSE;
															bDelete				= TRUE;
														}
														else
														{
															// 다음 철근이 이 시점에서 제거 되야 됨을 미리 알려줌.
															if(!bDeleteNextRebar)
															{
																bLeftDeleteNextRebar	= dOffsetOrg < dDistCen;	
																bDeleteNextRebar		= TRUE;
																nIdxDeleteNextRebar		= i;
																nIdxDeleteNextRebarRC	= rc+1;
															}
														}
													}

													if(!bDelete)
													{
														tvTmp	= tvArrTmp.GetAt(0);
														// 두개로 나눠진 경우 가각이 아닌 부분에 포함된 철근을 선택한다.
														BOOL bRemoveRebar	= FALSE;
														if(m_bIsExp)
														{
															double dSta1(0), dSta2(0);
															CLineInfo *pLineOrg	= GetLineBase();
															pLineOrg->GetStationMatchVerticalByXy(tvTmp.m_v1, dSta1);
															pLineOrg->GetStationMatchVerticalByXy(tvTmp.m_v2, dSta2);
															long nLeft	= dOffsetOrg < dDistCen ? -1 : 1;
															double dWid1	= GetWidthSlabAct(dSta1, CDPoint(0, 1), nLeft, FALSE, FALSE, FALSE);
															double dWid2	= GetWidthSlabAct(dSta2, CDPoint(0, 1), nLeft, FALSE, FALSE, FALSE);
															
															double dDist1	= fabs(pLineOrg->GetDisMatchVerticalByXy(tvTmp.m_v1));
															double dDist2	= fabs(pLineOrg->GetDisMatchVerticalByXy(tvTmp.m_v2));

															if(dDist1 > dWid1 || dDist2 > dWid2)
															{
																if(tvArrTmp.GetSize() == 2)
																	tvTmp	= tvArrTmp.GetAt(1);
																else
																	bRemoveRebar	= TRUE;
															}
														}
														else
														{
															// 이전에 이음이 있었는데, 이음보다 지금 철근 길이가 작으면
															// 이 철근은 사라져야 하는 철근임..
															if(bJointPrev && tvArrTmp.GetLength() <= dLenJointPrev)
															{
																bRemoveRebar	= TRUE;
															}
														}

														if(!bRemoveRebar)
														{
															if(dOffsetOrg < dDistCen)
															{
																tvArrAngLeftHalf.Add(tvTmp);
															}
															else
															{
																tvArrAngRightHalf.Add(tvTmp);
															}
														}
													}
												}
											}
										} // if(m_nTypePlacingMainRebar_UpperSlab == 2)
									}
								}
							}
						}
					}

					// (ARCBRIDGE-2661) 사보강 배치에만 적용되던 사방향철근을 선형방향 배치에 적용되도록 수정.
					// 2. 사방향 철근
					// 확폭일경우 주선형과 각도가 같아서 길이는 0이 나오더라도 사보강 철근이 1개는 들어가 줘야 피복위치를 맞출수 있다. 그래서 +120을 해줬다. 피복거리 보다는 많이 줘야 되니가 그냥 120 정도..
					if(bSttAngForVert && (dDistRealAng <= (dDistLeft+dDistLeftAngleRebar+120) || dDistRealAng >= (dDistRight-dDistRightAngleRebar-120)) && !bSttBracket && !bEndBracket)
					{
						// 사방향 철근은 최대길이가 아니라 실제 길이 내에서만 배근한다.
						if((dDistRealAng > dDistLeft && dDistRealAng < dDistRight))
						{
							////////////////////////////////////////////////////////////////////////////////////////////////

							// 시종점 교차 둘중에 하나라도 안되는 경우 진행방향 철근
							// 실선부
							CDPoint xyDirOrg	= dOffsetAng < dMid ? xyDirLeft : xyDirRight;
							double dStaOrg		= GetStationByTarget(BRIDGE_OFF_STT_SLAB, 0, TRUE);		
							CDPoint vAngOrg		= GetAngleByTarget(BRIDGE_OFF_STT_SLAB, 0);
							CDPoint xyOrg		= GetLineBase()->GetXyLineByLengthAndAngle(dStaOrg, dOffsetAng - dDistDiff, vAngOrg);
							if(bVertDir == FALSE)
							{
								// (ARCBRIDGE-2661	) 선형방향 배치에 사보강이 들어갈때는 사보강 철근 Offset이 달라서 철근의 Station을 다시 구해줘야한다.
								dStaStt			= pLineBase->GetStationByScInLine(dStaSttTmp, dOffsetAng, ToDPointFrDegree(dAngSttTmp));
								dStaEnd			= pLineBase->GetStationByScInLine(dStaEndTmp, dOffsetAng, ToDPointFrDegree(dAngEndTmp));
								dStaSttSolid	= pLineBase->GetStationByScInLine(dStaSttSolidTmp, dOffsetAng, ToDPointFrDegree(dAngSttTmp));
								dStaEndSolid	= pLineBase->GetStationByScInLine(dStaEndSolidTmp, dOffsetAng, ToDPointFrDegree(dAngEndTmp));
								if(!Compare(dStaSttHiddenTmp, dStaEndHiddenTmp, "="))
								{
									BOOL bStt	= (dStaSttHiddenTmp + dStaEndHiddenTmp)/2 < (dStaSttSolidTmp + dStaEndSolidTmp)/2;
									dStaSttHidden	= pLineBase->GetStationByScInLine(dStaSttHiddenTmp, dOffsetAng, ToDPointFrDegree(bStt ? dAngSttTmp : dAngEndTmp));
									dStaEndHidden	= pLineBase->GetStationByScInLine(dStaEndHiddenTmp, dOffsetAng, ToDPointFrDegree(bStt ? dAngSttTmp : dAngEndTmp));
								}
								// Hidden은 주철근의 앞에 생기는지 뒤에 생기는지 판단해서 
								// dAngSttTmp나 dAngEndTmp을 통일해서 사용함
								if(!Compare(dStaSttHiddenTmp2, dStaEndHiddenTmp2, "="))
								{
									BOOL bStt	= (dStaSttHiddenTmp2 + dStaEndHiddenTmp2)/2 < (dStaSttSolidTmp + dStaEndSolidTmp)/2;
									dStaSttHidden2	= pLineBase->GetStationByScInLine(dStaSttHiddenTmp2, dOffsetAng, ToDPointFrDegree(bStt ? dAngSttTmp : dAngEndTmp));
									dStaEndHidden2	= pLineBase->GetStationByScInLine(dStaEndHiddenTmp2, dOffsetAng, ToDPointFrDegree(bStt ? dAngSttTmp : dAngEndTmp));
								}
							}

							if(bForDrawing && bHunch)
							{
								tv.m_sInfoVer.Format("%d", nIdx++);
								if(Compare(dStaSttParalOfHunch, dStaEndParalOfHunch, "="))
								{
									// 점선부 전체
									tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaStt, dOffsetAng, ToDPointFrDegree(dAngStt));
									tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEnd, dOffsetAng, ToDPointFrDegree(dAngEnd));
									GetXyMatchLineAndLine(tv.m_v1, GetAngleAzimuthJijum(0), xyOrg, xyDirOrg, tv.m_v1);
									GetXyMatchLineAndLine(tv.m_v2, GetAngleAzimuthJijum(m_nQtyJigan), xyOrg, xyDirOrg, tv.m_v2);

									double dSta1(0), dSta2(0);
									
									BOOL bLeft	= dOffsetAng <= dMid;

									// 선형에 꼭 맞도록 변경 ///////////////////////////////////////
									CLineInfoApp *pLineCur = bLeft? pLineLeft : pLineRight;
									double dDist	= pLineCur->GetDisMatchVerticalByXy(xyOrg);
									// 										if(bLeft)
									// 										{
									// 											pLineLeft->GetStationMatchVerticalByXy(tv.m_v1, dSta1);
									// 											pLineLeft->GetStationMatchVerticalByXy(tv.m_v2, dSta2);
									// 										}
									// 										else
									// 										{
									pLineCur->GetStationMatchVerticalByXy(tv.m_v1, dSta1);
									pLineCur->GetStationMatchVerticalByXy(tv.m_v2, dSta2);
									//										}

									tv.m_v1	= pLineCur->GetXyLineDis(dSta1, dDist);
									tv.m_v2	= pLineCur->GetXyLineDis(dSta2, dDist);
									// 선형에 꼭 맞도록 변경 ///////////////////////////////////////
									tv.m_v1.z	= 0;
									tv.m_sInfo	= "HIDDEN";

									// 좌측 사방향 철근인지?
									if(bLeft)//dDistLeftAngleRebar) 
									{
										tvArrAngLeft.Add(tv);
									}
									// 우측 사방향 철근인지
									else
									{
										tvArrAngRight.Add(tv);
									}
								}
								else
								{
									// 점선부 앞
									tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaStt, dOffsetAng, ToDPointFrDegree(dAngStt));
									tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaSttParalOfHunch, dOffsetAng, ToDPointFrDegree(dAngEnd));
									GetXyMatchLineAndLine(tv.m_v1, GetAngleAzimuthJijum(0), xyOrg, xyDirOrg, tv.m_v1);
									GetXyMatchLineAndLine(tv.m_v2, GetAngleAzimuthJijum(m_nQtyJigan), xyOrg, xyDirOrg, tv.m_v2);
									tv.m_v1.z	= 0;
									tv.m_sInfo	= "HIDDEN";

									// 좌측 사방향 철근인지?
									if(dOffsetAng <= dMid)//dDistLeftAngleRebar) 
										tvArrAngLeft.Add(tv);
									// 우측 사방향 철근인지
									else
										tvArrAngRight.Add(tv);

									// 실선부 중앙
									tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaSttParalOfHunch, dOffsetAng, ToDPointFrDegree(dAngStt));
									tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEndParalOfHunch, dOffsetAng, ToDPointFrDegree(dAngEnd));
									GetXyMatchLineAndLine(tv.m_v1, GetAngleAzimuthJijum(0), xyOrg, xyDirOrg, tv.m_v1);
									GetXyMatchLineAndLine(tv.m_v2, GetAngleAzimuthJijum(m_nQtyJigan), xyOrg, xyDirOrg, tv.m_v2);
									tv.m_v1.z	= 0;
									tv.m_sInfo	= "SOLID";

									// 좌측 사방향 철근인지?
									if(dOffsetAng <= dMid)//dDistLeftAngleRebar) 
										tvArrAngLeft.Add(tv);
									// 우측 사방향 철근인지
									else
										tvArrAngRight.Add(tv);
									// 점선부 뒤
									tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaEndParalOfHunch, dOffsetAng, ToDPointFrDegree(dAngStt));
									tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEnd, dOffsetAng, ToDPointFrDegree(dAngEnd));
									GetXyMatchLineAndLine(tv.m_v1, GetAngleAzimuthJijum(0), xyOrg, xyDirOrg, tv.m_v1);
									GetXyMatchLineAndLine(tv.m_v2, GetAngleAzimuthJijum(m_nQtyJigan), xyOrg, xyDirOrg, tv.m_v2);
									tv.m_v1.z	= 0;
									tv.m_sInfo	= "HIDDEN";

									// 좌측 사방향 철근인지?
									if(dOffsetAng <= dMid)//dDistLeftAngleRebar) 
										tvArrAngLeft.Add(tv);
									// 우측 사방향 철근인지
									else
										tvArrAngRight.Add(tv);
								}								
							}
							else
							{
								// 직방향 철근에 포함되는 사방향 철근은 점선부가 없다.
								// 포함되는지 여부를 정확하게 체크하기 위해서는 사방향 철근의 시작과 끝의 직방향
								// 선형에 대한 dist를 구해야 됨.
								// 직철근도 CTC로 나누다 보면 정확히 dist에 안걸리므로, 체크시 CTC만큼 여유를 둠.
								CTwinVector tvTmp;
								tvTmp.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaStt, dOffsetAng, ToDPointFrDegree(dAngStt));
								tvTmp.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEnd, dOffsetAng, ToDPointFrDegree(dAngEnd));
								GetXyMatchLineAndLine(tvTmp.m_v1, GetAngleAzimuthJijum(0), xyOrg, xyDirOrg, tvTmp.m_v1);
								GetXyMatchLineAndLine(tvTmp.m_v2, GetAngleAzimuthJijum(m_nQtyJigan), xyOrg, xyDirOrg, tvTmp.m_v2);
								double dDistStt	= pLineBase->GetDisMatchVerticalByXy(tvTmp.m_v1);
								double dDistEnd	= pLineBase->GetDisMatchVerticalByXy(tvTmp.m_v2);
								double dCTC	= GetCtcRebarMain(TRUE);

								// 사보강 배치가 되어 있는 경우 직철근과 겹치면 선형방향 철근에서 첫번째와 마지막은 무조건 실선이어야 한다.
								BOOL bLeftTmp	= i == 0;
								BOOL bSttTmp	= rc == 0;

								BOOL bContiForce	= FALSE;
								if((i == 0 || i == nSizeArr) && (rc == 0 || rc == nSize-1))
								{
									bContiForce	= IsRebarMainOneLineUpperSlab(bLeftTmp, bSttTmp);
								}

								if(bContiForce
									|| (rc == 0 && dDistLeftRangeVertRebar+dCTC <= dDistStt && dDistRightRangeVertRebar+dCTC >= dDistStt)
									|| (rc == nSize-1 && dDistLeftRangeVertRebar+dCTC <= dDistEnd && dDistRightRangeVertRebar+dCTC >= dDistEnd))
								{
									dStaSttSolid	= dStaStt;
									dStaEndSolid	= dStaEnd;
									dStaSttHidden	= dStaStt;
									dStaEndHidden	= dStaStt;
									dStaSttHidden2	= dStaStt;
									dStaEndHidden2	= dStaStt;
								}

								tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaSttSolid, dOffsetAng, ToDPointFrDegree(dAngStt));
								tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEndSolid, dOffsetAng, ToDPointFrDegree(dAngEnd));
								GetXyMatchLineAndLine(tv.m_v1, GetAngleAzimuthJijum(0), xyOrg, xyDirOrg, tv.m_v1);
								GetXyMatchLineAndLine(tv.m_v2, GetAngleAzimuthJijum(rc == nSize-1 ? m_nQtyJigan : 0), xyOrg, xyDirOrg, tv.m_v2);

								// 사보강 배치에다가 마지막 철근일 경우
								// 종점 각도가 시점 각도와 달라서 남거나 모자라는 경우가 생길 수 있다.
								// 이 경우를 대비해서 마지막 철근일 때는 종점에 교차점을 찾아서 철근길이에 변화를 준다.(에이 번거로워ㅡㅡ;)
								CDPoint xyMatch(0,0);
								if(rc == nSize-1)
								{
									GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), xyEndLeft, tvEnd.GetXyDir(), xyMatch);

									double dDiffSta	= tv.GetLength() - ~(tv.m_v1 - xyMatch) + (dStaEndHidden-dStaSttHidden);
									dStaEndSolid -= dDiffSta;
									dStaSttHidden -= dDiffSta;
									dStaEndHidden -= dDiffSta;
									dStaSttHidden2 -= dDiffSta;
									dStaEndHidden2 -= dDiffSta;
									if(!Compare(dStaSttHidden, dStaEndHidden, "="))
										dStaEndSolid	= dStaSttHidden;

									tv.m_v2	= xyMatch + tv.GetXyDir(TRUE) * (dStaEndHidden-dStaSttHidden);
								}
								tv.m_v1.z	= 0;
								tv.m_sInfo	= "SOLID";

								// (ARCBRIDGE-2661) 사보강철근의 좌우측을 결정하는 부분...
								// 사보강배치일때는 중간을 기준으로 좌우를 나누고 있지만 확폭에의한 사보강 일때는 확폭을 고려해서 구해줘야 한다.
								// 좌측 사방향 철근인지?
								BOOL bLeft	= TRUE;
								if(dOffsetAng <= dMid)//dDistLeftAngleRebar) 
								{
									bLeft	= TRUE;
									tv	= ConvertFromVertialRebarToLineRebarAtSabogang(tv, ToDPointFrDegree(dAngStt), ToDPointFrDegree(dAngEnd), TRUE);
									tvArrAngLeft.Add(tv);
								}
								// 우측 사방향 철근인지
								else
								{
									bLeft	= FALSE;
									tv	= ConvertFromVertialRebarToLineRebarAtSabogang(tv, ToDPointFrDegree(dAngStt), ToDPointFrDegree(dAngEnd), FALSE);
									tvArrAngRight.Add(tv);
								}

								// 이음구함
								if(bJoint)
								{
									double dStaEndJo	= pLineBase->GetStationByScInLine(dStaEndTmp, dOffsetAng+m_dGapJoint, ToDPointFrDegree(dAngEndTmp));

									tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaEndJo-dLenJoint, (dOffsetAng+m_dGapJoint), ToDPointFrDegree(dAngStt));
									tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEndJo, (dOffsetAng+m_dGapJoint), ToDPointFrDegree(dAngEnd));
									GetXyMatchLineAndLine(tv.m_v1, GetAngleAzimuthJijum(0), (xyOrg+xyDirOrg.RotateInv90()*m_dGapJoint), xyDirOrg, tv.m_v1);
									GetXyMatchLineAndLine(tv.m_v2, GetAngleAzimuthJijum(0), (xyOrg+xyDirOrg.RotateInv90()*m_dGapJoint), xyDirOrg, tv.m_v2);
									tv.m_v1.z	= 0;
									tv.m_sInfo	= "SOLID";
									tv	= ConvertFromVertialRebarToLineRebarAtSabogang(tv, ToDPointFrDegree(dAngStt), ToDPointFrDegree(dAngEnd), bLeft);
									tv.m_sInfoHor	= bLeft ? "좌측이음" : "우측이음";
									
									///ARCBRIDGE-2723 철근 사구간 이음 변경
									if(ComparePt(vAngStt, CDPoint(0,1), _T("="), 0.1) == FALSE)
									{
										double dLenOrg = tv.GetLength();
										double dLenExt  = dLenOrg * vAngStt.y;
										tv.m_v1 = tv.m_v1 + (tv.GetXyDir(TRUE) * (dLenExt - dLenOrg)/2);
										tv.m_v2 = tv.m_v2 + (tv.GetXyDir() * (dLenExt - dLenOrg)/2);										
									}

									tvArrJoint.Add(tv);
									tv.m_sInfoHor	= "";
								}

								
								// 점선부
								if(!Compare(dStaSttHidden, dStaEndHidden, "="))
								{

									if(rc == nSize - 1)	// 마지막일 경우 시종점 각도가 달라서 스테이션을 조정할 필요가 있다.
									{
										tv.m_v1	= xyMatch + xyDirOrg * (dStaSttHidden - dStaEndHidden);
										tv.m_v2	= xyMatch;
									}
									else
									{
										BOOL bSttAng	= dStaSttHidden < (dStaSttSolid+dStaEndSolid)/2;
										tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaSttHidden, dOffsetAng, ToDPointFrDegree(dAngStt));
										tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEndHidden, dOffsetAng, ToDPointFrDegree(dAngEnd));
										GetXyMatchLineAndLine(tv.m_v1, GetAngleAzimuthJijum(bSttAng ? 0 : m_nQtyJigan), xyOrg, xyDirOrg, tv.m_v1);
										GetXyMatchLineAndLine(tv.m_v2, GetAngleAzimuthJijum(bSttAng ? 0 : m_nQtyJigan), xyOrg, xyDirOrg, tv.m_v2);
									}
									tv.m_v1.z	= 0;
									tv.m_sInfo	= "HIDDEN";
									tv	= ConvertFromVertialRebarToLineRebarAtSabogang(tv, ToDPointFrDegree(dAngStt), ToDPointFrDegree(dAngEnd), bLeft);

									CDPointArray xyArrMat2;
									long nMat = rb.GetXyMatchTvArrAndLine(tvArrCenter, tv.m_v1, tv.GetXyDir(), xyArrMat2);
									if(nCycle > 0)
									{
										if(nMat > -1) 
										{
											CDPoint xyMat= xyArrMat2.GetAt(0);
											double dDistMat = pLineBase->GetDisMatchVerticalByXy(xyMat, dStaStt, dStaEndTmp);
											double dDist1 = pLineBase->GetDisMatchVerticalByXy(tv.m_v1, dStaStt, dStaEndTmp);
											double dDist2 = pLineBase->GetDisMatchVerticalByXy(tv.m_v2, dStaStt, dStaEndTmp);
											double dDisMax = 0;

											if(dDistMat < 0)
											{
												dDisMax = min(dDist1, dDist2);
												if(Compare(dDistMat, dDisMax, _T("<"), 0.1))
													continue;
											}
											else
											{
												dDisMax = max(dDist1, dDist2);
												if(Compare(dDistMat, dDisMax, _T("<"), 0.1))
													continue;
											}											
										}
									}

									tv.m_sInfoHor	= bLeft ? "좌측점선" : "우측점선";
									if(dOffsetAng <= dMid)//dDistLeftAngleRebar) 
										tvArrHiddenAngLeftTmp.Add(tv);
									else
										tvArrHiddenAngRightTmp.Add(tv);
									tv.m_sInfoHor	= "";
								}

								if(!Compare(dStaSttHidden2, dStaEndHidden2, "="))
								{
									BOOL bSttAng	= dStaSttHidden2 < (dStaSttSolid+dStaEndSolid)/2;
									tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaSttHidden2, dOffsetAng, ToDPointFrDegree(dAngStt));
									tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEndHidden2, dOffsetAng, ToDPointFrDegree(dAngEnd));
									GetXyMatchLineAndLine(tv.m_v1, GetAngleAzimuthJijum(bSttAng ? 0 : m_nQtyJigan), xyOrg, xyDirOrg, tv.m_v1);
									GetXyMatchLineAndLine(tv.m_v2, GetAngleAzimuthJijum(bSttAng ? 0 : m_nQtyJigan), xyOrg, xyDirOrg, tv.m_v2);
									tv.m_v1.z	= 0;
									tv.m_sInfo	= "HIDDEN";
									tv	= ConvertFromVertialRebarToLineRebarAtSabogang(tv, ToDPointFrDegree(dAngStt), ToDPointFrDegree(dAngEnd), bLeft);

									tv.m_sInfoHor	= bLeft ? "좌측점선" : "우측점선";
									if(dOffsetAng <= dMid)//dDistLeftAngleRebar) 
										tvArrHiddenAngLeftTmp.Add(tv);
									else
										tvArrHiddenAngRightTmp.Add(tv);
									tv.m_sInfoHor	= "";
								}
							}
						}
					}
				}
			}
		}
	}

	tvArrHidden.AddFromTvArray(tvArrHiddenOrgTmp);
	tvArrHiddenLeft.AddFromTvArray(tvArrHiddenAngLeftTmp);
	tvArrHiddenRight.AddFromTvArray(tvArrHiddenAngRightTmp);


	if(nDrawLeft == 0 && nIdx != -1)
	{
		if(bHunch)
		{
			CTwinVectorArray *pTvArr	= new CTwinVectorArray;
			*pTvArr	= tvArr;
			m_tvArr_RebarMain_PlaneHunch[nCycle].Add(pTvArr);	

			CTwinVectorArray *pTvArrAngLeft	= new CTwinVectorArray;
			*pTvArrAngLeft	= tvArrAngLeft;
			m_tvArrAngLeft_RebarMain_PlaneHunch[nCycle].Add(pTvArrAngLeft);

			CTwinVectorArray *pTvArrAngRight	= new CTwinVectorArray;
			*pTvArrAngRight	= tvArrAngRight;
			m_tvArrAngRight_RebarMain_PlaneHunch[nCycle].Add(pTvArrAngRight);

			CTwinVectorArray *pTvArrHidden	= new CTwinVectorArray;
			*pTvArrHidden	= tvArrHidden;
			m_tvArrHidden_RebarMain_PlaneHunch[nCycle].Add(pTvArrHidden);

			CTwinVectorArray *pTvArrHiddenLeft	= new CTwinVectorArray;
			*pTvArrHiddenLeft	= tvArrHiddenLeft;
			m_tvArrHiddenLeft_RebarMain_PlaneHunch[nCycle].Add(pTvArrHiddenLeft);

			CTwinVectorArray *pTvArrHiddenRight	= new CTwinVectorArray;
			*pTvArrHiddenRight	= tvArrHiddenRight;
			m_tvArrHiddenRight_RebarMain_PlaneHunch[nCycle].Add(pTvArrHiddenRight);

			CTwinVectorArray *pTvArrAngLeftHalf	= new CTwinVectorArray;
			*pTvArrAngLeftHalf	= tvArrAngLeftHalf;
			m_tvArrAngLeftHalf_RebarMain_PlaneHunch[nCycle].Add(pTvArrAngLeftHalf);

			CTwinVectorArray *pTvArrAngRightHalf	= new CTwinVectorArray;
			*pTvArrAngRightHalf	= tvArrAngRightHalf;
			m_tvArrAngRightHalf_RebarMain_PlaneHunch[nCycle].Add(pTvArrAngRightHalf);
		}
		else if(bSttBracket)
		{
			m_tvArrSttBracket_RebarMain_Plane.AddFromTvArray(tvArr);
		}
		else if(bEndBracket)
		{
			m_tvArrEndBracket_RebarMain_Plane.AddFromTvArray(tvArr);
		}
		else
		{
			CTwinVectorArray *pTvArr	= new CTwinVectorArray;
			*pTvArr	= tvArr;
			m_tvArr_RebarMain_Plane[nCycle][nDan][upper].Add(pTvArr);	

			CTwinVectorArray *pTvArrAngLeft	= new CTwinVectorArray;
			*pTvArrAngLeft	= tvArrAngLeft;
			m_tvArrAngLeft_RebarMain_Plane[nCycle][nDan][upper].Add(pTvArrAngLeft);

			CTwinVectorArray *pTvArrAngRight	= new CTwinVectorArray;
			*pTvArrAngRight	= tvArrAngRight;
			m_tvArrAngRight_RebarMain_Plane[nCycle][nDan][upper].Add(pTvArrAngRight);

			CTwinVectorArray *pTvArrJoint	= new CTwinVectorArray;
			*pTvArrJoint	= tvArrJoint;
			m_tvArrJoint_RebarMain_Plane[nCycle][nDan][upper].Add(pTvArrJoint);

			CTwinVectorArray *pTvArrHidden	= new CTwinVectorArray;
			*pTvArrHidden	= tvArrHidden;
			m_tvArrHidden_RebarMain_Plane[nCycle][nDan][upper].Add(pTvArrHidden);

			CTwinVectorArray *pTvArrHiddenLeft	= new CTwinVectorArray;
			*pTvArrHiddenLeft	= tvArrHiddenLeft;
			m_tvArrHiddenLeft_RebarMain_Plane[nCycle][nDan][upper].Add(pTvArrHiddenLeft);

			CTwinVectorArray *pTvArrHiddenRight	= new CTwinVectorArray;
			*pTvArrHiddenRight	= tvArrHiddenRight;
			m_tvArrHiddenRight_RebarMain_Plane[nCycle][nDan][upper].Add(pTvArrHiddenRight);

			CTwinVectorArray *pTvArrAngLeftHalf	= new CTwinVectorArray;
			*pTvArrAngLeftHalf	= tvArrAngLeftHalf;
			m_tvArrAngLeftHalf_RebarMain_Plane[nCycle][nDan][upper].Add(pTvArrAngLeftHalf);

			CTwinVectorArray *pTvArrAngRightHalf	= new CTwinVectorArray;
			*pTvArrAngRightHalf	= tvArrAngRightHalf;
			m_tvArrAngRightHalf_RebarMain_Plane[nCycle][nDan][upper].Add(pTvArrAngRightHalf);
		}
	}
}



// 횡단면도 주철근 좌표들이 해당 sta에서 직각방향으로 얼마나 떨어진 거리인지 판단한다. (확폭지원 안됨)
// 아래에서 위로 감..
// 사보강일경우 시점각도 방향으로 위치를 구하고(횡단방향 최대 거리를 구함(시종점고려))
// 선형방향일 경우 직각방향으로 위치를 구한다.
// 중심선형에서의 거리임
// BOOL bForRightAngleRebar : 직철근 용인지?
// BOOL bCheckRebar : dSta에 철근이 존재 하는지 체크해서 존재할 경우에만 간격을 구함.
void CRcBridgeRebar::GetDistRebarMain_CrossSection_Slab(BOOL bUpperSlab, CDoubleArray &dArr1, CDoubleArray &dArrHunch1, CDoubleArray &dArr2, CDoubleArray &dArrHunch2, CDoubleArray &dArr3, CDoubleArray &dArrHunch3, CDoubleArray &dArr4, CDoubleArray &dArrHunch4, double dSta, BOOL bUpper, long nDan, BOOL bForRightAngleRebar, BOOL bCheckRebar, BOOL bForArrangePlane)
{
	dArr1.RemoveAll();
	dArr2.RemoveAll();
	dArr3.RemoveAll();
	dArr4.RemoveAll();
	if(nDan == 0 && bUpperSlab != bUpper)
	{
		dArrHunch1.RemoveAll();
		dArrHunch2.RemoveAll();
		dArrHunch3.RemoveAll();
		dArrHunch4.RemoveAll();
	}

	BOOL bVertDir	= IsVertDir();
	CDPoint vAng	= bVertDir ? GetAngleJijum(0) : CDPoint(0, 1);

	CDPointArray xyArr[MAX_REBAR_CYCLE], xyArrHunch[MAX_REBAR_CYCLE];	// 횡단면상의 주철근 좌표
	GetXyRebarMain_CrossSection_SlabForPlacingMainRebar(bUpperSlab, xyArr[0], xyArrHunch[0], xyArr[1], xyArrHunch[1], xyArr[2], xyArrHunch[2], xyArr[3], xyArrHunch[3], dSta, bUpper, nDan, bForRightAngleRebar, bCheckRebar, bForArrangePlane);
	
	CTwinVectorArray tvArrCross;
	GetTvCrossSection(tvArrCross, dSta, vAng, FALSE, FALSE, FALSE, 0, FALSE, FALSE, FALSE, FALSE, TRUE);
	CDRect rect		= tvArrCross.GetRect();
	CDPoint xyOrg	= CDPoint(rect.left, rect.bottom);

	// 횡단 슬래브 좌측으로 부터 거리를 구한뒤, dDistFromRight고려해서 재계산
	long cycle = 0; for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
	{
		CDoubleArray *pDArr, *pDArrHunch;
		switch(cycle)
		{
			case 0: pDArr	= &dArr1; pDArrHunch	= &dArrHunch1; break;
			case 1: pDArr	= &dArr2; pDArrHunch	= &dArrHunch2; break;
			case 2: pDArr	= &dArr3; pDArrHunch	= &dArrHunch3; break;
			case 3: pDArr	= &dArr4; pDArrHunch	= &dArrHunch4; break;
		}

		long nSize	= xyArr[cycle].GetSize();
		long i = 0; for(i = 0; i < nSize; i++)
		{
			CDPoint xy	= xyArr[cycle].GetAt(i);
			pDArr->Add(xy.x);
		}

		if(nDan == 0 && bUpperSlab != bUpper)
		{
			nSize	= xyArrHunch[cycle].GetSize();
			for(i = 0; i < nSize; i++)
			{
				CDPoint xy	= xyArrHunch[cycle].GetAt(i);
				pDArrHunch->Add(xy.x);
			}
		}

		pDArr->Sort();
		pDArr->RemoveSameValue(0.001);

		pDArrHunch->Sort();
		pDArrHunch->RemoveSameValue(0.001);
	}
}

// 평면상 해당 sta에서 직각 방향으로 dArrDist만큼 떨어진 위치의 좌표들을 구한다.
// void CRcBridgeRebar::GetXyArray_Plane_UpperSlab(CDPointArray &xyArr, CDoubleArray &dArrDist, double dSta)
// {
// 	xyArr.RemoveAll();
// 	
// 	CLineInfo *pLineBase	= GetLineBase();
// 	CDPoint xyDirTan		= pLineBase->GetAngleAzimuth(dSta).Rotate90();	// 선형 접선의 직각방향
// 	CDPoint xyOrg			= pLineBase->GetXyLine(dSta);					// 해당 sta의 좌표
// 	CDPoint xy				= CDPoint(0, 0);
// 
// 	long nSize	= dArrDist.GetSize();
// 	long i = 0; for(i = 0; i < nSize; i++)
// 	{
// 		xy	= xyOrg+(xyDirTan*dArrDist.GetAt(i));
// 		xyArr.Add(xy);
// 	}
// }

// 종단면도 상부슬래브 배력근들의 sta
void CRcBridgeRebar::GetStaRebarSupport_VertSection_Slab(CDoubleArray &dArr, BOOL bUpper, long nDan, BOOL bUpperSlab)
{
	dArr.RemoveAll();
	
	CDPointArray xyArr;	
	if(bUpperSlab)
		GetXyRebarSupport_VertSection_UpperSlab(xyArr, bUpper, nDan, 0);
	else
		GetXyRebarSupport_VertSection_LowerSlab(xyArr, bUpper, nDan, 0);
	
	// 횡단 슬래브 좌측으로 부터 거리를 구한뒤, dDistFromRight고려해서 재계산
	long nSize	= xyArr.GetSize();
	long i = 0; for(i = 0; i < nSize; i++)
		dArr.Add(xyArr[i].x);
}

void CRcBridgeRebar::GetTvRebarSupport_Plane_Slab_Std(BOOL bUpperSlab, CTwinVectorArray &tvArr, CTwinVectorArray &tvArrAngStt, CTwinVectorArray &tvArrAngEnd, CTwinVectorArray &tvArrRAngStt, CTwinVectorArray &tvArrRAngEnd, BOOL bUpper, long nDan, long nDrawLeft, BOOL bForDimRebarMain)
{
	tvArr.RemoveAll();
	tvArrAngStt.RemoveAll();
	tvArrAngEnd.RemoveAll();
	tvArrRAngStt.RemoveAll();
	tvArrRAngEnd.RemoveAll();

	if(!m_bCaledRebarSupport_Plane)
	{
		SettingTvArrRebarSupportPlane();
	}

	long upper	= bUpper ? iUPPER : iLOWER;
	if(bUpperSlab)
	{
		tvArr.AddFromTvArray(m_tvArr_RebarSupport_Plane[nDan][upper]);
		tvArrAngStt.AddFromTvArray(m_tvArrAngStt_RebarSupport_Plane[nDan][upper]);
		tvArrAngEnd.AddFromTvArray(m_tvArrAngEnd_RebarSupport_Plane[nDan][upper]);
		tvArrRAngStt.AddFromTvArray(m_tvArrRAngStt_RebarSupport_Plane[nDan][upper]);
		tvArrRAngEnd.AddFromTvArray(m_tvArrRAngEnd_RebarSupport_Plane[nDan][upper]);
	}
	else
	{
		tvArr.AddFromTvArray(m_tvArr_RebarSupport_LowerPlane[nDan][upper]);
		tvArrAngStt.AddFromTvArray(m_tvArrAngStt_RebarSupport_LowerPlane[nDan][upper]);
		tvArrAngEnd.AddFromTvArray(m_tvArrAngEnd_RebarSupport_LowerPlane[nDan][upper]);
		tvArrRAngStt.AddFromTvArray(m_tvArrRAngStt_RebarSupport_LowerPlane[nDan][upper]);
		tvArrRAngEnd.AddFromTvArray(m_tvArrRAngEnd_RebarSupport_LowerPlane[nDan][upper]);
	}

	if(nDrawLeft != 0)
	{
		GetTvArrUpperSlabByDrawLeft_SupportRebar(tvArr, nDrawLeft);
		GetTvArrUpperSlabByDrawLeft_SupportRebar(tvArrAngStt, nDrawLeft);
		GetTvArrUpperSlabByDrawLeft_SupportRebar(tvArrAngEnd, nDrawLeft);
		GetTvArrUpperSlabByDrawLeft_SupportRebar(tvArrRAngStt, nDrawLeft);
		GetTvArrUpperSlabByDrawLeft_SupportRebar(tvArrRAngEnd, nDrawLeft);

		/*
		BOOL bVertDir	= IsVertDir();
		CTwinVectorArray tvArrPlane;
		GetTvRebarOut_Plane_UpperSlabStd(tvArrPlane, -1, TRUE, nDrawLeft==-1?iUPPER:iLOWER, bVertDir);

		CRebarPlacing rb;
		rb.GetTvArrayByCrossTvArrayArea(tvArr, tvArrPlane, TRUE);
		rb.GetTvArrayByCrossTvArrayArea(tvArrAngStt, tvArrPlane, TRUE);
		rb.GetTvArrayByCrossTvArrayArea(tvArrAngEnd, tvArrPlane, TRUE);
		rb.GetTvArrayByCrossTvArrayArea(tvArrRAngStt, tvArrPlane, TRUE);
		rb.GetTvArrayByCrossTvArrayArea(tvArrRAngEnd, tvArrPlane, TRUE);
		*/
	}
}
// 평면 상부슬래브 배력근 좌표
// CTwinVectorArray &tvArrAngStt : 시점측에 배치된 사보강 철근
// CTwinVectorArray &tvArrAngEnd : 종점측에 배치된 사보강 철근
// BOOL bForDimRebarMain : 주철근 배치를 위한 좌표 찾기인지?
// 주철근 배치를 위해 찾을때는 nType이 0과 2는 상관이 없으나, 1인경우 0으로 좌표를 구하게 된다(배력근의 정확한 각도를 알기 위해)
// m_nTypePlacingSupportRebar_UpperSlab : 배력근 배근타입
// 0 : 시점각도기준 경사방향 배치
// 1 : 종점각도기준 경사방향 배치
// 2 : 사보강(전체)
// 3 : 사보강(절반) - 아직 지원 안됨
// bForDimRebarMain : 주철근 치수기입을 위한 것으로 중복되는 철근이 없도록 구한다.
// 즉, 추가된 구간이라던가, 사보강/경사방향 배치시 tvArrAngStt나 tvArrAngEnd에 tvArr과 겹치도록 들어가는 것은 구하지 않는다
void CRcBridgeRebar::GetTvRebarSupport_Plane_Slab(BOOL bUpperSlab, CTwinVectorArray &tvArr, CTwinVectorArray &tvArrAngStt, CTwinVectorArray &tvArrAngEnd, CTwinVectorArray &tvArrRAngStt, CTwinVectorArray &tvArrRAngEnd, BOOL bUpper, long nDan, long nDrawLeft, BOOL bForDimRebarMain)
{
	tvArr.RemoveAll();
	tvArrAngStt.RemoveAll();
	tvArrAngEnd.RemoveAll();
	tvArrRAngStt.RemoveAll();
	tvArrRAngEnd.RemoveAll();

	CLineInfo *pLine	= GetLineBase();
	long nType	= m_nTypePlacingSupportRebar_UpperSlab;

	SetDataDefaultDistJijumDirPlacing();

	BOOL bVertDir	= IsVertDir();
	CLineInfo *pLineBase	= GetLineBase(bVertDir);
	if(!pLineBase) return;
	
	// 배철철근 구할때는 좌우측 선형에 피복을 적용해서 구한뒤 
	// 다시 복귀 시킨다.
	double dCoverSide	= GetCoverSide_UpperSlab(0);
	double dCoverSideAng 	= GetCoverSide_UpperSlab(0);
	if(nType == 0)
		dCoverSideAng /= GetAngleJijum(0).y;
	else if(nType == 1)
		dCoverSideAng /= GetAngleJijum(m_nQtyJigan).y;
	CLineInfo *pLineL	= GetLineLeftRight(TRUE);
	CLineInfo *pLineR	= GetLineLeftRight(FALSE);
	if(!pLineL || !pLineR) return;
	

	long upper	= bUpper ? iUPPER : iLOWER;
	CTwinVector tv, tvTmp;
	CTwinVectorArray tvArrStt, tvArrEnd;
	CDoubleArray dArr;
	if(nDan == 0)
	{
		dArr	= bUpperSlab? m_dArrStaSupRebar[upper] : m_dArrStaSupRebarLowerSlab[upper];
	}

	if(dArr.GetSize() == 0)
	{
		GetStaRebarSupport_VertSection_Slab(dArr, bUpper, nDan, bUpperSlab);
	}

	long nSize	= dArr.GetSize();
	if(nSize == 0) return;

	BOOL	bMatchStt	= FALSE,
			bMatchEnd	= FALSE;

	double dSta	= 0;
	double dStaVert	= 0;	// 직철근용 sta(도로중심과 선형중심이 일치 하지 않을 경우 차이가 날 수 있다.)
	CDPoint xyMatch(0, 0);
	double	dWidthLeft	= 0,	// 중심선형에서 좌측선형까지 너비
			dWidthRight	= 0;	// 중심선형에서 우측선형까지 너비

	// 기준이 되는 철근 방향 ////////////////
	// 기준은 수직방향이고, all 사방향 배치일 경우 시점 각도를 기준으로 함.
	// 참고로 all 사방향 배치는 시점 각도를 기준으로 하기 때문에 시점과 종점의 각도가 다를 경우 정상적으로 배치 되지않을 수 있음
	CDPoint xyDirDefaultRebar	= CDPoint(0, 1);	
	if(nType == 0)
		xyDirDefaultRebar	= GetAngleJijum(0, bVertDir);
	else if(nType == 1)
		xyDirDefaultRebar	= GetAngleJijum(m_nQtyJigan, bVertDir);
	else if(nType == 2 || nType == 3)
		xyDirDefaultRebar	= CDPoint(0, 1);
	///////////////////////////////////////////

	// tvArrCenter은 중심선과 교차점을 찾는데만 쓸 것이므로 충분히 길게 잡는다.
	CTwinVectorArray tvArrCenter;
	GetTvCenterPlane_UpperSlab(tvArrCenter, TRUE, FALSE, GetWidthSlabAct(m_dStationBridgeStt, CDPoint(0, 1)), bVertDir);
	CDPointArray xyArrMatchMid;
	CDPointArray xyArrMatchStt, xyArrMatchEnd;
	CDPoint xyMatchMid(0, 0);
	CRebarPlacing rb;

	// 가각부 좌우측 외곽라인 구함. ///////////////
	CTwinVectorArray tvArrPlaneExp;
	CTwinVectorArray tvArrExp[2][2];
	GetTvRebarOut_Plane_UpperSlabStd(tvArrPlaneExp, 0, TRUE);
	long i = 0; for(i = 0; i < tvArrPlaneExp.GetSize(); i++)
	{
		tv	= tvArrPlaneExp.GetAt(i);
		if(tv.m_sInfo.Find("시점좌측가각부", 0) != -1)
			tvArrExp[iSTT][iLEFT].Add(tv);
		else if(tv.m_sInfo.Find("종점좌측가각부", 0) != -1)
			tvArrExp[iEND][iLEFT].Add(tv);
		else if(tv.m_sInfo.Find("시점우측가각부", 0) != -1)
			tvArrExp[iSTT][iRIGHT].Add(tv);
		else if(tv.m_sInfo.Find("종점우측가각부", 0) != -1)
			tvArrExp[iEND][iRIGHT].Add(tv);
		else if(tv.m_sInfo == "시점")
			tvArrStt.Add(tv);
		else if(tv.m_sInfo == "종점")
			tvArrEnd.Add(tv);
	}

	// 사보강(절반)을위해서 시종점 교차점을 찾아야 된다.
	GetTvRebarOut_Plane_UpperSlabStd(tvArrPlaneExp, 0, TRUE);
	// 가각부 좌우측 외곽라인 구함. ///////////////

	double dWS		= IsOutWall(TRUE) ? m_dWS / GetAngleJijum(0).y : 0;
	double dWE		= IsOutWall(FALSE) ? m_dWE / GetAngleJijum(m_nQtyJigan).y : 0;
	double dStaStt	= bVertDir ? -dWS : GetStationByTarget(BRIDGE_OFF_STT_SLAB, 0, TRUE);
	double dStaEnd	= bVertDir ? GetLengthBridge(bVertDir) + dWE : GetStationByTarget(BRIDGE_OFF_END_SLAB, 0, TRUE);

	nSize	= dArr.GetSize();
	CDPointArray xyArrMatch;
	tv.m_v1.z	= 0;
	tv.m_v2.z	= 0;
	CDPoint xy(0, 0);


	// 주철근 선형방향 배치고 배력근 사보강 배치일때
	double dDiffStaForVert	= GetDiffStationSupportForVert();
	
	// vert == 0 : 각 스테이션별 철근 구함
	// vert == 1 : 사보강(절반)일때 비는 부분에 대한 직방향 철근 구함
	double dStaSttVertRebar	= 0;
	double dStaEndVertRebar	= 0;

	CDPoint xyDirDefaultRebarOld	= xyDirDefaultRebar;
	for(long vert = 0; vert < 2; vert++)
	{
		if(nType != 3 && vert == 1) continue;

		nSize	= dArr.GetSize();
		for(i = 0; i < nSize; i++)
		{
			dSta	= dArr.GetAt(i);
			xyDirDefaultRebar	= xyDirDefaultRebarOld;
			
			// 사보강배치일 경우 시점0을 기준으로하는 직방향 선형을 사용하기 때문에 실제로 그려진 종단면상의 철근에서일부 수정이 있엉 ㅑ함.
			// 철근배치를 하기 위해선 직방향용 선형의 sta으로 변경
			if(bVertDir)
			{
 				double dDiff = m_dStationBridgeStt;
				dSta	-= dDiff;
				dStaVert = dSta - dDiffStaForVert;
			}
			else
				dStaVert = dSta - dDiffStaForVert;
			
			if(!bVertDir)
			{
				if(m_nTypePlacingSupportRebar_UpperSlab == 0)
					xyDirDefaultRebar	= pLineBase->GetAngleByOffset(m_dStationBridgeStt, dSta, xyDirDefaultRebarOld);
				else if(m_nTypePlacingSupportRebar_UpperSlab == 1)
					xyDirDefaultRebar	= pLineBase->GetAngleByOffset(m_dStationBridgeStt+m_dLengthBridge, dSta, xyDirDefaultRebarOld);
				else
				{
					// 원곡선일경우 벽체 외곽에 있는 철근은 시점과 방위각이 같게 철근을 배치해야 된다.(벽체기 때문)
					// 단, 사보강일 때는 선형자체가 직선으로 변하므로 고려 하지 않는다.
					// 그리고 배력근은 사보강 배치이어야 한다.
					if(!bVertDir && m_nTypePlacingSupportRebar_UpperSlab == 2 || m_nTypePlacingSupportRebar_UpperSlab == 3)
					{
						if(dSta < m_dStationBridgeStt)
							xyDirDefaultRebar	= pLineBase->GetAngleByOffset(m_dStationBridgeStt, dSta, xyDirDefaultRebarOld);
						else if(dSta > m_dStationBridgeStt + m_dLengthBridge)
							xyDirDefaultRebar	= pLineBase->GetAngleByOffset(m_dStationBridgeStt+m_dLengthBridge, dSta, xyDirDefaultRebarOld);
					}
				}
			}
			else
				xyDirDefaultRebar	= xyDirDefaultRebarOld;
			
			// (ARCBRIDGE-3375) 시종점에서 가각이 있는경우 철근 간섭체크를 실제 슬래브폭까지 적용해줘야 한다.
			if((dSta <= dStaStt + m_dDistSttJijumDirPlacing[upper]) || (dSta >= dStaEnd - m_dDistEndJijumDirPlacing[upper]))
			{
				dWidthLeft	= GetWidthSlabActByGagak(vert == 0 ? dStaVert : dSta, xyDirDefaultRebar, -1, FALSE);
				dWidthRight	= GetWidthSlabActByGagak(vert == 0 ? dStaVert : dSta, xyDirDefaultRebar, 1, FALSE);
			}
			else
			{
				dWidthLeft	= GetWidthSlabAct(vert == 0 ? dStaVert : dSta, xyDirDefaultRebar, -1, FALSE, bVertDir);
				dWidthRight	= GetWidthSlabAct(vert == 0 ? dStaVert : dSta, xyDirDefaultRebar, 1, FALSE, bVertDir);
			}

			// 사보강 배치일때 sta틀려지는 경우를 대비해서 dStaVert를 사용한다.
			tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(vert == 0 ? dStaVert : dSta, dWidthRight-dCoverSideAng, xyDirDefaultRebar); //GetXySlabEdgeAct(dSta, CDPoint(0, 1), FALSE);
			tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(vert == 0 ? dStaVert : dSta, -(dWidthLeft-dCoverSideAng), xyDirDefaultRebar);
			
			// 사각인경우 시점측에 가까운지 종점측에 가까운지 판단해서 각도적용해서 그림 ///////////
			// 구한 철근이 시점이나 종점에 교차되면 직방향 철근은 없다.
			// 시점과 교차되는지 확인
			rb.GetXyMatchTvArrAndSeg(tvArrStt, tv.m_v1, tv.m_v2, xyArrMatchStt, FALSE);
			rb.GetXyMatchTvArrAndSeg(tvArrEnd, tv.m_v1, tv.m_v2, xyArrMatchEnd, FALSE);
			bMatchStt	= xyArrMatchStt.GetSize() > 0;
			bMatchEnd	= xyArrMatchEnd.GetSize() > 0;


			// 사방향 철근 들어가야 되는지 판단했다면 충분히 길게 다시 만듬
			// 사보강 배치일때 sta틀려지는 경우를 대비해서 dStaVert를 사용한다.
			tv.m_v1	= tv.m_v1 + (tv.GetXyDir(TRUE) * 100000);
			tv.m_v2	= tv.m_v2 + (tv.GetXyDir() * 100000);

			// 시종점에 걸린다면 이것은 가각부 철근으로 사용
			// 가각인 경우 절반까지의 거리만으로 판단이 불가능 하므로..
			BOOL bHalfVertRebar	= FALSE;
			if(vert == 0)
			{
				rb.GetXyMatchTvArrAndSeg(tvArrStt, tv.m_v1, tv.m_v2, xyArrMatchStt, FALSE);
				rb.GetXyMatchTvArrAndSeg(tvArrEnd, tv.m_v1, tv.m_v2, xyArrMatchEnd, FALSE);
				bHalfVertRebar	= xyArrMatchStt.GetSize() > 0 || xyArrMatchEnd.GetSize() > 0;
			}

			// 사방향 철근 구간에 포함되는지..
			BOOL bIncludeSttSpace	= FALSE;
			BOOL bIncludeEndSpace	= FALSE;

			// 구한 철근의 sta이 사방향 철근 구간에 포함되면 사방향 철근도 추가해준다.
			if(nType == 2 || nType == 3)
			{
				if(dSta <= dStaStt + m_dDistSttJijumDirPlacing[upper])
					bIncludeSttSpace = TRUE;

				if(dSta >= dStaEnd - m_dDistEndJijumDirPlacing[upper])
					bIncludeEndSpace = TRUE;
			}
			else if(nType == 0)
			{
				if(dSta <= dStaStt + m_dDistSttJijumDirPlacing[upper])
					bIncludeSttSpace = TRUE;

				 if(dSta >= dStaEnd - m_dDistEndJijumDirPlacing[upper])
					 bIncludeEndSpace = TRUE;
			}
			else if(nType == 1)
			{
				if(dSta <= dStaStt + m_dDistSttJijumDirPlacing[upper])
					bIncludeSttSpace = TRUE;
			}
			

// 			if((nType == 2 || nType == 3) && (dSta <= dStaStt + m_dDistSttJijumDirPlacing[upper] && dSta >= dStaEnd - m_dDistEndJijumDirPlacing[upper]))
// 			{
// 				bIncludeSttSpace	= TRUE;
// 				bIncludeEndSpace	= TRUE;
// 			}
// 			else if((nType == 2 || nType == 3) && dSta <= dStaStt + m_dDistSttJijumDirPlacing[upper])
// 			{
// 				bIncludeSttSpace	= TRUE;
// 				bIncludeEndSpace	= FALSE;
// 			}
// 			else if((nType == 2 || nType == 3) && dSta >= dStaEnd - m_dDistEndJijumDirPlacing[upper])
// 			{
// 				bIncludeSttSpace	= FALSE;
// 				bIncludeEndSpace	= TRUE;
// 			}
// 
// 			else if(nType == 0 && dSta >= dStaEnd - m_dDistEndJijumDirPlacing[upper])
// 			{
// 				bIncludeSttSpace	= FALSE;
// 				bIncludeEndSpace	= TRUE;
// 			}
// 			else if(nType == 1 && dSta <= dStaStt + m_dDistSttJijumDirPlacing[upper])
// 			{
// 				bIncludeSttSpace	= TRUE;
// 				bIncludeEndSpace	= FALSE;
// 			}
// 			else
// 			{
// 				bIncludeSttSpace	= FALSE;
// 				bIncludeEndSpace	= FALSE;
// 			}

			if(Compare(m_dDistSttJijumDirPlacing[upper], 0.0, "="))
				bIncludeSttSpace	= FALSE;
			if(Compare(m_dDistEndJijumDirPlacing[upper], 0.0, "="))
				bIncludeEndSpace	= FALSE;
			//////////////////////////////////////////////////////////////////////////////////////////

			// 중심선형과의 교차점을 미리 구해둠.
			rb.GetXyMatchTvArrAndSeg(tvArrCenter, tv.m_v1, tv.m_v2, xyArrMatchMid, FALSE);
			if(xyArrMatchMid.GetSize() > 0) 
				xyMatchMid	= xyArrMatchMid.GetAt(0);
			else
				xyMatchMid	= pLineBase->GetXyLineByLengthAndAngle(dSta, 0, xyDirDefaultRebar);

			// 직방향 철근 추가
			BOOL bVert	= FALSE;
			if((!bMatchStt && !bMatchEnd) || vert == 1)
			{
				CTwinVectorArray tvArrTmp;
				tvArrTmp.Add(tv);
				rb.GetTvByCrossTvArrArea(tvArrTmp, tvArrPlaneExp, TRUE, TRUE, FALSE);
				if(tvArrTmp.GetSize() > 0)
					tv	= tvArrTmp.GetAt(0);
				else
				{
					// 교차점 못 찾으면 길게 늘였던거 다시 짧게 해서 구함.
					tv.m_v1	= tv.m_v1 + (tv.GetXyDir(FALSE) * 100000);
					tv.m_v2	= tv.m_v2 + (tv.GetXyDir(TRUE) * 100000);
				}

				// 강제 직방향 철근은 추가할때 주의를 기울여야 한다.(순서대로 넣어줘야 하므로)
				if(vert == 1 && tvArr.GetSize() > 0)
				{
					if(nDrawLeft == -1)	// 진행방향 좌측만
					{
						tv.m_v1	= xyMatchMid;
					}
					else if(nDrawLeft == 1)	// 진행방향 우측만
					{
						tv.m_v2	= xyMatchMid;
					}

					double dStaSttTmp	= 0;
					double dStaCurTmp	= 0;
					pLine->GetStationMatchVerticalByXy(tvArr.GetAt(0).m_v1, dStaSttTmp);
					pLine->GetStationMatchVerticalByXy(tv.m_v1, dStaCurTmp);

					// 2단이상 철근은 시종점에 주철근이 있어야 직철근 넣을 수 있다.
					BOOL bIsRebarStt2Dan	= TRUE;
					BOOL bIsRebarEnd2Dan	= TRUE;
					if(nDan > 0)
					{
						CRebarInfoCycle *pRC2DanStt	= NULL;
						CRebarInfoCycle *pRC2DanEnd	= NULL;
						if(bUpperSlab)
						{
							pRC2DanStt	= GetRebarInfoCycleUpperSlab(0, nDan, bUpper, 0);
							pRC2DanEnd	= GetRebarInfoCycleUpperSlab(0, nDan, bUpper, -1);
						}
						else
						{
							pRC2DanStt	= GetRebarInfoCycleLowerSlab(0, nDan, bUpper, 0);
							pRC2DanEnd	= GetRebarInfoCycleLowerSlab(0, nDan, bUpper, -1);
						}
						if(!pRC2DanStt || !pRC2DanStt->m_bExist)
							bIsRebarStt2Dan	= FALSE;
						if(!pRC2DanEnd || !pRC2DanEnd->m_bExist)
							bIsRebarEnd2Dan	= FALSE;
					}

					if(rb.CheckXyByTvArrayArea(tv.GetXyMid(), tvArrPlaneExp, TRUE))
					{
						if(dStaCurTmp <= dStaSttTmp)
						{
							if(bIsRebarStt2Dan)
								tvArrRAngStt.InsertAt(0, tv);
						}
						else
						{
							if(bIsRebarEnd2Dan)
								tvArrRAngEnd.Add(tv);
						}
					}
				}
				else
				{
					if(nDrawLeft == -1)	// 진행방향 좌측만
						tv.m_v1	= xyMatchMid;
					else if(nDrawLeft == 1)	// 진행방향 우측만
						tv.m_v2	= xyMatchMid;

					// 기본 철근에 대해서 가각부를 구분할 필요가 있음.(집계시 참고할 예정) ///
					// 가각 지원인 경우 철근을 뻗어서 가각부에 교차되면 가각부 까지 뻗어준다.
					if(m_bIsExp)
					{
						tv.m_sInfo	= _T("");
						rb.GetXyMatchTvArrAndLine(tvArrExp[iSTT][iLEFT], tv.m_v1, tv.GetXyDir(), xyArrMatch);
						if(xyArrMatch.GetSize() > 0)
							tv.m_sInfo	+= "시점좌측가각부";

						rb.GetXyMatchTvArrAndLine(tvArrExp[iEND][iLEFT], tv.m_v1, tv.GetXyDir(), xyArrMatch);
						if(xyArrMatch.GetSize() > 0)
							tv.m_sInfo	+= "종점좌측가각부";
						
						rb.GetXyMatchTvArrAndLine(tvArrExp[iSTT][iRIGHT], tv.m_v1, tv.GetXyDir(), xyArrMatch);
						if(xyArrMatch.GetSize() > 0)
							tv.m_sInfo	+= "시점우측가각부";

						rb.GetXyMatchTvArrAndLine(tvArrExp[iEND][iRIGHT], tv.m_v1, tv.GetXyDir(), xyArrMatch);
						if(xyArrMatch.GetSize() > 0)
							tv.m_sInfo	+= "종점우측가각부";

						// 가각부에 걸리지 않는데, 시종점에 걸린다면 
						// 마지막철근의 위치정보를 따라가자.
						if(tv.m_sInfo.Find("가각부", 0) == -1 && bHalfVertRebar)
						{
							if(tvArr.GetSize() > 0)
							{
								tv.m_sInfo	= tvArr.GetAt(tvArr.GetSize()-1).m_sInfo;
							}
							else
								continue;
						}
					}
					//////////////////////////////////////////////////////////////////////////

					tvArr.Add(tv);
				}
				bVert	= TRUE;
			}
			
			// 강제 직방향 철근 추가할때는 사방향 철근 배근하지 않는다.
			if(vert == 1) continue;

			// 사방향 철근 추가
			long stt = 0; for(stt = 0; stt < 2; stt++)
			{
				BOOL bStt	= stt == iSTT;
				BOOL bInclude	= bStt ? bIncludeSttSpace : bIncludeEndSpace;
				if(!bInclude) continue;

				// 사방향 철근을 구할대 치수기입 목적이라면 절대로 직방향과 중복되서는 안된다.
				// 따라서 치수목적인데 직방향 철근이 이미 구해진 경우라면 사방향 철근을 추가하지 않는다.
				if((!bForDimRebarMain || !bVert) && (bInclude))	// 시점이나 종점이 교차될 경우 다시 구함.(시종점 사방향 철근)
				{
					double dStaStt	= GetStationOnJijum(0, 0, bVertDir);
					double dStaEnd	= GetStationOnJijum(m_nQtyJigan, 0, bVertDir);
					if(bVertDir)
					{
						dStaEnd	-= dStaStt;
						dStaStt	= 0;
					}
					double dLenMove	= bStt ? dSta - dStaStt : dSta - dStaEnd;
					tv	= GetTvJijum(bStt ? 0 : m_nQtyJigan, dLenMove);
					GetSwap(tv.m_v1, tv.m_v2);

					BOOL bApplyCover1	= FALSE;
					BOOL bApplyCover2	= FALSE;

					if(m_bIsExp)
					{
						rb.GetXyMatchTvArrAndLine(tvArrExp[iSTT][iLEFT], tv.m_v1, tv.GetXyDir(), xyArrMatch);
						if(xyArrMatch.GetSize() > 0)
						{
							tv.m_v2	= xyArrMatch.GetAt(0);
							tv.m_sInfo	= "시점좌측가각부";
							bApplyCover2	= TRUE;
						}

						rb.GetXyMatchTvArrAndLine(tvArrExp[iEND][iLEFT], tv.m_v1, tv.GetXyDir(), xyArrMatch);
						if(xyArrMatch.GetSize() > 0)
						{
							tv.m_v2	= xyArrMatch.GetAt(0);
							tv.m_sInfo	= "종점좌측가각부";
							bApplyCover2	= TRUE;
						}
						
						rb.GetXyMatchTvArrAndLine(tvArrExp[iSTT][iRIGHT], tv.m_v1, tv.GetXyDir(), xyArrMatch);
						if(xyArrMatch.GetSize() > 0)
						{
							tv.m_v1	= xyArrMatch.GetAt(0);
							tv.m_sInfo	= "시점우측가각부";
							bApplyCover1	= TRUE;
						}

						rb.GetXyMatchTvArrAndLine(tvArrExp[iEND][iRIGHT], tv.m_v1, tv.GetXyDir(), xyArrMatch);
						if(xyArrMatch.GetSize() > 0)
						{
							tv.m_v1	= xyArrMatch.GetAt(0);
							tv.m_sInfo	= "종점우측가각부";
							bApplyCover1	= TRUE;
						}
					}

					// 피복적용 //////////
					CTwinVectorArray tvArrPlane;
					GetTvRebarOut_Plane_UpperSlabStd(tvArrPlane, -1, FALSE);
					CTwinVector tvStt,  tvL, tvR;
					for (long nIx =0; nIx< tvArrPlane.GetSize(); nIx++)
					{
						CTwinVector tvPlan = tvArrPlane.GetAt(nIx);
						if(tvPlan.m_sInfo.Find("좌측") > -1 )
							tvL =  tvPlan;
						else if(tvPlan.m_sInfo.Find("우측") > -1 )
							tvR= tvPlan;
					}
					tvStt					= tvArrStt.GetAt(0);
					
					CDPoint xyMatch(0, 0);
					double dCoverSideL =0, dCoverSideR = 0;
					
					GetXyMatchLineAndLine(tvL.m_v1, tvL.GetXyDir(), tvStt.m_v1, tvStt.GetXyDir(), xyMatch);
					dCoverSideL	= (bVertDir && IsExtLine())? ~(xyMatch - tvStt.m_v2) : dCoverSide;
					if(dCoverSideL > dCoverSide * 3)
						dCoverSideL = dCoverSide;

					GetXyMatchLineAndLine(tvR.m_v2, tvR.GetXyDir(), tvStt.m_v2, tvStt.GetXyDir(TRUE), xyMatch);
					dCoverSideR	=  (bVertDir && IsExtLine())? ~(xyMatch - tvStt.m_v1) : dCoverSide;
					if(dCoverSideR > dCoverSide * 3)
						dCoverSideR = dCoverSide;


					double dCoverSide2	= dCoverSide/GetAngleJijum(bStt ? 0 : m_nQtyJigan).y;
					if(!bApplyCover1)
						tv.m_v1	= tv.m_v1 + tv.GetXyDir() * dCoverSideR;
					if(!bApplyCover2)
						tv.m_v2	= tv.m_v2 + tv.GetXyDir(TRUE) * dCoverSideL;
					///////////////////////

					// 중심선형과의 교차점을 미리 구해둠.
					rb.GetXyMatchTvArrAndSeg(tvArrCenter, tv.m_v1, tv.m_v2, xyArrMatchMid, FALSE);
					if(xyArrMatchMid.GetSize() > 0) 
						xyMatchMid	= xyArrMatchMid.GetAt(0);
					else
						xyMatchMid	= pLineBase->GetXyLineByLengthAndAngle(dSta, 0, xyDirDefaultRebar);


					if(nDrawLeft == -1)	// 진행방향 좌측만
					{
						tv.m_v1	= xyMatchMid;
					}
					else if(nDrawLeft == 0)	// 좌우측 모두
					{
					}
					else if(nDrawLeft == 1)	// 진행방향 우측만
					{
						tv.m_v2	= xyMatchMid;
					}	

					if(bStt)
					{
						tvArrAngStt.Add(tv);
					}
					else
					{
						tvArrAngEnd.Add(tv);
					}
				}
			}
		}

		// 직방향 철근을 모두 구한뒤에 직방향의 처음과 끝 sta을 찾아서 빈공간에 채워야 되는 직방향 철근을 찾아낸다.
		// 사보강배치 절반일 경우 사방향 철근은 정상적으로 배근되지만, 직방향 철근은 그만큼 비게 된다.
		// 비는 공간에 CTC간격으로 비는 만큼 채워주자.
		
		if(tvArr.GetSize() > 0)
		{
			if(nDrawLeft == -1)
			{
				pLine->GetStationMatchVerticalByXy(tvArr.GetAt(0).m_v1, dStaSttVertRebar);
				pLine->GetStationMatchVerticalByXy(tvArr.GetAt(tvArr.GetSize()-1).m_v1, dStaEndVertRebar);
			}
			else if(nDrawLeft == 1)
			{
				pLine->GetStationMatchVerticalByXy(tvArr.GetAt(0).m_v2, dStaSttVertRebar);
				pLine->GetStationMatchVerticalByXy(tvArr.GetAt(tvArr.GetSize()-1).m_v2, dStaEndVertRebar);
			}
			else if(nDrawLeft == 0)
			{
				pLine->GetStationMatchVerticalByXy(tvArr.GetAt(0).GetXyMid(), dStaSttVertRebar);
				pLine->GetStationMatchVerticalByXy(tvArr.GetAt(tvArr.GetSize()-1).GetXyMid(), dStaEndVertRebar);
			}
		}


		if(nType == 3)
		{
			dArr.RemoveAll();
			// 시점방향으로 채워야 되는 개수
			CTwinVector tvStt, tvEnd;//	= GettvTvJijum(0, -dWS);
			GetTvSttEndOfSlab(tvStt, tvEnd, FALSE);	// 가각부 빼고 계산해야 됨.
			double dStaMid		= 0;

			long nCountMax	= 1000;
			if(Compare(m_dDistSttJijumDirPlacing[upper], 0.0, ">"))
			{
				pLine->GetStationMatchVerticalByXy(tvStt.GetXyMid(), dStaMid);
				
				dStaSttVertRebar -= m_dCTC_SupportRebar[bUpperSlab ? iUPPER : iLOWER];
				while(dStaMid < dStaSttVertRebar)
				{
					dArr.Add(dStaSttVertRebar);
					dStaSttVertRebar -= m_dCTC_SupportRebar[bUpperSlab ? iUPPER : iLOWER];

					// 이렇게 되면 오류라고 봐도 됨..
					// 어차피 너무 많으면 느려서 진행할 수 없음
					if(dArr.GetSize() > nCountMax) break;
				}
			}

			// 종점방향으로 채우기
			//CTwinVector tvEnd	= GetTvJijum(m_nQtyJigan, dWE);
			if(Compare(m_dDistEndJijumDirPlacing[upper], 0.0, ">"))
			{
				pLine->GetStationMatchVerticalByXy(tvEnd.GetXyMid(), dStaMid);

				dStaEndVertRebar += m_dCTC_SupportRebar[bUpperSlab ? iUPPER : iLOWER];
				while(dStaMid > dStaEndVertRebar)
				{
					CDPoint xy(0, 0);
					xy	= pLine->GetXyLine(dStaEndVertRebar);
					dArr.Add(dStaEndVertRebar);
					dStaEndVertRebar += m_dCTC_SupportRebar[bUpperSlab ? iUPPER : iLOWER];

					// 이렇게 되면 오류라고 봐도 됨..
					// 어차피 너무 많으면 느려서 진행할 수 없음
					if(dArr.GetSize() > nCountMax) break;
				}
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////
	}

	if(nDrawLeft == 0)
	{
		if(bUpperSlab)
		{
			m_tvArr_RebarSupport_Plane[nDan][upper].AddFromTvArray(tvArr);
			m_tvArrAngStt_RebarSupport_Plane[nDan][upper].AddFromTvArray(tvArrAngStt);
			m_tvArrAngEnd_RebarSupport_Plane[nDan][upper].AddFromTvArray(tvArrAngEnd);
			m_tvArrRAngStt_RebarSupport_Plane[nDan][upper].AddFromTvArray(tvArrRAngStt);
			m_tvArrRAngEnd_RebarSupport_Plane[nDan][upper].AddFromTvArray(tvArrRAngEnd);
		}
		else
		{
			m_tvArr_RebarSupport_LowerPlane[nDan][upper].AddFromTvArray(tvArr);
			m_tvArrAngStt_RebarSupport_LowerPlane[nDan][upper].AddFromTvArray(tvArrAngStt);
			m_tvArrAngEnd_RebarSupport_LowerPlane[nDan][upper].AddFromTvArray(tvArrAngEnd);
			m_tvArrRAngStt_RebarSupport_LowerPlane[nDan][upper].AddFromTvArray(tvArrRAngStt);
			m_tvArrRAngEnd_RebarSupport_LowerPlane[nDan][upper].AddFromTvArray(tvArrRAngEnd);
		}
	}
}

// 평면도 상부슬래브 전단철근 좌표
// 수직보강과 사보강
// 일단 수직보강에 대해서만 작업한다.
// BOOL bForBM : 집계용일땐 각도 고려 안 해도 됨..(속도개선)
// BOOL bNormal : 일반부(변화치수아닌거), BOOL bHunch : 헌치부(변화치수인거),
void CRcBridgeRebar::GetTvRebarShear_Plane_UpperSlab(CTwinVectorArray &tvArr, BOOL bForBM, BOOL bNormal, BOOL bHunch, BOOL bRib)
{
	tvArr.RemoveAll();

	BOOL bVertDir		= IsVertDir();
	if(bVertDir)
	{
		GetTvRebarShear_Plane_UpperSlab_Vert(tvArr, bForBM, bNormal, bHunch, bRib);
		return;
	}


	CLineInfo *pLine	= GetLineBase();
	if(!pLine) return;

	// 전단철근 제원
	double dLenShear	= GetLenShearUpperSlab();

	// 배치 되는 sta 모두 찾음
	CDoubleArray dArrSta;
	CTwinVectorArray tvArrVert, tvArrHunch, tvArrRib;
	CTwinVectorArray tvArrTot;
	GetTvRebarShear_VertSection_UpperSlab(tvArrVert, tvArrHunch, tvArrRib);
	if(bNormal)
		tvArrTot.AddFromTvArray(tvArrVert);
	if(bHunch)
		tvArrTot.AddFromTvArray(tvArrHunch);
	if(bRib)
		tvArrTot.AddFromTvArray(tvArrRib);
	
	long nSizeTot	= tvArrTot.GetSize();
	CTwinVector tv;
	long i = 0; for(i = 0; i < nSizeTot; i++)
	{
		tv	= tvArrTot.GetAt(i);
		dArrSta.Add(tv.m_v1.x);
	}
	dArrSta.Sort();

	// 전단철근 그릴때 필요한 영역 ////////////
	CRebarPlacing rb;
	CTwinVectorArray tvArrCuttingArea;
	GetTvCuttingArea_UpperSlab_Shear(tvArrCuttingArea, -1);
	CTwinVector tvArea	= tvArrCuttingArea.GetAt(0);
	CDPoint xyCen		= rb.GetXyCircleCenter(tvArea.m_v1, tvArea.m_v2, tvArea.m_v2.z, tvArea.m_v1.z == -1);
	double dStaCen		= m_dStationBridgeStt;
	pLine->GetStationMatchVerticalByXy(xyCen, dStaCen);
	double dStaLimitL	= dStaCen - fabs(tvArea.m_v2.z*2);
	double dStaLimitR	= dStaCen + fabs(tvArea.m_v2.z*2);
	//////////////////////////////////////////////


	// 각 스테이션 별로 배치되는 전단철근 찾음.
	CTwinVectorArray tvArrCross, tvArrCross2;
	GetTvRebarShear_CrossSection_UpperSlab(tvArrCross, tvArrCross2, dArrSta.GetSize() > 0 ? dArrSta.GetAt(0) : m_dStationBridgeStt, 0);

	CTwinVector tvShear;
	CDPoint xy(0, 0), xyR(0, 0);
	double dDiffStaForVert = GetDiffStationSupportForVert();
	
	CDPoint xyDirSup	= CDPoint(0, 1);	// 해당 sta의 배력철근의 각도
	CDPoint xyDirShearReal	= CDPoint(0, 1);	// 전단철근 그리는 방위각
	BOOL bAddAtFirst	= TRUE;
	long nSizeSta		= dArrSta.GetSize();
	for(i = 0; i < nSizeSta; i++)
	{
		double dSta	= 0;
		dSta		= dArrSta.GetAt(i);

		// 집계를 위해서가 아닐땐 실제로 그려주는 곳만 구하면 됨.
		if(!bForBM)
		{
			// (ARCBRIDGE-2898) 배력철근 사보강 배치일때 종단면에서의 Station에서 직구간 배력철근을 보정해서 그래고 있다
			// 배력철근에 맞춰주기 위해서 전단철근도 Station을 맞춘다.
			dSta -= dDiffStaForVert;
			if(dSta < dStaLimitL || dSta > dStaLimitR) continue;
		}


		// 주철근에 대한 배력근의 각도를 구해야됨 /////////////////////////
		// 실제로 사보강일때만 좌우끝부분에 사방향 배력근이 있고 나머지는 모두 지점각도???
		switch(GetDirSupportRebar(dSta, TRUE))
		{
			case -1: 
				xyDirSup	= GetAngleJijum(0); 
				xyDirShearReal	= xyDirSup;
				break;	// 시점각도기준
			case 0: 
				xyDirSup	= CDPoint(0, 1);
				xyDirShearReal	= CDPoint(0, 1);
				break;	// 직방향
			case 1:
				xyDirSup	= GetAngleJijum(m_nQtyJigan); 
				xyDirShearReal	= xyDirSup;
				break;	// 종점각도기준
			default: 
				xyDirSup	= CDPoint(0, 1);
				xyDirShearReal	= xyDirSup;
				break;
		}

		if(m_nTypePlacingMainRebar_UpperSlab==1 || m_nTypePlacingMainRebar_UpperSlab==2)
		{
			xyDirShearReal	= CDPoint(0, 1);
		}
		////////////////////////////////////////////////////////////////////
		
		// 각 sta에 배치되는 전단철근
		// 횡단면상 좌에서 우로니까, 평면상에서는 진행방향 우에서 좌로 배치됨
		
		CTwinVector tv;
		long nIdxStt	= bAddAtFirst ? 0 : 1;
		long j = 0; for(j = nIdxStt; j < tvArrCross.GetSize()-(nIdxStt+1); j+=2)
		{
			double dDist	= 0;
			tv		= tvArrCross.GetAt(j);
			dDist	= tv.m_v1.x/xyDirShearReal.y;

			tvShear.m_v1	= pLine->GetXyLineByLengthAndAngle(dSta, dDist, xyDirSup);
			tvShear.m_v2	= pLine->GetXyLineByLengthAndAngle(dSta, dDist+dLenShear/xyDirShearReal.y, xyDirSup);
			if(i == 0)
				tvShear.m_sInfo	= "시작1";
			else if(i == 1)
				tvShear.m_sInfo	= "시작2";
			else if(i == nSizeSta-2)
				tvShear.m_sInfo	= "끝1";
			else if(i == nSizeSta-1)
				tvShear.m_sInfo	= "끝2";
			else
				tvShear.m_sInfo	= "";
			tvArr.Add(tvShear);
		}
		bAddAtFirst	= !bAddAtFirst;
	}
}

// 상부 슬래브 배근시 2cycle부분 절단할 좌표(상부슬래브 내측)
// nIdxInWall 은 내측벽체가 있을 경우에만 해당됨
// void CRcBridgeRebar::GetTvCuttingArea_Plane_UpperSlabInner(CTwinVectorArray &tvArr, BOOL bLeft, long nIdxInWall)
// {
// 	tvArr.RemoveAll();
// 
// 	// 트랙형 CuttingArea의 제원
// 	double dLenHor	= 5000;	// 수평 라인
// 	double dR		= 1000;	// 원 반지름
// 	double dSta		= 0;	// 트랙의 무게중심위치.
// 	double dOffset	= 0;	// 트랙의 무게중심위치의 두께 방향 거리
// 
// 	long nCountInWall	= GetCountInWall();
// 	BOOL bInWall		= nCountInWall > 0;
// 	if(bInWall)
// 	{
// 		if(nCountInWall <= nIdxInWall)
// 			nIdxInWall = nCountInWall-1;
// 		
// 		if(nIdxInWall < 0) nIdxInWall = 0;
// 	}
// 
// 	// 트랙의 무게중심 위치 구함
// 	dSta	= bInWall ? GetStationOnJijum(nIdxInWall+1, 0) : m_dStationBridgeStt+m_dLengthBridge/2;
// 
// 	// 트랙의 수평길이 구함.
// 	double dStaPrev	= bInWall ? GetStationOnJijum(nIdxInWall, 0) : m_dStationBridgeStt;
// 	double dStaNext	= bInWall ? GetStationOnJijum(nIdxInWall+2, 0) : m_dStationBridgeStt+m_dLengthBridge;
// 	dLenHor			= (dStaNext - dStaPrev)/3;
// 
// 	// 트랙의 R 구함.
// 	double dWidth	= GetWidthSlabAct(dSta, CDPoint(0, 1), bLeft ? -1 : 1);	// 두께 
// 	dR				= dWidth / 4;
// 
// 	// 트랙의 무게 중심의 두께방향 거리
// 	dOffset			= bLeft ? -dWidth / 2 : dWidth / 2;
// 
// 	// 구해진 제원들로 tvArr 생성 ///////////////////////
// 	CWallApp *pWall	= GetInWall(nIdxInWall);
// 	CDPoint vAng	= bInWall ? CDPoint(0, 1) : ToDPointFrDegree(pWall->m_dAnglePath);
// 
// 	// 우측원부터 위로..
// 	CDPoint xyDirHor	= ToDPointFrDegree(180-GetXyDirRotateDomByBridgeSttEndXy().GetAngleDegree());
// 	CDPoint xyDirVer	= xyDirHor.Rotate90();
// 	CLineInfo *pLine	= GetLineBase();
// 	CDPoint xyOrg		= pLine->GetXyLineByLengthAndAngle(dSta, dOffset, vAng);
// 	CDPoint xyCenL		= pLine->GetXyLineByLengthAndAngle(dSta-dLenHor/2, dOffset, vAng);
// 	CDPoint xyCenR		= pLine->GetXyLineByLengthAndAngle(dSta+dLenHor/2, dOffset, vAng);
// 
// 	CTwinVector tv;
// 	tv.m_v1		= xyCenR + (xyDirVer*-dR);//CVector(xyCenR.x, xyCenR.y-dR, -1);
// 	tv.m_v1.z	= -1;
// 	tv.m_v2		= tv.m_v1 + (xyDirVer*(dR*2)); //CVector(tv.m_v1.x, tv.m_v1.y+dR*2, dR);
// 	tv.m_v2.z	= dR;
// 	tvArr.Add(tv);
// 
// 	tv.m_v1		= tv.m_v2;
// 	tv.m_v1.z	= 0;
// 	tv.m_v2		= tv.m_v1 + (xyDirHor * -dLenHor);//CVector(tv.m_v1.x - dLenHor, tv.m_v1.y, 0);
// 	tv.m_v2.z	= 0;
// 	tvArr.Add(tv);
// 
// 	tv.m_v1		= tv.m_v2;
// 	tv.m_v1.z	= -1;
// 	tv.m_v2		= tv.m_v1 + (xyDirVer * (-dR*2));//CVector(tv.m_v1.x, tv.m_v1.y-dR*2, dR);
// 	tv.m_v2.z	= dR;
// 	tvArr.Add(tv);
// 
// 	tv.m_v1		= tv.m_v2;
// 	tv.m_v1.z	= 0;
// 	tv.m_v2		= tv.m_v1 + (xyDirHor * dLenHor);//CVector(tv.m_v1.x + dLenHor, tv.m_v1.y, 0);
// 	tv.m_v2.z	= 0;
// 		
// 	tvArr.Add(tv);
// }

// 임시로 만든 함수
// 선형정보를 가진 tvLine를 tvArrArea 안이나 밖의 것만 걸러낸다.
// 중심선형을 기준으로 함
// void CRcBridgeRebar::GetTvLineByCrossTvArrayArea(CTwinVectorArray &tvArrLine, CTwinVectorArray &tvArrArea, BOOL bInner)
// {
// 	CLineInfo *pLine	= GetLineBase();
// 	if(!pLine) return;
// 	if(tvArrLine.GetSize() == 0) return;
// 
// 	CRebarPlacing rb;
// 
// 	// tvLine 설명
// 	// 1. tvLine.m_v1.x : 시작sta
// 	// 2. tvLine.m_v2.x : 끝sta
// 	// 3. tvLine.m_v2.z : offset 거리
// 	CTwinVector tvLine	= tvArrLine.GetAt(0);
// 	tvArrLine.RemoveAll();
// 	double dOffset	= tvLine.m_v2.z;
// 	double dStaStt	= tvLine.m_v1.x;
// 	double dStaEnd	= tvLine.m_v2.x;
// 	CDPoint vAngStt	= CDPoint(0, 1);
// 	CDPoint vAngEnd	= CDPoint(0, 1);
// 
// 	// 미리처리할 문제
// 	// 선형자체가 영역에 완전히 포함된 경우를 알아야 된다.
// 	// 그래야 교차점이 없는경우를 처리할 수 있다.
// 	BOOL bIncludeLine	= FALSE;
// 	CVectorArray vecArrArea;
// 	CDPoint xy1	= pLine->GetXyLineByLengthAndAngle(dStaStt, dOffset, vAngStt);
// 	CDPoint xy2	= pLine->GetXyLineByLengthAndAngle(dStaEnd, dOffset, vAngEnd);
// 	tvArrArea.GetToVectorArray(vecArrArea);
// 	if(rb.CheckXyByVectorArrayArea(xy1, vecArrArea, TRUE) &&
// 		rb.CheckXyByVectorArrayArea(xy1, vecArrArea, TRUE))
// 		bIncludeLine	= TRUE;
// 
// 
// 
// 	// 임시로 만든거기 때문에 상당히 어설픈 코드
// 	// area와 교차되는 점이 2개가 되어야만 가능함. 2004.10.14 - 차차 업그레이드 할 예정(엄청 난형일 경우 제대로 안 나올 수도 있음)
// 	CDoubleArray dArrMatchSta;	// 교차점이 있는 곳의 모든 sta
// 	CTwinVector tv;
// 	double staResult1	= 0;
// 
// 	// 일단 모든 교차점을 구함.
// 	long nSize	= tvArrArea.GetSize();
// 	long i = 0; for(i = 0; i < nSize; i++)
// 	{
// 		tv	= tvArrArea.GetAt(i);
// 		if(tv.m_v1.z == 0)
// 		{
// 			if(pLine->GetStationMatchSegment(tv.m_v1, tv.m_v2, staResult1, dOffset))
// 			{
// 				dArrMatchSta.Add(staResult1);
// 			}
// 		}
// 		else if(tv.m_v1.z == 1 || tv.m_v2.z == -1)
// 		{
// 			CDPoint xyCen	= rb.GetXyCircleCenter(tv.m_v1, tv.m_v2, tv.m_v2.z, tv.m_v1.z == -1);
// 			CDPoint vAngStt	= (tv.m_v1-xyCen).Unit();
// 			CDPoint vAngEnd	= (tv.m_v2-xyCen).Unit();
// 			if(pLine->GetStationMatchArc(xyCen, tvLine.m_v2.z, vAngStt, vAngEnd, staResult1, dOffset))
// 			{
// 				dArrMatchSta.Add(staResult1);
// 			}
// 		}
// 	}
// 
// 	// 교차점 구한뒤.. 시작 스테이션과 가까운 순서대로 골라냄.
// 	dArrMatchSta.Sort(TRUE);
// 
// 	// bInner에 맞게 골라냄
// 	nSize	= dArrMatchSta.GetSize();
// 	if(nSize > 0)
// 	{
// 		if(bInner)
// 		{
// 			for(i = 0; i < nSize-1; i+=2)
// 			{
// 				tvLine.m_v1.x	= dArrMatchSta[i];
// 				tvLine.m_v2.x	= dArrMatchSta[i+1];
// 				tvLine.m_v2.z	= dOffset;
// 				tvArrLine.Add(tvLine);
// 			}
// 
// 			// 홀수개이면 마지막에 하나를 저장
// 			if(nSize%2 == 1 && nSize > 0)
// 			{
// 				tvLine.m_v1.x	= dArrMatchSta[nSize-1];
// 				tvLine.m_v2.x	= dStaEnd;
// 				tvLine.m_v2.z	= dOffset;
// 				tvArrLine.Add(tvLine);
// 			}
// 		}
// 		else
// 		{
// 			tvLine.m_v1.x	= dStaStt;
// 			for(i = 0; i < nSize-1; i+=2)
// 			{
// 				tvLine.m_v2.x	= dArrMatchSta[i];
// 				tvLine.m_v2.z	= dOffset;
// 				tvArrLine.Add(tvLine);
// 
// 				tvLine.m_v1.x	= dArrMatchSta[i+1];
// 			}
// 			
// 			// 짝수개이면 마지막에 하나 저장
// 			if(nSize%2 == 1 && nSize > 0)
// 			{
// 				tvLine.m_v2.x	= dArrMatchSta[nSize-1];
// 				tvLine.m_v2.z	= dOffset;
// 				tvArrLine.Add(tvLine);
// 			}
// 			else
// 			{
// 				tvLine.m_v2.x	= dStaEnd;
// 				tvLine.m_v2.z	= dOffset;
// 				tvArrLine.Add(tvLine);
// 			}
// 		}
// 	}
// 	else
// 	{
// 		// 교차점이 없는 경우
// 		if((bInner && bIncludeLine) || (!bInner && !bIncludeLine))
// 		{
// 			tvLine.m_v1.x	= dStaStt;
// 			tvLine.m_v2.x	= dStaEnd;
// 			tvLine.m_v2.z	= dOffset;
// 			tvArrLine.Add(tvLine);
// 		}
// 	}
// }


// void CRcBridgeRebar::GetTvLineArrayByCrossTvArrayArea(CTwinVectorArray &tvArrLine, CTwinVectorArray &tvArrArea, BOOL bInner)
// {
// 	CTwinVectorArray tvArrTmp;
// 	CTwinVectorArray tvArrResult;
// 	long nSize	= tvArrLine.GetSize();
// 
// 
// 	long i = 0; for(i = 0; i < nSize; i++)
// 	{
// 		tvArrTmp.RemoveAll();
// 		tvArrTmp.Add(tvArrLine[i]);
// 
// 		GetTvLineByCrossTvArrayArea(tvArrTmp, tvArrArea, bInner);
// 
// 		// 구한뒤.
// 		tvArrResult.AddFromTvArray(tvArrResult);
// 	}
// }

// 날개벽 A구간 수평 철근
void CRcBridgeRebar::MakeWingWallRebarJewonHorA(BOOL bStt, BOOL bLeft, int nOut, int nDan)
{
	CWingWall* pWing = GetWingWall(bStt, bLeft);
	if(nDan == 1 && pWing->m_nCountLayerA[nOut] == 1) return;

	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();
	const double dMulti = bLsd? 10 : 1;

	// 철근 초기화
	int nDanIdx = nDan == 0 ? 0 : WW_REBAR_COUNT;
	int nRBIndex = nOut==0 ? WW_REBAR_SLOPE_A_IN : WW_REBAR_SLOPE_A_OUT;

 	CRebar* pRB = NULL;
// 	CRebar* pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
// 	pRB->InitData();
// 	nRBIndex = nOut==0 ? WW_REBAR_HOR_A_IN : WW_REBAR_HOR_A_OUT;
// 	pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
// 	pRB->InitData();
// 	if(nOut==0)
// 	{
// 		nRBIndex = WW_REBAR_HOR_A_IN_VAR_SEC;
// 		pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
// 		pRB->InitData();
// 		nRBIndex = WW_REBAR_HOR_A_IN_VAR_SEC_BLOCK;
// 		pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
// 		pRB->InitData();
// 	}
	//////////////

	double dL1 = pWing->m_dL1;
	double dL2 = pWing->m_dL2;
	if(dL2==0) return;

	vector<double> len_slope, len_hor, len_var_sec, len_var_sec_block;
	CTwinVector tv;
	CTwinVectorArray tvArr;
	GetTvArrayRebarWingWallBlockAMainFront(tvArr, bStt, bLeft, nOut, nDan);
	int nSize = tvArr.GetSize();
	if(nSize==0) return;

	int i=0; for(i=0; i<nSize; i++)
	{
		tv = tvArr.GetAt(i);
		if(tv.m_sInfo==_T("상단경사A"))
			len_slope.push_back(tv.GetLength());
		if(tv.m_sInfo==_T("수평A"))
			len_hor.push_back(tv.GetLength());
		if(tv.m_sInfo==_T("수평변단면A"))
			len_var_sec.push_back(tv.GetLength());
		if(tv.m_sInfo==_T("수평변단면구간A"))
			len_var_sec_block.push_back(tv.GetLength());
	}

	double dT1 = pWing->m_dT1;
	double dT2 = pWing->m_dT2;
	double dCoverIn = m_dCoverWingIn[0];
	double dCoverOut = m_dCoverWingOut[0];
	double dCover = nOut==0 ? dCoverIn : dCoverOut;
	double dCTC = nOut==0 ? pWing->m_dMainCTCA/2 : pWing->m_dMainCTCA;
	double dDia = pWing->m_dDiaMainA[nOut][nDan];
	double dSettle(0);
	if(m_pARcBridgeDataStd->IsLsdDesign())
	{
		SRebarEnvOption LsdRebarOpt;
		SetRebarLsdOptionWingWall(&LsdRebarOpt, bStt, bLeft, nOut==0, WINGWALL_SECTA, TRUE);
		dSettle = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueSettle(dDia, &LsdRebarOpt);
	}
	else
	{
		dSettle = m_pARcBridgeDataStd->GetValueSettle(dDia, SETTLE_TENS_NORMAL, toCm(dCover), toCm(dCTC));
	}
	CDPoint vWing = GetAngleWingWallBetweenWall(bStt, bLeft);
	int nBaseRebar = 0;

	nRBIndex = nOut==0 ? WW_REBAR_SLOPE_A_IN : WW_REBAR_SLOPE_A_OUT;
	pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
	if(pRB && pRB->m_bLock == FALSE)
	{
		pRB->InitData();
		pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
		pRB->m_nPos = nOut==0 ? REBAR_POS_WING_BACK : REBAR_POS_WING_FRONT;
		pRB->m_nIdxNumber = nRBIndex;
		pRB->m_sMark = _T("W1");
		pRB->m_sDescription = _T("수평경사철근A");
		pRB->m_dDia = pWing->m_dDiaMainA[nOut][nDan];
		pRB->m_nEa = len_slope.size();
		if(pRB->m_nEa>0)
		{
			nBaseRebar = dL1==0 ? (nOut==0 ? 33 : 2) : 2;
			pRB->m_nTypeRebar = GetWingWallRebarDetail(bStt, bLeft, nBaseRebar);
			pRB->m_dLengthMax_A = *max_element(len_slope.begin(), len_slope.end());
			pRB->m_dLengthMin_A = *min_element(len_slope.begin(), len_slope.end());
			pRB->m_dLengthMax_B = (dL1==0 && nOut==0) ? dT1-dCoverIn-dCoverOut : dSettle;
			pRB->m_dLengthMax_C = (dL1==0 && nOut==0) ? dSettle : 0;
			pRB->m_dAngleX1 = vWing.GetAngleDegree();
		}
		pRB->m_bMainRebar = TRUE;
		pRB->m_dRateAdd	= MAKE_RATE;
		SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTA, TRUE);
		if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
			pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
	}

	nRBIndex = nOut==0 ? WW_REBAR_HOR_A_IN : WW_REBAR_HOR_A_OUT;
	pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
	if(pRB && pRB->m_bLock == FALSE)
	{
		pRB->InitData();
		pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
		pRB->m_nPos = nOut==0 ? REBAR_POS_WING_BACK : REBAR_POS_WING_FRONT;
		pRB->m_nIdxNumber = nRBIndex;
		pRB->m_sMark = _T("W2");
		pRB->m_sDescription = _T("수평철근A");
		pRB->m_dDia = pWing->m_dDiaMainA[nOut][nDan];
		pRB->m_nEa = len_hor.size();
		if(pRB->m_nEa>0)
		{
			nBaseRebar = dL1==0 ? (nOut==0 ? 33 : 2) : 2;
			pRB->m_nTypeRebar = GetWingWallRebarDetail(bStt, bLeft, nBaseRebar);
			pRB->m_dLengthMax_A = *max_element(len_hor.begin(), len_hor.end());
			pRB->m_dLengthMin_A = *min_element(len_hor.begin(), len_hor.end());
			pRB->m_dLengthMax_B = (dL1==0 && nOut==0) ? dT2-dCoverIn-dCoverOut : dSettle;
			pRB->m_dLengthMin_B = (dL1==0 && nOut==0) ? dT1-dCoverIn-dCoverOut : dSettle;
			pRB->m_dLengthMax_C = (dL1==0 && nOut==0) ? dSettle : 0;
			pRB->m_dAngleX1 = vWing.GetAngleDegree();
		}
		pRB->m_bMainRebar = TRUE;
		pRB->m_dRateAdd	= MAKE_RATE;
		SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTA, TRUE);
		if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
			pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
	}

	if(nOut==0)
	{
		nRBIndex = WW_REBAR_HOR_A_IN_VAR_SEC;
		pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
		if(pRB && pRB->m_bLock == FALSE)
		{
			pRB->InitData();
			pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
			pRB->m_nPos = REBAR_POS_WING_BACK;
			pRB->m_nIdxNumber = nRBIndex;
			pRB->m_sMark = _T("W3");
			pRB->m_sDescription = _T("변단면수평철근A");
			pRB->m_dDia = pWing->m_dDiaMainA[nOut][nDan];
			pRB->m_nEa = len_var_sec.size();
			if(pRB->m_nEa>0)
			{
				pRB->m_nTypeRebar = 47;
				pRB->m_dLengthMax_A = *max_element(len_var_sec.begin(), len_var_sec.end());
				pRB->m_dLengthMin_A = *min_element(len_var_sec.begin(), len_var_sec.end());
				pRB->m_dLengthMax_B = dSettle;
				CDPoint xyVar[3];
				GetXyRebarWingWallVaryPlane(xyVar, bStt, bLeft);
				pRB->m_dLengthMax_C = ~(xyVar[2]-xyVar[0]);
				pRB->m_dAngleX1 = vWing.GetAngleDegree();
			}
			pRB->m_bMainRebar = TRUE;
			pRB->m_dRateAdd	= MAKE_RATE;
			SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTA, TRUE);
			if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
				pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
			m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
		}
	}

	nRBIndex = nOut==0 ? WW_REBAR_HOR_A_IN_VAR_SEC_BLOCK : WW_REBAR_HOR_A_OUT_VAR_SEC_BLOCK;
	pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
	if(pRB && pRB->m_bLock == FALSE)
	{
		pRB->InitData();
		pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
		pRB->m_nPos = nOut==0 ? REBAR_POS_WING_BACK : REBAR_POS_WING_FRONT;
		pRB->m_nIdxNumber = nRBIndex;
		pRB->m_sMark = _T("W4");
		pRB->m_sDescription = _T("변단면구간수평철근A");
		pRB->m_dDia = pWing->m_dDiaMainA[nOut][nDan];
		pRB->m_nEa = len_var_sec_block.size();
		if(pRB->m_nEa>0)
		{
			nBaseRebar = nOut==0 ? 33 : 2;
			pRB->m_nTypeRebar = GetWingWallRebarDetail(bStt, bLeft, nBaseRebar);
			pRB->m_dLengthMax_A = *max_element(len_var_sec_block.begin(), len_var_sec_block.end());
			pRB->m_dLengthMin_A = *min_element(len_var_sec_block.begin(), len_var_sec_block.end());
			pRB->m_dLengthMax_B = (nOut==0)? dT2-dCoverIn-dCoverOut : dSettle;
			pRB->m_dLengthMin_B = (nOut==0)? dT1-dCoverIn-dCoverOut : dSettle;
			pRB->m_dLengthMax_C = (nOut==0)? dSettle : 0;
			pRB->m_dAngleX1 = vWing.GetAngleDegree();
		}
		pRB->m_bMainRebar = TRUE;
		pRB->m_dRateAdd	= MAKE_RATE;
		SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTA, TRUE);
		if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
			pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
	}
}

// 날개벽 A구간 수직 철근
void CRcBridgeRebar::MakeWingWallRebarJewonVerA(BOOL bStt, BOOL bLeft, int nOut, int nDan)
{
	CWingWall* pWing = GetWingWall(bStt, bLeft);
	if(nDan == 1 && pWing->m_nCountLayerA[nOut] == 1) return;

	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();
	const double dMulti = bLsd? 10 : 1;

	// 철근 초기화
	int nDanIdx = nDan == 0 ? 0 : WW_REBAR_COUNT;
	int nRBIndex = nOut==0 ? WW_REBAR_VER_A_IN : WW_REBAR_VER_A_OUT;

	CRebar* pRB = NULL;
// 	CRebar* pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
// 	pRB->InitData();
// 	if(nOut==0)
// 	{
// 		nRBIndex = WW_REBAR_VER_A_IN_VAR_SEC;
// 		pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
// 		pRB->InitData();
// 	}
	//////////////

	double dL2 = pWing->m_dL2;
	if(dL2==0) return;

	vector<double> len_ver, len_var;
	CTwinVector tv;
	CTwinVectorArray tvArr;
	GetTvArrayRebarWingWallBlockASupportFront(tvArr, bStt, bLeft, nOut, nDan);
	int nSize = tvArr.GetSize();

	int i=0; for(i=0; i<nSize; i++)
	{
		tv = tvArr.GetAt(i);
		if(tv.m_sInfo==_T("수직A"))
			len_ver.push_back(tv.GetLength());
		if(tv.m_sInfo==_T("변단면수직A"))
			len_var.push_back(tv.GetLength());
	}

	double dCoverIn = m_dCoverWingIn[0];
	double dCoverOut = m_dCoverWingOut[0];
	double dCover = nOut==0 ? dCoverIn : dCoverOut;
	double dCTC = nOut==0 ? pWing->m_dStdVerCTC/2 : pWing->m_dStdVerCTC;
	double dT1 = pWing->m_dT1;
	double dT2 = pWing->m_dT2;
	double dSH = pWing->m_dSH;

	BOOL bVar = IsWingWallVariableSect(bStt, bLeft);
	CDPoint xyVar[3];
	GetXyRebarWingWallVarySect(xyVar, bStt, bLeft);
	double dLenHu = ~(xyVar[2]-xyVar[0]);

	nRBIndex = nOut==0 ? WW_REBAR_VER_A_IN : WW_REBAR_VER_A_OUT;
	pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
	if(pRB && pRB->m_bLock == FALSE)
	{
		pRB->InitData();
		pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
		pRB->m_nPos = nOut==0 ? REBAR_POS_WING_BACK : REBAR_POS_WING_FRONT;
		pRB->m_nIdxNumber = nRBIndex;
		pRB->m_sMark = _T("W8");
		pRB->m_sDescription = _T("수직철근A");
		pRB->m_dDia = pWing->m_dDiaSupportA[nOut][nDan];
		pRB->m_nEa = len_ver.size();
		if(pRB->m_nEa>0)
		{
			if(nOut==0 && bVar && dT1>dT2)
			{
				pRB->m_nTypeRebar = 13;
				pRB->m_dLengthMax_A = dT1 - (dCoverIn+dCoverOut);
				pRB->m_dLengthMin_A = 0;
				pRB->m_dLengthMax_B = *max_element(len_ver.begin(), len_ver.end());
				pRB->m_dLengthMin_B = *min_element(len_ver.begin(), len_ver.end());
				pRB->m_dLengthMax_C = dLenHu;
				pRB->m_dAngleX1 = CDPoint(-dSH, 1).Unit().GetAngleDegree();
			}
			else
			{
				pRB->m_nTypeRebar = (nOut==0)? 2:1;
				pRB->m_dLengthMax_A = *max_element(len_ver.begin(), len_ver.end());
				pRB->m_dLengthMin_A = *min_element(len_ver.begin(), len_ver.end());
				pRB->m_dLengthMax_B = (nOut==0)? dT1 - (dCoverIn+dCoverOut) : 0;
				pRB->m_dLengthMin_B = 0;
				pRB->m_dLengthMax_C = 0;
				pRB->m_dAngleX1 = 0;
			}
		}
		pRB->m_bMainRebar = FALSE;
		pRB->m_dRateAdd	= MAKE_RATE;
		SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTA, FALSE);
		if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
			pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
	}

	if(nOut==0)
	{
		nRBIndex = WW_REBAR_VER_A_IN_VAR_SEC;
		pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
		if(pRB && pRB->m_bLock == FALSE)
		{
			pRB->InitData();
			pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
			pRB->m_nPos = REBAR_POS_WING_BACK;
			pRB->m_nIdxNumber = nRBIndex;
			pRB->m_sMark = _T("W8");
			pRB->m_sDescription = _T("변단면수직철근A");
			pRB->m_dDia = pWing->m_dDiaSupportA[nOut][nDan];
			pRB->m_nEa = len_var.size();
			if(pRB->m_nEa>0)
			{
				pRB->m_nTypeRebar = dT1<dT2 ? 8 : 1;
				pRB->m_dLengthMax_A = *max_element(len_var.begin(), len_var.end());
				pRB->m_dLengthMin_A = *min_element(len_var.begin(), len_var.end());
				pRB->m_dLengthMax_B = dT1<dT2 ? dLenHu : 0;
				pRB->m_dAngleX1 = dT1<dT2 ? CDPoint(-dSH, 1).Unit().GetAngleDegree() : 0;
			}
			pRB->m_bMainRebar = FALSE;
			pRB->m_dRateAdd	= MAKE_RATE;
			SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTA, FALSE);
			if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
				pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
			m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
		}
	}
}

// 날개벽 B구간 수평 철근
void CRcBridgeRebar::MakeWingWallRebarJewonHorB(BOOL bStt, BOOL bLeft, int nOut, int nDan)
{
	CWingWall* pWing = GetWingWall(bStt, bLeft);
	if(nDan == 1 && pWing->m_nCountLayerB[nOut] == 1) return;

	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();
	const double dMulti = bLsd? 10 : 1;

	// 철근 초기화
	int nDanIdx = nDan == 0 ? 0 : WW_REBAR_COUNT;
	int nRBIndex = nOut==0 ? WW_REBAR_HOR_B_IN_VAR : WW_REBAR_HOR_B_OUT_VAR;

	CRebar* pRB = NULL;
// 	CRebar* pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
// 	pRB->InitData();
// 	nRBIndex = nOut==0 ? WW_REBAR_HOR_B_IN : WW_REBAR_HOR_B_OUT;
// 	pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
// 	pRB->InitData();
// 	if(nOut==0)
// 	{
// 		nRBIndex = WW_REBAR_HOR_B_IN_VAR_SEC;
// 		pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
// 		pRB->InitData();
// 		nRBIndex = WW_REBAR_HOR_B_IN_VAR_SEC_VAR;
// 		pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
// 		pRB->InitData();
// 	}
// 	//////////////

	double dL2 = pWing->m_dL2;
	if(dL2==0) return;

	vector<double> len_var, len_hor, len_var_sec, len_var_sec_var;
	CTwinVector tv;
	CTwinVectorArray tvArr;
	GetTvArrayRebarWingWallBlockBMainFront(tvArr, bStt, bLeft, nOut, nDan);
	int nSize = tvArr.GetSize();
	if(nSize==0) return;

	int i=0; for(i=0; i<nSize; i++)
	{
		tv = tvArr.GetAt(i);
		if(tv.m_sInfo==_T("수평변화B"))
			len_var.push_back(tv.GetLength());
		if(tv.m_sInfo==_T("수평B"))
			len_hor.push_back(tv.GetLength());
		if(tv.m_sInfo==_T("수평변단면B"))
			len_var_sec.push_back(tv.GetLength());
		if(tv.m_sInfo==_T("수평변단면변화B"))
			len_var_sec_var.push_back(tv.GetLength());
	}

	double dCoverIn = m_dCoverWingIn[0];
	double dCoverOut = m_dCoverWingOut[0];
	double dCover = nOut==0 ? dCoverIn : dCoverOut;
	double dCTC = nOut==0 ? pWing->m_dMainCTCB/2 : pWing->m_dMainCTCB;
	double dDia = pWing->m_dDiaMainB[nOut][nDan];
	double dSettle(0);
	if(m_pARcBridgeDataStd->IsLsdDesign())
	{
		SRebarEnvOption LsdRebarOpt;
		SetRebarLsdOptionWingWall(&LsdRebarOpt, bStt, bLeft, nOut==0, WINGWALL_SECTB, TRUE);
		dSettle = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueSettle(dDia, &LsdRebarOpt);
	}
	else
	{
		dSettle = m_pARcBridgeDataStd->GetValueSettle(dDia, SETTLE_TENS_NORMAL, toCm(dCover), toCm(dCTC));
	}
	double dT2 = pWing->m_dT2;
	CDPoint vWing = GetAngleWingWallBetweenWall(bStt, bLeft);
	int nBaseRebar = 0;

	nRBIndex = nOut==0 ? WW_REBAR_HOR_B_IN_VAR : WW_REBAR_HOR_B_OUT_VAR;
	pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
	if(pRB && pRB->m_bLock == FALSE)
	{
		pRB->InitData();
		pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
		pRB->m_nPos = nOut==0 ? REBAR_POS_WING_BACK : REBAR_POS_WING_FRONT;
		pRB->m_nIdxNumber = nRBIndex;
		pRB->m_sMark = _T("W3");
		pRB->m_sDescription = _T("수평변화철근B");
		pRB->m_dDia = pWing->m_dDiaMainB[nOut][nDan];
		pRB->m_nEa = len_var.size();
		if(pRB->m_nEa>0)
		{
			// (ARCBRIDGE-2479) 날개벽 D 구간 B구간 처리
			// nBaseRebar = nOut==0 ? 33 : 2;
			nBaseRebar = 2;
			pRB->m_nTypeRebar = GetWingWallRebarDetail(bStt, bLeft, nBaseRebar);
			pRB->m_dLengthMax_A = *max_element(len_var.begin(), len_var.end());
			pRB->m_dLengthMin_A = *min_element(len_var.begin(), len_var.end());
			//pRB->m_dLengthMax_B = (nOut==0)? dT2 - (dCoverIn+dCoverOut) : dSettle;
			//pRB->m_dLengthMax_C = (nOut==0)? dSettle : 0;
			pRB->m_dLengthMax_B = dSettle;
			pRB->m_dLengthMax_C = 0;
			pRB->m_dAngleX1 = vWing.GetAngleDegree();
		}
		pRB->m_bMainRebar = TRUE;
		pRB->m_dRateAdd	= MAKE_RATE;
		SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTB, TRUE);
		if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
			pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
	}

	nRBIndex = nOut==0 ? WW_REBAR_HOR_B_IN : WW_REBAR_HOR_B_OUT;
	pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
	if(pRB && pRB->m_bLock == FALSE)
	{
		pRB->InitData();
		pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
		pRB->m_nPos = nOut==0 ? REBAR_POS_WING_BACK : REBAR_POS_WING_FRONT;
		pRB->m_nIdxNumber = nRBIndex;
		pRB->m_sMark = _T("W4");
		pRB->m_sDescription = _T("수평철근B");
		pRB->m_dDia = pWing->m_dDiaMainB[nOut][nDan];
		pRB->m_nEa = len_hor.size();
		if(pRB->m_nEa>0)
		{
			nBaseRebar = nOut==0 ? 33 : 2;
			pRB->m_nTypeRebar = GetWingWallRebarDetail(bStt, bLeft, nBaseRebar);
			pRB->m_dLengthMax_A = *max_element(len_hor.begin(), len_hor.end());
			pRB->m_dLengthMin_A = *min_element(len_hor.begin(), len_hor.end());
			pRB->m_dLengthMax_B = (nOut==0)? dT2 - (dCoverIn+dCoverOut) : dSettle;
			pRB->m_dLengthMax_C = (nOut==0)? dSettle : 0;
			pRB->m_dAngleX1 = vWing.GetAngleDegree();
		}
		pRB->m_bMainRebar = TRUE;
		pRB->m_dRateAdd	= MAKE_RATE;
		SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTB, TRUE);
		if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
			pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
	}

	if(nOut==0)
	{
		nRBIndex = WW_REBAR_HOR_B_IN_VAR_SEC;
		pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
		if(pRB && pRB->m_bLock == FALSE)
		{
			pRB->InitData();
			pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
			pRB->m_nPos = REBAR_POS_WING_BACK;
			pRB->m_nIdxNumber = nRBIndex;
			pRB->m_sMark = _T("W5");
			pRB->m_sDescription = _T("변단면수평철근B");
			pRB->m_dDia = pWing->m_dDiaMainB[nOut][nDan];
			pRB->m_nEa = len_var_sec.size();
			if(pRB->m_nEa>0)
			{
				pRB->m_nTypeRebar = 47;
				pRB->m_dLengthMax_A = *max_element(len_var_sec.begin(), len_var_sec.end());
				pRB->m_dLengthMin_A = *min_element(len_var_sec.begin(), len_var_sec.end());
				pRB->m_dLengthMax_B = dSettle;
				CDPoint xyVar[3];
				GetXyRebarWingWallVaryPlane(xyVar, bStt, bLeft);
				pRB->m_dLengthMax_C = ~(xyVar[2]-xyVar[0]);
				pRB->m_dAngleX1 = vWing.GetAngleDegree();
			}
			pRB->m_bMainRebar = TRUE;
			pRB->m_dRateAdd	= MAKE_RATE;
			SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTB, TRUE);
			if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
				pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
			m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
		}

		nRBIndex = WW_REBAR_HOR_B_IN_VAR_SEC_VAR;
		if(pRB && pRB->m_bLock == FALSE)
		{
			pRB->InitData();
			pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
			pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
			pRB->m_nPos = REBAR_POS_WING_BACK;
			pRB->m_nIdxNumber = nRBIndex;
			pRB->m_sMark = _T("W6");
			pRB->m_sDescription = _T("변단면수평변화철근B");
			pRB->m_dDia = pWing->m_dDiaMainB[nOut][nDan];
			pRB->m_nEa = len_var_sec_var.size();
			if(pRB->m_nEa>0)
			{
				pRB->m_nTypeRebar = 2;
				pRB->m_dLengthMax_A = *max_element(len_var_sec_var.begin(), len_var_sec_var.end());
				pRB->m_dLengthMin_A = *min_element(len_var_sec_var.begin(), len_var_sec_var.end());
				pRB->m_dLengthMax_B = dT2 - (dCoverIn+dCoverOut);
				pRB->m_dAngleX1 = vWing.GetAngleDegree();
			}
			pRB->m_bMainRebar = TRUE;
			pRB->m_dRateAdd	= MAKE_RATE;
			SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTB, TRUE);
			if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
				pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
			m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
		}
	}
}

// 날개벽 C구간 수직 철근
void CRcBridgeRebar::MakeWingWallRebarJewonVerC(BOOL bStt, BOOL bLeft, int nOut, int nDan)
{
	CWingWall* pWing = GetWingWall(bStt, bLeft);
	if(nDan == 1 && pWing->m_nCountLayerC[nOut] == 1) return;

	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();
	const double dMulti = bLsd? 10 : 1;

	// 철근 초기화
	int nDanIdx = nDan == 0 ? 0 : WW_REBAR_COUNT;
	int nRBIndex = nOut==0 ? WW_REBAR_VER_C_IN : WW_REBAR_VER_C_OUT;
	CRebar* pRB = NULL;
// 	CRebar* pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
// 	pRB->InitData();
// 	nRBIndex = nOut==0 ? WW_REBAR_VER_C_IN_EXC_FOOT : WW_REBAR_VER_C_OUT_EXC_FOOT;
// 	pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
// 	pRB->InitData();
	//////////////

	double dL2 = pWing->m_dL2;
	if(dL2==0) return;

	vector<double> len_ver, len_ver_out;
	CTwinVector tv;
	CTwinVectorArray tvArr1, tvArr2;
	GetTvArrayRebarWingWallBlockCMainFront(tvArr1, tvArr2, bStt, bLeft, nOut, nDan);
	int nSize = tvArr2.GetSize();
	if(nSize==0) return;

	int i=0; for(i=0; i<nSize; i++)
	{
		tv = tvArr2.GetAt(i);
		if(tv.m_sInfo==_T("수직C"))
			len_ver.push_back(tv.GetLength());
		if(tv.m_sInfo==_T("기초외수직C"))
			len_ver_out.push_back(tv.GetLength());
	}

	double dCoverIn = m_dCoverWingIn[0];
	double dCoverOut = m_dCoverWingOut[0];
	double dCover = nOut==0 ? dCoverIn : dCoverOut;
	double dCTC = nOut==0 ? pWing->m_dStdVerCTC/2 : pWing->m_dStdVerCTC;
	double dT1 = pWing->m_dT1;
	double dT2 = pWing->m_dT2;
	double dR = GetWingWallVertRebarCurveRadius(bStt, bLeft, nOut, nDan);
	double dSH = pWing->m_dSH;

	BOOL bMergedAC = IsMergedRebarWingWall(bStt, bLeft, nOut, nDan, 'A', 'C');	// A구간 주철근과 병합되는지..
	BOOL bVar = IsWingWallVariableSect(bStt, bLeft);
	CDPoint xyVar[3];
	GetXyRebarWingWallVarySect(xyVar, bStt, bLeft);
	double dLenHu = ~(xyVar[2]-xyVar[0]);

	nRBIndex = nOut==0 ? WW_REBAR_VER_C_IN : WW_REBAR_VER_C_OUT;
	pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
	if(pRB && pRB->m_bLock == FALSE)
	{
		pRB->InitData();
		pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
		pRB->m_nPos = nOut==0 ? REBAR_POS_WING_BACK : REBAR_POS_WING_FRONT;
		pRB->m_nIdxNumber = nRBIndex;
		pRB->m_sMark = _T("W9");
		pRB->m_sDescription = _T("수직철근C");
		pRB->m_dDia = pWing->m_dDiaMainC[nOut][nDan];
		pRB->m_nEa = len_ver.size();
		if(pRB->m_nEa>0)
		{
			if(nOut==0 && bVar && dT1<dT2 && bMergedAC)
			{
				pRB->m_nTypeRebar = dR==0 ? 47 : 14;
				pRB->m_dLengthMax_A = *max_element(len_ver.begin(), len_ver.end());
				pRB->m_dLengthMin_A = *min_element(len_ver.begin(), len_ver.end());
				if(dR==0)
				{
					pRB->m_dLengthMax_B = 500;
					pRB->m_dLengthMax_C = dLenHu;
					pRB->m_dLengthMax_D = 0;
				}
				else
				{
					pRB->m_dLengthMax_B = ConstPi*dR/2.0;
					pRB->m_dLengthMax_C = 500;
					pRB->m_dLengthMax_D = dLenHu;
				}
				pRB->m_dAngleX1 = CDPoint(-dSH, 1).Unit().GetAngleDegree();
			}
			else
			{
				if(bMergedAC && nOut ==0)	pRB->m_nTypeRebar = dR==0? 33 : 23;
				else										pRB->m_nTypeRebar = dR==0? 2 : 5;
				
				if(pRB->m_nTypeRebar == 23 || pRB->m_nTypeRebar == 33)
				{
					double dMaxVer	= *max_element(len_ver.begin(), len_ver.end());
					double dMinVer		= *min_element(len_ver.begin(), len_ver.end());
					double dThick		= max(pWing->m_dT1, pWing->m_dT2) - dCoverIn - dCoverOut;
					double dFixBot		 = 500;

					pRB->m_dLengthMax_A		= pRB->m_nTypeRebar == 33? dMaxVer : dThick;
					pRB->m_dLengthMax_A		= pRB->m_nTypeRebar == 33? dMinVer : dThick;
					pRB->m_dLengthMax_B		= pRB->m_nTypeRebar == 33? dFixBot : dMaxVer;
					pRB->m_dLengthMin_B		= pRB->m_nTypeRebar == 33? 0 : dMinVer;
					pRB->m_dLengthMax_C		= pRB->m_nTypeRebar == 33? dThick : ConstPi*dR/2.0;
					pRB->m_dLengthMax_D		= pRB->m_nTypeRebar == 33? 0 : dFixBot;					
				}
				else
				{
					pRB->m_dLengthMax_A = *max_element(len_ver.begin(), len_ver.end());
					pRB->m_dLengthMin_A = *max_element(len_ver.begin(), len_ver.end());
					if(dR==0)
					{
						pRB->m_dLengthMax_B = 500;
						pRB->m_dLengthMax_C = 0;
					}
					else
					{
						pRB->m_dLengthMax_B = ConstPi*dR/2.0;
						pRB->m_dLengthMax_C = 500;
					}
					pRB->m_dLengthMax_D = 0;
				}				
				pRB->m_dAngleX1 = 0;
			}
			pRB->m_R = dR;
		}
		pRB->m_bMainRebar = TRUE;
		pRB->m_dRateAdd	= MAKE_RATE;
		SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTC, TRUE);
		if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
			pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
	}

	nRBIndex = nOut==0 ? WW_REBAR_VER_C_IN_EXC_FOOT : WW_REBAR_VER_C_OUT_EXC_FOOT;
	pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
	if(pRB && pRB->m_bLock == FALSE)
	{
		pRB->InitData();
		pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
		pRB->m_nPos = nOut==0 ? REBAR_POS_WING_BACK : REBAR_POS_WING_FRONT;
		pRB->m_nIdxNumber = nRBIndex;
		pRB->m_sMark = _T("W10");
		pRB->m_sDescription = _T("기초외수직철근C");
		pRB->m_dDia = pWing->m_dDiaMainC[nOut][nDan];
		pRB->m_nEa = len_ver_out.size();
		if(pRB->m_nEa>0)
		{
			if(nOut==0 && bVar && dT1<dT2 && bMergedAC)
			{
				pRB->m_nTypeRebar = 13;
				pRB->m_dLengthMax_A = dT2 - (dCoverIn+dCoverOut);
				pRB->m_dLengthMin_A = 0;
				pRB->m_dLengthMax_B = *max_element(len_ver_out.begin(), len_ver_out.end());
				pRB->m_dLengthMin_B = *min_element(len_ver_out.begin(), len_ver_out.end());
				pRB->m_dLengthMax_C = dLenHu;
				pRB->m_dAngleX1 = CDPoint(-dSH, 1).Unit().GetAngleDegree();
			}
			else
			{
				pRB->m_nTypeRebar = 2;
				pRB->m_dLengthMax_A = *max_element(len_ver_out.begin(), len_ver_out.end());
				pRB->m_dLengthMin_A = *min_element(len_ver_out.begin(), len_ver_out.end());
				pRB->m_dLengthMax_B = dT2 - (dCoverIn+dCoverOut);
				pRB->m_dLengthMin_B = 0;
				pRB->m_dLengthMax_C = 0;
				pRB->m_dAngleX1 = 0;
			}
		}
		pRB->m_bMainRebar = TRUE;
		pRB->m_dRateAdd	= MAKE_RATE;
		SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTC, TRUE);
		if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
			pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
	}
}

// 날개벽 D구간 수평 철근
void CRcBridgeRebar::MakeWingWallRebarJewonHorD(BOOL bStt, BOOL bLeft, int nOut, int nDan)
{
	CWingWall* pWing = GetWingWall(bStt, bLeft);
	if(nDan == 1 && pWing->m_nCountLayerD[nOut] == 1) return;

	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();
	const double dMulti = bLsd? 10 : 1;

	// 철근 초기화
	int nDanIdx = nDan == 0 ? 0 : WW_REBAR_COUNT;
	int nRBIndex = nOut==0 ? WW_REBAR_SLOPE_D_IN : WW_REBAR_SLOPE_D_OUT;
	CRebar* pRB = NULL;
// 	CRebar* pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
// 	pRB->InitData();
// 	nRBIndex = nOut==0 ? WW_REBAR_HOR_D_IN : WW_REBAR_HOR_D_OUT;
// 	pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
// 	pRB->InitData();
// 	nRBIndex = nOut==0 ? WW_REBAR_HOR_D_IN_VAR : WW_REBAR_HOR_D_OUT_VAR;
// 	pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
// 	pRB->InitData();
// 	if(nOut==0)
// 	{
// 		nRBIndex = WW_REBAR_HOR_D_IN_VAR_SEC;
// 		pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
// 		pRB->InitData();
// 		nRBIndex = WW_REBAR_HOR_D_IN_VAR_SEC_BLOCK;
// 		pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
// 		pRB->InitData();
// 		nRBIndex = WW_REBAR_HOR_D_IN_VAR_UNDER; 
// 		pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
// 		pRB->InitData();
// 	}
	//////////////

	double dL1 = pWing->m_dL1;
	double dL2 = pWing->m_dL2;
	if(dL1==0) return;

	vector<double> len_slope, len_var, len_hor, len_var_sec, len_var_sec_block, len_var_under, len_var2;
	CTwinVector tv;
	
	CTwinVectorArray tvArr;
	GetTvArrayRebarWingWallBlockDMainFront(tvArr, bStt, bLeft, nOut, nDan);
	int nSize = tvArr.GetSize();
	if(nSize==0) return;

	// 이 변수는 세로방향 변단면일 때만 사용됨 ////////////////////////////////
	BOOL bMatchVarUpperHor	= FALSE;	// 수평D 철근이 변단면 위에 있는지
	BOOL bMatchVarLowerHor	= FALSE;	// 수평D 철근이 변단면 아래에도 있는지
	BOOL bMatchVarUpperHorVar	= FALSE;	// 수평변화D 철근이 변단면 위에 있는지
	BOOL bMatchVarLowerHorVar	= FALSE;	// 수평변화D 철근이 변단면 아래에도 있는지 
	BOOL bMatchVarNotAll			= FALSE; //모든 변화구간이 존재하지 않을때
	double dTopVar	= GetXySectionWingWallStt(bStt, TRUE, FALSE).y - pWing->m_dLT;
	double dBottomVar	= dTopVar - (pWing->m_dT2 - pWing->m_dT1) * pWing->m_dSH;
	////////////////////////////////////////////////////////////////////////////
	int i=0; for(i=0; i<nSize; i++)
	{
		CTwinVector *pTv	= NULL;
		pTv	= &tvArr.GetAt(i);
		if(pTv->m_sInfo==_T("상단경사D"))
			len_slope.push_back(pTv->GetLength());
		if(pTv->m_sInfo==_T("수평D"))
		{
			len_hor.push_back(pTv->GetLength());
			if(pTv->m_v1.y > dTopVar) bMatchVarUpperHor	= TRUE;
			if(pTv->m_v1.y < dBottomVar) bMatchVarLowerHor	= TRUE;
		}
		if(pTv->m_sInfo ==_T("수평변화D")) 
		{
			len_var.push_back(pTv->GetLength());
			if(pTv->m_v1.y > dTopVar) bMatchVarUpperHorVar	= TRUE;
			if(pTv->m_v1.y < dBottomVar) bMatchVarLowerHorVar	= TRUE;
		}
		if(pTv->m_sInfo==_T("수평변단면D"))
			len_var_sec.push_back(pTv->GetLength());
		if(pTv->m_sInfo==_T("수평변단면구간D"))
			len_var_sec_block.push_back(pTv->GetLength());
		if(pTv->m_sInfo==_T("수평변단면하단D"))
			len_var_under.push_back(pTv->GetLength());
		if(pTv->m_sInfo == _T("수평변화D2"))
			len_var2.push_back(pTv->GetLength());
	}
	if(bMatchVarUpperHorVar || bMatchVarLowerHorVar)
		bMatchVarNotAll = TRUE; //변화구간 있음

	double dCoverIn = m_dCoverWingIn[0];
	double dCoverOut = m_dCoverWingOut[0];
	double dCover = nOut==0 ? dCoverIn : dCoverOut;
	double dCTC = nOut==0 ? pWing->m_dMainCTCA/2 : pWing->m_dMainCTCA;
	if(nOut==0 && pWing->m_bSelMainCTCD)
		dCTC = pWing->m_dMainCTCA;
	double dDia = pWing->m_dDiaMainD[nOut][nDan];
	double dSettle(0);
	if(m_pARcBridgeDataStd->IsLsdDesign())
	{
		SRebarEnvOption LsdRebarOpt;
		SetRebarLsdOptionWingWall(&LsdRebarOpt, bStt, bLeft, nOut==0, WINGWALL_SECTD, TRUE);
		dSettle = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueSettle(dDia, &LsdRebarOpt);
	}
	else
	{
		dSettle = m_pARcBridgeDataStd->GetValueSettle(dDia, SETTLE_TENS_NORMAL, toCm(dCover), toCm(dCTC));
	}
	double dT1 = pWing->m_dT1;
	double dT2 = pWing->m_dT2;
	BOOL bMergedAD = IsMergedRebarWingWall(bStt, bLeft, nOut, nDan, 'A', 'D');	// A구간 주철근과 병합되는지..
	CDPoint vWing = GetAngleWingWallBetweenWall(bStt, bLeft);
	int nBaseRebar = 0;
	BOOL bCrossVar = pWing->m_nDirHunch==2 && nOut==0;

	nRBIndex = nOut==0 ? WW_REBAR_SLOPE_D_IN : WW_REBAR_SLOPE_D_OUT;
	pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
	if(pRB && pRB->m_bLock == FALSE)
	{
		pRB->InitData();
		pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
		pRB->m_nPos = nOut==0 ? REBAR_POS_WING_BACK : REBAR_POS_WING_FRONT;
		pRB->m_nIdxNumber = nRBIndex;
		pRB->m_sMark = _T("W5");
		pRB->m_sDescription = _T("수평경사철근D");
		pRB->m_dDia = pWing->m_dDiaMainD[nOut][nDan];
		pRB->m_nEa = len_slope.size();
		if(pRB->m_nEa>0)
		{
			nBaseRebar = nOut==0 ? 33 : 2;
			pRB->m_nTypeRebar = (bMergedAD || dL2==0) && !bCrossVar ? GetWingWallRebarDetail(bStt, bLeft, nBaseRebar) : nOut==0? 2:1;

			double dMaxA = *max_element(len_slope.begin(), len_slope.end());
			double dMinA = *min_element(len_slope.begin(), len_slope.end());
			BOOL   bMin = (Compare(dMaxA ,dMinA, _T("="),1) || pRB->m_nEa  < 2)? FALSE : TRUE;
			bMin = bMin && bMatchVarNotAll? TRUE : FALSE;

			pRB->m_dLengthMax_A = dMaxA;
			pRB->m_dLengthMin_A = bMin? dMinA : 0;
			pRB->m_dLengthMax_B = (nOut==0)? dT2 - (dCoverIn+dCoverOut) : (bMergedAD || dL2==0) && !bCrossVar ? dSettle:0;
			pRB->m_dLengthMin_B = (nOut==0)? dT1 - (dCoverIn+dCoverOut) : (bMergedAD || dL2==0) && !bCrossVar ? dSettle:0;
			// 세로방향 변단면이면 경사철근의 두께는 항상 T1 modified by jaeho 2007.10.09
			if(pWing->m_nDirHunch == 1)
			{
				pRB->m_dLengthMax_B = (nOut==0)? dT1 - (dCoverIn+dCoverOut) : (bMergedAD || dL2==0) && !bCrossVar ? dSettle:0;
				pRB->m_dLengthMin_B = (nOut==0)? dT1 - (dCoverIn+dCoverOut) : (bMergedAD || dL2==0) && !bCrossVar ? dSettle:0;
			}
			pRB->m_dLengthMax_C = (bMergedAD || dL2==0) && !bCrossVar ? nOut==0? dSettle:0 : 0;
			pRB->m_dAngleX1 = (bMergedAD || dL2==0) && !bCrossVar ? vWing.GetAngleDegree() : 0;
		}
		pRB->m_bMainRebar = TRUE;
		pRB->m_dRateAdd	= MAKE_RATE;
		SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTD, TRUE);
		if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
			pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
	}

	nRBIndex = nOut==0 ? WW_REBAR_HOR_D_IN : WW_REBAR_HOR_D_OUT;
	pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
	if(pRB && pRB->m_bLock == FALSE)
	{
		pRB->InitData();
		pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
		pRB->m_nPos = nOut==0 ? REBAR_POS_WING_BACK : REBAR_POS_WING_FRONT;
		pRB->m_nIdxNumber = nRBIndex;
		pRB->m_sMark = _T("W6");
		pRB->m_sDescription = _T("수평철근D");
		pRB->m_dDia = pWing->m_dDiaMainD[nOut][nDan];
		pRB->m_nEa = len_hor.size();

		//31447 
		CTwinVectorArray tvArrWingHori;
		CTwinVector tvWingFrontHori , tvWingBackHori;
		double dFrontHori = 0, dBackHori = 0;

		GetWingWallbackAndSideAttachRebar(tvArrWingHori, nOut, nDan, bStt, TRUE, bLeft);

		tvWingFrontHori = tvArrWingHori.GetTvByInfo(_T("날개벽전면수평철근1"));
		tvWingBackHori = tvArrWingHori.GetTvByInfo(_T("날개벽배면수평철근1"));

		dFrontHori = tvWingFrontHori.GetLength();
		dBackHori = tvWingBackHori.GetLength();
		//}

		if(pRB->m_nEa>0)
		{
			nBaseRebar = nOut==0 ? 33 : 2;
			pRB->m_nTypeRebar = (bMergedAD || dL2==0) && !bCrossVar ? GetWingWallRebarDetail(bStt, bLeft, nBaseRebar) : nOut==0? 2:1;
		
			//{31447 
			if((dFrontHori <= 0 && dBackHori <= 0) || pRB->m_nEa == 1)
			{
				double dMaxA =  *max_element(len_hor.begin(), len_hor.end());
				double dMinA = *min_element(len_hor.begin(), len_hor.end());

				pRB->m_dLengthMax_A = dMaxA;
				pRB->m_dLengthMin_A = (Compare(dMaxA, dMinA, _T("="), 1) || pRB->m_nEa < 2 || !bMatchVarNotAll)? 0 : dMinA;
			}
			else
			{
				pRB->m_dLengthMax_A = nOut == 1? dFrontHori : dBackHori;

				double dMaxA = pRB->m_dLengthMax_A;
				double dMinA = *min_element(len_hor.begin(), len_hor.end());

				pRB->m_dLengthMin_A =  (Compare(dMaxA, dMinA, _T("="), 1) || pRB->m_nEa < 2 || !bMatchVarNotAll)? 0 : dMinA;
			}
			//}		
		
			pRB->m_dLengthMax_B = (nOut==0)? dT2 - (dCoverIn+dCoverOut) : (bMergedAD || dL2==0) && !bCrossVar ? dSettle:0;
			pRB->m_dLengthMin_B = (nOut==0)? dT1 - (dCoverIn+dCoverOut) : (bMergedAD || dL2==0) && !bCrossVar ? dSettle:0;
			// 수평철근은 세로방향 변단면일때 변단면 하단이 H1보다 올라가 있으면 T1 ~ T2가 되고, 변단면 상단이 0이면 T2가 되고
			// 나머지의 경우 T1이 된다.
			if(pWing->m_nDirHunch == 1)
			{
				double dTMax	= dT2;
				double dTMin	= dT1;
				if(bMatchVarLowerHor && bMatchVarUpperHor)
				{
					dTMax	= dT2;
					dTMin	= dT1;
				}
				else if(bMatchVarLowerHor)
				{
					dTMax	= dT2;
					dTMin	= dT2;
				}
				else if(bMatchVarUpperHor)
				{
					dTMax	= dT1;
					dTMin	= dT1;
				}

				pRB->m_dLengthMax_B = (nOut==0)? dTMax - (dCoverIn+dCoverOut) : (bMergedAD || dL2==0) && !bCrossVar ? dSettle:0;
				pRB->m_dLengthMin_B = (nOut==0)? dTMin - (dCoverIn+dCoverOut) : (bMergedAD || dL2==0) && !bCrossVar ? dSettle:0;
			}
			pRB->m_dLengthMax_C = (bMergedAD || dL2==0) && !bCrossVar ? nOut==0? dSettle:0 : 0;
			pRB->m_dAngleX1 = (bMergedAD || dL2==0) && !bCrossVar ? vWing.GetAngleDegree() : 0;
		}
		pRB->m_bMainRebar = TRUE;
		pRB->m_dRateAdd	= MAKE_RATE;
		SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTD, TRUE);
		if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
			pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
	}

	nRBIndex = nOut==0 ? WW_REBAR_HOR_D_IN_VAR : WW_REBAR_HOR_D_OUT_VAR;
	pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
	if(pRB && pRB->m_bLock == FALSE)
	{
		pRB->InitData();
		pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
		pRB->m_nPos = nOut==0 ? REBAR_POS_WING_BACK : REBAR_POS_WING_FRONT;
		pRB->m_nIdxNumber = nRBIndex;
		pRB->m_sMark = _T("W7");
		pRB->m_sDescription = _T("수평변화철근D");
		pRB->m_dDia = pWing->m_dDiaMainD[nOut][nDan];
		pRB->m_nEa = len_var.size();
		if(pRB->m_nEa>0)
		{
			nBaseRebar = nOut==0 ? 33 : 2;
			pRB->m_nTypeRebar = (bMergedAD || dL2==0) && !bCrossVar ? GetWingWallRebarDetail(bStt, bLeft, nBaseRebar) : nOut==0? 2:1;
			pRB->m_dLengthMax_A = *max_element(len_var.begin(), len_var.end());
			pRB->m_dLengthMin_A = *min_element(len_var.begin(), len_var.end());
			pRB->m_dLengthMax_B = (nOut==0)? dT2 - (dCoverIn+dCoverOut) : (bMergedAD || dL2==0) && !bCrossVar ? dSettle:0;
			pRB->m_dLengthMin_B = (nOut==0)? dT1 - (dCoverIn+dCoverOut) : (bMergedAD || dL2==0) && !bCrossVar ? dSettle:0;
			// 수평변화철근은 세로방향 변단면일때 변단면 상단이 H1보다 내려가 있으면 T1 ~ T2가 되고
			// 변단면 하단이 날개벽 경사 하면까지 내려가 있으면 T1이 되고, 나머지는 T2가 됨
			if(pWing->m_nDirHunch == 1)
			{
				double dTMax	= dT2;
				double dTMin	= dT1;
				if(bMatchVarLowerHorVar && bMatchVarUpperHorVar)
				{
					dTMax	= dT2;
					dTMin	= dT1;
				}
				else if(bMatchVarUpperHorVar)
				{
					dTMax	= dT1;
					dTMin	= dT1;
				}
				else if(bMatchVarLowerHorVar)
				{
					dTMax	= dT2;
					dTMin	= dT2;
				}

				pRB->m_dLengthMax_B = (nOut==0)? dTMax - (dCoverIn+dCoverOut) : (bMergedAD || dL2==0) && !bCrossVar ? dSettle:0;
				pRB->m_dLengthMin_B = (nOut==0)? dTMin - (dCoverIn+dCoverOut) : (bMergedAD || dL2==0) && !bCrossVar ? dSettle:0;
			}
			pRB->m_dLengthMax_C = (bMergedAD || dL2==0) && !bCrossVar ? nOut==0? dSettle:0 : 0;
			pRB->m_dAngleX1 = (bMergedAD || dL2==0) && !bCrossVar ? vWing.GetAngleDegree() : 0;
		}
		pRB->m_bMainRebar = TRUE;
		pRB->m_dRateAdd	= MAKE_RATE;
		SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTD, TRUE);
		if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
			pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
	}

	if(nOut==0)
	{
		nRBIndex = WW_REBAR_HOR_D_IN_VAR_SEC;
		pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
		if(pRB && pRB->m_bLock == FALSE)
		{
			pRB->InitData();
			pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
			pRB->m_nPos = REBAR_POS_WING_BACK;
			pRB->m_nIdxNumber = nRBIndex;
			pRB->m_sMark = _T("W8");
			pRB->m_sDescription = _T("변단면수평철근D");
			pRB->m_dDia = pWing->m_dDiaMainD[nOut][nDan];
			pRB->m_nEa = len_var_sec.size();
			if(pRB->m_nEa>0)
			{
				pRB->m_nTypeRebar = 47;
				pRB->m_dLengthMax_A = *max_element(len_var_sec.begin(), len_var_sec.end());
				pRB->m_dLengthMin_A = *min_element(len_var_sec.begin(), len_var_sec.end());
				pRB->m_dLengthMax_B = dSettle;
				CDPoint xyVar[3];
				GetXyRebarWingWallVaryPlane(xyVar, bStt, bLeft);
				pRB->m_dLengthMax_C = ~(xyVar[2]-xyVar[0]);
				pRB->m_dAngleX1 = vWing.GetAngleDegree();
			}
			pRB->m_bMainRebar = TRUE;
			pRB->m_dRateAdd	= MAKE_RATE;
			SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTD, TRUE);
			if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
				pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
			m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
		}

		// 수평변화D 변단면 하부..
		nRBIndex = WW_REBAR_HOR_D_IN_VAR_UNDER;
		pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
		if(pRB && pRB->m_bLock == FALSE)
		{
			pRB->InitData();
			pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
			pRB->m_nPos = REBAR_POS_WING_BACK;
			pRB->m_nIdxNumber = nRBIndex;
			pRB->m_sMark = _T("W10");
			pRB->m_sDescription = _T("수평변화철근하부D");
			pRB->m_dDia = pWing->m_dDiaMainD[nOut][nDan];
			pRB->m_nEa = len_var_under.size();
			if(pRB->m_nEa>0)
			{
				nBaseRebar = 33;
				pRB->m_nTypeRebar = (bMergedAD || dL2==0) && !bCrossVar ? GetWingWallRebarDetail(bStt, bLeft, nBaseRebar) : nOut==0? 2:1;
				pRB->m_dLengthMax_A = *max_element(len_var_under.begin(), len_var_under.end());
				pRB->m_dLengthMin_A = *min_element(len_var_under.begin(), len_var_under.end());
				pRB->m_dLengthMax_B = dT2 - (dCoverIn+dCoverOut);
				pRB->m_dLengthMin_B = dT1 - (dCoverIn+dCoverOut);
				pRB->m_dLengthMax_C = (bMergedAD || dL2==0) && !bCrossVar ? nOut==0? dSettle:0 : 0;
				pRB->m_dAngleX1 = (bMergedAD || dL2==0) && !bCrossVar ? vWing.GetAngleDegree() : 0;
			}
			pRB->m_bMainRebar = TRUE;
			pRB->m_dRateAdd	= MAKE_RATE;
			SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTD, TRUE);
			if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
				pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
			m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
		}
	}

	nRBIndex = nOut==0 ? WW_REBAR_HOR_D_IN_VAR_SEC_BLOCK : WW_REBAR_HOR_D_OUT_VAR_SEC_BLOCK;
	pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
	if(pRB && pRB->m_bLock == FALSE)
	{
		pRB->InitData();
		pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
		pRB->m_nPos = nOut==0 ? REBAR_POS_WING_BACK : REBAR_POS_WING_FRONT;
		pRB->m_nIdxNumber = nRBIndex;
		pRB->m_sMark = _T("W9");
		pRB->m_sDescription = _T("변단면구간수평철근D");
		pRB->m_dDia = pWing->m_dDiaMainD[nOut][nDan];
		pRB->m_nEa = len_var_sec_block.size();
		if(pRB->m_nEa>0)
		{
			nBaseRebar = nOut==0 ? 33 : 2;
			pRB->m_nTypeRebar = (bMergedAD || dL2==0) && !bCrossVar ? GetWingWallRebarDetail(bStt, bLeft, nBaseRebar) : nOut==0? 2:1;
			pRB->m_dLengthMax_A = *max_element(len_var_sec_block.begin(), len_var_sec_block.end());
			pRB->m_dLengthMin_A = *min_element(len_var_sec_block.begin(), len_var_sec_block.end());
			pRB->m_dLengthMax_B = (nOut==0)? dT2 - (dCoverIn+dCoverOut) : (bMergedAD || dL2==0) && !bCrossVar ? dSettle:0;
			pRB->m_dLengthMin_B = (nOut==0)? dT1 - (dCoverIn+dCoverOut) : (bMergedAD || dL2==0) && !bCrossVar ? dSettle:0;
			pRB->m_dLengthMax_C = (bMergedAD || dL2==0) && !bCrossVar ? nOut==0? dSettle:0 : 0;
			pRB->m_dAngleX1 = (bMergedAD || dL2==0) && !bCrossVar ? vWing.GetAngleDegree() : 0;
		}
		pRB->m_bMainRebar = TRUE;
		pRB->m_dRateAdd	= MAKE_RATE;
		SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTD, TRUE);
		if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
			pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
	}

	nRBIndex = nOut==0 ? WW_REBAR_HOR_D_IN_VAR2 : WW_REBAR_HOR_D_OUT_VAR2;
	pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
	if(pRB && pRB->m_bLock == FALSE)
	{
		pRB->InitData();
		pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
		pRB->m_nPos = nOut==0 ? REBAR_POS_WING_BACK : REBAR_POS_WING_FRONT;
		pRB->m_nIdxNumber = nRBIndex;
		pRB->m_sMark = _T("W7");
		pRB->m_sDescription = _T("수평변화철근D2");
		pRB->m_dDia = pWing->m_dDiaMainD[nOut][nDan];
		pRB->m_nEa = len_var2.size();
		if(pRB->m_nEa>0)
		{
			nBaseRebar = nOut==0 ? 33 : 2;
			pRB->m_nTypeRebar = (bMergedAD || dL2==0) && !bCrossVar ? GetWingWallRebarDetail(bStt, bLeft, nBaseRebar) : nOut==0? 2:1;
			pRB->m_dLengthMax_A = *max_element(len_var2.begin(), len_var2.end());
			pRB->m_dLengthMin_A = *min_element(len_var2.begin(), len_var2.end());
			pRB->m_dLengthMax_B = (nOut==0)? dT2 - (dCoverIn+dCoverOut) : (bMergedAD || dL2==0) && !bCrossVar ? dSettle:0;
			pRB->m_dLengthMin_B = (nOut==0)? dT1 - (dCoverIn+dCoverOut) : (bMergedAD || dL2==0) && !bCrossVar ? dSettle:0;
			// 수평변화철근은 세로방향 변단면일때 변단면 상단이 H1보다 내려가 있으면 T1 ~ T2가 되고
			// 변단면 하단이 날개벽 경사 하면까지 내려가 있으면 T1이 되고, 나머지는 T2가 됨
			if(pWing->m_nDirHunch == 1)
			{
				double dTMax	= dT2;
				double dTMin	= dT1;
				if(bMatchVarLowerHorVar && bMatchVarUpperHorVar)
				{
					dTMax	= dT2;
					dTMin	= dT1;
				}
				else if(bMatchVarUpperHorVar)
				{
					dTMax	= dT1;
					dTMin	= dT1;
				}
				else if(bMatchVarLowerHorVar)
				{
					dTMax	= dT2;
					dTMin	= dT2;
				}

				pRB->m_dLengthMax_B = (nOut==0)? dTMax - (dCoverIn+dCoverOut) : (bMergedAD || dL2==0) && !bCrossVar ? dSettle:0;
				pRB->m_dLengthMin_B = (nOut==0)? dTMin - (dCoverIn+dCoverOut) : (bMergedAD || dL2==0) && !bCrossVar ? dSettle:0;
			}
			pRB->m_dLengthMax_C = (bMergedAD || dL2==0) && !bCrossVar ? nOut==0? dSettle:0 : 0;
			pRB->m_dAngleX1 = (bMergedAD || dL2==0) && !bCrossVar ? vWing.GetAngleDegree() : 0;
		}
		pRB->m_bMainRebar = TRUE;
		pRB->m_dRateAdd	= MAKE_RATE;
		SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTD, TRUE);
		if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
			pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
	}
}

// 날개벽 D구간 수직 철근
void CRcBridgeRebar::MakeWingWallRebarJewonVerD(BOOL bStt, BOOL bLeft, int nOut, int nDan)
{
	CWingWall* pWing = GetWingWall(bStt, bLeft);
	if(nDan == 1 && pWing->m_nCountLayerD[nOut] == 1) return;

	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();
	const double dMulti = bLsd? 10 : 1;

	// 철근 초기화
	int nDanIdx = nDan == 0 ? 0 : WW_REBAR_COUNT;
	int nRBIndex = nOut==0 ? WW_REBAR_VER_D_IN : WW_REBAR_VER_D_OUT;
	CRebar* pRB = NULL;
// 	CRebar* pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
// 	pRB->InitData();
// 	if(nOut==0)
// 	{
// 		nRBIndex = WW_REBAR_VER_D_IN_VAR_SEC;
// 		pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
// 		pRB->InitData();
// 		nRBIndex = WW_REBAR_VER_D_IN_VAR_SEC_BLOCK;
// 		pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
// 		pRB->InitData();
// 	}
// 	nRBIndex = nOut==0 ? WW_REBAR_TAIL_END_IN : WW_REBAR_TAIL_END_OUT;
// 	pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
// 	pRB->InitData();
	//////////////

	double dL1 = pWing->m_dL1;
	if(dL1==0) return;

	vector<double> len_ver, len_var, len_var_sec_block, len_var_hu, len_ver_up, len_ver2, len_var2;
	CTwinVector tv;
	CTwinVectorArray tvArr;
	GetTvArrayRebarWingWallBlockDSupportFront(tvArr, bStt, bLeft, nOut, nDan);
	int nSize = tvArr.GetSize();
	if(nSize==0) return;

	double dLenTailVer = 0;
	double dLenTailSlope = 0;
	int i=0; for(i=0; i<nSize; i++)
	{
		tv = tvArr.GetAt(i);
		if(tv.m_sInfo==_T("수직D"))
			len_ver.push_back(tv.GetLength());
		if(tv.m_sInfo==_T("변단면상부수직D"))
			len_ver_up.push_back(tv.GetLength());
		if(tv.m_sInfo==_T("변단면수직D"))
			len_var.push_back(tv.GetLength());
		if(tv.m_sInfo==_T("수직변단면헌치D"))
			len_var_hu.push_back(tv.GetLength());
		if(tv.m_sInfo==_T("수직변단면구간D"))
			len_var_sec_block.push_back(tv.GetLength());
		if(tv.m_sInfo==_T("꼬리수직"))
			dLenTailVer = tv.GetLength();
		if(tv.m_sInfo==_T("꼬리경사"))
			dLenTailSlope = tv.GetLength();
		if(tv.m_sInfo==_T("수직D_2"))
			len_ver2.push_back(tv.GetLength());
		if(tv.m_sInfo==_T("변단면수직D_2"))
			len_var2.push_back(tv.GetLength());
	}

	double dCoverIn = m_dCoverWingIn[0];
	double dCoverOut = m_dCoverWingOut[0];
	double dCover = nOut==0 ? dCoverIn : dCoverOut;
	double dCTC = nOut==0 ? pWing->m_dStdVerCTC/2 : pWing->m_dStdVerCTC;
	double dT1 = pWing->m_dT1;
	double dT2 = pWing->m_dT2;
	double dSH = pWing->m_dSH;
	double dSW = pWing->m_dSW;

	BOOL bVar = IsWingWallVariableSect(bStt, bLeft);
	CDPoint xyVar[3];
	GetXyRebarWingWallVarySect(xyVar, bStt, bLeft);
	double dLenHu = ~(xyVar[2]-xyVar[0]);
	double dLenHuVer = fabs(xyVar[2].y-xyVar[0].y);

	for(long ix=0; ix<2; ++ix)
	{
		if(ix > 0 && pWing->m_bMatchBottom == FALSE)
			continue;

		if(ix == 0)
			nRBIndex = nOut==0 ? WW_REBAR_VER_D_IN : WW_REBAR_VER_D_OUT;
		else
			nRBIndex = nOut==0 ? WW_REBAR_VER_D_IN_FLAT : WW_REBAR_VER_D_OUT_FLAT;

		pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
		if(pRB && pRB->m_bLock == FALSE)
		{
			pRB->InitData();
			pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
			pRB->m_nPos = nOut==0 ? REBAR_POS_WING_BACK : REBAR_POS_WING_FRONT;
			pRB->m_nIdxNumber = nRBIndex;
			pRB->m_sMark = (ix == 0)? _T("W11") : _T("W17");
			pRB->m_sDescription = (ix == 0)? _T("수직폐합구간D") : _T("수직폐합구간D2");
			pRB->m_dDia = pWing->m_dDiaSupportD[nOut][nDan];
			pRB->m_nEa = (ix == 0)? len_ver.size() : len_ver2.size();
			if(pRB->m_nEa>0)
			{
				if(nOut==0 && bVar)
				{
					if(dT1<dT2)
					{
						pRB->m_nTypeRebar = 2;
						if(ix==0)
						{
							pRB->m_dLengthMax_A = *max_element(len_ver.begin(), len_ver.end());
							pRB->m_dLengthMin_A = *min_element(len_ver.begin(), len_ver.end());
							pRB->m_dLengthMax_B = dT1 - (dCoverIn+dCoverOut);
						}
						else
						{
							pRB->m_dLengthMax_A = *max_element(len_ver2.begin(), len_ver2.end());
							pRB->m_dLengthMin_A = *min_element(len_ver.begin(), len_ver.end());
							pRB->m_dLengthMax_B = dT1 - (dCoverIn+dCoverOut);
						}
						pRB->m_dLengthMin_B = 0;
						pRB->m_dLengthMax_C = 0;
						pRB->m_dAngleX1 = 0;
					}
					else
					{
						pRB->m_nTypeRebar = 13;
						pRB->m_dLengthMax_A = dT1 - (dCoverIn+dCoverOut);
						pRB->m_dLengthMin_A = 0;
						if(ix==0)
						{
							pRB->m_dLengthMax_B = *max_element(len_ver.begin(), len_ver.end());
							pRB->m_dLengthMin_B = *min_element(len_ver.begin(), len_ver.end());
						}
						else
						{
							pRB->m_dLengthMax_B = *max_element(len_ver2.begin(), len_ver2.end());
							pRB->m_dLengthMin_B = 0;
						}
						pRB->m_dLengthMax_C = dLenHu;
						pRB->m_dAngleX1 = CDPoint(-dSH, 1).Unit().GetAngleDegree();
					}
				}
				else
				{
					pRB->m_nTypeRebar = 2;
					if(ix==0)
					{
						pRB->m_dLengthMax_A = *max_element(len_ver.begin(), len_ver.end());
						pRB->m_dLengthMin_A = *min_element(len_ver.begin(), len_ver.end());
					}
					else
					{
						pRB->m_dLengthMax_A = *max_element(len_ver2.begin(), len_ver2.end());
						pRB->m_dLengthMin_A = 0;
					}
					pRB->m_dLengthMax_B = dT1 - (dCoverIn+dCoverOut);
					pRB->m_dLengthMin_B = 0;
					pRB->m_dLengthMax_C = 0;
					pRB->m_dAngleX1 = 0;
				}
			}
			pRB->m_bMainRebar = FALSE;
			pRB->m_dRateAdd	= MAKE_RATE;
			SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTD, FALSE);
			if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
				pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
			m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
		}
	}

	if(nOut==0)
	{
		// 변단면 상단수직D - 변단면 상부구간
		nRBIndex = WW_REBAR_VER_D_IN_VAR_UP;
		pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
		if(pRB && pRB->m_bLock == FALSE)
		{
			pRB->InitData();
			pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
			pRB->m_nPos = REBAR_POS_WING_BACK;
			pRB->m_nIdxNumber = nRBIndex;
			pRB->m_sMark = _T("W12");
			pRB->m_sDescription = _T("수직철근D");
			pRB->m_dDia = pWing->m_dDiaSupportD[nOut][nDan];
			pRB->m_nEa = len_ver_up.size();
			if(pRB->m_nEa>0)
			{
				if(dT1<dT2)
				{
					pRB->m_nTypeRebar = 1;
					pRB->m_dLengthMax_A = MAX(*max_element(len_ver_up.begin(), len_ver_up.end()), 0);
					pRB->m_dLengthMin_A = MAX(*min_element(len_ver_up.begin(), len_ver_up.end()), 0);
					pRB->m_dLengthMax_B = 0;
					pRB->m_dLengthMin_B = 0;
					pRB->m_dLengthMax_C = 0;
					pRB->m_dLengthMin_C = 0;
					pRB->m_dAngleX1 = 0;
				}
				else
				{
					pRB->m_nTypeRebar = 8;
					pRB->m_dLengthMax_A = *max_element(len_ver_up.begin(), len_ver_up.end()) - dLenHuVer;
					pRB->m_dLengthMin_A = *min_element(len_ver_up.begin(), len_ver_up.end()) - dLenHuVer;
					pRB->m_dLengthMax_B = dLenHu;
					pRB->m_dLengthMin_B = 0;
					pRB->m_dLengthMax_C = 0;
					pRB->m_dAngleX1 = CDPoint(-dSH, 1).Unit().GetAngleDegree();
				}
			}
			pRB->m_bMainRebar = FALSE;
			pRB->m_dRateAdd	= MAKE_RATE;
			SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTD, FALSE);
			if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
				pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
			m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
		}

		// 변단면 수직철근D - 변단면 하부구간
		for(long ix=0; ix<2; ++ix)
		{
			if(ix > 0 && pWing->m_bMatchBottom == FALSE)
				continue;

			if(ix == 0)
				nRBIndex = WW_REBAR_VER_D_IN_VAR_SEC;
			else
				nRBIndex = WW_REBAR_VER_D_IN_VAR_SEC_FLAT;

			pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
			if(pRB && pRB->m_bLock == FALSE)
			{
				pRB->InitData();
				pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
				pRB->m_nPos = REBAR_POS_WING_BACK;
				pRB->m_nIdxNumber = nRBIndex;
				pRB->m_sMark = (ix==0)? _T("W13") : _T("W18");
				pRB->m_sDescription = (ix==0)? _T("변단면수직철근D") : _T("변단면수직철근D2");
				pRB->m_dDia = pWing->m_dDiaSupportD[nOut][nDan];
				pRB->m_nEa = (ix==0)? len_var.size() : len_var2.size();
				if(pRB->m_nEa>0)
				{
					if(dT1<dT2)
					{
						pRB->m_nTypeRebar = 13;
						pRB->m_dLengthMax_A = dT2 - (dCoverIn+dCoverOut);
						pRB->m_dLengthMin_A = 0;
						if(ix==0)
						{
							pRB->m_dLengthMax_B = MAX(*max_element(len_var.begin(), len_var.end())-dLenHuVer, 0);
							pRB->m_dLengthMin_B = MAX(*min_element(len_var.begin(), len_var.end())-dLenHuVer, 0);
						}
						else
						{
							pRB->m_dLengthMax_B = MAX(*max_element(len_var2.begin(), len_var2.end())-dLenHuVer, 0);
							pRB->m_dLengthMin_B = 0;
						}
						pRB->m_dLengthMax_C = dLenHu;
						pRB->m_dLengthMin_C = 0;
						pRB->m_dAngleX1 = CDPoint(-dSH, 1).Unit().GetAngleDegree();
					}
					else
					{
						pRB->m_nTypeRebar = 1;
						if(ix==0)
						{
							pRB->m_dLengthMax_A = *max_element(len_var.begin(), len_var.end());
							pRB->m_dLengthMin_A = *min_element(len_var.begin(), len_var.end());
						}
						else
						{
							pRB->m_dLengthMax_A = *max_element(len_var2.begin(), len_var2.end());
							pRB->m_dLengthMin_A = 0;
						}
						
						pRB->m_dLengthMax_B = 0;
						pRB->m_dLengthMin_B = 0;
						pRB->m_dLengthMax_C = 0;
						pRB->m_dAngleX1 = 0;
					}
				}
				pRB->m_bMainRebar = FALSE;
				pRB->m_dRateAdd	= MAKE_RATE;
				SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTD, FALSE);
				if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
					pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
				m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
			}
		}

		// 변단면 헌치철근 WW_REBAR_VER_D_IN_VAR_HU
		nRBIndex = WW_REBAR_VER_D_IN_VAR_HU;
		pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
		if(pRB && pRB->m_bLock == FALSE)
		{
			pRB->InitData();
			pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
			pRB->m_nPos = REBAR_POS_WING_BACK;
			pRB->m_nIdxNumber = nRBIndex;
			pRB->m_sMark = _T("W14");
			pRB->m_sDescription = _T("변단면수직변화D");
			pRB->m_dDia = pWing->m_dDiaSupportD[nOut][nDan];
			pRB->m_nEa = len_var_hu.size();
			if(pRB->m_nEa>0)
			{
				if(dT1<dT2)
				{
					pRB->m_nTypeRebar = 46;
					pRB->m_dLengthMax_A = dLenHu;
					pRB->m_dLengthMin_A = (min(dLenHuVer, *min_element(len_var_hu.begin(), len_var_hu.end())) / dLenHuVer * dLenHu);
					pRB->m_dLengthMax_B = dT2 - (dCoverIn+dCoverOut);
					pRB->m_dLengthMin_B = dT1 - (dCoverIn+dCoverOut);
					pRB->m_dLengthMax_C = 0;
					pRB->m_dLengthMin_C = 0;
					pRB->m_dAngleX1 = CDPoint(-dSH, 1).Unit().GetAngleDegree() - 90;
				}
				else
				{
					pRB->m_nTypeRebar = 2;
					pRB->m_dLengthMax_A = *max_element(len_var_hu.begin(), len_var_hu.end());
					pRB->m_dLengthMin_A = *min_element(len_var_hu.begin(), len_var_hu.end());
					pRB->m_dLengthMax_B = dT2 - (dCoverIn+dCoverOut);
					pRB->m_dLengthMin_B = 0;
					pRB->m_dLengthMax_C = 0;
					pRB->m_dAngleX1 = 0;
				}
			}
			pRB->m_bMainRebar = FALSE;
			pRB->m_dRateAdd	= MAKE_RATE;
			SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTD, FALSE);
			if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
				pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
			m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
		}
	}

	nRBIndex = nOut==0 ? WW_REBAR_VER_D_IN_VAR_SEC_BLOCK : WW_REBAR_VER_D_OUT_VAR_SEC_BLOCK;
	pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
	if(pRB && pRB->m_bLock == FALSE)
	{
		pRB->InitData();
		pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
		pRB->m_nPos = nOut==0 ? REBAR_POS_WING_BACK : REBAR_POS_WING_FRONT;
		pRB->m_nIdxNumber = nRBIndex;
		pRB->m_sMark = _T("W15");
		pRB->m_sDescription = _T("변단면구간수직철근D");
		pRB->m_dDia = pWing->m_dDiaSupportD[nOut][nDan];
		pRB->m_nEa = len_var_sec_block.size();
		if(pRB->m_nEa>0)
		{
			pRB->m_nTypeRebar = 2;
			pRB->m_dLengthMax_A = *max_element(len_var_sec_block.begin(), len_var_sec_block.end());
			pRB->m_dLengthMin_A = *min_element(len_var_sec_block.begin(), len_var_sec_block.end());
			pRB->m_dLengthMax_B = dT2 - (dCoverIn+dCoverOut);
			pRB->m_dLengthMin_B = dT1 - (dCoverIn+dCoverOut);
		}
		pRB->m_bMainRebar = FALSE;
		pRB->m_dRateAdd	= MAKE_RATE;
		SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTD, FALSE);
		if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
			pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
	}

	nRBIndex = nOut==0 ? WW_REBAR_TAIL_END_IN : WW_REBAR_TAIL_END_OUT;
	pRB = pWing->m_pArrRebar[nDanIdx + nRBIndex];
	if(pRB && pRB->m_bLock == FALSE)
	{
		pRB->InitData();
		pRB->m_Fy	= m_pARcBridgeDataStd->m_Fy;
		pRB->m_nPos = nOut==0 ? REBAR_POS_WING_BACK : REBAR_POS_WING_FRONT;
		pRB->m_nIdxNumber = nRBIndex;
		pRB->m_sMark = _T("W16");
		pRB->m_sDescription = _T("끝단철근D");
		pRB->m_dDia = pWing->m_dDiaMainD[nOut][nDan];
		pRB->m_nEa = 1;
		if(pRB->m_nEa>0)
		{
			pRB->m_nTypeRebar = 8;
			pRB->m_dLengthMax_A = dLenTailSlope;
			pRB->m_dLengthMax_B = dLenTailVer;
			pRB->m_dAngleX1 = CDPoint(-1, dSW).Unit().GetAngleDegree();
		}
		pRB->m_bMainRebar = TRUE;
		pRB->m_dRateAdd	= MAKE_RATE;
		dCTC = nOut==0 ? pWing->m_dMainCTCA/2 : pWing->m_dMainCTCA;
		if(nOut==0 && pWing->m_bSelMainCTCD)
			dCTC = pWing->m_dMainCTCA;
		SetRebarLsdOptionWingWall(pRB->m_pOptionLsd, bStt, bLeft, nOut==0, WINGWALL_SECTD, FALSE);
		if(pRB->m_pOptionLsd->dFy > 0 && bLsd)		
			pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
	}
}

// 날개벽 벽체부 헌치 철근
void CRcBridgeRebar::MakeWingWallRebarJewonHunchWall(BOOL bStt, BOOL bLeft)
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();

	CWingWall* pWing = GetWingWall(bStt, bLeft);

	// 철근 초기화
	int nRBIndex = WW_REBAR_HUNCH_WALL_UP;
	CRebar* pRB = NULL;
// 	CRebar* pRB = pWing->m_pArrRebar[nRBIndex];
// 	pRB->InitData();
// 	nRBIndex = WW_REBAR_HUNCH_WALL_LO;
// 	pRB = pWing->m_pArrRebar[nRBIndex];
// 	pRB->InitData();
	//////////////

	if(!pWing->m_bExist) return;
	if(!(pWing->m_dHuH2 > 0 && pWing->m_dHuW2 > 0)) return;

	CTwinVector tv;
	CTwinVectorArray tvArr, tvArrHu;
	GetTvArrayRebarWingWallHunchWallFront(tvArr, bStt, bLeft);
	GetTvArrayRebarWingWallHunchWallPlane(tvArrHu, bStt, bLeft, TRUE);
	double dB = GetLengthWingWallBlockBC(bStt, bLeft, TRUE);
	int nSize = tvArr.GetSize();
	int nEaLower =0;
	int i=0; for(i=0; i<nSize; i++)
	{
		tv = tvArr.GetAt(i);
		if(tv.m_v1.y<=dB)
			nEaLower++;
	}

	int nHunchCTC = pWing->m_nHunchCTC;
	double dCover = m_dCoverWingOut[0];
	double dCTC = nHunchCTC==0 ? pWing->m_dMainCTCB/2 : pWing->m_dMainCTCB;
	double dDiaUpper = pWing->m_dDiaHuUpper;
	double dDiaLower = pWing->m_dDiaHuLower;
	if(dDiaUpper==dDiaLower)
		nEaLower = 0;
	CDPoint vHu1 = tvArrHu.GetAt(bLeft ? 0 : 1).GetXyDir(TRUE);
	CDPoint vHu2 = tvArrHu.GetAt(bLeft ? 1 : 0).GetXyDir();

	nRBIndex = WW_REBAR_HUNCH_WALL_UP;
	pRB = pWing->m_pArrRebar[nRBIndex];
	if(pRB && pRB->m_bLock == FALSE)
	{
		pRB->InitData();
		pRB->m_Fy	= bLsd? GetValueFy(bStt? ePartWingWallStt : ePartWingWallEnd) : m_pARcBridgeDataStd->m_Fy;
		pRB->m_nPos = REBAR_POS_WING_ETC;
		pRB->m_nIdxNumber = nRBIndex;
		pRB->m_sMark = _T("W13");
		pRB->m_sDescription = _T("벽체헌치철근1");
		pRB->m_dDia = dDiaUpper;
		pRB->m_nEa = nSize - nEaLower;
		if(pRB->m_nEa>0)
		{
			pRB->m_nTypeRebar = 9;
			pRB->m_dLengthMax_A = tvArrHu.GetAt(1).GetLength();
			pRB->m_dLengthMax_B = tvArrHu.GetAt(0).GetLength();
			pRB->m_dAngleX1 = pRB->m_dAngleX2 = vHu2.BetweenAngle(vHu1).GetAngleDegree();
		}
		pRB->m_bMainRebar = FALSE;
		pRB->m_dRateAdd	= MAKE_RATE;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
	}

	nRBIndex = WW_REBAR_HUNCH_WALL_LO;
	pRB = pWing->m_pArrRebar[nRBIndex];
	if(pRB && pRB->m_bLock == FALSE)
	{
		pRB->InitData();
		pRB->m_Fy	= bLsd? GetValueFy(bStt? ePartWingWallStt : ePartWingWallEnd) :m_pARcBridgeDataStd->m_Fy;
		pRB->m_nPos = REBAR_POS_WING_ETC;
		pRB->m_nIdxNumber = nRBIndex;
		pRB->m_sMark = _T("W14");
		pRB->m_sDescription = _T("벽체헌치철근2");
		pRB->m_dDia = dDiaLower;
		pRB->m_nEa = nEaLower;
		if(pRB->m_nEa>0)
		{
			pRB->m_nTypeRebar = 9;
			pRB->m_dLengthMax_A = tvArrHu.GetAt(1).GetLength();
			pRB->m_dLengthMax_B = tvArrHu.GetAt(0).GetLength();
			pRB->m_dAngleX1 = pRB->m_dAngleX2 = vHu2.BetweenAngle(vHu1).GetAngleDegree();
		}
		pRB->m_bMainRebar = FALSE;
		pRB->m_dRateAdd	= MAKE_RATE;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
	}
}

// 날개벽 기초부 헌치 철근
void CRcBridgeRebar::MakeWingWallRebarJewonHunchFoot(BOOL bStt, BOOL bLeft)
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();

	CWingWall* pWing = GetWingWall(bStt, bLeft);

	// 철근 초기화
	int nRBIndex = WW_REBAR_HUNCH_FOOT;
	CRebar* pRB = pWing->m_pArrRebar[nRBIndex];
	//////////////

	if(!pWing->m_bExist) return;

	CTwinVectorArray tvArr, tvArrHu;
	GetTvArrayRebarWingWallHunchFootingFront(tvArr, bStt, bLeft);
	GetTvArrayRebarWingWallHunchFootingSect(tvArrHu, bStt, bLeft);

	double dDiaHu = pWing->m_dDiaHuFoot;
	double dCover = m_dCoverWingOut[0];
	double dCTC = pWing->m_dStdVerCTC;
	CDPoint vHu1 = tvArrHu.GetAt(bLeft ? 0 : 1).GetXyDir(TRUE);
	CDPoint vHu2 = tvArrHu.GetAt(bLeft ? 1 : 0).GetXyDir();

	nRBIndex = WW_REBAR_HUNCH_FOOT;
	pRB = pWing->m_pArrRebar[nRBIndex];
	if(pRB && pRB->m_bLock == FALSE)
	{
		pRB->InitData();
		pRB->m_Fy	= bLsd? GetValueFy(bStt? ePartWingWallStt : ePartWingWallEnd) : m_pARcBridgeDataStd->m_Fy;
		pRB->m_nPos = REBAR_POS_WING_ETC;
		pRB->m_nIdxNumber = nRBIndex;
		pRB->m_sMark = _T("W15");
		pRB->m_sDescription = _T("기초헌치철근");
		pRB->m_dDia = dDiaHu;
		pRB->m_nEa = tvArr.GetSize();
		if(pRB->m_nEa>0)
		{
			pRB->m_nTypeRebar = 9;
			pRB->m_dLengthMax_A = tvArrHu.GetAt(1).GetLength();
			pRB->m_dLengthMax_B = tvArrHu.GetAt(0).GetLength();
			pRB->m_dAngleX1 = pRB->m_dAngleX2 = vHu2.BetweenAngle(vHu1).GetAngleDegree();
		}
		pRB->m_bMainRebar = FALSE;
		pRB->m_dRateAdd	= MAKE_RATE;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTC);
	}
}

// 날개벽 A구간 전단 철근
void CRcBridgeRebar::MakeWingWallRebarJewonShearA(BOOL bStt, BOOL bLeft)
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();

	CWingWall* pWing = GetWingWall(bStt, bLeft);

	// 철근 초기화
	int nDan = 0;
	int nRBIndex = WW_REBAR_SHEAR_A;
	CRebar* pRB = pWing->m_pArrRebar[nRBIndex];
	//////////////

	double dL2 = pWing->m_dL2;
	if(dL2==0) return;

	CTwinVectorArray tvArr;
	GetTvArrayRebarWingWallShearAFront(tvArr, bStt, bLeft, 0);

	double dRebarSpace	= pWing->m_dSpaceShearA;
	double dCover = m_dCoverWingIn[0] + m_dCoverWingOut[0];
	double dMax = pWing->m_dT2;
	double dMin = pWing->m_nDirHunch == 1 ? pWing->m_dT1 : pWing->m_dT2;
	double dDiaA = pWing->m_dDiaMainA[0][nDan];
	double dCTCA = pWing->m_dMainCTCA/2;
	int nBind = pWing->m_nCountShearBind;

	nRBIndex = WW_REBAR_SHEAR_A;
	pRB = pWing->m_pArrRebar[nRBIndex];
	if(pRB && pRB->m_bLock == FALSE)
	{
		pRB->InitData();
		pRB->m_Fy	= bLsd? GetValueFy(bStt? ePartWingWallStt : ePartWingWallEnd, TRUE) : m_pARcBridgeDataStd->m_Fy;
		pRB->m_nPos = REBAR_POS_WING_ETC;
		pRB->m_nIdxNumber = nRBIndex;
		pRB->m_sMark = _T("W16");
		pRB->m_sDescription = _T("전단철근A");

		double dExt = dDiaA + pRB->m_dDia;
		double dSettle = m_pARcBridgeDataStd->GetValueJoint(pWing->m_RebarShearDetailA.m_dDia, JOINT_TENS_NORMAL_B, toCm(pWing->m_dSpaceShearA));
		double dLenMaxA = (pWing->m_RebarShearDetailA.m_nType == TYPE_SHEAR_DIGUT || pWing->m_RebarShearDetailA.m_nType == TYPE_SHEAR_SINGLE_HOOK) ? dMax - dCover + dExt : dCTCA*(nBind) + dExt;
		double dLenMaxB = dMax - dCover + dExt;
		double dLenMinB = dMin - dCover + dExt;
	
		pWing->m_RebarShearDetailA.SetRB(pRB, pWing->m_dDiaMainA[0][nDan], pWing->m_dDiaMainA[1][nDan], dLenMaxA, dLenMaxB, dSettle);
		pWing->m_RebarShearDetailA.SetMin(dLenMaxA, dLenMinB);
		pWing->m_RebarShearDetailA.SetDataDefaultRebarJewon();

		pRB->m_nEa = tvArr.GetSize();
		pRB->m_bMainRebar = FALSE;
		pRB->m_dRateAdd	= MAKE_RATE;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, m_dCoverWingOut[0], dRebarSpace);
	}
}

// 날개벽 BC구간 전단 철근
void CRcBridgeRebar::MakeWingWallRebarJewonShearBC(BOOL bStt, BOOL bLeft)
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();

	CWingWall* pWing = GetWingWall(bStt, bLeft);

	// 철근 초기화
	int nDan = 0;
	int nRBIndex = WW_REBAR_SHEAR_B;
	CRebar* pRB = pWing->m_pArrRebar[nRBIndex];
	//////////////

	double dL2 = pWing->m_dL2;
	if(dL2==0) return;

	CTwinVectorArray tvArr;
	CTwinVector tv;
	GetTvArrayRebarWingWallShearBCFront(tvArr, bStt, bLeft, 0);

	double dCover = m_dCoverWingIn[0] + m_dCoverWingOut[0];
	double dT2 = pWing->m_dT2;
	double dDiaB = pWing->m_dDiaMainB[0][nDan];
	double dDiaC = pWing->m_dDiaMainC[0][nDan];
	double dCTCB = pWing->m_dMainCTCB/2;
	double dCTCC = pWing->m_dStdVerCTC/2;
	int nBind = pWing->m_nCountShearBind;
	long nEaHor = 0;
	long nEaVer = 0;

	long i=0; for(i=0; i<tvArr.GetSize(); i++)
	{
		tv = tvArr.GetAt(i);
		if(tv.m_sInfo == "전단B")
		{
			nEaHor++;
		}
		else if(tv.m_sInfo == "전단C")
		{
			nEaVer++;
		}
	}

	double dExt = 0;
	double dSettle = 100;
	double dRebarSpace	= 0;
	double dLenMaxB = 0;

	nRBIndex = WW_REBAR_SHEAR_B;
	pRB = pWing->m_pArrRebar[nRBIndex];
	if(pRB && pRB->m_bLock == FALSE)
	{
		pRB->InitData();
		pRB->m_Fy	= bLsd? GetValueFy(bStt? ePartWingWallStt : ePartWingWallEnd, TRUE) : m_pARcBridgeDataStd->m_Fy;
		pRB->m_nPos = REBAR_POS_WING_ETC;
		pRB->m_nIdxNumber = nRBIndex;
		pRB->m_sMark = _T("W17");
		pRB->m_sDescription = _T("수직전단철근BC");

		dExt = dDiaB + pRB->m_dDia;
		dRebarSpace	= pWing->m_dSpaceShearB;
		double dLenMaxA = (pWing->m_RebarShearDetailA.m_nType == TYPE_SHEAR_DIGUT || pWing->m_RebarShearDetailA.m_nType == TYPE_SHEAR_SINGLE_HOOK) ? dT2 - dCover + dExt : dCTCB*(nBind) + dExt;
		dLenMaxB = dT2 - dCover + dExt;

		dSettle = m_pARcBridgeDataStd->GetValueJoint(pWing->m_RebarShearDetailB.m_dDia, JOINT_TENS_NORMAL_B, toCm(dRebarSpace));
		pRB->m_nEa = nEaHor;
		pWing->m_RebarShearDetailB.SetRB(pRB, pWing->m_dDiaMainB[0][nDan], pWing->m_dDiaMainB[1][nDan], dLenMaxA, dLenMaxB, dSettle);
		pWing->m_RebarShearDetailB.SetMin(dLenMaxA, dLenMaxB);
		pWing->m_RebarShearDetailB.SetDataDefaultRebarJewon();

		pRB->m_bMainRebar = FALSE;
		pRB->m_dRateAdd	= MAKE_RATE;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, m_dCoverWingOut[0], dRebarSpace);
	}
	
	nRBIndex = WW_REBAR_SHEAR_C;
	pRB = pWing->m_pArrRebar[nRBIndex];
	if(pRB && pRB->m_bLock == FALSE)
	{
		pRB->InitData();
		pRB->m_Fy	= bLsd? GetValueFy(bStt? ePartWingWallStt : ePartWingWallEnd, TRUE) : m_pARcBridgeDataStd->m_Fy;
		pRB->m_nPos = REBAR_POS_WING_ETC;
		pRB->m_nIdxNumber = nRBIndex;
		pRB->m_sMark = _T("W17");
		pRB->m_sDescription = _T("수평전단철근BC");

		dExt = dDiaC + pRB->m_dDia;
		dRebarSpace	= pWing->m_dSpaceShearC;
		double dLenMaxA = (pWing->m_RebarShearDetailA.m_nType == TYPE_SHEAR_DIGUT || pWing->m_RebarShearDetailA.m_nType == TYPE_SHEAR_SINGLE_HOOK) ? dT2 - dCover + dExt : dCTCC*(nBind) + dExt;
		dLenMaxB = dT2 - dCover + dExt;
		dSettle = m_pARcBridgeDataStd->GetValueJoint(pWing->m_RebarShearDetailC.m_dDia, JOINT_TENS_NORMAL_B, toCm(dRebarSpace));
		
		pRB->m_nEa = nEaVer;
		pWing->m_RebarShearDetailC.SetRB(pRB, pWing->m_dDiaMainC[0][nDan], pWing->m_dDiaMainC[1][nDan], dLenMaxA, dLenMaxB, dSettle);
		pWing->m_RebarShearDetailC.SetMin(dLenMaxA, dLenMaxB);
		pWing->m_RebarShearDetailC.SetDataDefaultRebarJewon();

		pRB->m_bMainRebar = FALSE;
		pRB->m_dRateAdd	= MAKE_RATE;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, m_dCoverWingOut[0], dRebarSpace);
	}
}

// 날개벽 D구간 전단 철근
void CRcBridgeRebar::MakeWingWallRebarJewonShearD(BOOL bStt, BOOL bLeft)
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();


	CWingWall* pWing = GetWingWall(bStt, bLeft);

	// 철근 초기화
	int nDan = 0;
	int nRBIndex = WW_REBAR_SHEAR_D;
	CRebar* pRB = pWing->m_pArrRebar[nRBIndex];
	//////////////

	double dL1 = pWing->m_dL1;
	if(dL1==0) return;

	CTwinVectorArray tvArr;
	GetTvArrayRebarWingWallShearDFront(tvArr, bStt, bLeft, 0);

	double dRebarSpace	= pWing->m_dSpaceShearD;
	double dCover = m_dCoverWingIn[0] + m_dCoverWingOut[0];
	double dMax = pWing->m_nDirHunch == 2 ? pWing->m_dT1 : pWing->m_dT2;	// 가로방향 변단면일 때는 D구간이 무조건 얇다,,
	double dMin = pWing->m_nDirHunch == 1 ? pWing->m_dT1 : pWing->m_dT2;	// 세로방향 변단면일 때는 D구간이 변단면을 포함한다.
	double dDiaD = pWing->m_dDiaMainD[0][nDan];
	double dCTCD = pWing->m_dMainCTCA/2;
	int nBind = pWing->m_nCountShearBind;

	nRBIndex = WW_REBAR_SHEAR_D;
	pRB = pWing->m_pArrRebar[nRBIndex];
	if(pRB && pRB->m_bLock == FALSE)
	{
		pRB->InitData();
		pRB->m_Fy	= bLsd? GetValueFy(bStt? ePartWingWallStt : ePartWingWallEnd, TRUE) : m_pARcBridgeDataStd->m_Fy;
		pRB->m_nPos = REBAR_POS_WING_ETC;
		pRB->m_nIdxNumber = nRBIndex;
		pRB->m_sMark = _T("W18");
		pRB->m_sDescription = _T("전단철근D");

		double dExt = dDiaD + pRB->m_dDia;
		double dSettle = m_pARcBridgeDataStd->GetValueJoint(pWing->m_RebarShearDetailD.m_dDia, JOINT_TENS_NORMAL_B, toCm(dRebarSpace));
		double dLenMaxA = (pWing->m_RebarShearDetailA.m_nType == TYPE_SHEAR_DIGUT || pWing->m_RebarShearDetailA.m_nType == TYPE_SHEAR_SINGLE_HOOK) ? dMax - dCover + dExt : dCTCD*(nBind) + dExt;
		double dLenMaxB = dMax - dCover + dExt;
		double dLenMinB = dMin - dCover + dExt;

		pWing->m_RebarShearDetailD.SetRB(pRB, pWing->m_dDiaMainD[0][nDan], pWing->m_dDiaMainD[1][nDan], dLenMaxA, dLenMaxB, dSettle);
		pWing->m_RebarShearDetailD.SetMin(dLenMaxA, dLenMinB);
		pWing->m_RebarShearDetailD.SetDataDefaultRebarJewon();

		pRB->m_nEa = tvArr.GetSize();
		pRB->m_bMainRebar = FALSE;
		pRB->m_dRateAdd	= MAKE_RATE;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, m_dCoverWingOut[0], dRebarSpace);
	}
}

// 흉벽보강철근
void CRcBridgeRebar::MakeWingWallRebarJewonReinforce(BOOL bStt, BOOL bLeft)
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();

	CWingWall* pWing = GetWingWall(bStt, bLeft);

	// 철근 초기화
	int nDan = 0;
	int nRBIndex = WW_REBAR_REINFORCE_A;
	CRebar* pRB = pWing->m_pArrRebar[nRBIndex];
	
	if(!pWing->m_bAddRebarReinforce || pWing->m_nAttachPos == 1) return;
	
	BOOL bMergeAD = IsMergedRebarWingWall(bStt, bLeft, 0, nDan, 'A', 'D');
	long nEaA = 0;
	long nEaB = 0;
	CTwinVector tv;
	CTwinVectorArray tvArrA, tvArrB;
	if(bMergeAD)
		GetTvArrayRebarWingWallBlockDMainFront(tvArrA, bStt, bLeft, 0, nDan);
	else
		GetTvArrayRebarWingWallBlockAMainFront(tvArrA, bStt, bLeft, 0, nDan);

	GetTvArrayRebarWingWallBlockBMainFront(tvArrB, bStt, bLeft, 0, nDan);
	int nSizeA = tvArrA.GetSize();
	int nSizeB = tvArrB.GetSize();
	if(nSizeA==0 && nSizeB==0) 
	{
		pRB->InitData();
		return;
	}

	int i=0; for(i=0; i<nSizeA; i++)
	{
		tv = tvArrA.GetAt(i);
		if(tv.m_sInfo==_T("상단경사A"))
			nEaA++;
		if(tv.m_sInfo==_T("수평A"))
			nEaA++;
		if(tv.m_sInfo==_T("수평변단면A"))
			nEaA++;
		if(tv.m_sInfo==_T("수평변단면구간A"))
			nEaA++;

		if(tv.m_sInfo==_T("상단경사D"))
			nEaA++;
		if(tv.m_sInfo==_T("수평D"))
			nEaA++;
		if(tv.m_sInfo==_T("수평변화D"))
			nEaA++;
		if(tv.m_sInfo==_T("수평변단면D"))
			nEaA++;
		if(tv.m_sInfo==_T("수평변단면구간D"))
			nEaA++;
	}

	for(i=0; i<nSizeB; i++)
	{
		tv = tvArrB.GetAt(i);
		if(tv.m_sInfo==_T("수평변화B"))
			nEaB++;
		if(tv.m_sInfo==_T("수평B"))
			nEaB++;
		if(tv.m_sInfo==_T("수평변단면B"))
			nEaB++;
		if(tv.m_sInfo==_T("수평변단면변화B"))
			nEaB++;
	}

	double dCoverIn = m_dCoverWingIn[0];
	double dCover = dCoverIn;
	double dCTCA = pWing->m_dMainCTCA/2;
	double dCTCB = pWing->m_dMainCTCB/2;
	double dDiaA = pWing->m_dDiaMainA[0][nDan];
	double dDiaB = pWing->m_dDiaMainB[0][nDan];
	double dSettle = 1000;
	CDPoint vWing = GetAngleWingWallBetweenWall(bStt, bLeft);
	int nBaseRebar = 0;

	// A 구간
	nRBIndex = WW_REBAR_REINFORCE_A;
	pRB = pWing->m_pArrRebar[nRBIndex];
	if(pRB && pRB->m_bLock == FALSE)
	{
		pRB->m_Fy	= bLsd? GetValueFy(bStt? ePartWingWallStt : ePartWingWallEnd) : m_pARcBridgeDataStd->m_Fy;
		pRB->m_nPos = REBAR_POS_WING_ETC;
		pRB->m_nIdxNumber = nRBIndex;
		pRB->m_sMark = _T("W19");
		pRB->m_sDescription = _T("흉벽보강철근A");
		pRB->m_dDia = dDiaA;
		pRB->m_nEa = nEaA;
		if(pRB->m_nEa>0)
		{
			nBaseRebar = 2;
			pRB->m_nTypeRebar = GetWingWallRebarDetail(bStt, bLeft, nBaseRebar);
			pRB->m_dLengthMax_A = 3000;
			pRB->m_dLengthMin_A = 3000;
			pRB->m_dLengthMax_B = dSettle;
			pRB->m_dLengthMax_C = 0;
			pRB->m_dAngleX1 = vWing.GetAngleDegree();
		}
		pRB->m_bMainRebar = FALSE;
		pRB->m_dRateAdd	= MAKE_RATE;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTCA);
	}

	// B 구간
	nRBIndex = WW_REBAR_REINFORCE_B;
	pRB = pWing->m_pArrRebar[nRBIndex];
	if(pRB && pRB->m_bLock == FALSE)
	{
		pRB->m_Fy	= bLsd? GetValueFy(bStt? ePartWingWallStt : ePartWingWallEnd) : m_pARcBridgeDataStd->m_Fy;
		pRB->m_nPos = REBAR_POS_WING_ETC;
		pRB->m_nIdxNumber = nRBIndex;
		pRB->m_sMark = _T("W20");
		pRB->m_sDescription = _T("흉벽보강철근B");
		pRB->m_dDia = dDiaB;
		pRB->m_nEa = nEaB;
		if(pRB->m_nEa>0)
		{
			nBaseRebar = 2;
			pRB->m_nTypeRebar = GetWingWallRebarDetail(bStt, bLeft, nBaseRebar);
			pRB->m_dLengthMax_A = 3000;
			pRB->m_dLengthMin_A = 3000;
			pRB->m_dLengthMax_B = dSettle;
			pRB->m_dLengthMax_C = 0;
			pRB->m_dAngleX1 = vWing.GetAngleDegree();
		}
		pRB->m_bMainRebar = FALSE;
		pRB->m_dRateAdd	= MAKE_RATE;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dCTCB);
	}
}

// 날개벽 철근 번호
void CRcBridgeRebar::MakeWingWallRebarNumber(BOOL bStt, BOOL bLeft)
{
	CString str = _T("");
	if(bStt && bLeft)
		str = _T("W");
	else if(bStt && !bLeft)
		str = _T("X");
	else if(!bStt && bLeft)
		str = _T("Y");
	else
		str = _T("Z");

	int nCount = 0;
	CString strNum = _T("");
	CRebar* pRB = NULL;
	CWingWall* pWing = GetWingWall(bStt, bLeft);

	for(long i=WW_REBAR_SLOPE_A_IN; i<WW_REBAR_COUNT * 2; i++)
	{
		pRB = pWing->m_pArrRebar[i];
		if(pRB->IsTrue())
		{
			nCount++;
			strNum.Format(_T("%d"), nCount);
			pRB->m_sMark = str + strNum;
			if(i >= WW_REBAR_COUNT)
			{
				pRB->m_sDescription += _T(" 2단");
			}
		}
	}
}

// 날개벽 철근을 배면, 전면, 기타 순으로 정렬
// void CRcBridgeRebar::SetAlignRebarWingWall(BOOL bStt, BOOL bLeft)
// {
// 	CWingWall* pWing = GetWingWall(bStt, bLeft);
// 
// 	CSafetyTypedPtrArray <CObArray, CRebar*> pArrRebarBack;
// 	CSafetyTypedPtrArray <CObArray, CRebar*> pArrRebarFront;
// 	CSafetyTypedPtrArray <CObArray, CRebar*> pArrRebarETC;
// 
// 	int i = 0;
// 	for(i=0; i<pWing->m_pArrRebar.GetSize(); i++)
// 	{
// 		CRebar* pRB = pWing->m_pArrRebar[i];
// 		CRebar* pRBNew = new CRebar;
// 		*pRBNew = *pRB;
// 
// 		if(pRB->m_nPos==REBAR_POS_WING_BACK)
// 			pArrRebarBack.Add(pRBNew);
// 		else if(pRB->m_nPos==REBAR_POS_WING_FRONT)
// 			pArrRebarFront.Add(pRBNew);
// 		else
// 			pArrRebarETC.Add(pRBNew);
// 	}
// 
// 	pWing->m_pArrRebar.RemoveAll();
// 	for(i=0; i<pArrRebarBack.GetSize(); i++)
// 	{
// 		CRebar* pRB = pArrRebarBack[i];
// 		CRebar* pRBNew = new CRebar;
// 		*pRBNew = *pRB;
// 		pWing->m_pArrRebar.Add(pRBNew);
// 	}
// 	for(i=0; i<pArrRebarFront.GetSize(); i++)
// 	{
// 		CRebar* pRB = pArrRebarFront[i];
// 		CRebar* pRBNew = new CRebar;
// 		*pRBNew = *pRB;
// 		pWing->m_pArrRebar.Add(pRBNew);
// 	}
// 	for(i=0; i<pArrRebarETC.GetSize(); i++)
// 	{
// 		CRebar* pRB = pArrRebarETC[i];
// 		CRebar* pRBNew = new CRebar;
// 		*pRBNew = *pRB;
// 		pWing->m_pArrRebar.Add(pRBNew);
// 	}
// 
// 	AhTPADelete(&pArrRebarBack, (CRebar*)0);
// 	AhTPADelete(&pArrRebarFront, (CRebar*)0);
// 	AhTPADelete(&pArrRebarETC, (CRebar*)0);
// }

void CRcBridgeRebar::SetDataDefaultRebarJewonWingWall(BOOL bStt, BOOL bLeft)
{
	int se = bStt ? -1 : 1;
	int lr = bLeft ? -1 : 1;

	CWingWall* pWing = GetWingWall(bStt, bLeft);

// 삭제하고 다시 만들 경우 Lock 처리를 못함.
// 	AhTPADelete(&pWing->m_pArrRebar, (CRebar*)0);
// 	AhTPAMake(WW_REBAR_COUNT * 2, &pWing->m_pArrRebar, (CRebar*)0);

	// (39729) 다시 만들진 않더라도 InitData는 한번 해주고 가자.
	long nSize = pWing->m_pArrRebar.GetSize();
	for(long ix=0; ix<nSize; ix++)
	{
		CRebar *pRb = pWing->m_pArrRebar.GetAt(ix);
		if(pRb->m_bLock == FALSE)
			pRb->InitData();
	}

	if(!pWing->m_bExist) return;

	int nSizeSide = pWing->m_xyArrSide[0][0].GetSize();
	int nSizeUpper = pWing->m_xyArrUpper[0][0].GetSize();
	int nSizeLower = pWing->m_xyArrLower[0][0].GetSize();

	if(nSizeSide == 0 || nSizeUpper == 0 || (pWing->m_dL2!=0 && nSizeLower ==0)) return;

//	long nTypeJongdanForRebarOrg = m_nTypeJongdanForRebar;
//	m_nTypeJongdanForRebar = 2;

	//SyncBridge(se*lr);

	GetTvVertSection_Std(se*lr, TRUE, FALSE, FALSE, 2);

	for(long nDan = 0; nDan < 2; nDan++)
	{
		MakeWingWallRebarJewonHorA(bStt, bLeft, 0, nDan);
		MakeWingWallRebarJewonHorA(bStt, bLeft, 1, nDan);
		MakeWingWallRebarJewonVerA(bStt, bLeft, 0, nDan);
		MakeWingWallRebarJewonVerA(bStt, bLeft, 1, nDan);
		MakeWingWallRebarJewonHorB(bStt, bLeft, 0, nDan);
		MakeWingWallRebarJewonHorB(bStt, bLeft, 1, nDan);
		MakeWingWallRebarJewonVerC(bStt, bLeft, 0, nDan);
		MakeWingWallRebarJewonVerC(bStt, bLeft, 1, nDan);
		MakeWingWallRebarJewonHorD(bStt, bLeft, 0, nDan);
		MakeWingWallRebarJewonHorD(bStt, bLeft, 1, nDan);
		MakeWingWallRebarJewonVerD(bStt, bLeft, 0, nDan);
		MakeWingWallRebarJewonVerD(bStt, bLeft, 1, nDan);
	}
	MakeWingWallRebarJewonHunchWall(bStt, bLeft);
	MakeWingWallRebarJewonHunchFoot(bStt, bLeft);
	MakeWingWallRebarJewonShearA(bStt, bLeft);
	MakeWingWallRebarJewonShearBC(bStt, bLeft);
	MakeWingWallRebarJewonShearD(bStt, bLeft);
	MakeWingWallRebarJewonReinforce(bStt, bLeft);

//	SetAlignRebarWingWall(bStt, bLeft);
	MakeWingWallRebarNumber(bStt, bLeft);

	GetTvVertSection_Std(se*lr, TRUE, FALSE, TRUE);
	//m_nTypeJongdanForRebar	= nTypeJongdanForRebarOrg;
}

// 해당 sta에 해당 rc를 리턴(상부슬래브 주철근들)
// 없으면 null
CRebarInfoCycle* CRcBridgeRebar::GetRCMain_Slab(BOOL bUpperSlab, double dSta, BOOL bUpper, long nDan, long nCycle, BOOL bNotCompareSta)
{
	long upper	= bUpper ? iUPPER : iLOWER;
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC;
	if(bUpperSlab)
		pArrRC = &m_pArrRCMainUpperSlab[nCycle][upper][nDan];
	else
		pArrRC = &m_pArrRCMainLowerSlab[nCycle][upper][nDan];

	double dStaLeft			= 0;
	double dStaRight		= 0;

	CRebarInfoCycle *pRC	= NULL;
	CRebarInfoCycle *pRCResult	= NULL;

	long nSize	= pArrRC->GetSize();
	if(bNotCompareSta && nSize > 0) return pArrRC->GetAt(0);

	long i = 0; for(i = 0; i < nSize; i++)
	{
		pRC	= pArrRC->GetAt(i);

		if(pRC->m_bUseEndExt)
		{
			dStaLeft	= pRC->m_xyStt.x;
			dStaRight	= pRC->m_xyEndExt.x;
		}
		else
		{
			dStaLeft	= pRC->m_xyStt.x;
			dStaRight	= pRC->m_nPosStt == pRC->m_nPosEnd ? pRC->m_xyMid1.x : pRC->m_xyEnd.x;
		}

		if(dStaLeft <= dSta && dStaRight >= dSta)
		{
			pRCResult	= pRC;
			break;
		}
	}

	return pRCResult;
}

// 해당 sta에 해당 rc 리턴(상부슬래브 헌치부 철근들)
CRebarInfoCycle* CRcBridgeRebar::GetRCMain_SlabHunch(BOOL bUpperSlab, double dSta, long nCycle, BOOL bNotCompareSta)
{
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC;
	if(bUpperSlab)
		pArrRC	= &m_pArrRCMainUpperSlabHunch[nCycle];
	else
		pArrRC	= &m_pArrRCMainLowerSlabHunch[nCycle];

	
	

	CRebarInfoCycle *pRC	= NULL;
	CRebarInfoCycle *pRCResult	= NULL;

	long nSize	= pArrRC->GetSize();
	if(bNotCompareSta && nSize > 0) return pArrRC->GetAt(0);

	long i = 0; for(i = 0; i < nSize; i++)
	{
		pRC	= pArrRC->GetAt(i);
		
		double dStaLeft			= 0;
		dStaLeft	= pRC->m_xyStt.x;
		// 상부슬래브헌치도 오류가 있네.. pRC->m_nPosStt, pRC->m_nPosEnd를그냥 슬래브로만 넣어놓는데.. 그냥 Stt, End쓰면되지 Mid는 무슨...
		// dStaRight	= pRC->m_nPosStt == pRC->m_nPosEnd ? pRC->m_xyMid1.x : pRC->m_xyEnd.x;
		double dStaRight		= 0;
		dStaRight	= pRC->m_xyEnd.x;
		if(dStaLeft > dStaRight) GetSwap(dStaLeft, dStaRight);

		if(dStaLeft <= dSta && dStaRight >= dSta)
		{
			pRCResult	= pRC;
			break;
		}
	}

	return pRCResult;
}

// 외측벽체 제원으로 wall 을 만들어 낸다.
// BOOL bInner : 벽체 안쪽과 바깥쪽은 상부슬래브의 높이가 다른다.
void CRcBridgeRebar::MakeWallByOutWall(CWallApp &wall, BOOL bStt, BOOL bApplyAngle, BOOL bDefaultSupAndShear, BOOL bAcute, BOOL bLeft, double dStation)
{
	if(!IsOutWall(bStt)) return;

	long nStt	= bStt ? iSTT : iEND;
	
	// 형상 만듬 
	MakeWallByOutWallOnlyShape(wall, bStt, bApplyAngle, bDefaultSupAndShear, dStation);
	if(IsBoxType())
	{
		CTwinVector tvLower;
		tvLower = GetTvOffset_LowerSlab(0, FALSE, -1, -1, bApplyAngle);
		wall.m_tvArrLowerLimit_FrontRebar.RemoveAll();
		wall.m_tvLowerLimitOfMainRebar		= tvLower;
		tvLower.m_v1.y -= m_dCoverLower_LowerSlab[0];
		tvLower.m_v2.y -= m_dCoverLower_LowerSlab[0];
		wall.m_tvArrLowerLimit_FrontRebar.Add(tvLower);
		
		tvLower = GetTvOffset_LowerSlab(-1, TRUE, -1, -1, bApplyAngle);
		wall.m_tvLowerLimitOfSupportRebar		= tvLower;
		
		wall.m_dCoverLower_LowerSlab			= m_dCoverLower_LowerSlab[0];
		wall.m_bRebarLowerSettle[iLEFT]			= bStt? TRUE : FALSE;
		wall.m_bRebarLowerSettle[iRIGHT]		= bStt? FALSE : TRUE;
	}
	
	// 배근 관련 convert
	wall.m_nIdxCTC_MainRebar				= m_nIdxCTC_MainRebar;
	wall.m_dCTC_MainRebar					= GetCtcRebarMain(TRUE);
	wall.m_nIdxCTC_SupportAndShearRebar		= m_nIdxCTC_SupportAndShearRebar;
	wall.m_dCTC_SupportRebar				= m_dCTC_SupportRebarOutWall[nStt];
	wall.m_dCTC_ShearRebar					= m_dCTC_ShearRebarOutWall[nStt];
	wall.m_rebarShearDetail					= m_RebarShearDetail_OutWall[nStt];
	wall.m_bSameOffsetPlaceTAndCBlock		= m_bSameOffsetPlaceTAndCBlock;	// 인장 압축구간을 동일 간격으로 배치
	wall.m_bPlacing23DanByStandardOffset	= m_bPlacing23DanByStandardOffset;
	wall.m_nTypeCurveOfVertRebar			= m_nTypeCurveOfWallVertRebar;
	wall.m_bApplyAngleToMainRebarCTC		= m_nTypePlacingMainRebar_UpperSlab == 0;
	wall.m_dRangeSupportRebarForSameUpperSlab	= m_dRangeSupportRebarForSameUpperSlab[nStt];
	wall.m_placeByBlock_SupportRebarAddSameUpperSlab	= m_placeByBlock_SupportRebarAddSameUpperSlab[nStt];	// 상부슬래브 처럼 꺽을 배력근이 추가될 범위
	wall.m_dDistAddSupportRebarForSameUpperSlab[iLEFT]	= m_dDistAddSupportRebarForSameUpperSlab[nStt][iLEFT];	// 상부슬래브 처럼 꺽을 추가되는 배력근의 좌우측 거리
	wall.m_dDistAddSupportRebarForSameUpperSlab[iRIGHT]	= m_dDistAddSupportRebarForSameUpperSlab[nStt][iRIGHT];	// 상부슬래브 처럼 꺽을 추가되는 배력근의 좌우측 거리
	wall.m_Fy								= GetValueFy(bStt? ePartOutWallStt : ePartOutWallEnd, FALSE);
	wall.m_Fck								= GetValueFck(bStt? ePartOutWallStt : ePartOutWallEnd);
	wall.m_pBasicConcInfo					= m_pARcBridgeDataStd->m_pBasicConcInfo;
	wall.m_nCountWrapMainRebar				= m_nCountWrapMainRebarForOutWall[nStt];
	wall.m_bDetailInput23DanMainRebar		= m_bDetailInput23DanMainRebar;
	wall.m_setRebarDan[iLEFT]				= m_pArrSetRebarDanOutWall[nStt][iLEFT];
	wall.m_setRebarDan[iRIGHT]				= m_pArrSetRebarDanOutWall[nStt][iRIGHT];

	// 주철근
	if(bAcute)
	{
		long stt	= bStt ? iSTT : iEND;
		long left	= bLeft ? iLEFT : iRIGHT;
		long leftRC	= bStt ? iLEFT : iRIGHT;

		CRebarInfoCycle *pRCTmp	 = new CRebarInfoCycle;
		*pRCTmp	= m_rebarInfoCycle_AcuteAngle_OutWall[stt][left];
		wall.m_pArrRCMain[0][leftRC][0].Add(pRCTmp);

		wall.m_dCTC_MainRebar /= 2;
		wall.m_placeByBlock_SupportRebar[leftRC][0]	= m_placeByBlock_AcuteAngle_SupportRebar_OutWall[stt][left];
	}
	else
	{
		long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
		{
			long left = 0; for(left = 0; left < 2; left++)
			{
				BOOL bLeft	= left == iLEFT;
				long inner	= bStt ? (bLeft ? iOUTTER : iINNER) : (bLeft ? iINNER : iOUTTER);
				BOOL bInner	= inner == iINNER;

				long cycle = 0; for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
				{
					AhTPACopy(&wall.m_pArrRCMain[cycle][left][dan], &m_pArrRCMainOutWall[cycle][nStt][inner][dan], (CRebarInfoCycle*)0);

					long stt	= bStt ? iSTT : iEND;

					wall.m_dArrDiaRC[cycle][left][dan]	= m_pArrDiaOutWall[cycle][stt][inner][dan];
					wall.m_dArrExistRC[cycle][left][dan]	= m_pArrExistOutWall[cycle][stt][inner][dan];
					wall.m_dArrDistRC[cycle][left][dan]	= m_pArrDistOutWall[cycle][stt][inner][dan];
				}

				// 내측은 추가할 필요 없음.
				if(bInner) continue;

				// 시종점 벽체의 경우 상부슬래브 철근 하나가 내려 와 있다. 이거를 포함 시켜 줘야 된다.
				// 단 시종점에 있는 철근이 아니라면 붙이지 않는다.
				if((bStt && left==iLEFT) || (!bStt && left==iRIGHT))
				{
					for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
					{
						// 시종점 철근이 2단이 아니면 붙이지 않음
						// 벽체에서는 어짜피 안 보이므로
						if(GetDanMainRebarUpperSlab(cycle, TRUE, bStt ? 0 : -1) > dan)
						{
							CRebarInfoCycle *pRCTmp	= GetRebarInfoCycleUpperSlab(cycle, dan, TRUE, bStt ? 0 : -1);
							if(pRCTmp)
							{
								BOOL bSttRebar	= TRUE;
								if(IsMainRebarJointUpperSlabAndOutWall(pRCTmp, bSttRebar))
								{
									CRebarInfoCycle *pRC	= new CRebarInfoCycle;
									*pRC	= *pRCTmp;
									// 종점측은 벽체 아래에서 위로 올라가도록 해준다.
									if(!bSttRebar)
									{
										pRC->m_xyStt	= pRCTmp->m_xyEndExt;
										pRC->m_xyMid1	= pRCTmp->m_xyMidExt;
										pRC->m_xyMid2	= pRCTmp->m_xyEnd;
										pRC->m_xyEnd	= pRCTmp->m_xyMid2;
										pRC->m_xyMidExt	= pRCTmp->m_xyMid1;
										pRC->m_xyEndExt	= pRCTmp->m_xyStt;
										pRC->m_R_Mid	= pRCTmp->m_R_MidExt;
										pRC->m_R_MidExt	= pRCTmp->m_R_Mid;
										pRC->m_xyCen	= pRCTmp->m_xyCenExt;
										pRC->m_xyCenExt	= pRCTmp->m_xyCen;
									}

									pRC->m_bVariableLength	= TRUE;
									pRC->m_bVariablePos		= FALSE;
									wall.m_pArrRCMain[cycle][left][dan].Add(pRC);
								}
								else
								{
									CRebarInfoCycle *pRC	= new CRebarInfoCycle;
									*pRC	= *pRCTmp;
									// 종점측은 벽체 아래에서 위로 올라가도록 해준다.
									if(!bStt)
									{
										pRC->m_xyStt	=  pRCTmp->m_xyEnd;
										pRC->m_xyMid1	= pRCTmp->m_xyMid2;
										pRC->m_xyMid2	= pRCTmp->m_xyMid1;
										pRC->m_xyEnd	= pRCTmp->m_xyStt;
										pRC->m_R_Mid	= pRCTmp->m_R_Mid;
										pRC->m_xyCen	= pRCTmp->m_xyCen;
									}
									pRC->m_bVariablePos	= TRUE;
									pRC->m_bVariableLength	= FALSE;
									wall.m_pArrRCMain[cycle][left][dan].Add(pRC);
								}
							}
						}

						// Box타입이면 하부슬래브의 주철근도 추가해준다.
						if(IsBoxType() && GetDanMainRebarLowerSlab(cycle, FALSE, bStt ? 0 : -1) > dan)
						{
							CRebarInfoCycle *pRCTmp	= GetRebarInfoCycleLowerSlab(cycle, dan, FALSE, bStt ? 0 : -1);
							if(pRCTmp)
							{
								BOOL bSttRebar	= TRUE;
								if(IsMainRebarJointLowerSlabAndOutWall(pRCTmp, bSttRebar))
								{
									CRebarInfoCycle *pRC	= new CRebarInfoCycle;
									*pRC	= *pRCTmp;
									// 시점측은 벽체 아래에서 위로 올라가도록 해준다.
									if(bSttRebar)
									{
										pRC->m_xyStt	= pRCTmp->m_xyEndExt;
										pRC->m_xyMid1	= pRCTmp->m_xyMidExt;
										pRC->m_xyMid2	= pRCTmp->m_xyEnd;
										pRC->m_xyEnd	= pRCTmp->m_xyMid2;
										pRC->m_xyMidExt	= pRCTmp->m_xyMid1;
										pRC->m_xyEndExt	= pRCTmp->m_xyStt;
										pRC->m_R_Mid	= pRCTmp->m_R_MidExt;
										pRC->m_R_MidExt	= pRCTmp->m_R_Mid;
										pRC->m_xyCen	= pRCTmp->m_xyCenExt;
										pRC->m_xyCenExt	= pRCTmp->m_xyCen;
									}

									pRC->m_bVariableLength	= TRUE;
									pRC->m_bVariablePos		= FALSE;
									wall.m_pArrRCMain[cycle][left][dan].InsertAt(0, pRC);
								}
								else
								{
									CRebarInfoCycle *pRC	= new CRebarInfoCycle;
									*pRC	= *pRCTmp;
									// 시점측은 벽체 아래에서 위로 올라가도록 해준다.
									if(bStt)
									{
										pRC->m_xyStt	=  pRCTmp->m_xyEnd;
										pRC->m_xyMid1	= pRCTmp->m_xyMid2;
										pRC->m_xyMid2	= pRCTmp->m_xyMid1;
										pRC->m_xyEnd	= pRCTmp->m_xyStt;
										pRC->m_R_Mid	= pRCTmp->m_R_Mid;
										pRC->m_xyCen	= pRCTmp->m_xyCen;
									}

									pRC->m_bVariableLength	= TRUE;
									pRC->m_bVariablePos		= FALSE;
									wall.m_pArrRCMain[cycle][left][dan].InsertAt(0, pRC);
								}
							}
						}
					}
				}
			}
		}

		// 배력철근 
		for(dan = 0; dan < MAX_REBAR_DAN; dan++)
		{
			long left = 0; for(left = 0; left < 2; left++)
			{
				long inner	= bStt ? (left==iLEFT ? iOUTTER : iINNER) : (left==iLEFT ? iINNER : iOUTTER);
				BOOL bInner	= inner == iINNER;
				wall.m_placeByBlock_SupportRebar[left][dan]	= m_placeByBlock_SupportRebar_OutWall[nStt][inner][dan];

				// 단부에 있는 배력근 하나를 벽체로 넣어줌.
				if(dan == 0 && !bInner)
				{
					CDPointArray xyArr;
					GetXyRebarSupport_VertSection_UpperSlabDanBu(xyArr, bStt);
					if(xyArr.GetSize() > 0)
					{
						CDPointArray xyArrSup;
						GetXyRebarSupport_VertSection_OutWall(xyArrSup, bStt, bInner, 0);
						if(xyArrSup.GetSize() > 0)
						{
							CDPoint xyLast	= xyArrSup.GetAt(xyArrSup.GetSize() - 1);

							wall.m_placeByBlock_SupportRebar[left][dan].m_nCountBlock++;
							wall.m_placeByBlock_SupportRebar[left][dan].m_xyArr.Add(CDPoint(1, xyArr.GetAt(xyArr.GetSize()-1).y - xyLast.y));
						}
					}

					if(IsBoxType())
					{
						GetXyRebarSupport_VertSection_LowerSlabDanBu(xyArr, bStt);
						if(xyArr.GetSize() > 0)
						{
							CDPointArray xyArrSup;
							GetXyRebarSupport_VertSection_OutWall(xyArrSup, bStt, bInner, 0);
							if(xyArrSup.GetSize() > 1)
							{
								CDPoint xyFirst	= xyArr.GetAt(0);

								wall.m_placeByBlock_SupportRebar[left][dan].m_nCountBlock++;
								wall.m_placeByBlock_SupportRebar[left][dan].m_xyArr.InsertAt(0, CDPoint(1, xyFirst.y - xyArrSup.GetAt(0).y));
								wall.m_placeByBlock_SupportRebar[left][dan].m_xyArr.SetAt(0, CDPoint(1, xyArrSup.GetAt(1).y -  xyFirst.y));
							}
						}
					}					
				}
			}
		}

		// 전단철근
		wall.m_placeByBlock_ShearRebar	= m_placeByBlock_ShearRebar_OutWall[nStt];

		long i = 0; for(i = 0; i < m_pArrRebarMain.GetSize(); i++)
		{
			CRebar *pRBTmp	= m_pArrRebarMain.GetAt(i);
			if(pRBTmp->m_sDescription.Find(bStt ? "종점측벽체" : "시점측벽체", 0) != -1)
				continue;

			CRebar *pRB	= new CRebar(pRBTmp);
			wall.m_pArrRebarMain.Add(pRB);
		}
		//AhTPACopy(&wall.m_pArrRebarMain, &m_pArrRebarMain, (CRebar*)0);

		for(i = 0; i < m_pArrRebarSupport.GetSize(); i++)
		{
			CRebar *pRBTmp	= m_pArrRebarSupport.GetAt(i);
			if(pRBTmp->m_sDescription.Find(bStt ? "종점측벽체" : "시점측벽체", 0) != -1)
				continue;

			CRebar *pRB	= new CRebar(pRBTmp);
			wall.m_pArrRebarSupport.Add(pRB);
		}
		//AhTPACopy(&wall.m_pArrRebarSupport, &m_pArrRebarSupport, (CRebar*)0);

		for(i = 0; i < m_pArrRebarShear.GetSize(); i++)
		{
			CRebar *pRBTmp	= m_pArrRebarShear.GetAt(i);
			if(pRBTmp->m_sDescription.Find(bStt ? "종점측벽체" : "시점측벽체", 0) != -1)
				continue;

			CRebar *pRB	= new CRebar(pRBTmp);
			wall.m_pArrRebarShear.Add(pRB);
		}
		//AhTPACopy(&wall.m_pArrRebarShear, &m_pArrRebarShear, (CRebar*)0);
	}


	wall.m_sNameLeft	= bStt ? "외측" : "내측";
	wall.m_sNameRight	= bStt ? "내측" : "외측";
}

// 주철근에 대해서 마크 리턴함.
// bInit 이면 초기화만 한다.
// 그렇지 않은 경우 증가된 값을 리턴

/* 철근마크 리턴을 위한 부위 정의 ///////////////////////////////
#define MARK_UPPERSLAB_UPPER	0	// 상부슬래브 상면 철근 마크
#define MARK_UPPERSLAB_LOWER	1	// 상부슬래브 하면 철근 마크
#define MARK_UPPERSLAB_HUNCH	2	// 상부슬래브 헌치부 철근 마크
#define MARK_STTWALL_INNER		3	// 시점측벽체 내측 철근 마크
#define MARK_STTWALL_OUTTER		4	// 시점측벽체 외측 철근 마크
#define MARK_ENDWALL_INNER		5	// 종점측벽체 내측 철근 마크
#define MARK_ENDWALL_OUTTER		6	// 종점측벽체 외측 철근 마크
#define MARK_OUTWALL_HUNCH		7	// 외측벽체 헌치 철근 마크
#define MARK_OBTUSE_UPPER		8	// 상부슬래브 둔각부 상면
#define MARK_OBTUSE_LOWER		9	// 상부슬래브 둔각부 하면
#define MARK_OBTUSE_CROSS		10	// 상부슬래브 둔각부 (횡)
#define MARK_ACUTE_OUTWALL		11	// 외측벽체 예각부 
#define MARK_ARCHRIB_UPPER			12	// 리브 상면
#define MARK_ARCHRIB_LOWER			13	// 리브 하면

/////////////////////////////////////////////////////////////////*/

CString CRcBridgeRebar::GetMarkRebarMain(long nType, BOOL bInput, long nCycle, BOOL bOnlyInit, BOOL bForBM, CString sDescription, long nDan)
{
	static long nNum	= 1;
	if(bOnlyInit) 
	{
		nNum		= 1;
		return _T("");
	}

	CString sMark		= _T("");
	if(!bInput && !bForBM)
	{
		CString sMark	= _T("");

		CRebar *pRB	= GetRebarMainByDescription(sDescription);
		if(pRB)
		{
			sMark	= pRB->m_sMark;
		}

		return sMark;
	}
	
	switch(nType)
	{
	case MARK_UPPERSLAB_UPPER:	sMark	= bInput ? "TU" : "T"; break;
	case MARK_UPPERSLAB_LOWER:	sMark	= bInput ? "TL" : "T"; break;
	case MARK_UPPERSLAB_HUNCH:	sMark	= bInput ? "TH" : "H"; break;
	case MARK_STTWALL_INNER:	sMark	= bInput ? "SI" : "OW"; break;
	case MARK_STTWALL_OUTTER:	sMark	= bInput ? "SO" : "OW"; break;
	case MARK_ENDWALL_INNER:	sMark	= bInput ? "EI" : "OW"; break;
	case MARK_ENDWALL_OUTTER:	sMark	= bInput ? "EO" : "OW"; break;
	case MARK_OUTWALL_HUNCH:	sMark	= /*bInput ? "OH" : */ "OH"; break;
	case MARK_OBTUSE_UPPER:		sMark	= bInput ? "UD" : "OT"; break;
	case MARK_OBTUSE_LOWER:		sMark	= bInput ? "LD" : "OT"; break;
	case MARK_ACUTE_OUTWALL:	sMark	= bInput ? "OD" : "AT"; break;
	case MARK_ARCHRIB_UPPER:	sMark	= bInput ? "RU" : "RB"; break;	// 리브 상면
	case MARK_ARCHRIB_LOWER:	sMark	= bInput ? "RL" : "RB"; break;	// 리브 하면
	case MARK_LOWERSLAB_UPPER:	sMark	= bInput ? "TU" : "LT"; break;
	case MARK_LOWERSLAB_LOWER:	sMark	= bInput ? "TL" : "LT"; break;
	case MARK_LOWERSLAB_HUNCH:	sMark	= bInput ? "TH" : "LH"; break;
	case MARK_OBTUSE_UPPER_LOWSLAB: sMark	= bInput ? "DU" : "OT"; break;
	case MARK_OBTUSE_LOWER_LOWSLAB: sMark	= bInput ? "DL" : "OT"; break;

	default: break;
	}

	if(!bInput || nDan == 0)
	{
		sMark	= sMark + COMMA(nNum);
		nNum++;	
	}

	return sMark;
}	

// 본체 철근 집계 통합
// 1. 상부슬래브
// 2. 외측벽체
// 3. 내측벽체 
void CRcBridgeRebar::SetDataDefaultRebarJewonMainStd()
{
	CHgBaseConcStd baseConc;
	baseConc.ClearRebarJewon(&m_pArrRebarMain, TRUE);

	// (39755) 철근수량 종단면은 주철근 배치 옵션과 맞게...
	GetTvVertSection_Std(0, !IsVertDir(), FALSE, FALSE);

	SyncBridgeRebar(FALSE);
	SetDataDefaultRebarJewonUpperSlab();
	SetDataDefaultRebarJewonLowerSlab();
	SetDataDefaultRebarJewonSlabHunch(TRUE); 
	SetDataDefaultRebarJewonSlabHunch(FALSE); 
	SetDataDefaultRebarJewonUpperSlabDanbu(TRUE);
	SetDataDefaultRebarJewonUpperSlabDanbu(FALSE);
	SetDataDefaultRebarJewonOutWall();
	SetDataDefaultRebarJewonInWall();
	SetDataDefaultRebarJewonBFooting();

	if(m_nTypeBridge == BRIDGE_TYPE_ARCH)
		SetDataDefaultRebarJewonArchRib();

	///////////////////////////////////////////////////////////////////////////

	SetDataDefaultRebarJewonFooting();

	///////////////////////////////////////////////////////////////////////////

	SetDataDefaultRebarJewon_Slab_Obtuse(TRUE);
	if(IsBoxType())
		SetDataDefaultRebarJewon_Slab_Obtuse(FALSE);

	GetTvVertSection_Std(0, TRUE, FALSE, TRUE);
}

// 상부슬래브 철근 집계
// m_nCountRebarDanbu : 단부 철근 개수 셋팅
void CRcBridgeRebar::SetDataDefaultRebarJewonUpperSlab()
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd		= pStd->IsLsdDesign();
	const double dMulti		= bLsd? 10 : 1;

	long dan(0), upper(0), cycle(0), nIdx(0), nSize(0), left(0), stt(0);
	BOOL bUpper(TRUE), bStt(TRUE), bLeft(TRUE);
	CString sUpper(_T("")), sCycle(_T("")), sStt(_T("")), sLeft(_T("")), sInner(_T(""));

	for(stt = 0; stt < 2; stt++)
	{
		m_nCountRebarDanbu[iUPPER][0][stt]	= 0;
		m_nCountRebarDanbu[iUPPER][1][stt]	= 0;
	}

	CHgBaseConcStd baseConc;
	CRebarPlacing rb;

	CTwinVectorArray tvArr, tvArrAngLeft, tvArrAngRight, tvArrVertLeft, tvArrVertRight, tvArrVertTotLen;
	CTwinVectorArray tvArrJoint, tvArrHidden, tvArrHiddenLeft, tvArrHiddenRight;
	CTwinVector tv;
	CRebarInfoCycle *pRC	= NULL;
	double dLenRound	= 0;	// 라운드된 철근에서 라운드부분의 평면상의 길이
	double dLenRoundL	= 0;	// 사보강일때 왼쪽 R
	double dLenRoundR	= 0;	// 사보강일때 오른쪽 R
	double dLenMax		= 0;	// 최대길이
	double dLenMin		= 0;	// 최소길이
	double dCover		= 0;	// 피복
	double dRebarSpace	= 0;	// 간격

	double dRad		= 1;
	// 경사로 구하는 경우 수평 거리는 경사각도를 적용한다.	
	if(m_nTypeJongdanForRebar != 0)
	{
		CTwinVector tvUpper	= m_tvArrVertSection.GetTvByInfo(m_nTypeBridge == BRIDGE_TYPE_SLAB ? "슬래브상면(1번째지간)" : "슬래브상면(외측벽체안쪽)");
		dRad	= fabs(sin(ToRadian(90 - tvUpper.GetXyDir().GetAngleDegree())));
	}
	
	// 사보강(절반) 배치 일때 직방향 철근 잘린거 있을 수 있다.(따로 집계함

	// 주철근
	dRebarSpace	= m_dCTC_MainRebar/2;

	// 상부 슬래브
	for(cycle = 0; cycle < GetCountCycleMainRebar(); cycle++)
	{
		sCycle	= m_pARcBridgeDataStd->GetStringCircleNum(cycle+1);

		for(upper = 0; upper < 2; upper++)
		{
			bUpper	= upper == iUPPER ? TRUE : FALSE;
			sUpper	= bUpper ? "상" : "하";
			
			for(dan = 0; dan < MAX_REBAR_DAN; dan++)
			{
				dCover	= bUpper ? m_dCoverUpper_UpperSlab[dan] : m_dCoverLower_UpperSlab[dan];


				long nSizeRC	= m_pArrRCMainUpperSlab[cycle][upper][dan].GetSize();
				for(nIdx = 0; nIdx < nSizeRC; nIdx++)
				{
					tvArr.RemoveAll();

					GetTvRebarMain_Plane_UpperSlab_TypeNormal_Std(tvArr, tvArrAngLeft, tvArrAngRight, bUpper, cycle, dan, 0, nIdx, FALSE, FALSE, FALSE, tvArrJoint, tvArrHidden, tvArrHiddenLeft, tvArrHiddenRight, TRUE, tvArrVertLeft, tvArrVertRight);
					pRC	= GetRebarInfoCycleUpperSlab(cycle, dan, bUpper, nIdx);
					if(!pRC) continue;
					if(!pRC->m_bExist) continue;

					// 사보강(절반) 배치일때 직방향 철근 분리.
					/*
					if(m_nTypePlacingMainRebar_UpperSlab == 2)
					{
						m_Util.DivideVertMainRebarBySabogang(tvArrVertTotLen, tvArrVertLeft, tvArrVertRight);
					}
					*/

					// Round반지름이 차지 하는 길이 
					dLenRound	= 0;
					dLenRoundL	= 0;
					dLenRoundR	= 0;
					if(pRC->m_nPosStt != pRC->m_nPosEnd)
					{
						dLenRound	= tvArrHidden.GetSize() > 0 ? tvArrHidden.GetAt(0).GetLength() : 0;
						dLenRoundL	= tvArrHiddenLeft.GetSize() > 0 ? tvArrHiddenLeft.GetAt(0).GetLength() : 0;
						dLenRoundR	= tvArrHiddenRight.GetSize() > 0 ? tvArrHiddenRight.GetAt(0).GetLength() : 0;
					}

					BOOL bSttTmp	= nIdx == 0;
					if(nIdx == 0 || nIdx == nSizeRC-1)
					{
						if(IsRebarMainOneLineUpperSlab(TRUE, bSttTmp))
							dLenRoundL	= 0;
						if(IsRebarMainOneLineUpperSlab(FALSE, bSttTmp))
							dLenRoundR	= 0;
					}

					// 평면상에서 최대와 최소 길이를 판단해서 철근 집계함.
					// ang == 0 : 기본철근
					// ang == 1 : 좌측철근
					// ang == 2 : 우측철근
					// ang == 3 : 좌측변화구간(직방향)
					// ang == 4 : 우측변화구간(직방향)
					double dLenRoundApply	= dLenRound;
					for(long ang = 0; ang < 5; ang++)
					{
						CTwinVectorArray *pTvArr	= NULL;
						switch(ang)
						{
							case 0: 
								pTvArr	= &tvArr; 
								dLenRoundApply = dLenRound; 
								break;
							case 1: 
								pTvArr	= &tvArrAngLeft; 
								dLenRoundApply	= dLenRoundL;
								break;
							case 2: 
								pTvArr	= &tvArrAngRight; 
								dLenRoundApply	= dLenRoundR;
								break;
							case 3:
								pTvArr	= &tvArrVertLeft;
								dLenRoundApply	= 0;
								break;
							case 4:
								pTvArr	= &tvArrVertRight;
								dLenRoundApply	= 0;
								break;
							default: break;
						}
						if(!pTvArr) return;

						dLenMax	= 0;
						dLenMin	= 0;
						nSize	= pTvArr->GetSize();
						if(nSize > 0)
						{
							CLineInfo *pLineCur	= NULL;
							if(ang == 0)
								pLineCur	= GetLineBase(IsVertDir());
							else if(ang == 1)
								pLineCur	= GetLineLeftRight(TRUE);
							else if(ang == 2)
								pLineCur	= GetLineLeftRight(FALSE);

							long i = 0; for(i = 0; i < pTvArr->GetSize(); i++)
							{
								tv	= pTvArr->GetAt(i);

								
								if(i == 0)
								{
									dLenMax	= GetLengthLineByPlaneXy(tv.m_v1, tv.m_v2, pLineCur);
									dLenMin	= GetLengthLineByPlaneXy(tv.m_v1, tv.m_v2, pLineCur);
								}
								else
								{
									dLenMax	= max(GetLengthLineByPlaneXy(tv.m_v1, tv.m_v2, pLineCur), dLenMax);
									dLenMin	= min(GetLengthLineByPlaneXy(tv.m_v1, tv.m_v2, pLineCur), dLenMin);
								}
							}

							// 주인철근이 있으면 주인 철근에 묻어가자.
							CRebarInfoCycle *pRCOwner	= GetOwerRebarInfoCycleSlab(TRUE, cycle, dan, bUpper, nIdx);
							if(pRCOwner && pRCOwner != pRC)
							{
								CRebar *pRBOwner	= NULL;
								for(i = 0; i < m_pArrRebarMain.GetSize(); i++)
								{
									pRBOwner	= m_pArrRebarMain.GetAt(i);
									if(pRBOwner->m_sDescription == pRCOwner->m_sDescription)
									{
										pRBOwner->m_nEa += nSize;
										break;
									}
								}
							}
							else
							{
								CRebar *pRB	= new CRebar;
								pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
								pRB->m_sDescription	= pRC->m_sDescription;
								pRB->m_sMark		= pRC->m_szMark;
								if(ang > 0)
								{
									pRB->m_sDescription.Format("%s(%s)", pRC->m_sDescription, ang==1 ? "좌1" : "우1");
									if(ang > 2)
										pRB->m_sDescription.Format("%s(%s)", pRC->m_sDescription, ang==3 ? "좌2" : "우2");
									pRB->m_sMark.Format("%s-%d", pRC->m_szMark, ang);
								}

								pRB->m_dDia			= pRC->m_Dia;
								// 중간에 짤린거 는 일체형만 아니라면 직선철근이다.
								if((ang == 3 || ang == 4 || (pRC->m_nPosStt == pRC->m_nPosEnd && (Compare(dLenRoundApply, 0.0, "="))) && !IsMainRebarJointUpperSlabAndUpperSlab(pRC)))
								{
									pRB->m_dLengthMax_A	= dLenMax/dRad;
									pRB->m_dLengthMin_A	= dLenMin/dRad;
									pRB->m_nTypeRebar	= 1;
								}
								else
								{
									BOOL bSttRebar	= TRUE;
									// 상부슬래브와 외측벽체 연결된 형태
									// 편경사에 의해서 변화치수 나옴
									if(IsMainRebarJointUpperSlabAndOutWall(pRC, bSttRebar))
									{
										CTwinVectorArray tvArrMainWall, tvArrJoint;
										GetTvRebarMain_Side_OutWall(tvArrMainWall, bSttRebar, FALSE, cycle, dan, -1, tvArrJoint);
										double dLenMax	= tvArrMainWall.GetLengthMax();
										double dLenMin	= tvArrMainWall.GetLengthMin();

										if(bSttRebar)
										{
											pRB->m_dLengthMax_A	= ~(pRC->m_xyStt-pRC->m_xyMid1);
											pRB->m_dLengthMin_A	= 0;
											pRB->m_dLengthMax_B	= dLenMax - (fabs(pRC->m_xyMid1.y-pRC->m_xyMid2.y)) - (fabs(pRC->m_xyEnd.y - pRC->m_xyMidExt.y));
											pRB->m_dLengthMin_B	= dLenMin - (fabs(pRC->m_xyMid1.y-pRC->m_xyMid2.y)) - (fabs(pRC->m_xyEnd.y - pRC->m_xyMidExt.y));
											pRB->m_dLengthMax_C	= ~(pRC->m_xyMidExt-pRC->m_xyEndExt);
											pRB->m_dLengthMin_C	= ~(pRC->m_xyMidExt-pRC->m_xyEndExt);
											pRB->m_dLengthMax_C1	= pRC->GetLengthMid();
											pRB->m_dLengthMin_C1	= pRB->m_dLengthMax_C1;
											pRB->m_dLengthMax_C2	= pRC->GetLengthMidExt();
											pRB->m_dLengthMin_C2	= pRB->m_dLengthMax_C2;
											
											if(pRC->m_R_Mid > 0)
											{
												pRB->m_dLengthMax_R1	= pRC->m_R_Mid;
												pRB->m_dLengthMin_R1	= pRB->m_dLengthMax_R1;
											}

											if(pRC->m_R_MidExt > 0)
											{
												pRB->m_dLengthMax_R2	= pRC->m_R_MidExt;
												pRB->m_dLengthMin_R2	= pRB->m_dLengthMax_R2;
											}

										}
										else
										{
											pRB->m_dLengthMax_C	= pRC->GetLengthStt();
											pRB->m_dLengthMin_C	= pRC->GetLengthStt();
											pRB->m_dLengthMax_B	= dLenMax - (fabs(pRC->m_xyMid1.y-pRC->m_xyMid2.y)) - (fabs(pRC->m_xyEnd.y - pRC->m_xyMidExt.y));
											pRB->m_dLengthMin_B	= dLenMin - (fabs(pRC->m_xyMid1.y-pRC->m_xyMid2.y)) - (fabs(pRC->m_xyEnd.y - pRC->m_xyMidExt.y));
											pRB->m_dLengthMax_A	= ~(pRC->m_xyMidExt-pRC->m_xyEndExt);
											pRB->m_dLengthMin_A	= 0;
											pRB->m_dLengthMax_C1	= pRC->GetLengthMidExt();
											pRB->m_dLengthMin_C1	= pRB->m_dLengthMax_C1;
											pRB->m_dLengthMax_C2	= pRC->GetLengthMid();
											pRB->m_dLengthMin_C2	= pRB->m_dLengthMax_C2;
											pRB->m_dLengthMax_R1	= pRC->m_R_MidExt;
											pRB->m_dLengthMin_R1	= pRB->m_dLengthMax_R1;
											pRB->m_dLengthMax_R2	= pRC->m_R_Mid;
											pRB->m_dLengthMin_R2	= pRB->m_dLengthMax_R2;
										}

										// 타입 결정
										if(Compare(pRB->m_dLengthMax_R1, 0.0, ">") && Compare(pRB->m_dLengthMax_R2, 0.0, ">"))
											pRB->m_nTypeRebar	= 86;
										else if(Compare(pRB->m_dLengthMax_R1, 0.0, ">") && Compare(pRB->m_dLengthMax_R2, 0.0, "="))
											pRB->m_nTypeRebar	= 87;
										else if(Compare(pRB->m_dLengthMax_R1, 0.0, "=") && Compare(pRB->m_dLengthMax_R2, 0.0, ">"))
											pRB->m_nTypeRebar	= 88;
										else if(Compare(pRB->m_dLengthMax_R1, 0.0, "=") && Compare(pRB->m_dLengthMax_R2, 0.0, "="))
											pRB->m_nTypeRebar	= 89;
									}
									// 상부슬래브 주철근 일체형
									else if(IsMainRebarJointUpperSlabAndUpperSlab(pRC))
									{
										pRB->m_dLengthMax_A	= ~(pRC->m_xyStt - pRC->m_xyMid1);
										pRB->m_dLengthMin_A	= 0;
										pRB->m_dLengthMax_B	= dLenMax/dRad;
										pRB->m_dLengthMin_A	= dLenMin/dRad;
										pRB->m_dLengthMax_C	= ~(pRC->m_xyMidExt-pRC->m_xyEndExt);
										pRB->m_dLengthMin_C	= 0;
										pRB->m_dLengthMax_C1	= pRC->GetLengthMid();
										pRB->m_dLengthMin_C1	= pRB->m_dLengthMax_C1;
										pRB->m_dLengthMax_R1	= pRC->m_R_Mid;
										pRB->m_dLengthMin_R1	= pRB->m_dLengthMax_R1;
										pRB->m_dLengthMax_C2	= pRC->GetLengthMidExt();
										pRB->m_dLengthMin_C2	= pRB->m_dLengthMax_C2;
										pRB->m_dLengthMax_R2	= pRC->m_R_MidExt;
										pRB->m_dLengthMin_R2	= pRB->m_dLengthMax_R2;

										// 철근 타입 결정
										if(Compare(pRB->m_dLengthMax_R1, 0.0, ">") && Compare(pRB->m_dLengthMax_R2, 0.0, ">"))
											pRB->m_nTypeRebar	= 87;
										else
											pRB->m_nTypeRebar	= 91;
									}
									else	// 보통 형태!!
									{
										pRB->m_dLengthMax_A	= dLenMax/dRad;// - dLenRoundApply;
										pRB->m_dLengthMin_A	= dLenMin/dRad;// - dLenRoundApply;
											
										if(pRC->m_nPosStt == REBARINFO_POS_UPPERSLAB_UPPER)
										{
											pRB->m_dLengthMax_C	= fabs(pRC->m_xyMid2.y - pRC->m_xyEnd.y);
											pRB->m_dLengthMin_C	= pRB->m_dLengthMax_C;
										}
										else if(pRC->m_nPosEnd == REBARINFO_POS_UPPERSLAB_UPPER)
										{
											pRB->m_dLengthMax_C	= fabs(pRC->m_xyMid1.y - pRC->m_xyStt.y);
											pRB->m_dLengthMin_C	= pRB->m_dLengthMax_C;
										}
										
										if(pRC->m_R_Mid > 0)
										{
											pRB->m_nTypeRebar	= 5;
											pRB->m_R			= pRC->m_R_Mid;

											// dLengthMax_C값은 사보강일 경우 Round의 변화로 약간씩 차이가 생길 수 있음
											if(ang > 0)
											{
												double dDiff	= (ang == 1 ? dLenRoundL : dLenRoundR) - dLenRound;
												pRB->m_dLengthMax_C -= dDiff;
												pRB->m_dLengthMin_C	-= dDiff;
												pRB->m_R			+= dDiff;

												//사보강 배치일 경우, 사보강(90도)의 점선 길이에 맞추므로 오차율을 빼줌
												if(m_nTypePlacingMainRebar_UpperSlab > 0 && Compare(pRB->m_R, 2.0 , _T("<"), 0.1))
												{
													if(pRB->m_R > 0)
														pRB->m_R -= dRad;
													else
														pRB->m_R += dRad;
												}

											}
											pRB->m_dLengthMax_B	= pRC->GetLengthMid();// 2*ConstPi*pRB->m_R/4;
																						// 사보강의 사철근이 직철근과 겹쳐서 사철근의 상세가 라운드 ㄱ 형태에서 ㅡ 형태로 변경
											if(Compare(pRB->m_R, 0.0, "=", dRad))
											{
												pRB->m_R	= 0;
												pRB->m_dLengthMax_B	= 0;
												pRB->m_dLengthMax_C	= 0;
												pRB->m_dLengthMin_C	= 0;
											}
										}
										else if(Compare(pRC->m_R_Mid, 0.0, "=") && Compare(pRC->GetLengthMid(), 0.0, ">"))
										{
											// 단  신축이음 부일 경우 다른 철근 타입임
											if(IsBlockOut(TRUE) || IsBlockOut(FALSE))
											{
												pRB->m_nTypeRebar	= 4;
												pRB->m_dLengthMax_B	= pRC->GetLengthMid();
												pRB->m_dLengthMin_B	= 0;
												if(pRC->m_nPosStt == REBARINFO_POS_UPPERSLAB_SIDE && pRC->m_nPosEnd == REBARINFO_POS_UPPERSLAB_LOWER)
												{
													double dRate	= pRC->GetLengthStt() / pRC->GetLengthEnd();
													pRB->m_dLengthMax_C	= pRB->m_dLengthMax_A * dRate;
													pRB->m_dLengthMin_C	= pRB->m_dLengthMin_A * dRate;
												}
												else 
												{
													double dRate	= pRC->GetLengthEnd() / pRC->GetLengthStt();
													pRB->m_dLengthMax_C	= pRB->m_dLengthMax_A * dRate;
													pRB->m_dLengthMin_C	= pRB->m_dLengthMin_A * dRate;
												}

												GetSwap(pRB->m_dLengthMax_A, pRB->m_dLengthMax_B);
												GetSwap(pRB->m_dLengthMin_A, pRB->m_dLengthMin_B);
											}
											else
											{
												pRB->m_nTypeRebar	= 78;
												pRB->m_dLengthMax_B	= pRC->GetLengthMid();
											}
										}
										else if(Compare(pRC->GetLengthMid(), 0.0, "="))
										{
											pRB->m_dLengthMax_B	= pRB->m_dLengthMax_C;
											pRB->m_dLengthMin_B	= pRB->m_dLengthMin_C;
											pRB->m_dLengthMax_C	= 0;
											pRB->m_dLengthMin_C	= 0;
											pRB->m_nTypeRebar	= 2;
										}
									}
								}

								pRB->m_bMainRebar	= TRUE;
								pRB->m_nEa			= nSize;
								baseConc.OptimizationRebar(pRB);	// 철근 최적화
								SetRebarLsdOptionSlab(pRB->m_pOptionLsd, TRUE, bUpper, TRUE, cycle, dan);
								if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;								
								m_Util.SetLengthRebar(pRB, bUpper ? JOINT_TENS_UPPER_B : JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
								pRB->m_dRateAdd	= MAKE_RATE;
								AddOrDeleteRebarInList(&m_pArrRebarMain, pRB);

								// 단부 철근 개수 집계
								if(dan == 0 && bUpper && (nIdx == 0 || nIdx == nSizeRC-1))
								{
									long nCycleRebarDanbu	= cycle == 0 || cycle == 2 ? 0 : 1;
									long nStt	= nIdx == 0 ? iSTT : iEND;
									m_nCountRebarDanbu[iUPPER][nCycleRebarDanbu][nStt] += pRB->m_nEa;
								}
							}
						}
					}
				}
			}
		}
	} // end of 상부슬래브


	// 가각부 (헌치부도 함께 집계함)
	CTwinVectorArrayArray pTvArrCycle1[2];
	CTwinVectorArrayArray pTvArrCycle2[2];
	CTwinVectorArray tvArrCycleHunch1, tvArrCycleHunch2;

	CTwinVector tvUpper	= GetTvOffset_UpperSlab(0, TRUE, -1.0, -1.0, IsVertDir());
	CTwinVector tvHunch[2]	= {m_tvArrVertSection.GetTvByInfo("시점벽체헌치"), m_tvArrVertSection.GetTvByInfo("종점벽체헌치")};
	tvUpper.Sort(TRUE, FALSE);
	tvHunch[0].Sort(TRUE, FALSE);
	tvHunch[1].Sort(TRUE, FALSE);
	

	for(stt = 0; stt < 2; stt++)
	{
		bStt	= stt == iSTT;

		for(upper = 0; upper < 2; upper++)
		{
			bUpper	= upper == iUPPER;
			
			for(left = 0; left < 2; left++)
			{
				bLeft	= left == iLEFT;

				for(dan = 0; dan < MAX_REBAR_DAN; dan++)
				{
					GetTvRebarMain_Plane_Slab_Exp(TRUE, &pTvArrCycle1[0], &pTvArrCycle2[0], &pTvArrCycle1[1], &pTvArrCycle2[1], bStt, bLeft, dan, bUpper, tvArrCycleHunch1, tvArrCycleHunch2);

					CString sMark	= _T("");
					CString sDescription	= _T("");
					double dDia		= 0;

					CTwinVectorArrayArray *pTvArr	= NULL;
					
					for(cycle = 0; cycle < 2; cycle++)
					{
						long type = 0; for(type = 0; type < 2; type++)
						{
							pTvArr	= cycle == 0 ? &pTvArrCycle1[type] : &pTvArrCycle2[type];

							long nSize	= pTvArr->GetSize();
							if(nSize == 0) continue;


							// 가각 주철근은 두가지로 분류가능함.
							CTwinVectorArray tvArrMain1, tvArrMain2;
							GetInfoMainRebarExp_UpperSlab(bStt, bLeft, bUpper, cycle, dan, type, sMark, dDia, sDescription);

							long i = 0; for(i = 0; i < nSize; i++)
							{
								CTwinVectorArray *pTvArrTmp	= pTvArr->GetAt(i);
								if(pTvArrTmp->GetLength() == 0) continue;
								if(i == 0)
								{
									dLenMax		= pTvArrTmp->GetLength();
									dLenMin		= pTvArrTmp->GetLength();
								}
								else
								{
									dLenMax		= max(dLenMax, pTvArrTmp->GetLength());
									dLenMin		= min(dLenMin, pTvArrTmp->GetLength());
								}
							}
							dLenRound	= GetLenRebarAtEdge(dDia, FALSE);

							CRebar *pRB	= new CRebar;
							pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
							pRB->m_sDescription	= sDescription;
							pRB->m_sMark		= sMark;
							pRB->m_dDia			= dDia;

							// 상면철근이 벽체로 내려 가는 경우는
							// 가각철근을 선형방향으로 하면 1Cycle에는 보강철근이
							// 2Cycle에는 선형방향 철근이 들어온다.
							if((bUpper && !m_bLineDirRebarOfExp[stt][left]) || (bUpper && m_bLineDirRebarOfExp[stt][left] && cycle == 1))
							{
								pRB->m_dLengthMax_A	= (dLenMax-dLenRound)/dRad;
								pRB->m_dLengthMin_A	= dLenMin > dLenRound ? (dLenMin-dLenRound)/dRad : 0;
								
								// (ARCBRIDGE-2828) 철근제원을 1,2 Cycle을 같이 적용하고 있었다. 분리하낟.
								CRebarInfoCycle *pRCSlab	= GetRebarInfoCycleUpperSlab(cycle, 0, bUpper, bStt ? 0 : -1);
								//CRebarInfoCycle *pRCSlab2Cycle	= GetRebarInfoCycleUpperSlab(1, 0, bUpper, bStt ? 0 : -1);

								if(pRCSlab)
								{
									if(!bStt)
									{
										pRB->m_dLengthMax_C	= fabs(pRCSlab->m_xyMid2.y - pRCSlab->m_xyEnd.y);
									}
									else
									{
										pRB->m_dLengthMax_C	= fabs(pRCSlab->m_xyMid1.y - pRCSlab->m_xyStt.y);
									}

									if(pRCSlab->m_R_Mid > 0)
									{
										pRB->m_nTypeRebar	= 5;
										pRB->m_R			= pRCSlab->m_R_Mid;
										pRB->m_dLengthMax_B	= pRCSlab->GetLengthMid();
									}
									else if(Compare(pRCSlab->m_R_Mid, 0.0, "=") && Compare(pRCSlab->GetLengthMid(), 0.0, ">"))
									{
										pRB->m_nTypeRebar	= 78;
										pRB->m_dLengthMax_B	= pRCSlab->GetLengthMid();
									}
									else if(Compare(pRCSlab->GetLengthMid(), 0.0, "="))
									{
										pRB->m_dLengthMax_B	= pRB->m_dLengthMax_C;
										pRB->m_dLengthMin_B	= pRB->m_dLengthMin_C;
										pRB->m_dLengthMax_C	= 0;
										pRB->m_dLengthMin_C	= 0;
										pRB->m_nTypeRebar	= 2;
									}
								}
							}
							else
							{
								pRB->m_dLengthMax_A	= dLenMax/dRad;
								pRB->m_dLengthMin_A	= dLenMin/dRad;
								pRB->m_nTypeRebar	= 1;
							}

							pRB->m_bMainRebar	= TRUE;
							pRB->m_nEa			= nSize;
							baseConc.OptimizationRebar(pRB);	// 철근 최적화
							SetRebarLsdOptionSlab(pRB->m_pOptionLsd, TRUE, bUpper, TRUE, cycle, dan);
							if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;			
							m_Util.SetLengthRebar(pRB, bUpper ? JOINT_TENS_UPPER_B : JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
							pRB->m_dRateAdd	= MAKE_RATE;
							AddOrDeleteRebarInList(&m_pArrRebarMain, pRB);

							// 단부 철근 개수 집계
							if(bUpper)
							{
								long nCycleRebarDanbu	= 0;
								long nStt	= bStt ? iSTT : iEND;
								m_nCountRebarDanbu[iUPPER][nCycleRebarDanbu][nStt] += pRB->m_nEa;
							}
						}

						// 하면일 경우 헌치부도 구한다.
						CTwinVectorArray *pTvArrHunch	= NULL;
						pTvArrHunch	= cycle == 0 ? &tvArrCycleHunch1 : &tvArrCycleHunch2;


						if(!bUpper && pTvArrHunch->GetSize() > 0)
						{
							// 헌치철근이 곡선일수도 있으므로 다시 분리 한다. //////////
							CTwinVectorArrayArray pTvArrHunchArr;
							CString sInfoLast	= _T("");
							CTwinVectorArray *pTvArr	= new CTwinVectorArray;
							long h = 0; for(h = 0; h < pTvArrHunch->GetSize(); h++)
							{
								tv	= pTvArrHunch->GetAt(h);

								if(h == 0)
								{
									sInfoLast	= tv.m_sInfo;
								}
								else if(tv.m_sInfo != sInfoLast)
								{
									pTvArrHunchArr.Add(pTvArr);
									sInfoLast	= tv.m_sInfo;
									
									pTvArr	= new CTwinVectorArray;
								}

								pTvArr->Add(tv);

								if(h == pTvArrHunch->GetSize()-1)
									pTvArrHunchArr.Add(pTvArr);
							}
							//////////////////////////////////////////////////////////

							GetInfoMainRebarExp_UpperSlabHunch(bStt, bLeft, cycle, sMark, dDia, sDescription);
							long nJ	= bStt ? 0 : m_nQtyJigan;
							CRebarInfoCycle *pRC	= NULL;
							for(long rc = 0; rc < m_pArrRCMainUpperSlabHunch[cycle].GetSize(); rc++)
							{
								CRebarInfoCycle *pTmp	= m_pArrRCMainUpperSlabHunch[cycle].GetAt(rc);
								if(nJ == pTmp->m_nPosHunch)
								{
									pRC	= pTmp;
									break;
								}
							}
							if(!pRC) continue;
							if(!pRC->m_bExist) continue;
							if(pRC->m_tvArrRebar.GetSize() < 3) continue;
							CTwinVector tvSlope	= pRC->m_tvArrRebar.GetAt(1);
							
							// 
							double dH	= tvSlope.GetVerLength();
							double dW	= 0;//pTvArrHunch->GetLengthMax();
							double dWMin	= 0;
							for(h = 0; h < pTvArrHunchArr.GetSize(); h++)
							{
								CTwinVectorArray *pTvArr	= pTvArrHunchArr.GetAt(h);
								if(h == 0)
								{
									dW	= pTvArr->GetLength();
									dWMin	= dW;
								}
								else
								{
									dW	= max(dW, pTvArr->GetLength());
									dWMin	= min(dWMin, pTvArr->GetLength());
								}
							}
							

							CRebar *pRB	= new CRebar;
							pRB->m_Fy				= m_pARcBridgeDataStd->m_Fy;
							pRB->m_sDescription 	= sDescription;
							pRB->m_sMark			= sMark;
							pRB->m_dDia				= dDia;

							pRB->m_nTypeRebar		= 9;
							pRB->m_dLengthMax_A		= sqrt(dH*dH + dW*dW);
							pRB->m_dLengthMin_A		= sqrt(dH*dH + dWMin*dWMin);
							pRB->m_dLengthMax_B		= pRC->m_tvArrRebar.GetAt(0).GetLength();

							// 헌치철근 각도와 비교해서 각도를 넣어줌
							if(bStt)
							{
								CDPoint vAngUpper	= tvUpper.GetXyDir();
								CDPoint vAngHunch	= tvHunch[stt].GetXyDir(TRUE);
								CDPoint vAngVer		= CDPoint(0, -1);
								pRB->m_dAngleX1	= vAngUpper.BetweenAngle(vAngHunch).GetAngleDegree();
								vAngHunch	= tvHunch[stt].GetXyDir(FALSE);
								pRB->m_dAngleX2	= vAngHunch.BetweenAngle(vAngVer).GetAngleDegree();
							}
							else
							{
								CDPoint vAngUpper	= tvUpper.GetXyDir(TRUE);
								CDPoint vAngHunch	= tvHunch[stt].GetXyDir(FALSE);
								CDPoint vAngVer		= CDPoint(0, -1);
								pRB->m_dAngleX1	= vAngHunch.BetweenAngle(vAngUpper).GetAngleDegree();
								vAngHunch	= tvHunch[stt].GetXyDir(TRUE);
								pRB->m_dAngleX2	= vAngVer.BetweenAngle(vAngHunch).GetAngleDegree();
							}
							if(pRB->m_dAngleX1 > 180)
								pRB->m_dAngleX1 = 360 - pRB->m_dAngleX1;
							if(pRB->m_dAngleX2 > 180)
								pRB->m_dAngleX2 = 360 - pRB->m_dAngleX2;

							double dWExp	= bStt ? m_dExpSttW[left] : m_dExpEndW[left];
							double dHExp	= bStt ? m_dExpSttH[left] : m_dExpEndH[left];

							double dRate	= sqrt(dWExp*dWExp + dHExp*dHExp) / dWExp;
							pRB->m_dAngleX1 *= dRate;
							pRB->m_dAngleX2 *= dRate;
							
							pRB->m_bMainRebar		= TRUE;
							pRB->m_nEa				= pTvArrHunchArr.GetSize();
							baseConc.OptimizationRebar(pRB);	// 철근 최적화
							SetRebarLsdOptionSlab(pRB->m_pOptionLsd, TRUE, bUpper, TRUE, cycle, dan);
							if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
							m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
							pRB->m_dRateAdd	= MAKE_RATE;
							AddOrDeleteRebarInList(&m_pArrRebarMain, pRB);
							
							AhTPADelete(&pTvArrHunchArr,   (CTwinVectorArray*)0);
						}
					}
				}
			}
		}
	}

	long type = 0; for(type = 0; type < 2; type++)
	{
		AhTPADelete(&pTvArrCycle1[type], (CTwinVectorArray*)0);
		AhTPADelete(&pTvArrCycle2[type], (CTwinVectorArray*)0);
	}
}

// 외측벽체 철근 집계
void CRcBridgeRebar::SetDataDefaultRebarJewonOutWall()
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd		= pStd->IsLsdDesign();
	const double dMulti		= bLsd? 10 : 1;

	long dan(0), cycle(0), nIdx(0), nSize(0), left(0), stt(0), inner(0);
	BOOL bStt(TRUE), bLeft(TRUE), bInner(TRUE);
	CString sUpper(_T("")), sCycle(_T("")), sStt(_T("")), sLeft(_T("")), sInner(_T(""));

	CHgBaseConcStd baseConc;
	CRebarPlacing rb;
	
	CTwinVectorArray tvArr, tvArrJoint, tvArrJointInner;
	CTwinVector tv;
	CRebarInfoCycle *pRC	= NULL;
	double dLen			= 0;	// 철근 길이
	double dLenRound	= 0;	// 라운드된 철근에서 라운드부분의 평면상의 길이
	double dLenMax		= 0;	// 최대길이
	double dLenMin		= 0;	// 최소길이
	double dCover		= 0;	// 피복
	double dRebarSpace	= 0;	// 간격

	SyncBridgeRebar(FALSE);
	// 주철근
	dRebarSpace	= GetCtcRebarMain(FALSE)/2;

	for(cycle = 0; cycle < GetCountCycleMainRebar(); cycle++)
	{
		sCycle	= m_pARcBridgeDataStd->GetStringCircleNum(cycle+1);
		for(stt = 0; stt < 2; stt++)
		{
			bStt	= stt == iSTT ? TRUE : FALSE;
			if(!IsOutWall(bStt)) continue;
	
			for(inner = 0; inner < 2; inner++)
			{
				bInner	= inner == iINNER ? TRUE : FALSE;
				dCover	= m_dCoverWallOut[0];
				
				for(dan = 0; dan < MAX_REBAR_DAN; dan++)
				{
					for(nIdx = 0; nIdx < m_pArrRCMainOutWall[cycle][stt][inner][dan].GetSize(); nIdx++)
					{
						tvArr.RemoveAll();

						HGINT32 iIndexReal = nIdx;
						if(IsBoxType() && bInner == FALSE)
						{
							// (ARCBRIDGE-1553)CWallApp를 만들어 줄때 BoxType은 하부슬래브 철근을 하나 포함하고 있기 때문에 철근 수량 구할때 인덱스는 1을 더해줘야 한다.
							++iIndexReal;
						}
						GetTvRebarMain_Side_OutWall(tvArr, bStt, bInner, cycle, dan, iIndexReal, tvArrJoint);
						pRC	= GetRebarInfoCycleOutWall(cycle, dan, bStt, bInner, nIdx);
						if(!pRC) continue;
						if(!pRC->m_bExist) continue;

						// Round반지름이 차지 하는 길이 
						dLenRound	= 0;
						if(pRC->m_nPosStt != pRC->m_nPosEnd)
							dLenRound	= fabs(pRC->m_xyMid2.y - pRC->m_xyMid1.y);

						// 평면상에서 최대와 최소 길이를 판단해서 철근 집계함.
						dLenMax	= tvArr.GetLengthMax();
						dLenMin	= tvArr.GetLengthMin();
						nSize	= tvArr.GetSize();
						if(nSize > 0)
						{
							CRebar *pRB	= new CRebar;
							pRB->m_Fy				= bLsd? GetValueFy(bStt? ePartOutWallStt : ePartOutWallEnd) : m_pARcBridgeDataStd->m_Fy;
							pRB->m_sDescription	= pRC->m_sDescription; //Format("%s벽체 %s면 %d단 %s %d", sStt, sInner, dan+1, sCycle, nIdx+1);
							pRB->m_sMark			= pRC->m_szMark;
							pRB->m_dDia			= pRC->m_Dia;
							if(pRC->m_nPosStt == pRC->m_nPosEnd)
							{
								pRB->m_dLengthMax_A	= dLenMax;
								pRB->m_dLengthMin_A	= dLenMin;
								pRB->m_nTypeRebar	= 1;
							}
							else
							{
								pRB->m_dLengthMax_A	= dLenMax - dLenRound;
								pRB->m_dLengthMin_A	= dLenMin - dLenRound;
								pRB->m_dLengthMax_B	= pRC->GetLengthMid();
								pRB->m_dLengthMax_C	= fabs(pRC->m_xyStt.x-pRC->m_xyMid1.x);//fabs(pRC->m_xyMid2.y - pRC->m_xyEnd.y);
								pRB->m_dLengthMin_C	= pRB->m_dLengthMax_C;
								pRB->m_nTypeRebar	= 5;
								pRB->m_R			= pRC->m_R_Mid;
							}
							pRB->m_bMainRebar	= TRUE;
							pRB->m_nEa			= nSize;
							baseConc.OptimizationRebar(pRB);	// 철근 최적화
							SetRebarLsdOptionOutWall(pRB->m_pOptionLsd, bStt, bInner, TRUE, cycle, dan);
							if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
							m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
							pRB->m_dRateAdd	= MAKE_RATE;
							AddOrDeleteRebarInList(&m_pArrRebarMain, pRB);
						}
					}
				}
			}
		}
	} // end of 외측벽체


	for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
	{
		long stt = 0; for(stt = 0; stt < 2; stt++)
		{
			BOOL bStt	= stt == iSTT;

				// 외측벽체 헌치부 철근
			if(IsOutWallHunch(bStt))
			{
				pRC	= &m_rebarInfoCycleOutWallHunch[cycle][stt];
				GetTvRebarMain_Side_OutWallHunch(tvArr, cycle, bStt);
				nSize	= tvArr.GetSize();
				dLen	= pRC->GetLengthMid();

				double dAngleX1	= (pRC->m_xyMid2-pRC->m_xyMid1).Unit().GetAngleDegree() + 90;
				double dAngleX2	= (pRC->m_xyMid1-pRC->m_xyMid2).Unit().GetAngleDegree();

				CRebar *pRB	= new CRebar;
				pRB->m_Fy			= bLsd? GetValueFy(bStt? ePartOutWallStt : ePartOutWallEnd) : m_pARcBridgeDataStd->m_Fy;
				pRB->m_sDescription	= pRC->m_sDescription;
				pRB->m_sMark		= pRC->m_szMark;
				pRB->m_dDia			= pRC->m_Dia;
				pRB->m_nTypeRebar	= 9;
				pRB->m_dLengthMax_A	= dLen;
				pRB->m_dLengthMax_B	= pRC->GetLengthStt();
				pRB->m_dAngleX1		= dAngleX1;
				pRB->m_dAngleX2		= dAngleX2;
				
				pRB->m_R			= 0;
				pRB->m_bMainRebar	= TRUE;
				pRB->m_nEa			= nSize;
				baseConc.OptimizationRebar(pRB);	// 철근 최적화				
				m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
				pRB->m_dRateAdd	= MAKE_RATE;
				AddOrDeleteRebarInList(&m_pArrRebarMain, pRB);
			}
		}
	}


	// 가각부
	CTwinVectorArray tvArrCycle1[2], tvArrCycle2[2];
	for(stt = 0; stt < 2; stt++)
	{
		bStt	= stt == iSTT;

		for(left = 0; left < 2; left++)
		{
			bLeft	= left == iLEFT;
			if(!IsGagakForLine(bStt, bLeft)) continue;

			for(inner = 0; inner < 2; inner++)
			{
				bInner	= inner == iINNER;

				for(dan = 0; dan < MAX_REBAR_DAN; dan++)
				{
					long nCountRebar1	= m_pArrRCMainOutWall[0][stt][iOUTTER][dan].GetSize();
					long nCountRebar2	= m_pArrRCMainOutWall[1][stt][iOUTTER][dan].GetSize();
					long nCountRebar1Inner	= m_pArrRCMainOutWall[0][stt][iINNER][dan].GetSize();
					long nCountRebar2Inner	= m_pArrRCMainOutWall[1][stt][iINNER][dan].GetSize();
					long nCountRebar	= bInner ? max(nCountRebar1Inner, nCountRebar2Inner) : max(nCountRebar1, nCountRebar2);
					
					for(cycle = 0; cycle < 2; cycle++)
					{
						for(nIdx = 0; nIdx < nCountRebar; nIdx++)
						{
							if(bInner)
							{
								if(cycle == 0 && nIdx >= nCountRebar1Inner) continue;
								if(cycle == 1 && nIdx >= nCountRebar2Inner) continue;
							}
							else
							{
								if(cycle == 0 && nIdx >= nCountRebar1) continue;
								if(cycle == 1 && nIdx >= nCountRebar2) continue;
							}

							pRC	= GetRebarInfoCycleOutWall(cycle, dan, bStt, bInner, nIdx);
							if(!pRC) continue;
							if(!pRC->m_bExist) continue;
							
							tvArrCycle1[0].RemoveAll();
							tvArrCycle2[0].RemoveAll();
							tvArrCycle1[1].RemoveAll();
							tvArrCycle2[1].RemoveAll();
							GetTvRebarMain_CrossSection_OutWallExp(tvArrCycle1[0], tvArrCycle2[0], tvArrCycle1[1], tvArrCycle2[1], tvArrJoint, bStt, bLeft, bInner, dan, nIdx, !bStt);
		
							// 철근 제원 설정하는 루틴은 외측벽체 일반부와 같음.
							CString sMark	= _T("");
							CString sDescription	= _T("");
							double dDia		= 0;
							GetInfoMainRebarExp_OutWall(bStt, bLeft, bInner, cycle, nIdx, sMark, dDia, sDescription, TRUE);

	

							// Round반지름이 차지 하는 길이 
							dLenRound	= 0;
							if(pRC->m_nPosStt != pRC->m_nPosEnd)
							dLenRound	= fabs(pRC->m_xyMid2.y - pRC->m_xyMid1.y);

							// 최대와 최소 길이를 판단해서 철근 집계함.
							dLenMax	= cycle==0 ? tvArrCycle1[0].GetLengthMax():tvArrCycle2[0].GetLengthMax();
							dLenMin	= cycle==0 ? tvArrCycle1[0].GetLengthMin():tvArrCycle2[0].GetLengthMin();
							nSize	= cycle==0 ? tvArrCycle1[0].GetSize():tvArrCycle2[0].GetSize();

							if(nSize > 0)
							{
								CRebar *pRB	= new CRebar;
								pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
								pRB->m_sDescription	= sDescription;
								pRB->m_sMark		= sMark;
								pRB->m_dDia			= dDia;
								if(pRC->m_nPosStt == pRC->m_nPosEnd)
								{
									pRB->m_dLengthMax_A	= dLenMax;
									pRB->m_dLengthMin_A	= dLenMin;
									pRB->m_nTypeRebar	= 1;
								}
								else
								{
									pRB->m_dLengthMax_A	= dLenMax - dLenRound;
									pRB->m_dLengthMin_A	= dLenMin - dLenRound;
									pRB->m_dLengthMax_B	= pRC->GetLengthMid();
									pRB->m_dLengthMax_C	= fabs(pRC->m_xyStt.x-pRC->m_xyMid1.x);//fabs(pRC->m_xyMid2.y - pRC->m_xyEnd.y);
									pRB->m_dLengthMin_C	= pRB->m_dLengthMax_C;
									pRB->m_nTypeRebar	= 5;
									pRB->m_R			= pRC->m_R_Mid;
								}
								pRB->m_bMainRebar	= TRUE;
								pRB->m_nEa			= nSize;
								baseConc.OptimizationRebar(pRB);	// 철근 최적화
								SetRebarLsdOptionOutWall(pRB->m_pOptionLsd, bStt, bInner, TRUE, cycle, dan);
								if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
								m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
								pRB->m_dRateAdd	= MAKE_RATE;
								AddOrDeleteRebarInList(&m_pArrRebarMain, pRB);
							}
						}
					}
				}
			}
		}
	}

	// 예각부 보강
	SetDataDefaultRebarJewonOutWall_AcuteAngle();
}

// 내측벽체 철근 집계
void CRcBridgeRebar::SetDataDefaultRebarJewonInWall()
{
	long nCountInWall	= GetCountInWall();
	long wall		= 0;
	CString sWall	= _T("");

	// 내측벽체
	for(wall = 0; wall < nCountInWall; wall++)
	{
		CWallApp *pWall	= GetInWall(wall);
		if(pWall)
		{
			pWall->m_nTypeAddRate.Attach(&m_nTypeAddRate);		// 0 : 직경별, 1 : 주철근,기타철근
			pWall->m_dAddRateLower.Attach(&m_dAddRateLower);		// 하위 할증률
			pWall->m_dAddRateUpper.Attach(&m_dAddRateUpper);		// 상위 할증률
			pWall->m_dAddRateDiaOrg.Attach(&m_dAddRateDiaOrg);	// 직경별일경우 기준 직경

			pWall->SetDataDefaultRebarJewonMain();

			/*
			// 벽체가 여러개인데 각각 철근 이름을 기분하기 위해.
			sWall.Format("중간지점%d", wall+1);
			long i = 0; for(i = 0; i < pWall->m_pArrRebarMain.GetSize(); i++)
			{
				CRebar *pRB	= pWall->m_pArrRebarMain.GetAt(i);
				pRB->m_sDescription.Replace("중간지점", sWall);
			}
			*/
		}
	}
}

// 평면상 두좌표간의 선형길이를 리턴함.
double CRcBridgeRebar::GetLengthLineByPlaneXy(CDPoint xyStt, CDPoint xyEnd, CLineInfo *pLine)
{
	double dLen	= 0;
	if(IsVertDir() && !pLine)
	{
		dLen	= ~(xyStt - xyEnd);
	}
	else
	{
		if(!pLine)
			pLine	= GetLineBase();

		double dStaStt		= 0;	// 시작점의 sta
		double dStaEnd		= 0;	// 끝점의 sta
		double dDistStt		= 0;	// 시작점과 기준선형과 떨어진 거리
		pLine->GetStationMatchVerticalByXy(xyStt, dStaStt);
		pLine->GetStationMatchVerticalByXy(xyEnd, dStaEnd);
		dDistStt	= pLine->GetDisMatchVerticalByXy(xyStt);
		dLen		= pLine->GetLengthByDis(dStaStt, dStaEnd, dDistStt);
	}
	
	return dLen;
}

// 외측벽체 주철근 
void CRcBridgeRebar::GetTvRebarMain_Side_OutWall(CTwinVectorArray &tvArr, BOOL bStt, BOOL bInner, long nCycle, long nDan, long nIdxRC, CTwinVectorArray &tvArrJoint)
{
	tvArr.RemoveAll();
	if(!IsOutWall(bStt)) return;

	CWallApp wall;
	// convert : 외측벽체를 CWallApp에 맞게 제원을 설정해서 벽체를 만들어 냄.

	MakeWallByOutWall(wall, bStt, TRUE);
	wall.GetTvRebarMain_Side(tvArr, bStt ? (bInner ? FALSE : TRUE) : (bInner ? TRUE : FALSE), nCycle, nDan, nIdxRC, tvArrJoint);
}


// 외측벽체 헌치부 철근 표현을 위한 영역
void CRcBridgeRebar::GetTvCuttingArea_Side_OutWallHunch(CTwinVectorArray &tvArr, BOOL bStt, long nDrawLeft)
{
	tvArr.RemoveAll();

	
	if(!IsOutWallHunch(bStt)) return;
	CTwinVectorArray tvArrSide;
	GetTvCrossSection_OutWall(tvArrSide, bStt, bStt ? FALSE : TRUE);
	CFootingApp *pFooting	= bStt ? &m_footingStt : &m_footingEnd;
	
	// 현재 area 모양은 (옵션에 따라 바꿀 수도 있음, 바꿀 경우 tvArr만 적당하게 바꿔주면 됨(아크와 선의 조합이면 어떤 모양이든 가능))
	// 세로로 세워진 트랙형..
	// R크기는 벽체 길이/16
	// 세로 직선 길이는 벽체 높이/2	
	CDRect rect	= tvArrSide.GetRect();
	double dDiff	= rect.Width()/8*3;
	double dX		= rect.left + rect.Width()/2;
	dX	= nDrawLeft == -1 ? dX - dDiff : dX + dDiff;
	CDPoint xyMatchL	= CDPoint(0, 0);
	CTwinVectorArray tvArrLeftFooting, tvArrHidden;
	pFooting->GetTvLeftSide(tvArrLeftFooting, tvArrHidden, FALSE);
	CTwinVector tvLower	= tvArrLeftFooting.GetTvByInfo("기초하면");
	GetXyMatchLineAndLine(xyMatchL, CDPoint(0, -1), tvLower.m_v1, tvLower.GetXyDir(), xyMatchL);
	
	double dY	= xyMatchL.y;
	double dR	= rect.Width()/20;
	double dH	= fabs(m_rebarInfoCycleOutWallHunch[0]->m_xyStt.y - m_rebarInfoCycleOutWallHunch[0]->m_xyEnd.y);

	// 트랙형 만든다.(트랙의 우측 중심 아래에서 시작)
	CTwinVector tv;
	tv.m_v1		= CVector(dX+dR, dY-dH/2, 0);
	tv.m_v2		= tv.m_v1 + CVector(0, dH, 0);
	tv.m_sInfo	= "좌측세로";
	tvArr.Add(tv);

	tv.m_v1		= tv.m_v2;
	tv.m_v1.z	= 1;
	tv.m_v2		= tv.m_v1 + CVector(-dR*2, 0, dR);
	tv.m_sInfo	= "상단아크";
	tvArr.Add(tv);

	tv.m_v1		= tv.m_v2;
	tv.m_v1.z	= 0;
	tv.m_v2		= tv.m_v1 + CVector(0, -dH, 0);
	tv.m_sInfo	= "우측세로";
	tvArr.Add(tv);

	tv.m_v1		= tv.m_v2;
	tv.m_v1.z	= 1;
	tv.m_v2		= tv.m_v1 + CVector(dR*2, 0, dR);
	tv.m_sInfo	= "그릴때제거";
	tvArr.Add(tv);

	CRebarPlacing rb;
	rb.MoveRebar(tvArr, CDPoint(0, dH/2-300));
}

void CRcBridgeRebar::SetDataDefaultRebarDanbu()
{
	for(long iUD=iUPPER; iUD<=iLOWER; iUD++)
	{
		// 1cycle
		m_bIsDanbuRebar_Cycle1[iUD][iSTT]	= TRUE;
		m_bIsDanbuRebar_Cycle1[iUD][iEND]	= TRUE;
		long dan = 0; for(dan = 0; dan < 3; dan++)
		{
			m_dDia_DanbuRebar_Cycle1[iUD][iSTT][dan]		= dan == 0 ? 25 : 0;
			m_dDia_DanbuRebar_Cycle1[iUD][iEND][dan]		= dan == 0 ? 25 : 0;
			m_bIsDanbuRebar_Cycle1[iUD][iSTT]			= TRUE;
			m_bIsDanbuRebar_Cycle1[iUD][iEND]			= TRUE;
		}

		// 2cycle
		m_bIsDanbuRebar_Cycle2[iUD][iSTT]	= TRUE;
		m_bIsDanbuRebar_Cycle2[iUD][iEND]	= TRUE;
		for(dan = 0; dan < 3; dan++)
		{
			m_dDia_DanbuRebar_Cycle2[iUD][iSTT][dan]		= dan == 0 ? 25 : 0;
			m_dDia_DanbuRebar_Cycle2[iUD][iEND][dan]		= dan == 0 ? 25 : 0;
			m_bIsDanbuRebar_Cycle2[iUD][iSTT]			= TRUE;
			m_bIsDanbuRebar_Cycle2[iUD][iEND]			= TRUE;
		}
	}

	m_nType_DanbuRebar = 0;
}

// 상부단절점부 철근 생성
// 2cycle은 없다.
void CRcBridgeRebar::MakeRebarInfoCycle_UpperDanbu(BOOL bInput, long nVertDir)
{
	BOOL bVertDir	= IsVertDir();
	if(nVertDir != 0)
		bVertDir	= nVertDir == -1 ? TRUE : FALSE;
	// 절점부철근은 무조건 45도임
	// 헌치철근이 없어도 들어가며..
	// 좌우모서리에서, 내측벽체선까지 45도방향으로 뻗은 거리를 기준으로 0.4거리~0.6거리
	// 에 설치함.
	CTwinVector tvDanbu[2];	// 단부 가상 라인(시종점)
	CTwinVector tv;

	tvDanbu[iSTT] = GetTvCornerBaseLine(TRUE, TRUE);
	tvDanbu[iEND] = GetTvCornerBaseLine(FALSE, TRUE);

	// 단 절점부는 기호를 달리 하므로 철근 만들때 마다 초기화
	GetMarkRebarDanbu(TRUE);

	CTwinVector tvRebar;	// 구해진 단부철근..
	CTwinVector tvWall;		// 벽체 가상선
	CDPoint xyPos(0, 0);	// 철근 높이는 위치..
	long nIdx	= 1;
	long cycle = 0; for(cycle = 0; cycle < 2; cycle++)
	{
		long stt = 0; for(stt = 0; stt < 2; stt++)
		{
			BOOL bStt	= stt==iSTT;
			tvWall	= GetTvOffset_OutWall(0, bStt, FALSE, bVertDir);

			long dan = 0; for(dan = 0; dan < 3; dan++)
			{
				CRebarInfoCycle *pRC	= cycle == 0 ? &m_rebarInfoCycleDanbu_UpperCycle1[stt][dan] : &m_rebarInfoCycleDanbu_UpperCycle2[stt][dan];
				if(IsDanbuRebar(bStt, dan, cycle, TRUE))
				{
					double dDiaDanbuRebar	= cycle == 0 ? m_dDia_DanbuRebar_Cycle1[iUPPER][stt][dan] : m_dDia_DanbuRebar_Cycle2[iUPPER][stt][dan];
					long nTypeDanbu			= m_nType_DanbuRebar;
					double dSettle(0);
					if(m_pARcBridgeDataStd->IsLsdDesign() && nTypeDanbu != 1)
					{
						SRebarEnvOption LsdRebarOpt;
						SetRebarLsdOptionSlab(&LsdRebarOpt, TRUE, TRUE, TRUE, 0, 0);
						dSettle = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueSettle(dDiaDanbuRebar, &LsdRebarOpt);
					}
					else
					{
						dSettle			= nTypeDanbu == 1 ? 100 : m_pARcBridgeDataStd->GetValueSettle(dDiaDanbuRebar, 0);
					}

					tv		= tvDanbu[stt];
				
					double dRate = m_dDanCorner_UpperSlab[dan];
					xyPos	= tv.m_v1 + (tv.GetXyDir() * tv.GetLength() * dRate);

					// 벽체쪽으로 교차점
					GetXyMatchLineAndLine(tvWall.m_v1, tvWall.GetXyDir(), xyPos, bStt ? CDPoint(-1, -1).Unit() : CDPoint(1, -1).Unit(), tvRebar.m_v1);

					// 상부슬래브 쪽으로 교차점
					tvRebar.m_v2	= GetXyMatchLineAndSlabUpper(xyPos, bStt ? CDPoint(1, 1).Unit() : CDPoint(-1, 1).Unit(), 0, m_dCoverUpper_UpperSlab[0], bVertDir);

					// 교차점을 찾았으면 정착장합쳐서 rc로 만듬.
					// 외측벽체에서 상부슬래브로 가는 방향으로 생성
					pRC->m_Dia		= dDiaDanbuRebar;
					pRC->m_szMark	= GetMarkRebarDanbu(FALSE);
					pRC->m_sDescription.Format("상부SLAB 단 절점부 %s %d", m_pARcBridgeDataStd->GetStringCircleNum(cycle+1), nIdx++);
					pRC->m_nPosStt	= bStt ? REBARINFO_POS_STTWALL_OUTTER : REBARINFO_POS_ENDWALL_OUTTER;
					pRC->m_nPosEnd	= REBARINFO_POS_UPPERSLAB_UPPER;
					pRC->m_xyStt	= tvRebar.m_v1 + CDPoint(0, -dSettle);
					pRC->m_xyMid1	= tvRebar.m_v1;
					pRC->m_xyMid2	= tvRebar.m_v2;
					pRC->m_xyEnd	= GetXyToDistFromSlabUpper(tvRebar.m_v2.x, bStt ? dSettle : -dSettle, 0, m_dCoverUpper_UpperSlab[0], bVertDir); 
					pRC->m_R_Mid	= 0;
				}
				else
				{
					pRC->m_xyStt	= tvRebar.m_v1;
					pRC->m_xyMid1	= tvRebar.m_v1;
					pRC->m_xyMid2	= tvRebar.m_v1;
					pRC->m_xyEnd	= tvRebar.m_v1;
				}
			}
		}
	}
}

// 하부단절점부 철근 생성
// 2cycle은 없다.
void CRcBridgeRebar::MakeRebarInfoCycle_LowerDanbu(BOOL bInput, long nVertDir)
{
	if(!IsBoxType()) return;
	
	BOOL bVertDir	= IsVertDir();
	if(nVertDir != 0)
		bVertDir	= nVertDir == -1 ? TRUE : FALSE;

	// 절점부철근은 무조건 45도임
	// 헌치철근이 없어도 들어가며..
	// 좌우모서리에서, 내측벽체선까지 45도방향으로 뻗은 거리를 기준으로 0.4거리~0.6거리
	// 에 설치함.
	CTwinVector tvDanbu[2];	// 단부 가상 라인(시종점)
	CTwinVector tv;

	tvDanbu[iSTT] = GetTvCornerBaseLine(TRUE, FALSE);
	tvDanbu[iEND] = GetTvCornerBaseLine(FALSE, FALSE);

	// 단 절점부는 기호를 달리 하므로 철근 만들때 마다 초기화
	//GetMarkRebarDanbu(TRUE);

	CTwinVector tvRebar;	// 구해진 단부철근..
	CTwinVector tvWall;		// 벽체 가상선
	CDPoint xyPos(0, 0);	// 철근 높이는 위치..
	long nIdx	= 1;
	long cycle = 0; for(cycle = 0; cycle < 2; cycle++)
	{
		long stt = 0; for(stt = 0; stt < 2; stt++)
		{
			BOOL bStt	= stt==iSTT;
			tvWall	= GetTvOffset_OutWall(0, bStt, FALSE, bVertDir);

			long dan = 0; for(dan = 0; dan < 3; dan++)
			{
				CRebarInfoCycle *pRC	= cycle == 0 ? &m_rebarInfoCycleDanbu_LowerCycle1[stt][dan] : &m_rebarInfoCycleDanbu_LowerCycle2[stt][dan];
				if(IsDanbuRebar(bStt, dan, cycle, FALSE))
				{
					double dDiaDanbuRebar	= cycle == 0 ? m_dDia_DanbuRebar_Cycle1[iLOWER][stt][dan] : m_dDia_DanbuRebar_Cycle2[iLOWER][stt][dan];
					long nTypeDanbu			= m_nType_DanbuRebar;
					double dSettle(0);
					if(m_pARcBridgeDataStd->IsLsdDesign() && nTypeDanbu != 1)
					{
						SRebarEnvOption LsdRebarOpt;
						SetRebarLsdOptionSlab(&LsdRebarOpt, FALSE, FALSE, TRUE, 0, 0);
						dSettle = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueSettle(dDiaDanbuRebar, &LsdRebarOpt);
					}
					else
					{
						dSettle			= nTypeDanbu == 1 ? 100 : m_pARcBridgeDataStd->GetValueSettle(dDiaDanbuRebar, 0);
					}
					tv		= tvDanbu[stt];

					double dRate = m_dDanCorner_LowerSlab[dan];
					xyPos	= tv.m_v1 + (tv.GetXyDir() * tv.GetLength() * dRate);
					
					// 벽체쪽으로 교차점
					GetXyMatchLineAndLine(tvWall.m_v1, tvWall.GetXyDir(), xyPos, bStt ? CDPoint(-1, 1).Unit() : CDPoint(1, 1).Unit(), tvRebar.m_v1);
					
					// 하부슬래브 쪽으로 교차점
					tvRebar.m_v2	= GetXyMatchLineAndLowerSlabLower(xyPos, bStt ? CDPoint(1, -1).Unit() : CDPoint(-1, -1).Unit(), 0, m_dCoverLower_LowerSlab[0], bVertDir);

					// 교차점을 찾았으면 정착장합쳐서 rc로 만듬.
					// 외측벽체에서 상부슬래브로 가는 방향으로 생성
					pRC->m_Dia		= dDiaDanbuRebar;
					pRC->m_szMark	= GetMarkRebarDanbu(FALSE);
					pRC->m_sDescription.Format("하부SLAB 단 절점부 %s %d", m_pARcBridgeDataStd->GetStringCircleNum(cycle+1), nIdx++);
					pRC->m_nPosStt	= bStt ? REBARINFO_POS_STTWALL_OUTTER : REBARINFO_POS_ENDWALL_OUTTER;
					pRC->m_nPosEnd	= REBARINFO_POS_LOWERSLAB_LOWER;
					pRC->m_xyStt	= tvRebar.m_v1 + CDPoint(0, dSettle);
					pRC->m_xyMid1	= tvRebar.m_v1;
					pRC->m_xyMid2	= tvRebar.m_v2;
					pRC->m_xyEnd	= GetXyToDistFromLowerSlab(tvRebar.m_v2.x, bStt ? dSettle : -dSettle, 0, m_dCoverLower_LowerSlab[0], bVertDir); 
					pRC->m_R_Mid	= 0;
				}
				else
				{
					pRC->m_xyStt	= tvRebar.m_v1;
					pRC->m_xyMid1	= tvRebar.m_v1;
					pRC->m_xyMid2	= tvRebar.m_v1;
					pRC->m_xyEnd	= tvRebar.m_v1;
				}
			}
		}
	}
}

// 단 절점부 철근 존재 여부...
BOOL CRcBridgeRebar::IsDanbuRebar(BOOL bStt, long nDan, long nCycle, BOOL bUpper)
{
	if(!IsOutWall(bStt)) return FALSE;

	long stt	= bStt ? iSTT : iEND;
	long iUD = bUpper ? iUPPER : iLOWER;

	if(nCycle == 0)
	{
		if(m_bIsDanbuRebar_Cycle1[iUD][stt] && !Compare(m_dDia_DanbuRebar_Cycle1[iUD][stt][nDan], 0.0, "="))
			return TRUE;
	}
	else
	{
		if(m_bIsDanbuRebar_Cycle2[iUD][stt] && !Compare(m_dDia_DanbuRebar_Cycle2[iUD][stt][nDan], 0.0, "="))
			return TRUE;
	}

	return FALSE;
}

void CRcBridgeRebar::GetTv_CrossSection_LowerSlab(CTwinVectorArray &tvArr, long nJ, double dStation, CDPoint vAng, long nDrawLeft)
{
	CLineInfoApp *pLine = m_pLineApp;
	if(!pLine) return;

	tvArr.RemoveAll();
		
	// 기초상단 
//	long nJijum = GetJijumNumberByStation(dStation);
	double dDistLeft = GetDisSlabLeftActByGagak(dStation, vAng);
	double dDistRight = GetDisSlabRighActByGagak(dStation, vAng);
	double dEl_Plan = pLine->GetElevationPlanEl(dStation);
	double dEL_Foot = dEl_Plan - GetThickPave() - GetHeightBridgeBox(dStation) + m_dTS_Lower;

	CDPoint xy1(dDistLeft, dEL_Foot), xy2(dDistRight, dEL_Foot);
	if(nDrawLeft == -1)
	{
		xy2.x = (dDistLeft + dDistRight) / 2.;
	}
	if(nDrawLeft == 1)
	{
		xy1.x = (dDistLeft + dDistRight) / 2.;
	}

	CTwinVector tv;
	CDPoint xyStt;
	tv.m_v1 = xy1;
	tv.m_v2 = xy2;
	xyStt = xy1;
	tvArr.Add(tv);

	tv.m_v1 = tv.m_v2;
	tv.m_v2.y = tv.m_v2.y - m_dTS_Lower;
	tvArr.Add(tv);

	tv.m_v1 = tv.m_v2;
	tv.m_v2.x = xyStt.x;
	tvArr.Add(tv);

	tv.m_v1 = tv.m_v2;
	tv.m_v2 = xyStt;
	tvArr.Add(tv);
}

CString CRcBridgeRebar::GetMarkRebarDanbu(BOOL bOnlyInit)
{
	static long nNum	= 1;
	if(bOnlyInit) 
	{
		nNum		= 1;
		return _T("");
	}

	CString sMark		= _T("");
	sMark.Format("R%d", nNum);
	nNum++;

	return sMark;
}

// 상부슬래브 평면구조도 그릴때 절단 할 부분 가져옴.
// 2,3단에 대해서만 해당됨.
// 기본형태는 트랙임(수평선은 선형을 따라 감.)
void CRcBridgeRebar::GetTvCuttingArea_Plane_UpperSlab(CTwinVectorArray &tvArr, BOOL bUpper, long nDan)
{
	tvArr.RemoveAll();
	if(nDan == 0) return;
	// 일단 해당하는 단의 주철근이 하나라도 존재해야 파는 것으로 인정
	CRebarInfoCycle *pRC	= GetRebarInfoCycleUpperSlabCheckExist(0, nDan, bUpper, 0);
	if(!pRC) return;

	// 트랙 제원
	double dLenJigan	= GetLengthJigan(0);
	double dSta			= bUpper ? m_dStationBridgeStt-m_dWS : m_dStationBridgeStt+dLenJigan/2;	// 트랙의 중심 sta
	double dWid			= GetWidthSlabAct(dSta, CDPoint(0, 1), 0)/2;
	double dR			= min(dLenJigan/8, dWid/8);		// 트랙의 원의 반지름
	double dB			= dLenJigan/4;	// 트랙의 수평선 길이
	double dDistMid		= GetDistMidOfSlab(dSta);
	double dDist		= bUpper ? dDistMid + (dWid/3*nDan*-1) : dDistMid + (dWid/3*nDan);	// 중심선형에서 트랙중심까지 거리.

	BOOL bDrawAllArc	= TRUE;
	if(bUpper)
	{
		bDrawAllArc		= FALSE;
		// 상면은 보통 시점단부를 파지만, 시점단부에 2단이 없고, 중간지점에 2단이 있다면, 위치를 옮겨야 된다.
		if(GetDanMainRebarUpperSlab(0, TRUE, 0) <= nDan)
		{
			bDrawAllArc	= TRUE;
			dSta	= ((pRC->m_xyStt+pRC->m_xyEnd)/2).x;
		}
		else
			dSta += dB/3;
	}
	else
	{
		if(pRC->m_xyStt.x > dSta || pRC->m_xyEnd.x < dSta)
			dSta	= ((pRC->m_xyStt+pRC->m_xyEnd)/2).x;
	}

	// 종점 지점각도가 90이 아니면 사각적용  sta조정
	double dAng	= GetAngleJijum(m_nQtyJigan).GetAngleDegree();
	if(!Compare(dAng, 90.0, "="))
		dSta -= dDist / tan(ToRadian(dAng));

	// 구하자.
	GetTvTrack_Plane(tvArr, dSta, dDist, dR, dB);

	// 주철근배치가 사보강으로 배치되면 시점각도의 직각방향으로 회전
	if(m_nTypePlacingMainRebar_UpperSlab == 1 || m_nTypePlacingMainRebar_UpperSlab == 2)
	{
		CRebarPlacing rb;
		double dRot	= dAng - 90;
		CDPoint xyOrg	= GetLineBase()->GetXyLineByLengthAndAngle(dSta, dDist, CDPoint(0, 1));
		rb.RotateTvArr(tvArr, xyOrg, dRot);
	}

	if(!bDrawAllArc)
	{
		tvArr.SetTvInfoByInfo("시점측아크1", "그릴때제거1");
		tvArr.SetTvInfoByInfo("시점측아크2", "그릴때제거2");
		tvArr.SetTvInfoByInfo("시점측아크3", "그릴때제거3");
		tvArr.SetTvInfoByInfo("시점측아크4", "그릴때제거4");
	}
}

// (ARCBRIDGE-2017) 1지간에만 2,3단철근 표현하던걸 옵션으로 각지간에 모두 표현
// 완전 진상이네.. 추후에 도면이 간섭되도 이 옵션에 대한 추가 수정은 없는걸로!
void CRcBridgeRebar::GetTvCuttingArea_Plane_UpperSlab(CTwinVectorArray &tvArr, BOOL bUpper, long nDan, long nJ)
{
	tvArr.RemoveAll();
	if(nDan == 0) return;
	// 일단 해당하는 단의 주철근이 하나라도 존재해야 파는 것으로 인정
	CRebarInfoCycle *pRC	= GetRebarInfoCycleUpperSlabCheckExist(0, nDan, bUpper, 0);
	if(!pRC) return;

	// 트랙 제원
	long nJigan = MIN(nJ, m_nQtyJigan-1);
	double dLenJigan	= GetLengthJigan(nJigan);
	double dStaCenter	= GetStationOnJijum(nJ);
	double dSta			= bUpper ? dStaCenter-m_dWS : dStaCenter+dLenJigan/2;	// 트랙의 중심 sta
	if(bUpper)
	{
		if(nJ == 0)
			dSta = dStaCenter - m_dWS;
		else if(nJ == m_nQtyJigan)
			dSta = dStaCenter + m_dWE;
		else
			dSta = dStaCenter;
	}
	double dWid			= GetWidthSlabAct(dSta, CDPoint(0, 1), 0)/2;
	double dR			= min(dLenJigan/8, dWid/8);		// 트랙의 원의 반지름
	double dB			= dLenJigan/4;	// 트랙의 수평선 길이
	double dDistMid		= GetDistMidOfSlab(dSta);
	double dDist		= bUpper ? dDistMid + (dWid/3*nDan*-1) : dDistMid + (dWid/3*nDan);	// 중심선형에서 트랙중심까지 거리.

	BOOL bDrawAllArc	= TRUE;
	if(bUpper)
	{
		bDrawAllArc		= (nJ != 0 && nJ != m_nQtyJigan)? TRUE : FALSE;
		// 상면은 보통 시점단부를 파지만, 시점단부에 2단이 없고, 중간지점에 2단이 있다면, 위치를 옮겨야 된다.
		if(GetDanMainRebarUpperSlab(0, TRUE, 0) <= nDan)
		{
			bDrawAllArc	= TRUE;
			if(nJ == 0)
				dSta	= ((pRC->m_xyStt+pRC->m_xyEnd)/2).x;
		}
		else
		{
			if(nJ == 0)
				dSta += dB/3;
			else if(nJ = m_nQtyJigan)
				dSta -= dB/3;
		}	
	}
	else if(nJ == 0)
	{
		if(pRC->m_xyStt.x > dSta || pRC->m_xyEnd.x < dSta)
			dSta	= ((pRC->m_xyStt+pRC->m_xyEnd)/2).x;
	}

	// 종점 지점각도가 90이 아니면 사각적용  sta조정
	double dAng	= GetAngleJijum(m_nQtyJigan).GetAngleDegree();
	if(!Compare(dAng, 90.0, "="))
		dSta -= dDist / tan(ToRadian(dAng));

	// 구하자.
	GetTvTrack_Plane(tvArr, dSta, dDist, dR, dB);

	// 주철근배치가 사보강으로 배치되면 시점각도의 직각방향으로 회전
	if(m_nTypePlacingMainRebar_UpperSlab == 1 || m_nTypePlacingMainRebar_UpperSlab == 2)
	{
		CRebarPlacing rb;
		double dRot	= dAng - 90;
		CDPoint xyOrg	= GetLineBase()->GetXyLineByLengthAndAngle(dSta, dDist, CDPoint(0, 1));
		rb.RotateTvArr(tvArr, xyOrg, dRot);
	}

	if(!bDrawAllArc)
	{
		if(nJ == 0)
		{
			tvArr.SetTvInfoByInfo("시점측아크1", "그릴때제거1");
			tvArr.SetTvInfoByInfo("시점측아크2", "그릴때제거2");
			tvArr.SetTvInfoByInfo("시점측아크3", "그릴때제거3");
			tvArr.SetTvInfoByInfo("시점측아크4", "그릴때제거4");
		}
		else if(nJ == m_nQtyJigan)
		{
			tvArr.SetTvInfoByInfo("종점측아크1", "그릴때제거1");
			tvArr.SetTvInfoByInfo("종점측아크2", "그릴때제거2");
			tvArr.SetTvInfoByInfo("종점측아크3", "그릴때제거3");
			tvArr.SetTvInfoByInfo("종점측아크4", "그릴때제거4");
		}
	}
}

// 평면상의 최소정보를 이용해서 트랙을 만든다.
// 선형을 따라 만듬.
// 트랙은 선형진행방향으로 봤을때 오른쪽부터 진행방향으로 만들어짐.
// BOOL bMakeToVer : 수직방향으로 만들지..(선형의 직각 방향.)
void CRcBridgeRebar::GetTvTrack_Plane(CTwinVectorArray &tvArr, double dStaOfCen, double dDist, double dR, double dLenHor, BOOL bMakeToVer)
{
	tvArr.RemoveAll();
	
	if(bMakeToVer)
		dLenHor	= 100;

	double dLenHorOld	= dLenHor;
	//if(bMakeToVer && Compare(dLenHor, 0.0, "="))
		//dLenHor	= 1;
	
	CLineInfoApp *pLine	= static_cast<CLineInfoApp*>(GetLineBase());
	if(!pLine) return;

	CTwinVectorArray tvArrHorRight, tvArrHorLeft;
	if(bMakeToVer)
	{
		CDPoint xyDir	= pLine->GetAngleAzimuth(dStaOfCen).Rotate90();
		CTwinVector tvRight, tvLeft;
		tvRight.m_v1	= pLine->GetXyLineByLengthAndAngle(dStaOfCen, dDist+dLenHor/2, CDPoint(0, 1));
		tvRight.m_v2	= tvRight.m_v1 + (xyDir * dLenHor);
		tvLeft	= tvRight;
		Offset(tvRight.m_v1, tvRight.m_v2, dR);
		Offset(tvLeft.m_v1, tvLeft.m_v2, -dR);

		tvArrHorRight.Add(tvRight);
		tvArrHorLeft.Add(tvLeft);
	}
	else
	{
		tvArrHorRight.AddFromLineInfo(pLine, dStaOfCen-dLenHor/2, dStaOfCen+dLenHor/2, dDist+dR);
		tvArrHorLeft.AddFromLineInfo(pLine, dStaOfCen-dLenHor/2, dStaOfCen+dLenHor/2, dDist-dR);
	}

	double dStaStt	= 0;
	double dStaEnd	= 0;

	CDPoint xyDirStt	= CDPoint(0, 1);
	CDPoint xyDirEnd	= CDPoint(0, 1);


	// (39465)두개의 Arc가 만나는 선은 절단이 안되는 문제가 있다 그걸 피하기 위해서 Arc를 2분할 에서 4분할 하자.
	CTwinVector tvRStt, tvREnd;
	CTwinVector tvRStt2, tvREnd2;
	CTwinVector tvRStt3, tvREnd3;
	CTwinVector tvRStt4, tvREnd4;
	CDPoint xyCenStt, xyCenEnd;
	CDPoint xyStt1	= tvArrHorLeft.GetAt(0).m_v1;
	CDPoint xyStt12	= tvArrHorLeft.GetAt(0).m_v2;
	CDPoint xyStt2	= tvArrHorRight.GetAt(0).m_v1;
	CDPoint xyStt22	= tvArrHorRight.GetAt(0).m_v2;
	if(bMakeToVer)
	{
		tvRStt.m_v1	= xyStt12;
		tvRStt.m_v2	= xyStt22;
	}
	else
	{
		pLine->GetStationMatchVerticalByXy(xyStt1, dStaStt);
		pLine->GetStationMatchVerticalByXy(xyStt12, dStaEnd);
		if(dStaStt < dStaEnd) tvRStt.m_v1	= xyStt1;
		else tvRStt.m_v1	= xyStt12;

		pLine->GetStationMatchVerticalByXy(xyStt2, dStaStt);
		pLine->GetStationMatchVerticalByXy(xyStt22, dStaEnd);
		if(dStaStt < dStaEnd) tvRStt.m_v2	= xyStt2;
		else tvRStt.m_v2	= xyStt22;
	}

	xyDirStt	= tvRStt.GetXyDir().RotateInv90();
	xyCenStt	= tvRStt.GetXyMid();
	CDPoint xyMid	= tvRStt.GetXyMid() + (xyDirStt * dR);
	tvRStt2.m_v1	= xyMid;
	tvRStt2.m_v2	= tvRStt.m_v2;
	tvRStt.m_v2		= xyMid;
	
	tvRStt.m_v1.z	= -1;
	tvRStt.m_v2.z	= dR;
	tvRStt.m_sInfo	= "시점측아크1";
	
	tvRStt2.m_v1.z	= -1;
	tvRStt2.m_v2.z	= dR;
	tvRStt2.m_sInfo	= "시점측아크2";

	CDPoint xyEnd1	= tvArrHorRight.GetAt(tvArrHorRight.GetSize()-1).m_v1;
	CDPoint xyEnd12	= tvArrHorRight.GetAt(tvArrHorRight.GetSize()-1).m_v2;
	CDPoint xyEnd2	= tvArrHorLeft.GetAt(tvArrHorLeft.GetSize()-1).m_v1;
	CDPoint xyEnd22	= tvArrHorLeft.GetAt(tvArrHorLeft.GetSize()-1).m_v2;
	if(bMakeToVer)
	{
		tvREnd.m_v1	= xyEnd1;
		tvREnd.m_v2	= xyEnd2;
	}
	else
	{
		pLine->GetStationMatchVerticalByXy(xyEnd1, dStaStt);
		pLine->GetStationMatchVerticalByXy(xyEnd12, dStaEnd);
		if(dStaStt > dStaEnd) tvREnd.m_v1	= xyEnd1;
		else tvREnd.m_v1	= xyEnd12;

		pLine->GetStationMatchVerticalByXy(xyEnd2, dStaStt);
		pLine->GetStationMatchVerticalByXy(xyEnd22, dStaEnd);
		if(dStaStt > dStaEnd) tvREnd.m_v2	= xyEnd2;
		else tvREnd.m_v2	= xyEnd22;
	}

	xyDirEnd	= tvREnd.GetXyDir().RotateInv90();
	xyCenEnd	= tvREnd.GetXyMid();
	xyMid	= tvREnd.GetXyMid() + (xyDirEnd * dR);
	tvREnd2.m_v1	= xyMid;
	tvREnd2.m_v2	= tvREnd.m_v2;
	tvREnd.m_v2		= xyMid;
	
	tvREnd.m_v1.z	= -1;
	tvREnd.m_v2.z	= dR;
	tvREnd.m_sInfo	= "종점측아크1";

	tvREnd2.m_v1.z	= -1;
	tvREnd2.m_v2.z	= dR;
	tvREnd2.m_sInfo	= "종점측아크2";

	// 원곡선에 걸릴경우 시종점 위치가 뒤집혀 있을 수 있다.(아크특성상) //////////
	// 따라서, 시종점아크의 스테이션이 시점이 더 크면 시종점을 바꿔준다.)
	pLine->GetStationMatchVerticalByXy(tvRStt.m_v1, dStaStt);
	pLine->GetStationMatchVerticalByXy(tvREnd.m_v1, dStaEnd);
	if(dStaStt > dStaEnd)
	{
		GetSwap(tvRStt.m_v1, tvREnd2.m_v2);
		GetSwap(tvRStt.m_v2, tvREnd2.m_v1);
		GetSwap(tvRStt2.m_v1, tvREnd.m_v2);
		GetSwap(tvRStt2.m_v2, tvREnd.m_v1);

		tvRStt.m_v2		= tvRStt.m_v2 + xyDirStt * dR * 2;
		tvRStt2.m_v1	= tvRStt.m_v2;

		tvREnd.m_v2		= tvREnd.m_v2 + xyDirEnd * dR * 2;
		tvREnd2.m_v1	= tvREnd.m_v2;

		tvRStt.m_v1.z = tvRStt2.m_v1.z = tvREnd.m_v1.z = tvREnd2.m_v1.z = -1;
		tvRStt.m_v2.z = tvRStt2.m_v2.z = tvREnd.m_v2.z = tvREnd2.m_v2.z = dR;
	}
	//////////////////////////////////////////////////////////////////////////

	CTwinVector tvTemp;
	// 두개로 분할된 Arc를 네개로 나누자
	tvTemp = tvRStt2;
	tvTemp.m_v1.z = 0;
	tvRStt3.m_v1 = tvTemp.m_v1;
	tvRStt4.m_v2 = tvTemp.m_v2;
	xyDirStt	= tvTemp.GetXyDir().RotateInv90();
	xyMid	= xyCenStt + (xyDirStt * dR);
	tvRStt3.m_v2 = xyMid;
	tvRStt4.m_v1 = xyMid;
	tvRStt3.m_v1.z = -1;
	tvRStt3.m_v2.z = dR;
	tvRStt4.m_v1.z = -1;
	tvRStt4.m_v2.z = dR;
	tvRStt3.m_sInfo	= "시점측아크3";
	tvRStt4.m_sInfo	= "시점측아크4";

	tvTemp = tvRStt;
	tvTemp.m_v1.z = 0;
	tvRStt.m_v1 = tvTemp.m_v1;
	tvRStt2.m_v2 = tvTemp.m_v2;
	xyDirStt	= tvTemp.GetXyDir().RotateInv90();
	xyMid	= xyCenStt + (xyDirStt * dR);
	tvRStt.m_v2 = xyMid;
	tvRStt2.m_v1 = xyMid;
	tvRStt.m_v1.z = -1;
	tvRStt.m_v2.z = dR;
	tvRStt2.m_v1.z = -1;
	tvRStt2.m_v2.z = dR;

	tvTemp = tvREnd2;
	tvTemp.m_v1.z = 0;
	tvREnd3.m_v1 = tvTemp.m_v1;
	tvREnd4.m_v2 = tvTemp.m_v2;
	xyDirEnd	= tvTemp.GetXyDir().RotateInv90();
	xyMid	= xyCenEnd + (xyDirEnd * dR);
	tvREnd3.m_v2 = xyMid;
	tvREnd4.m_v1 = xyMid;
	tvREnd3.m_v1.z = -1;
	tvREnd3.m_v2.z = dR;
	tvREnd4.m_v1.z = -1;
	tvREnd4.m_v2.z = dR;
	tvREnd3.m_sInfo	= "종점측아크3";
	tvREnd4.m_sInfo	= "종점측아크4";

	tvTemp = tvREnd;
	tvTemp.m_v1.z = 0;
	tvREnd.m_v1 = tvTemp.m_v1;
	tvREnd2.m_v2 = tvTemp.m_v2;
	xyDirEnd	= tvTemp.GetXyDir().RotateInv90();
	xyMid	= xyCenEnd + (xyDirEnd * dR);
	tvREnd.m_v2 = xyMid;
	tvREnd2.m_v1 = xyMid;
	tvREnd.m_v1.z = -1;
	tvREnd.m_v2.z = dR;
	tvREnd2.m_v1.z = -1;
	tvREnd2.m_v2.z = dR;


	// 구해진 선들을 연결함.
	CRebarPlacing rb;
	if(!Compare(dLenHorOld, 0.0, "=") && !bMakeToVer)
	{
		
		rb.ReverseRebar(tvArrHorLeft);
		tvArr.AddFromTvArray(tvArrHorRight);
		tvArr.Add(tvREnd);
		tvArr.Add(tvREnd2);
		tvArr.Add(tvREnd3);
		tvArr.Add(tvREnd4);
		tvArr.AddFromTvArray(tvArrHorLeft);
		tvArr.Add(tvRStt);
		tvArr.Add(tvRStt2);
		tvArr.Add(tvRStt3);
		tvArr.Add(tvRStt4);
	}
	else
	{
		if(bMakeToVer)
		{
			CDPoint xyDir	= pLine->GetAngleAzimuth(dStaOfCen).Rotate90();
			tvRStt.m_v1	+= xyDir*-100;
			tvRStt.m_v2 += xyDir*-100;
			tvRStt2.m_v1 += xyDir*-100;
			tvRStt2.m_v2 += xyDir*-100;
			tvRStt3.m_v1 += xyDir*-100;
			tvRStt3.m_v2 += xyDir*-100;
			tvRStt4.m_v1 += xyDir*-100;
			tvRStt4.m_v2 += xyDir*-100;
		}

		tvArr.Add(tvREnd);
		tvArr.Add(tvREnd2);
		tvArr.Add(tvREnd3);
		tvArr.Add(tvREnd4);
		tvArr.Add(tvRStt);
		tvArr.Add(tvRStt2);
		tvArr.Add(tvRStt3);
		tvArr.Add(tvRStt4);
	}
}


// 거더 들어가는 지점에 대한 파기
// 모든 지점이 대상이 된다.
// 평면 좌측에 판다.
void CRcBridgeRebar::GetTvCuttingArea_Plane_UpperSlabGirder(CTwinVectorArray &tvArr, long nJ, BOOL bStt, BOOL bLeft, BOOL bGagak, BOOL bJongGirder)
{
	tvArr.RemoveAll();
	if(bJongGirder)
	{
		if(!IsGirderRebarJong(bStt, bLeft, bGagak)) return;
	}
	else
	{
		if(!IsGirderRebar(nJ, TRUE)) return;
	}

	// 트랙 제원
	// 이번센 세워진 뭉퉁한 트랙이 될것이다.
	// 상면쪽에만 판다.
	double dSta			= GetStationOnJijum(nJ);
	if(bJongGirder)
	{
		if(bGagak)
		{
			nJ	= bStt ? 0 : m_nQtyJigan;
			dSta	= GetStationOnJijum(nJ);
		}
		else
		{
			if(m_nQtyJigan == 1)
			{
				dSta	= m_dStationBridgeStt + m_dLengthBridge / 2;
			}
			else
			{
				dSta	= GetStationOnJijum(m_nQtyJigan/2) + GetLengthJigan(m_nQtyJigan/2)/2;
			}
		}
	}

	// 찾는 위치
	CLineInfo *pLine	= GetLineBase();
	CDPoint vAng		= GetAngleJijum(nJ);
	CDPoint xy			= pLine->GetXyLineByLengthAndAngle(dSta, !bJongGirder || bLeft ? -GetWidthSlabAct(dSta, vAng, -1) : GetWidthSlabAct(dSta, vAng, 1), vAng);
	
	// 찾는 위치에서 수직으로 뻗은곳의 sta
	pLine->GetStationMatchVerticalByXy(xy, dSta);

	// 영역 제원
	double dWid			= GetWidthSlabAct(dSta, CDPoint(0, 1), 0);
	double dR			= dWid/6;		// 트랙의 원의 반지름
	if(m_dLengthBridge/6 < dR) dR = m_dLengthBridge/6;
	double dMinLenJigan	= 0;
	for(long jigan = 0; jigan < m_nQtyJigan; jigan++)
		dMinLenJigan = jigan == 0 ? GetLengthJigan(jigan) : min(GetLengthJigan(jigan), dMinLenJigan);
	if(dMinLenJigan > 0 && dMinLenJigan/4 < dR) dR = dMinLenJigan/4;

	double dB			= dR/4;			// 트랙의 수직선 길이
	double dDist		= -GetWidthSlabAct(dSta, CDPoint(0, 1), -1);
	if(bJongGirder && !bLeft)
	{
		dDist	= GetWidthSlabAct(dSta, CDPoint(0, 1), 1);
	}

	
	if(!bJongGirder)
	{
		if(nJ == 0) dSta += (dR - 300);
		else if(nJ == m_nQtyJigan) dSta -= (dR - 300);
	}
	
	// 구하자.
	GetTvTrack_Plane(tvArr, dSta, dDist, dR, dB, TRUE);	

	// 
	if(!bJongGirder || bLeft)
	{
		tvArr.SetTvInfoByInfo("종점측아크1", "그릴때제거1");
		tvArr.SetTvInfoByInfo("종점측아크2", "그릴때제거2");
		tvArr.SetTvInfoByInfo("종점측아크3", "그릴때제거3");
		tvArr.SetTvInfoByInfo("종점측아크4", "그릴때제거4");
	}
	else
	{
		tvArr.SetTvInfoByInfo("시점측아크1", "그릴때제거1");
		tvArr.SetTvInfoByInfo("시점측아크2", "그릴때제거2");
		tvArr.SetTvInfoByInfo("시점측아크3", "그릴때제거3");
		tvArr.SetTvInfoByInfo("시점측아크4", "그릴때제거4");
	}
}

// 외측벽체가 있을 경우 브라켓 부를 판다
// 시점측은 2,3단 철근에 대해서 파서 자리가 없으므로, 종점측에 판다
// 약간의 문제가 있다면, 지금은 시점측, 종점측 벽체의 유무를 각각 설정할 수 없지만, 차후에 
// 각각 설정하게 된다면 시점측만 브라켓이 있는 경우 어쩔 수 없이 시점측을 파야 될 경우가 생길 수 있다.
// 그때는 다시 파는 위치를 조정해야 됨
void CRcBridgeRebar::GetTvCuttingArea_Plane_UpperSlabBracket(CTwinVectorArray &tvArr)
{
	tvArr.RemoveAll();

	// 외측벽체가 없으면 리턴
	if(!IsOutWall(FALSE)) return;
	if(!IsBracket(FALSE)) return;
	
	// 트랙 제원
	double dWBracket	= m_dBHWE;
	double dLenJigan	= GetLengthJigan(m_nQtyJigan-1);
	double dSta			= m_dStationBridgeStt+m_dLengthBridge-m_dWE;	// 트랙의 중심 sta
	double dDistMid		= GetDistMidOfSlab(dSta);
	double dWid			= GetWidthSlabAct(dSta, CDPoint(0, 1), 0);
	double dR			= dWid/16;										// 트랙의 원의 반지름
	double dB			= dLenJigan/4;									// 트랙의 수평선 길이
	double dDist		= dDistMid - dWid/6 + 0.0345;					// 중심선형에서 트랙중심까지 거리.(0.0345는 정확히 원의 끝과 철근이 겹치는걸 방지하기 위해 임의로 더해줌)
	if(GetAngleJijum(0).GetAngleDegree() > 90)
		dDist	= dDistMid + dWid/6 + 0.0345;
	
	// 구하자.
	dSta += dB/3 + dWBracket;

	// 종점 지점각도가 90이 아니면 사각적용  sta조정
	double dAng	= GetAngleJijum(m_nQtyJigan).GetAngleDegree();
	if(!Compare(dAng, 90.0, "="))
		dSta -= dDist / tan(ToRadian(dAng));

	
	GetTvTrack_Plane(tvArr, dSta, dDist, dR, dB);

	// 주철근배치가 사보강으로 배치되면 시점각도의 직각방향으로 회전
	if(m_nTypePlacingMainRebar_UpperSlab == 1 || m_nTypePlacingMainRebar_UpperSlab == 2)
	{
		CRebarPlacing rb;
		double dRot	= dAng - 90;
		CDPoint xyOrg	= GetLineBase()->GetXyLineByLengthAndAngle(dSta, dDist, CDPoint(0, 1));
		rb.RotateTvArr(tvArr, xyOrg, dRot);
	}
	
	
	tvArr.SetTvInfoByInfo("종점측아크1", "그릴때제거1");
	tvArr.SetTvInfoByInfo("종점측아크2", "그릴때제거2");
	tvArr.SetTvInfoByInfo("종점측아크3", "그릴때제거3");
	tvArr.SetTvInfoByInfo("종점측아크4", "그릴때제거4");
}


// 평면도 거더 배력근 좌표 구함.
void CRcBridgeRebar::GetTvRebarSupport_Plane_SlabGirder(CTwinVectorArray &tvArr, BOOL bUpperSlab, long nJ, long nDan, BOOL bUpper, long nDrawLeft)
{
	tvArr.RemoveAll();

	// 종단면상의 거더 배력근 구함. (중심선형 기준임)
	CDPointArray xyArr, xyArrDirApplyScale;
	GetxyRebarSupport_SlabGirder(xyArr, xyArrDirApplyScale, bUpper ? iUPPER : iLOWER, nJ, TRUE, TRUE, TRUE, FALSE, bUpperSlab);

	if(xyArr.GetSize() > 0)
	{
		CDPoint vAng  = GetAngleJijum(nJ);
		CDPoint xyStt = xyArr.GetAt(0);
		CDPoint xyEnd = xyArr.GetAt(xyArr.GetSize()-1);
		CDPoint xyMid = (xyStt + xyEnd) / 2;
		for(long i = 0; i < xyArr.GetSize(); i++)
		{
			CDPoint xy	= xyArr.GetAt(i);
			double dist	= (xy.x - xyMid.x)/vAng.y;
			xy.x	= xyMid.x + dist;
			xyArr.SetAt(i, xy);
		}
	}

	// 지점 방향으로 배근되는 배력근 구하기
	GetTvRebarSupport_Plane_UpperSlab_JijumAngle(tvArr, xyArr, nJ, nDrawLeft);
}

// 평면도 상부슬래브 헌치부 주철근
// long nLeftRebar -> -1 : 헌치 좌측 철근, 0 : 헌치 좌우측 철근, 1 : 헌치 우측철근
CRebarInfoCycle *CRcBridgeRebar::GetTvRebarMain_Plane_SlabHunch(CTwinVectorArray &tvArr, CTwinVectorArray &tvArrAngLeft, CTwinVectorArray &tvArrAngRight, long nCycle, double dSta, long nLeftRebar, long nDrawLeft, BOOL bUpperSlab)
{
	tvArr.RemoveAll();
	tvArrAngLeft.RemoveAll();
	tvArrAngRight.RemoveAll();


	long nIdxLeft	= -1;
	long nIdxRight	= -1;
//	BOOL bVertDir	= IsVertDir();
	
	double dStaCheck	= GetStationModifyForRebarCheck(dSta);
	long nJ	= GetJijumNumberByStation(dSta);
	/*
	// 들어오는 dSta가 시점보다 작거나, 종점보다 크다면  //////////
	// 철근이 있는지 검사하기 위해 조정을 좀 해줘야 된다.
	long nJ	= GetJijumNumberByStation(dSta);
	if(nJ == 0 || nJ == m_nQtyJigan)
	{
		CDPoint vAng	= GetAngleJijum(nJ, bVertDir);
		double dStaStt	= GetStationByTarget(BRIDGE_OFF_STT_SLAB, 0, FALSE);
		double dLenBri	= GetStationByTarget(BRIDGE_OFF_END_SLAB, 0, FALSE) - GetStationByTarget(BRIDGE_OFF_STT_SLAB, 0, FALSE);
		if(nJ == 0 && dSta <= dStaStt + m_dCoverWallOut[0]/vAng.y)
			dSta = dStaStt + m_dCoverWallOut[0]/vAng.y;
		else if(nJ == m_nQtyJigan && dSta >= dStaStt + dLenBri - m_dCoverWallOut[0]/vAng.y)
			dSta	= dStaStt + dLenBri - m_dCoverWallOut[0]/vAng.y;
	}
*/

	// 철근이 없다면 그냥 리턴
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = bUpperSlab?	&m_pArrRCMainUpperSlabHunch[nCycle] : &m_pArrRCMainLowerSlabHunch[nCycle];
	BOOL bFind	= FALSE;
	CRebarInfoCycle *pRCReturnL	= NULL;
	CRebarInfoCycle *pRCReturnR	= NULL;
	long i = 0; for(i = 0; i < pArrRC->GetSize(); i++)
	{
		CRebarInfoCycle *pRC	= pArrRC->GetAt(i);
		double dLeft	= pRC->m_tvArrRebar.GetRect().left;
		double dRight	= pRC->m_tvArrRebar.GetRect().right;
		if(dLeft > dRight) GetSwap(dLeft, dRight);
		
		if(1)//(fabs(dStaCheck-dLeft) <= 100 || Compare(dStaCheck, dLeft, ">=")) && (fabs(dStaCheck-dRight) <= 100 || Compare(dStaCheck, dRight, "<=")))
		{
			if(pRC->m_nPosHunch == nJ)
			{
				if(nIdxLeft == -1) 
				{
					nIdxLeft	= i;
					pRCReturnL	= pRC;
				}
				else if(nIdxRight == -1)
				{
					nIdxRight	= i;
					pRCReturnR	= pRC;
				}
				bFind	= TRUE;
			}
		}
	}
	if(!bFind) return pRCReturnL;
	////////////////////////////////////////////////////////////////

	// 헌치부 주철근도 상부슬래브 주철근과 ctc가 같으므로 구지 따로 구할 필요 없이
	// 상부슬래브 주철근 구하는 함수를 이용하자.
	CTwinVectorArray tvArr1, tvArrAngLeft1, tvArrAngRight1;
	CTwinVectorArray tvArr2, tvArrAngLeft2, tvArrAngRight2;
	
	if(bUpperSlab)
	{
		if((nLeftRebar == -1 || nLeftRebar == 0) && nIdxLeft != -1)
			GetTvRebarMain_Plane_UpperSlab_TypeNormal_Std(tvArr1, tvArrAngLeft1, tvArrAngRight1, FALSE, nCycle, 0, nDrawLeft, nIdxLeft, TRUE);
		if((nLeftRebar == 1 || nLeftRebar == 0) && nIdxRight != -1)
			GetTvRebarMain_Plane_UpperSlab_TypeNormal_Std(tvArr2, tvArrAngLeft2, tvArrAngRight2, FALSE, nCycle, 0, nDrawLeft, nIdxRight, TRUE);
	}
	else
	{
		if((nLeftRebar == -1 || nLeftRebar == 0) && nIdxLeft != -1)
			GetTvRebarMain_Plane_LowerSlab_TypeNormal_Std(tvArr1, tvArrAngLeft1, tvArrAngRight1, TRUE, nCycle, 0, nDrawLeft, nIdxLeft, TRUE);
		if((nLeftRebar == 1 || nLeftRebar == 0) && nIdxRight != -1)
			GetTvRebarMain_Plane_LowerSlab_TypeNormal_Std(tvArr2, tvArrAngLeft2, tvArrAngRight2, TRUE, nCycle, 0, nDrawLeft, nIdxRight, TRUE);
	}
	tvArr.AddFromTvArray(tvArr1);
	tvArr.AddFromTvArray(tvArr2);
	tvArrAngLeft.AddFromTvArray(tvArrAngLeft1);
	tvArrAngLeft.AddFromTvArray(tvArrAngLeft2);
	tvArrAngRight.AddFromTvArray(tvArrAngRight1);
	tvArrAngRight.AddFromTvArray(tvArrAngRight2);

	return nLeftRebar == -1 || nLeftRebar == 0 ? pRCReturnL : pRCReturnR;
}

// 헌치부 배력근
// 진행방향이 거더철근과 같다.
void CRcBridgeRebar::GetTvRebarSupport_Plane_SlabHunch(CTwinVectorArray &tvArr, BOOL bUpperSlab, long nDrawLeft, long nJ)
{
	tvArr.RemoveAll();

	
	CTwinVectorArray tvArrTmp;
	CDPointArray xyArrLeft, xyArrRight;

	long nJOfHunchRebar	= 0;
	long nCountHunchRebar	= bUpperSlab? m_pArrRCMainUpperSlabHunch[0].GetSize() : m_pArrRCMainLowerSlabHunch[0].GetSize();
	long i = 0; for(i = 0; i < nCountHunchRebar; i++)
	{
		// 종단면상의 거더 배력근 구함. (중심선형 기준임)
		if(bUpperSlab)
			nJOfHunchRebar	= GetXyRebarSupport_VertSection_UpperSlabHunch(xyArrLeft, xyArrRight, i);
		else
			nJOfHunchRebar	= GetXyRebarSupport_VertSection_LowerSlabHunch(xyArrLeft, xyArrRight, i);

		if(nJ != nJOfHunchRebar && nJ != -1) continue;

		long nSize	= xyArrRight.GetSize();
		long j = 0; for(j = 0; j < nSize; j++)
			xyArrLeft.Add(xyArrRight.GetAt(j));

		// 좌에서 우로 정렬
		xyArrLeft.Sort(TRUE, TRUE);

		// 지점 방향으로 배근되는 배력근 구하기
		// (38838) 시종점 헌치는 슬래브 끝까지 들어간다. -> (39755) 헌치위치 까지만 넣는걸로 다시 변경
		// BOOL bHunchEnd = (nJ == 0 || nJ == m_nQtyJigan)? FALSE : TRUE;
		BOOL bHunchEnd = TRUE;
		GetTvRebarSupport_Plane_UpperSlab_JijumAngle(tvArrTmp, xyArrLeft, nJ == -1 ? nJOfHunchRebar : nJ, nDrawLeft, bHunchEnd);

		tvArr.AddFromTvArray(tvArrTmp);
	}
}

// 점 좌표들을 지점 방향으로 뻗게 해서 배력근 좌표들을 구한다.
// 점좌표들의 x좌표를 sta으로 사용한다.
// bByHunch : 헌치 폭으로 배근
void CRcBridgeRebar::GetTvRebarSupport_Plane_UpperSlab_JijumAngle(CTwinVectorArray &tvArr, CDPointArray &xyArr, long nJ, long nDrawLeft, BOOL bByHunch)
{
	tvArr.RemoveAll();
	if(nJ < 0 || nJ > m_nQtyJigan) return;
	if(xyArr.GetSize() == 0) return;

	BOOL bVertDir	= FALSE;
	CLineInfo *pLine	= GetLineBase(bVertDir);
	CRebarPlacing rb;

	// 가각부 좌우측 외곽라인 구함. ///////////////
	CTwinVectorArray tvArrPlaneExp;
	CTwinVectorArray tvArrLeftExp, tvArrRightExp;
	GetTvRebarOut_Plane_UpperSlabStd(tvArrPlaneExp, 0, TRUE);
	CTwinVector tv;
	long i = 0; for(i = 0; i < tvArrPlaneExp.GetSize(); i++)
	{
		tv	= tvArrPlaneExp.GetAt(i);
		if(tv.m_sInfo.Find("시점좌측가각부", 0) != -1)
			tvArrLeftExp.Add(tv);
		else if(tv.m_sInfo.Find("종점좌측가각부", 0) != -1)
			tvArrLeftExp.Add(tv);
		else if(tv.m_sInfo.Find("시점우측가각부", 0) != -1)
			tvArrRightExp.Add(tv);
		else if(tv.m_sInfo.Find("종점우측가각부", 0) != -1)
			tvArrRightExp.Add(tv);
	}
	// 가각부 좌우측 외곽라인 구함. ///////////////
// 	double dWidthRight(0);
	CDPoint xyDir	= GetAngleJijum(nJ, bVertDir);
	double dCoverSide	= GetCoverSide_UpperSlab(0)/xyDir.y;
	double dStaJijum	= GetStationOnJijum(nJ, 0, bVertDir);
//	double dSta		= 0;
	CDPoint xyMatchMid(0, 0);
	CDPointArray xyArrMatchMid;
	CDPointArray xyArrMatch;
	CTwinVectorArray tvArrCenter;
	GetTvCenterPlane_UpperSlab(tvArrCenter, TRUE, FALSE, 0, bVertDir);

		
	// 슬래브 끝단보다 sta가 적거나 크면 브라켓 배력근이다.
	BOOL bSttBracket	= xyArr.GetAt(0).x < GetStationByTarget(BRIDGE_OFF_STT_SLAB, 0, TRUE);
	BOOL bEndBracket	= xyArr.GetAt(xyArr.GetSize()-1).x > GetStationByTarget(BRIDGE_OFF_END_SLAB, 0, TRUE);

	tv.m_v1.z	= 0;
	tv.m_v2.z	= 0;

	for(i = 0; i < xyArr.GetSize(); i++)
	{
		double dSta		= 0;
		dSta	= xyArr.GetAt(i).x;
	
		// 사보강배치일 경우 시점0을 기준으로하는 직방향 선형을 사용하기 때문에 실제로 그려진 종단면상의 철근에서일부 수정이 있엉 ㅑ함.
		// 철근배치를 하기 위해선 직방향용 선형의 sta으로 변경
		if(bVertDir)
		{
 			double dDiff	= m_dStationBridgeStt;
			dSta			-= dDiff;
		}

		// 어짜피 사보강배치에선 선형이 직선이므로 따로 고려할 필요 없음(원곡선 선형 적용용)
		CDPoint xyDirL	= pLine->GetAngleByOffset(dStaJijum, dSta, xyDir);

		double dWidthLeft	= GetWidthSlabAct(dSta, xyDirL, -1, FALSE, bVertDir, FALSE, GetAngleJijum(nJ));
		double dWidthRight	= GetWidthSlabAct(dSta, xyDirL, 1, FALSE, bVertDir, FALSE, GetAngleJijum(nJ));
	

		tv.m_v1	= pLine->GetXyLineByLengthAndAngle(dSta, dWidthRight-dCoverSide, xyDirL); 
		tv.m_v2	= pLine->GetXyLineByLengthAndAngle(dSta, -(dWidthLeft-dCoverSide), xyDirL);


		// 가각 지원인 경우 철근을 뻗어서 가각부에 교차되면 가각부 까지 뻗어준다.
		if(m_bIsExp)
		{
			// 브라켓은 교차 되지 않을경우 뻗지 않고 그냥 가각 높이를 더해줌
			if(bSttBracket || bEndBracket)
			{
				double dHeightLeft	= bSttBracket ? m_dExpSttH[0] : m_dExpEndH[0];
				double dHeightRight	= bEndBracket ? m_dExpSttH[1] : m_dExpEndH[1];

				tv.m_v1 += tv.GetXyDir(TRUE) * dHeightRight;
				tv.m_v2 += tv.GetXyDir() * dHeightLeft;
			}
			else
			{
				rb.GetXyMatchTvArrAndLine(tvArrLeftExp, tv.m_v1, tv.GetXyDir(), xyArrMatch);
				if(xyArrMatch.GetSize() > 0)
					tv.m_v2	= xyArrMatch.GetAt(0);
				
				rb.GetXyMatchTvArrAndLine(tvArrRightExp, tv.m_v1, tv.GetXyDir(), xyArrMatch);
				if(xyArrMatch.GetSize() > 0)
					tv.m_v1	= xyArrMatch.GetAt(0);
			}
		}

		if(bByHunch)
		{
			double dLenL	= (m_dDH[0] + m_dCantilB[0]);
			double dLenR	= (m_dDH[1] + m_dCantilB[1]);
			tv.m_v1 = tv.m_v1 + tv.GetXyDir() * dLenR/xyDir.y;
			tv.m_v2 = tv.m_v2 + tv.GetXyDir(TRUE) * dLenL/xyDir.y;
		}

		// 중심선형과의 교차점을 미리 구해둠.
		rb.GetXyMatchTvArrAndSeg(tvArrCenter, tv.m_v1, tv.m_v2, xyArrMatchMid, FALSE);
		if(xyArrMatchMid.GetSize() > 0) 
			xyMatchMid	= xyArrMatchMid.GetAt(0);
		else
			xyMatchMid	= pLine->GetXyLineByLengthAndAngle(dSta, 0, xyDir);

		if(nDrawLeft == -1)	// 진행방향 좌측만
		{
			tv.m_v1	= xyMatchMid;
		}
		else if(nDrawLeft == 0)	// 좌우측 모두
		{
		}
		else if(nDrawLeft == 1)	// 진행방향 우측만
		{
			tv.m_v2	= xyMatchMid;
		}

		tv.m_v1.z	= 0;
		tv.m_v2.z	= 0;
		tvArr.Add(tv);
	}
}

// 상부슬래브 헌치부 배력근 sta 모두 구함.
void CRcBridgeRebar::GetStaRebarSupport_VertSection_SlabHunch(BOOL bUpperSlab, CDoubleArray &dArr)
{
	dArr.RemoveAll();
	
	CDPointArray xyArr, xyArrLeft, xyArrRight;	

	long nCountHunchRebar	= bUpperSlab? m_pArrRCMainUpperSlabHunch[0].GetSize() : m_pArrRCMainLowerSlabHunch[0].GetSize();
	long i = 0; for(i = 0; i < nCountHunchRebar; i++)
	{
		if(bUpperSlab)
			GetXyRebarSupport_VertSection_UpperSlabHunch(xyArrLeft, xyArrRight, i);
		else
			GetXyRebarSupport_VertSection_LowerSlabHunch(xyArrLeft, xyArrRight, i);

		long j = 0; for(j = 0; j < xyArrLeft.GetSize(); j++)
			xyArr.Add(xyArrLeft.GetAt(j));
		for(j = 0; j < xyArrRight.GetSize(); j++)
			xyArr.Add(xyArrRight.GetAt(j));
	}
	
	// 횡단 슬래브 좌측으로 부터 거리를 구한뒤, dDistFromRight고려해서 재계산
	long nSize	= xyArr.GetSize();
	for(i = 0; i < nSize; i++)
		dArr.Add(xyArr[i].x);

	dArr.Sort();
}

// 헌치부 철근 권고안
void CRcBridgeRebar::SetDataDefaultRebarHunch()
{
	long nCountDia	= m_nQtyJigan+1;
	CDoubleArray *pdArr;

	long nCountSlab = 1;
	if(IsBoxType()) nCountSlab = 2;

	for(long ix = iUPPER; ix < nCountSlab; ix++)
	{
		long cycle = 0; for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
		{
			if(ix == iUPPER)	pdArr	= &m_dArrDiaUpperSlabHunch[cycle];
			else	pdArr	= &m_dArrDiaLowerSlabHunch[cycle];

			pdArr->RemoveAll();
			long i = 0; for(i = 0; i < nCountDia; i++)
			{
				pdArr->Add(cycle == 0 ? 19 : 0);

				// 철근타입 설정
				if(cycle == 0)
				{
					if(ix == iUPPER)	m_dArrTypeUpperSlabHunch.Add(0);
					else	m_dArrTypeLowerSlabHunch.Add(0);
				}
			}
		}
	}
}

// 외측벽체 2cycle 내측 철근 이음 여부..
BOOL CRcBridgeRebar::IsJointMainRebarOutWall_Cycle2_Old(BOOL bStt, BOOL bUpper)
{
	long stt	= bStt ? iSTT : iEND;
	long upper	= bUpper ? iUPPER : iLOWER;

	CSetRebarJoint *pSetRebarJoint = &m_pArrSetRebarJointOutWall_Inner[stt][upper];

	if(Compare(GetDistMainRebarOutWall(1, 0, bStt, TRUE, bUpper ? -1 : 0, FALSE), 0.0, "="))
		pSetRebarJoint->m_bJoint	= TRUE;

	return pSetRebarJoint->m_bJoint;
}

// 상부슬래브 단 절점부 철근 집계
// 주철근 개수와 동일해야 함.
void CRcBridgeRebar::SetDataDefaultRebarJewonUpperSlabDanbu(BOOL bUpper)
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();

	double dCover		= 0;	// 피복
	double dRebarSpace	= GetCtcRebarMain(TRUE)/2;	// 간격
	CTwinVector tvSlab;
	if(bUpper)
		tvSlab	= GetTvOffset_UpperSlab(0, 0, -1.0, -1.0, IsVertDir());
	else
		tvSlab	= GetTvOffset_LowerSlab(0, 0, -1.0, -1.0, IsVertDir());

	tvSlab.Sort(TRUE);

	CHgBaseConcStd baseConc;
	long cycle = 0; for(cycle = 0; cycle < 2; cycle++)
	{
		long stt = 0; for(stt = 0; stt < 2; stt++)
		{
			BOOL bStt	= stt == iSTT;
			if(!IsOutWall(bStt)) continue;

			/*
			CVectorArray vecArr1, vecArrHunch1;
			CVectorArray vecArr2, vecArrHunch2;
			double dSta	= GetStationByTarget(bStt ? BRIDGE_OFF_STT_STT : BRIDGE_OFF_END_END, 0, TRUE);
			GetXyRebarMain_CrossSection_UpperSlab(vecArr1, vecArrHunch1, dSta, TRUE, 0, cycle==0?0:1);
			GetXyRebarMain_CrossSection_UpperSlab(vecArr2, vecArrHunch2, dSta, TRUE, 0, cycle==0?2:3);
			double dWidthGagak	= GetWidthSlabActByGagak(dSta, GetAngleJijum(bStt ? 0 : m_nQtyJigan), 0, FALSE) - m_dCoverSide_UpperSlab[0] * 2;
			*/
			
			long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
			{
				dCover	= m_dCoverUpper_UpperSlab[dan];
				if(dan > 0) dCover -= m_dCoverUpper_UpperSlab[dan-1];

				CRebarInfoCycle *pRC;
				if(bUpper)
					pRC	= cycle == 0 ? &m_rebarInfoCycleDanbu_UpperCycle1[stt][dan] : &m_rebarInfoCycleDanbu_UpperCycle2[stt][dan];
				else
					pRC	= cycle == 0 ? &m_rebarInfoCycleDanbu_LowerCycle1[stt][dan] : &m_rebarInfoCycleDanbu_LowerCycle2[stt][dan];
				
				
				long nTypeDanbu = m_nType_DanbuRebar;
				if(IsDanbuRebar(bStt, dan, cycle, bUpper))
				{
					CRebar *pRB	= new CRebar;
					pRB->m_Fy			= bLsd? GetValueFy(bUpper? ePartUpperSlab : ePartLowerSlab): m_pARcBridgeDataStd->m_Fy;
					pRB->m_sDescription	= pRC->m_sDescription;
					pRB->m_sMark		= pRC->m_szMark;
					pRB->m_dDia			= pRC->m_Dia;

					// 0, 2 모두 상세는 같으나, 연결부 길이가 다르게 산정된 타입임
					if(nTypeDanbu == 0 || nTypeDanbu == 1)
					{
						pRB->m_dLengthMax_A	= pRC->GetLengthMid();
						pRB->m_dLengthMax_B	= pRC->GetLengthStt();
						pRB->m_nTypeRebar	= 9;

						if(bStt)
						{
							double dAngSlab	= tvSlab.GetXyDir().GetAngleDegree();
							if(dAngSlab < 225)
								dAngSlab += 360;
							pRB->m_dAngleX1	= dAngSlab - 225;
						}
						else
						{
							double dAngSlab	= tvSlab.GetXyDir(TRUE).GetAngleDegree();
							pRB->m_dAngleX1	= 315 - dAngSlab;
						}

						pRB->m_dAngleX2	= 135;
	
					}
					else
					{
						pRB->m_dLengthMax_A	= pRC->GetLengthStt();
						pRB->m_dLengthMax_B	= pRC->GetLengthMid();

						// 철근 지름 별 반지름 [토목구조물의 배근상세 - 한국콘크리트학회 P17]
						// D10 ~ D25 : 3d
						// D29 ~ D35 : 4d
						// D38이상 : 5d
						// 아크 각도 : 135도
						// 아크 다음 갈고리 길이 : 6d
						pRB->m_R			= 3 * pRB->m_dDia;
						if(pRB->m_dDia >= 29 && pRB->m_dDia <= 35)
							pRB->m_R		= 4 * pRB->m_dDia;
						else if(pRB->m_dDia >= 38)
							pRB->m_R		= 5 * pRB->m_dDia;
						pRB->m_dLengthMax_C	= 2 * ConstPi * pRB->m_R * (135. / 360.);
						pRB->m_dLengthMax_D	= 6 * pRB->m_dDia;
						pRB->m_nTypeRebar	= 26;
					}
					pRB->m_bMainRebar	= TRUE;
					pRB->m_nEa			= GetCountRebarDanbu(bStt, cycle, TRUE);//vecArr1.GetSize() + vecArr2.GetSize();	// 상부슬래브 상면 주철근과 갯수 동일
					m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
					pRB->m_dRateAdd	= MAKE_RATE;
					AddOrDeleteRebarInList(&m_pArrRebarMain, pRB);
				}
			}
		}
	}
}

// 기초 주철근 철근 집계
void CRcBridgeRebar::SetDataDefaultRebarJewonFooting()
{
	long nCountFooting	= GetCountFooting();
	CString sFooting	= _T("");

	// 기초는 항상 직거리로 입력받으므로 집계하기 위해서는 직거리 sync 해준다.
	// 평면배근도를 가지고 철근 수량을 집계하기 때문에 이부분은 꼭 필요하다.
	SyncBridgeRebar(FALSE, -1);

	// 기초
	long nLastNum	= 0;
	for(long footing = 0; footing < nCountFooting; footing++)
	{
		CFootingApp *pFooting	= GetFooting(footing);
		if(!pFooting) continue;

		pFooting->m_nTypeAddRate.Attach(&m_nTypeAddRate);		// 0 : 직경별, 1 : 주철근,기타철근
		pFooting->m_dAddRateLower.Attach(&m_dAddRateLower);		// 하위 할증률
		pFooting->m_dAddRateUpper.Attach(&m_dAddRateUpper);		// 상위 할증률
		pFooting->m_dAddRateDiaOrg.Attach(&m_dAddRateDiaOrg);	// 직경별일경우 기준 직경

		pFooting->SetDataDefaultRebarJewonMain(nLastNum);
		CString sFooting	= _T("");
		sFooting.Format("기초%d ", footing+1);

		
		long i = 0; for(i = 0; i < pFooting->m_pArrRebarMain.GetSize(); i++)
		{
			CRebar *pRB	= pFooting->m_pArrRebarMain.GetAt(i);
			nLastNum	+= pRB->IsTrue() ? 1 : 0;

			CString sFront	= footing == 0 ? _T("좌측") : _T("우측");
			CString sBack	= footing == 0 ? _T("우측") : _T("좌측");
			pRB->m_sDescription.Replace("기초 ", sFooting);
			pRB->m_sDescription.Replace("전면", sFront);
			pRB->m_sDescription.Replace("후면", sBack);
		}
	}

	// 기초때문에 직거리 싱크한거 복구
	SyncBridgeRebar(FALSE, 0);
}

// 철근 집계 권고안(기타철근)
// 기타철근 : 본체,벽체,기초의 배력/전단철근, 기초 측면철근등.. 날개벽, 접속슬래브, 기타상세와 주철근을 제외한 모든 철근
void CRcBridgeRebar::SetDataDefaultRebarJewonEtcStd()
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();
	const double dMulti = bLsd? 10 : 1;

	long nCountInWall	= GetCountInWall();
	long nCountFooting	= GetCountFooting();
	long wall(0), footing(0);
	long nLastNum	= 1;
	long nLastNumShear	= 1;
	CString sWall	= _T("");
	CString sFooting	= _T("");

	// 배력철근 /////////////////////////////////
	ClearRebarList(1);
	GetMarkRebarSupport(0, FALSE, TRUE, TRUE);
	GetMarkRebarSupportArchRib(0, FALSE, TRUE, TRUE);

	// 본체
	SetDataDefaultRebarJewon_UpperSlab_Support();	// 상부슬래브 배력철근
	SetDataDefaultRebarJewon_LowerSlab_Support();
	SetDataDefaultRebarJewon_OutWall_Support();		// 외측벽체 배력철근

	// 내측벽체
	long i = 0; for(i = 0; i < m_pArrRebarSupport.GetSize(); i++)
	{
		nLastNum	= m_Util.GetNumMark(m_pArrRebarSupport.GetAt(i)->m_sMark);
	}

	for(wall = 0; wall < nCountInWall; wall++)
	{
		CWallApp *pWall	= GetInWall(wall);
		if(pWall)
		{
			pWall->m_nTypeAddRate.Attach(&m_nTypeAddRate);		// 0 : 직경별, 1 : 주철근,기타철근
			pWall->m_dAddRateLower.Attach(&m_dAddRateLower);		// 하위 할증률
			pWall->m_dAddRateUpper.Attach(&m_dAddRateUpper);		// 상위 할증률
			pWall->m_dAddRateDiaOrg.Attach(&m_dAddRateDiaOrg);	// 직경별일경우 기준 직경

			pWall->SetDataDefaultRebarJewonSupport(wall==0 ? nLastNum+1 : -1);

			for(i = 0; i < pWall->m_pArrRebarSupport.GetSize(); i++)
				nLastNum	= m_Util.GetNumMark(pWall->m_pArrRebarSupport.GetAt(i)->m_sMark);

			// 벽체가 여러개인데 각각 철근 이름을 구분하기 위해.
			sWall.Format("중간지점%d", wall+1);
			long i = 0; for(i = 0; i < pWall->m_pArrRebarSupport.GetSize(); i++)
			{
				CRebar *pRB	= pWall->m_pArrRebarSupport.GetAt(i);
				pRB->m_sDescription.Replace("중간지점", sWall);
			}
		}
	}

	SetDataDefaultRebarJewon_BFooting_Support();	// 부상방지저판 배력철근

	// 아치리브
	if(m_nTypeBridge == BRIDGE_TYPE_ARCH)
	{
		SetDataDefaultRebarJewon_ArchRib_Support();

		if(m_pArrRebarSupport.GetSize() > 0)
		{
			nLastNum	= m_Util.GetNumMark(m_pArrRebarSupport.GetAt(m_pArrRebarSupport.GetSize()-1)->m_sMark);
		}
	}
	

	// 전단철근
	ClearRebarList(2);
	nLastNumShear	= 0;
	GetMarkRebarShear(0, FALSE, TRUE, TRUE);
	GetMarkRebarShearArchRib(0, FALSE, TRUE, TRUE);
	// 본체
	SetDataDefaultRebarJewon_UpperSlab_Shear();	// 상부슬래브
	SetDataDefaultRebarJewon_LowerSlab_Shear();	// 하부슬래브
	SetDataDefaultRebarJewon_BFooting_Shear();// 부상방지저판
	// 아치리브
	if(m_nTypeBridge == BRIDGE_TYPE_ARCH)
		SetDataDefaultRebarJewon_ArchRib_Shear();
	SetDataDefaultRebarJewon_OutWall_Shear();	// 외측벽체

	// 내측벽체
	for(i = 0; i < m_pArrRebarShear.GetSize(); i++)
		nLastNumShear	+= m_pArrRebarShear.GetAt(i)->IsTrue() ? 1 : 0;

	for(wall = 0; wall < nCountInWall; wall++)
	{
		CWallApp *pWall	= GetInWall(wall);
		if(pWall)
		{
			pWall->m_nTypeAddRate.Attach(&m_nTypeAddRate);		// 0 : 직경별, 1 : 주철근,기타철근
			pWall->m_dAddRateLower.Attach(&m_dAddRateLower);		// 하위 할증률
			pWall->m_dAddRateUpper.Attach(&m_dAddRateUpper);		// 상위 할증률
			pWall->m_dAddRateDiaOrg.Attach(&m_dAddRateDiaOrg);	// 직경별일경우 기준 직경

			pWall->SetDataDefaultRebarJewonShear(wall==0 ? nLastNumShear+1 : -1);

			for(i = 0; i < pWall->m_pArrRebarShear.GetSize(); i++)
				nLastNumShear	+= pWall->m_pArrRebarShear.GetAt(i)->IsTrue() ? 1 : 0;

			// 벽체가 여러개인데 각각 철근 이름을 구분하기 위해.
			sWall.Format("중간지점%d", wall+1);
			long i = 0; for(i = 0; i < pWall->m_pArrRebarShear.GetSize(); i++)
			{
				CRebar *pRB	= pWall->m_pArrRebarShear.GetAt(i);
				pRB->m_sDescription.Replace("중간지점", sWall);
				pRB->m_Fy = bLsd? GetValueFy(ePartInWall, TRUE) : pWall->m_Fy;
			}
		}
	}



	// 기초는 항상 직거리로 입력받으므로 집계하기 위해서는 직거리 sync 해준다.
	SyncBridgeRebar(FALSE, -1);
	///////////////////////////////////////////////////////////////////////////

	
	// 기초
	for(footing = 0; footing < nCountFooting; footing++)
	{
		CFootingApp *pFooting	= GetFooting(footing);
		if(pFooting)
		{
			pFooting->m_nTypeAddRate.Attach(&m_nTypeAddRate);		// 0 : 직경별, 1 : 주철근,기타철근
			pFooting->m_dAddRateLower.Attach(&m_dAddRateLower);		// 하위 할증률
			pFooting->m_dAddRateUpper.Attach(&m_dAddRateUpper);		// 상위 할증률
			pFooting->m_dAddRateDiaOrg.Attach(&m_dAddRateDiaOrg);	// 직경별일경우 기준 직경

			pFooting->SetDataDefaultRebarJewonSupport(footing==0 ? nLastNum+1 : -1);

			// 기초가 여러개인데 각각 철근 이름을 구분하기 위해.
			sFooting.Format("기초%d", footing+1);
			long i = 0; for(i = 0; i < pFooting->m_pArrRebarSupport.GetSize(); i++)
			{
				CRebar *pRB	= pFooting->m_pArrRebarSupport.GetAt(i);
				pRB->m_sDescription.Replace("기초", sFooting);

				CString sFront	= footing == 0 ? "좌측" : "우측";
				CString sBack	= footing == 0 ? "우측" : "좌측";
				pRB->m_sDescription.Replace("전면", sFront);
				pRB->m_sDescription.Replace("후면 ", sBack);					
			}
		}
	}


	// 기초
	for(footing = 0; footing < nCountFooting; footing++)
	{
		CFootingApp *pFooting	= GetFooting(footing);
		if(pFooting)
		{
			pFooting->m_nTypeAddRate.Attach(&m_nTypeAddRate);		// 0 : 직경별, 1 : 주철근,기타철근
			pFooting->m_dAddRateLower.Attach(&m_dAddRateLower);		// 하위 할증률
			pFooting->m_dAddRateUpper.Attach(&m_dAddRateUpper);		// 상위 할증률
			pFooting->m_dAddRateDiaOrg.Attach(&m_dAddRateDiaOrg);	// 직경별일경우 기준 직경

			pFooting->SetDataDefaultRebarJewonShear(footing==0 ? nLastNumShear+1 : -1);

			for(i = 0; i < pFooting->m_pArrRebarShear.GetSize(); i++)
				nLastNumShear	+= pFooting->m_pArrRebarShear.GetAt(i)->IsTrue() ? 1 : 0;

			// 기초가 여러개인데 각각 철근 이름을 구분하기 위해.
			sFooting.Format("기초%d", footing+1);
			long i = 0; for(i = 0; i < pFooting->m_pArrRebarShear.GetSize(); i++)
			{
				CRebar *pRB	= pFooting->m_pArrRebarShear.GetAt(i);
				pRB->m_sDescription.Replace("기초", sFooting);

				if(bLsd)
				{
					if(IsBoxType())
						pRB->m_Fy = GetValueFy(ePartLowerSlab, TRUE);
					else
						pRB->m_Fy = (footing !=0 && footing != nCountFooting-1)? GetValueFy(ePartInFoot, TRUE): GetValueFy(footing == 0? ePartFootStt : ePartFootEnd, TRUE) ; 
				}
				else
				{
					pRB->m_Fy = pFooting->m_Fy;
				}	
			}
		}
	}



	// 기타 철근
	// 기초
	// 측면 철근
	nLastNum	= 0;
	for(footing = 0; footing < nCountFooting; footing++)
	{
		CFootingApp *pFooting	= GetFooting(footing);
		if(pFooting)
		{
			pFooting->m_nTypeAddRate.Attach(&m_nTypeAddRate);		// 0 : 직경별, 1 : 주철근,기타철근
			pFooting->m_dAddRateLower.Attach(&m_dAddRateLower);		// 하위 할증률
			pFooting->m_dAddRateUpper.Attach(&m_dAddRateUpper);		// 상위 할증률
			pFooting->m_dAddRateDiaOrg.Attach(&m_dAddRateDiaOrg);	// 직경별일경우 기준 직경

			pFooting->SetDataDefaultRebarJewonEtc(footing==0 ? nLastNum+1 : -1);
			
			// 기초가 여러개인데 각각 철근 이름을 구분하기 위해.
			sFooting.Format("기초%d", footing+1);
			long i = 0; for(i = 0; i < pFooting->m_pArrRebarEtc.GetSize(); i++)
			{
				CRebar *pRB	= pFooting->m_pArrRebarEtc.GetAt(i);
				pRB->m_sDescription.Replace("기초", sFooting);
			}
		}
	}

	// 브라켓 철근
	//#0031858 직구간의 단면을 가지고 브라켓을 그리면 안된다. 평면에서 표현되는 길이와 단면의 직구간의 길이가 다르기 때문에 브라켓이 다르게 나오게 됨
	GetTvVertSection_Std(0, FALSE, FALSE, FALSE, m_nTypeJongdanForRebar);
	SyncBridgeRebar(FALSE, 1);
	ClearRebarList(3);
	GetMarkRebarEtc(0, FALSE, TRUE, TRUE);
	SetDataDefaultRebarJewon_Bracket_All();
	GetTvVertSection_Std(0, FALSE, FALSE, TRUE, m_nTypeJongdanForRebar);
}

// 기타철근 마크 보내기
// bInput : 입력용인지..? 
// bForBM : 입력용이 아닌경우만 작동(아니라면 집계용인지?, 출력용인지?)
// nType 은 입력받을 때와 집계시에 부위별로 구분하기 위한 Type이며 실제 도면 출력 할때는
// sDescription으로 비교해서 해당 마크를 가져온다.
CString CRcBridgeRebar::GetMarkRebarEtc(long nType, BOOL bInput, BOOL bForBM, BOOL bOnlyInit, CString sDescription, BOOL bGirder)
{
	static long nNum	= 1;
	if(bOnlyInit)
	{
		nNum	= 1;
		return "";
	}
	if(!bInput && !bForBM)
	{
		CString sMark	= _T("");

		CRebar *pRB	= GetRebarEtcByDescription(sDescription, bGirder);
		if(pRB)
		{
			sMark	= pRB->m_sMark;
		}
		
		return sMark;
	}

	CString sMark	= _T("");
	
	// 상부슬래브
	switch(nType)
	{
		// 거더
		case G_REBAR_M_U1 : sMark	= bInput ? "GU" : "G"; break;	// 거더 철근 상면 1단(주철근)
		case G_REBAR_M_U2 : sMark	= bInput ? "GU" : "G"; break;	// 거더 철근 상면 2단(주철근)
		case G_REBAR_M_U3 : sMark	= bInput ? "GU" : "G"; break;	// 거더 철근 상면 3단(주철근)
		case G_REBAR_M_L1 : sMark	= bInput ? "GL" : "G"; break;	// 거더 철근 하면 1단(주철근)
		case G_REBAR_M_L2 : sMark	= bInput ? "GL" : "G"; break;	// 거더 철근 하면 2단(주철근)
		case G_REBAR_M_L3 : sMark	= bInput ? "GL" : "G"; break;	// 거더 철근 하면 3단(주철근)
		case G_REBAR_HORV : sMark	= bInput ? "GS" : "G"; break;	// 거더 철근 측면(수평전단철근)
		case G_REBAR_HORV_I : sMark	= bInput ? "GS" : "G"; break;	// 거더 철근 측면(수평전단철근 내측)
		case G_REBAR_ST : sMark		= bInput ? "GT" : "G"; break;	// 거더 스터럽 철근(수직전단철근)
		case G_REBAR_SUP : sMark	= /*bInput ? "G" : */"G"; break;	// 거더 보강철근(주철근 2단부터 아래에 받치는 철근)
		case BR_REBAR_M : sMark		= bInput ? "BRM" : "BR"; break; // 브라켓 주철근
		case BR_REBAR_S : sMark		= bInput ? "BRS" : "BR"; break; // 브라켓 배력근
		case BR_REBAR_V : sMark		= bInput ? "BRV" : "BR"; break; // 브라켓 전단철근
		case BF_REBAR_M : sMark		= bInput ? "BFM" : "BF"; break; // 부상방지저판 주철근
		case BF_REBAR_S : sMark		= bInput ? "BFS" : "BF"; break; // 부상방지저판 배력근
		case BF_REBAR_V : sMark		= bInput ? "BFV" : "BF"; break; // 부상방지저판 전단철근
		
	}

	if(!bInput)
	{
		sMark	+= COMMA(nNum);
		nNum++;
	}

	return sMark;
}

// 상부슬래브 배력철근 집계(헌치부포함)
// 둔각부 보강 포함
void CRcBridgeRebar::SetDataDefaultRebarJewon_UpperSlab_Support()
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();
	const double dMulti = bLsd? 10 : 1;

	CHgBaseConcStd baseConc;
	CRebarPlacing rb;
	CTwinVectorArray tvArr, tvArrAngStt, tvArrAngEnd, tvArrRAngStt, tvArrRAngEnd;
	CTwinVectorArray tvArrCross, tvArrMid, tvArrLeft, tvArrRight;
	CTwinVectorArray tvArrExpSttLAndR, tvArrExpSttLOrR;
	CTwinVectorArray tvArrExpEndLAndR, tvArrExpEndLOrR;

	double dLenMax(0), dLenMin(0), dLenDiff(0);
	double dCover(0);
	double dRebarSpace	= 0;
// 	double dRateLenPyungSlopAndPlane	= 1.0;	// 편구배 고려된 길이와 평면상의 길이와의 비..

	// 편구배 고려된 길이와 평면상 길이와의 비율을 계산해서 평면상의 길이에 적용하자!!! ///
	GetTvCrossSection(tvArrCross, m_dStationBridgeStt, CDPoint(0, 1), FALSE, FALSE, FALSE, 0, FALSE, FALSE, FALSE, TRUE);
	double dRateLenPyungSlopAndPlane	= tvArrCross.GetLength() / tvArrCross.GetHorLength();
	//////////////////////////////////////////////////////////////////////////////////////////
	
	// 횡단면 상에서 배력근의 좌우측 높이 //////////////////////////
	// 이것이 곳 상부슬래브 배력근 B값이나 C값이 된다.
	double dHeightRebarLeft		= 0;
	double dHeightRebarRight	= 0;
	double dSta	= GetStationSmallestWidthOfUpperSlab();
	GetTvRebarSupport_CrossSection_UpperSlab(tvArrMid, tvArrLeft, tvArrRight, dSta, FALSE, 0, 0, TRUE, TRUE);
	if(tvArrLeft.GetSize() > 0)
	{
		dHeightRebarLeft	= tvArrLeft.GetAt(0).GetLength();
	}
	else if(tvArrMid.GetSize() > 0)
	{
		dHeightRebarLeft	= tvArrMid.GetAt(0).GetLength();
	}
	
	if(tvArrRight.GetSize() > 0)
	{
		dHeightRebarRight	= tvArrRight.GetAt(tvArrRight.GetSize()-1).GetLength();
	}
	else if(tvArrMid.GetSize() > 0)
	{
		dHeightRebarRight	= tvArrMid.GetAt(tvArrMid.GetSize()-1).GetLength();
	}
	BOOL bSameHeight	= Compare(dHeightRebarLeft, dHeightRebarRight, "=");
	//////////////////////////////////////////////////////////////////

	long upper = 0; for(upper = 0; upper < 2; upper++)
	{
		BOOL bUpper		= upper == iUPPER;
		CString sUpdn	= bUpper ? "상면" : "하면";
		long nTypeRebar	= bUpper ? US_REBAR_S_U1 : US_REBAR_S_L1;

		long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
		{
			dCover		= bUpper ? m_dCoverUpper_UpperSlab[dan] : m_dCoverLower_UpperSlab[dan];
			dRebarSpace	= GetCTCRebarSupport_UpperSlabHunch();

			GetTvRebarSupport_Plane_Slab_Std(TRUE, tvArr, tvArrAngStt, tvArrAngEnd, tvArrRAngStt, tvArrRAngEnd, bUpper, dan, 0);
			if(m_bIsExp)
				DivideRebarSupport_Plane_UpperSlabExpSection(tvArr, tvArrExpSttLAndR, tvArrExpSttLOrR, tvArrExpEndLAndR, tvArrExpEndLOrR);

			CPlaceRebarByBlock *pPlace	= &m_placeByBlock_SupportRebar_UpperSlab[upper][dan];
			
			if(bUpper)
			{
				double dCover		= m_dCoverUpper_UpperSlab[0];
				double dRebarSpace	=  GetCTCRebarSupport_Slab(TRUE, bUpper, dan, TRUE);

				// ang == 0 : 기본철근
				// ang == 1 : 시점좌측우측 모두 교차되는 철근
				// ang == 2 : 시점좌측이나 우측 한 곳만 교차되는 철근
				// ang == 3 : 종점좌측우측 모두 교차되는 철근
				// ang == 4 : 시점좌측이나 우측 한 곳만 교차되는 철근
				CTwinVectorArray *pTvArr	= NULL;
				for(long ang = 0; ang < 5; ang++)
				{
					if(!m_bIsExp && ang > 0) break;
					switch(ang)
					{
						case 0: pTvArr	= &tvArr; break;
						case 1: pTvArr	= &tvArrExpSttLAndR; break;
						case 2: pTvArr	= &tvArrExpSttLOrR; break;
						case 3: pTvArr	= &tvArrExpEndLAndR; break;
						case 4: pTvArr	= &tvArrExpEndLOrR; break;
						default: break;
					}
					if(!pTvArr) continue;
					if(pTvArr->GetSize() == 0) continue;

					dLenMax		= pTvArr->GetLengthMax();
					dLenMin		= pTvArr->GetLengthMin();

					// 상부슬래브 상면 배력근 기본철근(사보강시 직방향 철근이나, 선형방향시 나오는 철근)
					CRebar *pRB	= new CRebar;
					pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
					if(ang == 0)
						pRB->m_sDescription.Format("상부슬래브 %s %d단 배력철근", sUpdn, dan+1);
					else
						pRB->m_sDescription.Format("상부슬래브 %s %d단 배력철근%d", sUpdn, dan+1, 5+ang);
					pRB->m_sMark		= GetMarkRebarSupport(nTypeRebar+dan, FALSE, TRUE, FALSE);
					pRB->m_dDia			= pPlace->m_dDia;
					pRB->m_dLengthMax_A	= dLenMax * dRateLenPyungSlopAndPlane;
					pRB->m_dLengthMin_A	= dLenMin * dRateLenPyungSlopAndPlane;
					if(bSameHeight)
					{
						pRB->m_dLengthMax_B	= dHeightRebarLeft;
						pRB->m_nTypeRebar	= 3;
					}
					else
					{
						pRB->m_dLengthMax_B	= dHeightRebarLeft;
						pRB->m_dLengthMax_C	= dHeightRebarRight;
						pRB->m_nTypeRebar	= 4;
					}
					pRB->m_bMainRebar	= FALSE;
					pRB->m_nEa			= pTvArr->GetSize();
					baseConc.OptimizationRebar(pRB);	// 철근 최적화
					SetRebarLsdOptionSlab(pRB->m_pOptionLsd, TRUE, bUpper, FALSE, 0, dan);
					if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
					m_Util.SetLengthRebar(pRB, (m_nSelectJointUpperRange == 0)? JOINT_TENS_UPPER_B:JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
					pRB->m_dRateAdd	= MAKE_RATE;
					AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
				}


				// 상부슬래브 상면 배력근 시점측 철근1(사보강시 시점측 사방향 철근)
				if(tvArrAngStt.GetSize() > 0)
				{
					dLenMax	= tvArrAngStt.GetLengthMax();
					dLenMin	= tvArrAngStt.GetLengthMin();

					CRebar *pRB	= new CRebar;
					pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
					pRB->m_sDescription.Format("상부슬래브 %s %d단 배력철근2", sUpdn, dan+1);
					pRB->m_sMark		= GetMarkRebarSupport(nTypeRebar+dan, FALSE, TRUE, FALSE);
					pRB->m_dDia			= pPlace->m_dDia;
					pRB->m_dLengthMax_A	= dLenMax * dRateLenPyungSlopAndPlane;
					pRB->m_dLengthMin_A	= dLenMin * dRateLenPyungSlopAndPlane;
					if(bSameHeight)
					{
						pRB->m_dLengthMax_B	= dHeightRebarLeft;
						pRB->m_nTypeRebar	= 3;
					}
					else
					{
						pRB->m_dLengthMax_B	= dHeightRebarLeft;
						pRB->m_dLengthMax_C	= dHeightRebarRight;
						pRB->m_nTypeRebar	= 4;
					}
					pRB->m_bMainRebar	= FALSE;
					pRB->m_nEa			= tvArrAngStt.GetSize();
					baseConc.OptimizationRebar(pRB);	// 철근 최적화
					SetRebarLsdOptionSlab(pRB->m_pOptionLsd, TRUE, bUpper, FALSE, 0, dan);
					if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
					m_Util.SetLengthRebar(pRB, (m_nSelectJointUpperRange == 0)? JOINT_TENS_UPPER_B:JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
					pRB->m_dRateAdd	= MAKE_RATE;
					AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
				}

				
				// 상부슬래브 상면 배력근 종점측 철근1(사보강시 종점측 사방향 철근)
				if(tvArrAngEnd.GetSize() > 0)
				{
					dLenMax	= tvArrAngEnd.GetLengthMax();
					dLenMin	= tvArrAngEnd.GetLengthMin();

					CRebar *pRB	= new CRebar;
					pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
					pRB->m_sDescription.Format("상부슬래브 %s %d단 배력철근3", sUpdn, dan+1);
					pRB->m_sMark		= GetMarkRebarSupport(nTypeRebar+dan, FALSE, TRUE, FALSE);
					pRB->m_dDia			= pPlace->m_dDia;
					pRB->m_dLengthMax_A	= dLenMax * dRateLenPyungSlopAndPlane;
					pRB->m_dLengthMin_A	= dLenMin * dRateLenPyungSlopAndPlane;
					if(bSameHeight)
					{
						pRB->m_dLengthMax_B	= dHeightRebarLeft;
						pRB->m_nTypeRebar	= 3;
					}
					else
					{
						pRB->m_dLengthMax_B	= dHeightRebarLeft;
						pRB->m_dLengthMax_C	= dHeightRebarRight;
						pRB->m_nTypeRebar	= 4;
					}
					pRB->m_nEa			= tvArrAngEnd.GetSize();
					baseConc.OptimizationRebar(pRB);	// 철근 최적화
					SetRebarLsdOptionSlab(pRB->m_pOptionLsd, TRUE, bUpper, FALSE, 0, dan);
					if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
					m_Util.SetLengthRebar(pRB, (m_nSelectJointUpperRange == 0)? JOINT_TENS_UPPER_B:JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
					pRB->m_dRateAdd	= MAKE_RATE;
					AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
				}

				// 상부슬래브 상면 배력근 시점측 철근2(사보강시 시점측 직방향 철근)
				if(tvArrRAngStt.GetSize() > 0)
				{
					dLenMax	= tvArrRAngStt.GetLengthMax();
					dLenMin	= tvArrRAngStt.GetLengthMin();

					CRebar *pRB	= new CRebar;
					pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
					pRB->m_sDescription.Format("상부슬래브 %s %d단 배력철근4", sUpdn, dan+1);
					pRB->m_sMark		= GetMarkRebarSupport(nTypeRebar+dan, FALSE, TRUE, FALSE);
					pRB->m_dDia			= pPlace->m_dDia;
					pRB->m_dLengthMax_A	= dLenMax * dRateLenPyungSlopAndPlane;
					pRB->m_dLengthMin_A	= dLenMin * dRateLenPyungSlopAndPlane;
					if(bSameHeight)
					{
						pRB->m_dLengthMax_B	= dHeightRebarLeft;
						pRB->m_nTypeRebar	= 3;
					}
					else
					{
						pRB->m_dLengthMax_B	= dHeightRebarLeft;
						pRB->m_dLengthMax_C	= dHeightRebarRight;
						pRB->m_nTypeRebar	= 4;
					}
					pRB->m_nEa			= tvArrRAngStt.GetSize();
					baseConc.OptimizationRebar(pRB);	// 철근 최적화
					SetRebarLsdOptionSlab(pRB->m_pOptionLsd, TRUE, bUpper, FALSE, 0, dan);
					if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
					m_Util.SetLengthRebar(pRB, (m_nSelectJointUpperRange == 0)? JOINT_TENS_UPPER_B:JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
					pRB->m_dRateAdd	= MAKE_RATE;
					AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
				}

				// 상부슬래브 상면 배력근 종점측 철근2(사보강시 종점측 직방향 철근)
				if(tvArrRAngStt.GetSize() > 0)
				{
					dLenMax	= tvArrRAngEnd.GetLengthMax();
					dLenMin	= tvArrRAngEnd.GetLengthMin();

					CRebar *pRB	= new CRebar;
					pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
					pRB->m_sDescription.Format("상부슬래브 %s %d단 배력철근5", sUpdn, dan+1);
					pRB->m_sMark		= GetMarkRebarSupport(nTypeRebar+dan, FALSE, TRUE, FALSE);
					pRB->m_dDia			= pPlace->m_dDia;
					pRB->m_dLengthMax_A	= dLenMax * dRateLenPyungSlopAndPlane;
					pRB->m_dLengthMin_A	= dLenMin * dRateLenPyungSlopAndPlane;
					if(bSameHeight)
					{
						pRB->m_dLengthMax_B	= dHeightRebarLeft;
						pRB->m_nTypeRebar	= 3;
					}
					else
					{
						pRB->m_dLengthMax_B	= dHeightRebarLeft;
						pRB->m_dLengthMax_C	= dHeightRebarRight;
						pRB->m_nTypeRebar	= 4;
					}
					pRB->m_bMainRebar	= FALSE;
					pRB->m_nEa			= tvArrRAngEnd.GetSize();
					baseConc.OptimizationRebar(pRB);	// 철근 최적화
					SetRebarLsdOptionSlab(pRB->m_pOptionLsd, TRUE, bUpper, FALSE, 0, dan);
					if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
					m_Util.SetLengthRebar(pRB, (m_nSelectJointUpperRange == 0)? JOINT_TENS_UPPER_B:JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
					pRB->m_dRateAdd	= MAKE_RATE;
					AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
				}
			}
			else
			{
				// 하면 desc에 붙은 배력철근뒤의 숫자는 1,2,3으로 하면철근 좌측캔티레버좌 : 1, 중간 : 2, 우 : 3으로 나누기 위해 구분함.
				double dSta	= GetStationSmallestWidthOfUpperSlab();
				GetTvRebarSupport_CrossSection_UpperSlab(tvArrMid, tvArrLeft, tvArrRight, dSta, FALSE, dan, 0,TRUE, TRUE, TRUE, 1, FALSE);

				// i == 0 : tvArrLeft, 1 : tvArrMid, 2 : tvArrRight
				// tvArrMid는 철근타입 파악의 정확성을 위해서 철근의 하부쪽에 있는 것들을 수평선으로 변경해준다.
				double dLen	= 0;
				long nIdx	= -1;
				CTwinVector tvLower, tv;
				long i = 0; for(i = 0; i < tvArrMid.GetSize(); i++)
				{
					tv	= tvArrMid.GetAt(i);
					if(tv.m_sInfo.Find("슬래브하부", 0) != -1)
					{
						if(nIdx == -1)
						{
							nIdx = i;
							tvLower	 = tv;
						}
						dLen += tvArrMid.GetAt(i).GetLength();
						tvArrMid.RemoveAt(i);
						i--;
					}
				}

				if(nIdx > -1)
				{
					tvLower.m_v2 = tvLower.m_v1 + CDPoint(dLen, 0);
					tvArrMid.InsertAt(nIdx, tvLower);

					//#0029964 - tvArrMid 철근이 끊겨져 있어 철근제원이 정상적으로 표현되어 있지 않았다. 슬래브 하부가 경사가 되어 있는데 이것을 강제적으로 직선으로 표현하다보니 슬래브우측면 횡단의 CTwinVector가 떨어져있게 됨
					tv	= tvArrMid.GetAt(tvArrMid.GetSize() - 1);

					if(tv.m_sInfo.Find("슬래브우측면 횡단", 0) != -1)
					{
						if(ComparePt(tvLower.m_v2, tv.m_v1, "=", 0.001) == FALSE)
						{
							//슬래브우측면 횡단이 90도가 되지않아 상세를 찾지 못함... (90.02도정도...)
							CDPoint xyMove = (CDPoint)tvLower.m_v2 - (CDPoint)tv.m_v1;

							CRebarPlacing rp;

							tv.m_v1 += xyMove;
							tv.m_v2 += xyMove;

							//90도로 강제 조정
							double dAng = tv.GetXyDir().GetAngleDegree();

							if(dAng != 90 && dAng != 270)
							{
								tv.m_v2.x = tv.m_v1.x;
							}

							tvArrMid.SetAt(tvArrMid.GetSize() - 1, tv);
						}
					}
				}

				// ang == 0 : 기본철근
				// ang == 1 : 시점좌측우측 모두 교차되는 철근
				// ang == 2 : 시점좌측이나 우측 한 곳만 교차되는 철근
				// ang == 3 : 종점좌측우측 모두 교차되는 철근
				// ang == 4 : 시점좌측이나 우측 한 곳만 교차되는 철근
				CTwinVectorArray *pTvArr	= NULL;

				for(long ang = 0; ang < 5; ang++)
				{
					if(!m_bIsExp && ang > 0) break;
					switch(ang)
					{
						case 0: pTvArr	= &tvArr; break;
						case 1: pTvArr	= &tvArrExpSttLAndR; break;
						case 2: pTvArr	= &tvArrExpSttLOrR; break;
						case 3: pTvArr	= &tvArrExpEndLAndR; break;
						case 4: pTvArr	= &tvArrExpEndLOrR; break;
						default: break;
					}
					if(!pTvArr) continue;
					if(pTvArr->GetSize() == 0) continue;

					double dLenDiffExpAndNormal	= pTvArr->GetLengthMax() - tvArr.GetLengthMax();	// 일반과 가각과의 길이차이
					dLenDiff	= pTvArr->GetLengthMax() - pTvArr->GetLengthMin();	// 평면상에서 최대와 최소의 차이

					// o == 0, 2 : 캔티레버일때 좌우에 하나씩 뻗는 철근.
					for(i = 0; i < 3; i++)
					{
						// 캔티레버부의 철근은 한번에 집계한다.(어짜피 길이가 모두 같을 테니까)
						if(ang > 0 && (i == 0 || i == 2)) continue;

						CTwinVectorArray tvArrTmp;
						switch(i)
						{
							case 0 : tvArrTmp = tvArrLeft; break;
							case 1 : tvArrTmp = tvArrMid; break;
							case 2 : tvArrTmp = tvArrRight; break;
							default : break;
						}
						if(tvArrTmp.GetSize() == 0) continue;

						CRebar *pRB	= new CRebar;
						pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
						CRebarType rt;
						
						rt.SetRebar(tvArrTmp, FALSE);
						rt.SetRB(pRB);
						baseConc.OptimizationRebar(pRB);
						
						//m_Util.GetRebarType(pRB, tvArrTmp);
						// mid일때 가장 긴 값은 최소 최대 값이 생길 수 있다.
						if(i == 1)
						{
							double dMax	= max(pRB->m_dLengthMax_A, max(pRB->m_dLengthMax_B, max(pRB->m_dLengthMax_C, pRB->m_dLengthMax_D)));
							if(Compare(dMax, pRB->m_dLengthMax_A, "=")) 
							{
								pRB->m_dLengthMax_A	+= dLenDiffExpAndNormal;
								pRB->m_dLengthMin_A = pRB->m_dLengthMax_A - dLenDiff;
							}
							else if(Compare(dMax, pRB->m_dLengthMax_B, "=")) 
							{
								pRB->m_dLengthMax_B += dLenDiffExpAndNormal;
								pRB->m_dLengthMin_B = pRB->m_dLengthMax_B - dLenDiff;
							}
							else if(Compare(dMax, pRB->m_dLengthMax_C, "=")) 
							{
								pRB->m_dLengthMax_C += dLenDiffExpAndNormal;
								pRB->m_dLengthMin_C = pRB->m_dLengthMax_C - dLenDiff;
							}
							else if(Compare(dMax, pRB->m_dLengthMax_D, "=")) 
							{
								pRB->m_dLengthMax_D += dLenDiffExpAndNormal;
								pRB->m_dLengthMin_D = pRB->m_dLengthMax_D - dLenDiff;
							}
						}
						if(ang == 0)
							pRB->m_sDescription.Format("상부슬래브 %s %d단 배력철근%d", sUpdn, dan+1, i+1);
						else
							pRB->m_sDescription.Format("상부슬래브 %s %d단 배력철근2_%d", sUpdn, dan+1, 5+ang);
						pRB->m_dDia			= pPlace->m_dDia;
						pRB->m_sMark.Format("%s", GetMarkRebarSupport(nTypeRebar+dan, FALSE, TRUE, FALSE));
						pRB->m_bMainRebar	= FALSE;
						pRB->m_nEa			= (i == 1) ? pTvArr->GetSize() : 
														tvArr.GetSize() + tvArrAngStt.GetSize() + 
														tvArrAngEnd.GetSize() + tvArrExpSttLAndR.GetSize() +
														tvArrExpSttLOrR.GetSize() + tvArrExpEndLAndR.GetSize() + 
														tvArrExpEndLOrR.GetSize();
						baseConc.OptimizationRebar(pRB);	// 철근 최적화
						SetRebarLsdOptionSlab(pRB->m_pOptionLsd, TRUE, bUpper, FALSE, 0, dan);
						if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
						m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
						pRB->m_dRateAdd	= MAKE_RATE;

						AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
					}
				}


				dLenDiff	= tvArr.GetLengthMax() - tvArr.GetLengthMin();

				dLenMax	= pTvArr->GetLengthMax();
				dLenMin	= pTvArr->GetLengthMin();
				// 상부슬래브 하면 배력근 시점측 철근1(사보강시 시점측 사방향 철근)
				if(tvArrAngStt.GetSize() > 0)
				{
					double dMaxTmp	= tvArrAngStt.GetLengthMax();
					double dMinTmp	= tvArrAngStt.GetLengthMin();

					// (ARCBRIDGE-3570) 하부슬래브는 슬래브 좌우의 캔틸래버부 형상 때문에 평면에서 뽑은 길이를 직접 쓸수 없다.
					// 그래서 횡단에서 길이를 뽑고 횡단 길이와 평면 길이의 차이를 더이해주는 방식인데 
					// 횡단 적용좌표인 tvArrMid의 위치와 조정을 위한 평면 좌표인tvArr의 위치가 일치하지 않는다.
					// dLenMax를 횡단의 수평길이를 쓰고 dLenMin은 사용하지 않으며 dMinTmp를 쓴다.

					dLenMax = tvArrMid.GetHorLength();
					dLenDiff	= dMaxTmp - dMinTmp;
					dLenMin = dLenMax - dLenDiff;

					CRebar *pRB	= new CRebar;
					pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
					CRebarType rt;
					rt.SetRebar(tvArrMid, FALSE);
					rt.SetRB(pRB);
					baseConc.OptimizationRebar(pRB);
					//m_Util.GetRebarType(pRB, tvArrMid);
					
					double dMax	= max(pRB->m_dLengthMax_A, max(pRB->m_dLengthMax_B, max(pRB->m_dLengthMax_C, pRB->m_dLengthMax_D)));
					if(Compare(dMax, pRB->m_dLengthMax_A, "=")) pRB->m_dLengthMin_A = pRB->m_dLengthMax_A - dLenDiff;
					else if(Compare(dMax, pRB->m_dLengthMax_B, "=")) pRB->m_dLengthMin_B = pRB->m_dLengthMax_B - dLenDiff;
					else if(Compare(dMax, pRB->m_dLengthMax_C, "=")) pRB->m_dLengthMin_C = pRB->m_dLengthMax_C - dLenDiff;
					else if(Compare(dMax, pRB->m_dLengthMax_D, "=")) pRB->m_dLengthMin_D = pRB->m_dLengthMax_D - dLenDiff;

					if(pRB->m_nTypeRebar == 87)
					{
						pRB->m_dLengthMax_B	= pRB->m_dLengthMax_B + (dMaxTmp - dLenMax);
						
						if(!Compare(pRB->m_dLengthMin_B, 0.0, "="))
							pRB->m_dLengthMin_B = pRB->m_dLengthMin_B + (dMinTmp - dLenMin);
					}
					else
					{
						pRB->m_dLengthMax_A	= pRB->m_dLengthMax_A + (dMaxTmp - dLenMax);
						
						if(!Compare(pRB->m_dLengthMin_A, 0.0, "="))
							pRB->m_dLengthMin_A = pRB->m_dLengthMin_A + (dMinTmp - dLenMin);
					}

					// 사방향 철근임(R에도 사거리 적용함)
					if(pRB->m_nTypeRebar == 7)
					{
						CDPoint vAng	= GetAngleJijum(0);
						pRB->m_dLengthMax_B	= pRB->m_dLengthMax_B/vAng.y;
						pRB->m_dLengthMin_B	= pRB->m_dLengthMin_B/vAng.y;

						double dR	= m_dRE1[0]-m_dCoverLower_UpperSlab[0];
						pRB->m_dLengthMax_A -= ((dR / vAng.y) - dR) * 2;
						if(!Compare(pRB->m_dLengthMin_A, 0.0, "="))
							pRB->m_dLengthMin_A	-= ((dR / vAng.y) - dR) * 2;
					}

					pRB->m_sDescription.Format("상부슬래브 %s %d단 배력철근2_2", sUpdn, dan+1);
					pRB->m_dDia			= pPlace->m_dDia;
					pRB->m_sMark.Format("%s", GetMarkRebarSupport(nTypeRebar+dan, FALSE, TRUE, FALSE));
					pRB->m_bMainRebar	= FALSE;
					pRB->m_nEa			= tvArrAngStt.GetSize();
					baseConc.OptimizationRebar(pRB);	// 철근 최적화
					SetRebarLsdOptionSlab(pRB->m_pOptionLsd, TRUE, bUpper, FALSE, 0, dan);
					if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
					m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
					pRB->m_dRateAdd	= MAKE_RATE;
					AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
				}

				// 상부슬래브 하면 배력근 종점측 철근1(사보강시 종점측 사방향 철근)
				if(tvArrAngEnd.GetSize() > 0)
				{
					double dMaxTmp	= tvArrAngEnd.GetLengthMax();
					double dMinTmp	= tvArrAngEnd.GetLengthMin();

					// (ARCBRIDGE-3570) 
					dLenMax = tvArrMid.GetHorLength();
					dLenDiff	= dMaxTmp - dMinTmp;
					dLenMin = dLenMax - dLenDiff;

					CRebar *pRB	= new CRebar;
					pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
					CRebarType rt;
					rt.SetRebar(tvArrMid, FALSE);
					rt.SetRB(pRB);
					baseConc.OptimizationRebar(pRB);
					//m_Util.GetRebarType(pRB, tvArrMid);
					
					double dMax	= max(pRB->m_dLengthMax_A, max(pRB->m_dLengthMax_B, max(pRB->m_dLengthMax_C, pRB->m_dLengthMax_D)));
					if(Compare(dMax, pRB->m_dLengthMax_A, "=")) pRB->m_dLengthMin_A = pRB->m_dLengthMax_A - dLenDiff;
					else if(Compare(dMax, pRB->m_dLengthMax_B, "=")) pRB->m_dLengthMin_B = pRB->m_dLengthMax_B - dLenDiff;
					else if(Compare(dMax, pRB->m_dLengthMax_C, "=")) pRB->m_dLengthMin_C = pRB->m_dLengthMax_C - dLenDiff;
					else if(Compare(dMax, pRB->m_dLengthMax_D, "=")) pRB->m_dLengthMin_D = pRB->m_dLengthMax_D - dLenDiff;

					if(pRB->m_nTypeRebar == 87)
					{
						pRB->m_dLengthMax_B	= pRB->m_dLengthMax_B + (dMaxTmp - dLenMax);
						
						if(!Compare(pRB->m_dLengthMin_B, 0.0, "="))
							pRB->m_dLengthMin_B = pRB->m_dLengthMin_B + (dMinTmp - dLenMin);
					}
					else
					{
						pRB->m_dLengthMax_A	= pRB->m_dLengthMax_A + (dMaxTmp - dLenMax);
						
						if(!Compare(pRB->m_dLengthMin_A, 0.0, "="))
							pRB->m_dLengthMin_A = pRB->m_dLengthMin_A + (dMinTmp - dLenMin);
					}

					// 사방향 철근임(R에도 사거리 적용함)
					if(pRB->m_nTypeRebar == 7)
					{
						CDPoint vAng	= GetAngleJijum(m_nQtyJigan);
						pRB->m_dLengthMax_B	= pRB->m_dLengthMax_B/vAng.y;
						pRB->m_dLengthMin_B	= pRB->m_dLengthMin_B/vAng.y;

						double dR	= m_dRE1[0]-m_dCoverLower_UpperSlab[0];
						pRB->m_dLengthMax_A -= ((dR / vAng.y) - dR) * 2;
						if(!Compare(pRB->m_dLengthMin_A, 0.0, "="))
							pRB->m_dLengthMin_A	-= ((dR / vAng.y) - dR) * 2;
					}

					pRB->m_sDescription.Format("상부슬래브 %s %d단 배력철근2_3", sUpdn, dan+1);
					pRB->m_dDia			= pPlace->m_dDia;
					pRB->m_sMark.Format("%s", GetMarkRebarSupport(nTypeRebar+dan, FALSE, TRUE, FALSE));
					pRB->m_bMainRebar	= FALSE;
					pRB->m_nEa			= tvArrAngEnd.GetSize();
					baseConc.OptimizationRebar(pRB);	// 철근 최적화
					SetRebarLsdOptionSlab(pRB->m_pOptionLsd, TRUE, bUpper, FALSE, 0, dan);
					if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
					m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
					pRB->m_dRateAdd	= MAKE_RATE;
					AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
				}
				
				// 상부슬래브 하면 배력근 시점측 철근2(사보강시 시점측 직방향 철근)
				if(tvArrRAngStt.GetSize() > 0)
				{
					double dMaxTmp	= tvArrRAngStt.GetLengthMax();
					double dMinTmp	= tvArrRAngStt.GetLengthMin();

					// (ARCBRIDGE-3570) 
					dLenMax = tvArrMid.GetHorLength();
					dLenDiff	= dMaxTmp - dMinTmp;
					dLenMin = dLenMax - dLenDiff;

					CRebar *pRB	= new CRebar;
					pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
					CRebarType rt;
					rt.SetRebar(tvArrMid, FALSE);
					rt.SetRB(pRB);
					baseConc.OptimizationRebar(pRB);
					//m_Util.GetRebarType(pRB, tvArrMid);
					
					double dMax	= max(pRB->m_dLengthMax_A, max(pRB->m_dLengthMax_B, max(pRB->m_dLengthMax_C, pRB->m_dLengthMax_D)));
					if(Compare(dMax, pRB->m_dLengthMax_A, "=")) pRB->m_dLengthMin_A = pRB->m_dLengthMax_A - dLenDiff;
					else if(Compare(dMax, pRB->m_dLengthMax_B, "=")) pRB->m_dLengthMin_B = pRB->m_dLengthMax_B - dLenDiff;
					else if(Compare(dMax, pRB->m_dLengthMax_C, "=")) pRB->m_dLengthMin_C = pRB->m_dLengthMax_C - dLenDiff;
					else if(Compare(dMax, pRB->m_dLengthMax_D, "=")) pRB->m_dLengthMin_D = pRB->m_dLengthMax_D - dLenDiff;

					if(pRB->m_nTypeRebar == 87)
					{
						pRB->m_dLengthMax_B	= pRB->m_dLengthMax_B + (dMaxTmp - dLenMax);

						if(!Compare(pRB->m_dLengthMin_B, 0.0, "="))
							pRB->m_dLengthMin_B = pRB->m_dLengthMin_B + (dMinTmp - dLenMin);
					}
					else
					{
						pRB->m_dLengthMax_A	= pRB->m_dLengthMax_A + (dMaxTmp - dLenMax);

						if(!Compare(pRB->m_dLengthMin_A, 0.0, "="))
							pRB->m_dLengthMin_A = pRB->m_dLengthMin_A + (dMinTmp - dLenMin);
					}

					pRB->m_sDescription.Format("상부슬래브 %s %d단 배력철근2_4", sUpdn, dan+1);
					pRB->m_dDia			= pPlace->m_dDia;
					pRB->m_sMark.Format("%s", GetMarkRebarSupport(nTypeRebar+dan, FALSE, TRUE, FALSE));
					pRB->m_bMainRebar	= FALSE;
					pRB->m_nEa			= tvArrRAngStt.GetSize();
					baseConc.OptimizationRebar(pRB);	// 철근 최적화
					SetRebarLsdOptionSlab(pRB->m_pOptionLsd, TRUE, bUpper, FALSE, 0, dan);
					if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
					m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
					pRB->m_dRateAdd	= MAKE_RATE;
					AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
				}

				// 상부슬래브 하면 배력근 종점측 철근2(사보강시 종점측 직방향 철근)
				if(tvArrRAngEnd.GetSize() > 0)
				{
					double dMaxTmp	= tvArrRAngEnd.GetLengthMax();
					double dMinTmp	= tvArrRAngEnd.GetLengthMin();

					// (ARCBRIDGE-3570) 
					dLenMax = tvArrMid.GetHorLength();
					dLenDiff	= dMaxTmp - dMinTmp;
					dLenMin = dLenMax - dLenDiff;

					CRebar *pRB	= new CRebar;
					pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
					CRebarType rt;
					rt.SetRebar(tvArrMid, FALSE);
					rt.SetRB(pRB);
					baseConc.OptimizationRebar(pRB);
					//m_Util.GetRebarType(pRB, tvArrMid);
					
					double dMax	= max(pRB->m_dLengthMax_A, max(pRB->m_dLengthMax_B, max(pRB->m_dLengthMax_C, pRB->m_dLengthMax_D)));
					if(Compare(dMax, pRB->m_dLengthMax_A, "=")) pRB->m_dLengthMin_A = pRB->m_dLengthMax_A - dLenDiff;
					else if(Compare(dMax, pRB->m_dLengthMax_B, "=")) pRB->m_dLengthMin_B = pRB->m_dLengthMax_B - dLenDiff;
					else if(Compare(dMax, pRB->m_dLengthMax_C, "=")) pRB->m_dLengthMin_C = pRB->m_dLengthMax_C - dLenDiff;
					else if(Compare(dMax, pRB->m_dLengthMax_D, "=")) pRB->m_dLengthMin_D = pRB->m_dLengthMax_D - dLenDiff;
					if(pRB->m_nTypeRebar == 87)
					{
						pRB->m_dLengthMax_B	= pRB->m_dLengthMax_B + (dMaxTmp - dLenMax);

						if(!Compare(pRB->m_dLengthMin_B, 0.0, "="))
							pRB->m_dLengthMin_B = pRB->m_dLengthMin_B + (dMinTmp - dLenMin);
					}
					else
					{
						pRB->m_dLengthMax_A	= pRB->m_dLengthMax_A + (dMaxTmp - dLenMax);

						if(!Compare(pRB->m_dLengthMin_A, 0.0, "="))
							pRB->m_dLengthMin_A = pRB->m_dLengthMin_A + (dMinTmp - dLenMin);
					}

					pRB->m_sDescription.Format("상부슬래브 %s %d단 배력철근2_5", sUpdn, dan+1);
					pRB->m_dDia			= pPlace->m_dDia;
					pRB->m_sMark.Format("%s", GetMarkRebarSupport(nTypeRebar+dan, FALSE, TRUE, FALSE));
					pRB->m_bMainRebar	= FALSE;
					pRB->m_nEa			= tvArrRAngEnd.GetSize();
					baseConc.OptimizationRebar(pRB);	// 철근 최적화
					SetRebarLsdOptionSlab(pRB->m_pOptionLsd, TRUE, bUpper, FALSE, 0, dan);
					if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
					m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
					pRB->m_dRateAdd	= MAKE_RATE;
					AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
				}

				// 하부인 경우 헌치부도 포함된다.
				if(dan == 0)
				{
					BOOL bIsHunch	= FALSE;
					// 헌치가 있는 sta 구함.
					double dSta	= m_dStationBridgeStt;
					long j = 0; for(j = 0; j <= m_nQtyJigan; j++)
					{
						if(IsHunch(j))
						{
							bIsHunch	= TRUE;
							dSta	= GetStationOnJijum(j);
						}

					}
					if(!bIsHunch) continue;


					GetTvRebarSupport_CrossSection_UpperSlabHunch(tvArrMid, dSta, dan, 0, TRUE, TRUE, TRUE);
					GetTvRebarSupport_Plane_SlabHunch(tvArr, TRUE, 0, -1);

					if(tvArr.GetSize() > 0)
					{
						double dMax	= tvArr.GetLengthMax();
						double dMin	= tvArr.GetLengthMin();

						// 각 지점별로 헌치의 최대 높이와 최소 높이를 구함.
						dLenMax	= 0;
						dLenMin	= 0;
						for(long nJ = 0; nJ < GetCountJijum(); nJ++)
						{
							if(IsHunch(nJ))
							{
								if(dLenMax==0)
								{
									dLenMax	= GetHeightHunchByJijum(nJ);
									dLenMin	= GetHeightHunchByJijum(nJ);
								}
								else
								{
									dLenMax	= max(GetHeightHunchByJijum(nJ), dLenMax);
									dLenMin	= min(GetHeightHunchByJijum(nJ), dLenMin);
								}
							}
						}
						
						CRebar *pRB	= new CRebar;
						pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
						pRB->m_nTypeRebar	= 3;
						pRB->m_dLengthMax_A	= dMax * dRateLenPyungSlopAndPlane;
						pRB->m_dLengthMin_A	= dMin * dRateLenPyungSlopAndPlane;
						pRB->m_dLengthMax_B	= dLenMax;
						pRB->m_dLengthMin_B	= dLenMin;
						pRB->m_sDescription.Format("상부슬래브 헌치부 배력철근");
						pRB->m_dDia			= pPlace->m_dDia;
						pRB->m_sMark.Format("%s", GetMarkRebarSupport(nTypeRebar+dan, FALSE, TRUE, FALSE));
						pRB->m_bMainRebar	= FALSE;
						pRB->m_nEa			= tvArr.GetSize();
						baseConc.OptimizationRebar(pRB);	// 철근 최적화
						SetRebarLsdOptionSlab(pRB->m_pOptionLsd, TRUE, bUpper, FALSE, 0, dan);
						if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
						m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
						pRB->m_dRateAdd	= MAKE_RATE;
						AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
					}
				}
			}
		}
	}

	// 상부슬래브 둔각부 보강 배력근
	SetDataDefaultRebarJewon_Slab_ObtuseSupportRebar(TRUE);
}

// serialize를 한뒤 혹시나 flag나 버전업 등의 이유로 올바르지 못한 데이타가 들어오면 
// 에러 메시지를 보낸뒤, 초기화를 해서라도 바로 잡을수 있는건 바로 잡아 준다.
// 특히 철근 집계같은거..
void CRcBridgeRebar::CheckSerialize()
{
}

// 해당부위 철근 삭제.
// nType 
// 0 : 주철근
// 1 : 배력철근
// 2 : 전단철근
// 3 : 기타철근
// 4 : 보(거더)철근
void CRcBridgeRebar::ClearRebarList(long nType)
{
	CHgBaseConcStd baseConc;
	if(nType == 0)
	{
	}
	else if(nType == 1)
	{
		// 배력철근
		baseConc.ClearRebarJewon(&m_pArrRebarSupport, TRUE);
	}
	else if(nType == 2)
	{
		// 전단 철근
		baseConc.ClearRebarJewon(&m_pArrRebarShear, TRUE);
	}
	else if(nType == 3)
	{
		// 배력철근
		baseConc.ClearRebarJewon(&m_pArrRebarEtc, TRUE);
	}
	else if(nType == 4)
	{
		baseConc.ClearRebarJewon(&m_pArrRebarGirder, TRUE);
	}
}

// 외측벽체 배력철근 집계 권고안. 
void CRcBridgeRebar::SetDataDefaultRebarJewon_OutWall_Support()
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();
	const double dMulti = bLsd? 10 : 1;

	CHgBaseConcStd baseConc;
	CTwinVectorArray tvArr, tvArrAngle, tvArrAngleAdd;
	double dLenMax(0), dLenMin(0);

	double dCover(0);
	double dRebarSpace	= 0;

	long stt = 0; for(stt = 0; stt < 2; stt++)
	{
		BOOL bStt	= stt == iSTT;
		if(!IsOutWall(bStt)) continue;

		CString sStt	= bStt ? "시점측벽체" : "종점측벽체";

		for(long inner = 0; inner < 2; inner++)
		{
			BOOL bInner		= inner == iINNER;
			CString sInner	= bInner ? "내측" : "외측";
			long nTypeRebar	= bInner ? (bStt ? SW_REBAR_S_I1 : EW_REBAR_S_I1) : (bStt ? SW_REBAR_S_O1 : EW_REBAR_S_O1);

			long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
			{
				dCover		= m_dCoverWallOut[dan];
				dRebarSpace	= GetCTCRebarSupport_OutWall(bStt, bInner, dan, TRUE);

				CWallApp wall;
				MakeWallByOutWall(wall, bStt, TRUE);
				// 가각부 처리
				double dWidthLeftExp	= GetWidthDiffSlabActOrgAndGagak(bStt, TRUE, bInner);
				double dWidthRightExp	= GetWidthDiffSlabActOrgAndGagak(bStt, FALSE, bInner);
				if(m_bIsExp)
				{
					wall.m_dWidthExp[iLEFT]		= bStt ? dWidthRightExp : dWidthLeftExp;
					wall.m_dWidthExp[iRIGHT]	= bStt ? dWidthLeftExp : dWidthRightExp;
				}
				
				wall.GetTvRebarSupport_Side(tvArr, tvArrAngle, tvArrAngleAdd, bStt ? (bInner ? FALSE : TRUE) : (bInner ? TRUE : FALSE), dan);
				
				CPlaceRebarByBlock *pPlace	= &m_placeByBlock_SupportRebar_OutWall[stt][inner][dan];
				dLenMax	= tvArr.GetLengthMax();
				dLenMin	= tvArr.GetLengthMin();
				if(tvArr.GetSize() == 0 && tvArrAngle.GetSize() == 0 && tvArrAngleAdd.GetSize() == 0) continue;

				CRebar *pRB;
				CString sMarkLast	= GetMarkRebarSupport(nTypeRebar+dan, FALSE, TRUE, FALSE);
				if(tvArr.GetSize() > 0)
				{
					pRB= new CRebar;
					pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
					pRB->m_sDescription.Format("%s %s %d단 배력철근", sStt, sInner, dan+1);
					pRB->m_sMark		= sMarkLast;
					pRB->m_dDia			= pPlace->m_dDia;
					pRB->m_dLengthMax_A	= dLenMax;
					pRB->m_dLengthMin_A	= dLenMin;
					pRB->m_nTypeRebar	= 1;
					pRB->m_bMainRebar	= FALSE;
					pRB->m_nEa			= tvArr.GetSize();
					baseConc.OptimizationRebar(pRB);	// 철근 최적화
					SetRebarLsdOptionOutWall(pRB->m_pOptionLsd, bStt, bInner, FALSE, 0, dan);
					if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
					m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
					pRB->m_dRateAdd	= MAKE_RATE;
					AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
				}

				// 꺽이는 철근
				for(long add = 0; add < 2; add++)
				{
					CTwinVectorArray *pTvArr = add == 0 ? &tvArrAngle : &tvArrAngleAdd;
					long nCount	= 0;
					dLenMax	= 0;
					dLenMin	= 0;
					CString sInfo	= _T("");
					CTwinVector tv;
					CTwinVectorArray tvArrRebar;
					long i = 0; for(i = 0; i < pTvArr->GetSize(); i++)
					{
						tv	= pTvArr->GetAt(i);

						tvArrRebar.RemoveAll();
						tvArrRebar.Add(tv);
						long j = 0; for(j = i+1; j < pTvArr->GetSize(); j++)
						{
							if(tv.m_sInfo == pTvArr->GetAt(j).m_sInfo)
							{
								tvArrRebar.Add(pTvArr->GetAt(j));
								i++;
							}
							else
								break;
						}

						nCount++;
						if(dLenMax == 0 && dLenMin == 0)
						{
							dLenMax	= tvArrRebar.GetLength();
							dLenMin	= tvArrRebar.GetLength();
						}
						else
						{
							dLenMax	= max(dLenMax, tvArrRebar.GetLength());
							dLenMin	= min(dLenMin, tvArrRebar.GetLength());
						}
					}

					CString sMark	= sMarkLast;
					pRB	= new CRebar;
					pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
					pRB->m_sDescription.Format("%s %s %d단 배력철근%d", sStt, sInner, dan+1, 2+add);
					pRB->m_sMark.Format("%s-%d", sMark, 1+add);
					pRB->m_dDia			= pPlace->m_dDia;
					pRB->m_dLengthMax_A	= dLenMax;
					pRB->m_dLengthMin_A	= dLenMin;
					pRB->m_nTypeRebar	= 1;
					pRB->m_bMainRebar	= FALSE;
					pRB->m_nEa			= nCount;
					baseConc.OptimizationRebar(pRB);	// 철근 최적화
					SetRebarLsdOptionOutWall(pRB->m_pOptionLsd, bStt, bInner, FALSE, 0, dan);
					if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
					m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
					pRB->m_dRateAdd	= MAKE_RATE;
					AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
				}
			}
		}

		// 외측벽체 헌치부 배력근
		if(IsOutWallHunch(bStt))
		{
			GetTvRebarSupport_CrossSection_OutWallHunch(tvArr, bStt);
			long nSize	= tvArr.GetSize();
			if(nSize == 0) continue;
			dLenMax	= tvArr.GetLengthMax();

			
			CRebar *pRB	= new CRebar;
			pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
			pRB->m_sDescription.Format("%s 헌치부 배력철근", sStt);
			pRB->m_sMark		= GetMarkRebarSupport(SW_REBAR_SH, FALSE, TRUE, FALSE);
			pRB->m_dDia			= GetDiaRebarSupportOutWallHunch(bStt);
			pRB->m_nTypeRebar	= 1;
			pRB->m_dLengthMax_A	= dLenMax;
			pRB->m_bMainRebar	= FALSE;
			pRB->m_nEa			= nSize;
			baseConc.OptimizationRebar(pRB);
			SetRebarLsdOptionOutWallHunchSupport(pRB->m_pOptionLsd, bStt);
			if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
			m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
			pRB->m_dRateAdd		= MAKE_RATE;
			AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
		}
	}

	// 외측벽체 하단 예각부 배력철근
	SetDataDefaultRebarJewonOutWall_AcuteAngleSupportRebar();
}

double CRcBridgeRebar::GetCTCRebarSupport_OutWall(BOOL bStt, BOOL bInner, long nDan, BOOL bStd)
{
	long stt	= bStt ? iSTT : iEND;
	long inner	= bInner ? iINNER : iOUTTER;

	CPlaceRebarByBlock *pPlace	= &m_placeByBlock_SupportRebar_OutWall[stt][inner][nDan];
	CDPointArray xyArr;
	xyArr	= pPlace->m_xyArr;
	if(xyArr.GetSize() == 0 || bStd)
	{
		return m_dCTC_SupportRebarOutWall[stt];
	}
	else
	{
		return pPlace->GetCTC();
	}
}

CString CRcBridgeRebar::GetMarkRebarSupportArchRib(long nType, BOOL bInput, BOOL bForBM, BOOL bOnlyInit, CString sDescription)
{
	static long nNum	= 1;
	if(bOnlyInit)
	{
		nNum	= 1;
		return "";
	}
	if(!bInput && !bForBM)
	{
		CString sMark	= _T("");

		CRebar *pRB	= GetRebarSupportByDescription(sDescription);
		if(pRB)
		{
			sMark	= pRB->m_sMark;
		}
		
		return sMark;
	}

	CString sMark	= _T("");
	
	// 상부슬래브
	switch(nType)
	{
		case US_REBAR_S_U1 : sMark	= bInput ? "DU1" : "D"; break;	// 상부슬래브 배력철근 상면 1단.
		case US_REBAR_S_U2 : sMark	= bInput ? "DU2" : "D"; break;	// 상부슬래브 배력철근 상면 2단.
		case US_REBAR_S_U3 : sMark	= bInput ? "DU3" : "D"; break;	// 상부슬래브 배력철근 상면 3단.
		case US_REBAR_S_L1 : sMark	= bInput ? "DL1" : "D"; break;	// 상부슬래브 배력철근 하면 1단.
		case US_REBAR_S_L2 : sMark	= bInput ? "DL2" : "D"; break;	// 상부슬래브 배력철근 하면 2단.
		case US_REBAR_S_L3 : sMark	= bInput ? "DL3" : "D"; break;	// 상부슬래브 배력철근 하면 3단.

		// 시점측 벽체
		case SW_REBAR_S_O1 : sMark	= bInput ? "DO1" : "D"; break;	// 시점측벽체 배력철근 외측 1단.
		case SW_REBAR_S_O2 : sMark	= bInput ? "DO2" : "D"; break;	// 시점측벽체 배력철근 외측 2단.
		case SW_REBAR_S_O3 : sMark	= bInput ? "DO3" : "D"; break;	// 시점측벽체 배력철근 외측 3단.
		case SW_REBAR_S_I1 : sMark	= bInput ? "DI1" : "D"; break;	// 시점측벽체 배력철근 내측 1단.
		case SW_REBAR_S_I2 : sMark	= bInput ? "DI2" : "D"; break;	// 시점측벽체 배력철근 내측 2단.
		case SW_REBAR_S_I3 : sMark	= bInput ? "DI3" : "D"; break;	// 시점측벽체 배력철근 내측 3단.

		// 종점측 벽체
		case EW_REBAR_S_O1 : sMark	= bInput ? "DO1" : "D"; break;	// 종점측벽체 배력철근 외측 1단.
		case EW_REBAR_S_O2 : sMark	= bInput ? "DO2" : "D"; break;	// 종점측벽체 배력철근 외측 2단.
		case EW_REBAR_S_O3 : sMark	= bInput ? "DO3" : "D"; break;	// 종점측벽체 배력철근 외측 3단.
		case EW_REBAR_S_I1 : sMark	= bInput ? "DI1" : "D"; break;	// 종점측벽체 배력철근 내측 1단.
		case EW_REBAR_S_I2 : sMark	= bInput ? "DI2" : "D"; break;	// 종점측벽체 배력철근 내측 2단.
		case EW_REBAR_S_I3 : sMark	= bInput ? "DI3" : "D"; break;	// 종점측벽체 배력철근 내측 3단.

		// 시점벽체 헌치부 철근
		case SW_REBAR_SH : sMark	= bInput ? "DH1" : "D"; break;	// 시점벽체 헌치부

		// 종점벽체 헌치부 철근
		case EW_REBAR_SH : sMark	= bInput ? "DH1" : "D"; break;	// 종점벽체 헌치부

		// 외측벽체 하단 예각부 배력근
		case SW_REBAR_AC_L : sMark	= bInput ? "ODS" : "D"; break;	// 시점벽체 좌측 예각부 배력철근
		case SW_REBAR_AC_R : sMark	= bInput ? "ODS" : "D"; break;	// 시점벽체 우측 예각부 배력철근
		case EW_REBAR_AC_L : sMark	= bInput ? "ODS" : "D"; break;	// 종점벽체 좌측 예각부 배력철근
		case EW_REBAR_AC_R : sMark	= bInput ? "ODS" : "D"; break;	// 종점벽체 우측 예각부 배력철근

		// 상부슬래브 둔각부 배력근
		case US_REBAR_OB_SL : sMark	= bInput ? "SDU" : "D"; break;	// 상부슬래브 시점좌측 둔각부 배력철근
		case US_REBAR_OB_SR : sMark	= bInput ? "SDU" : "D"; break;	// 상부슬래브 시점우측 둔각부 배력철근
		case US_REBAR_OB_EL	: sMark	= bInput ? "SDU" : "D"; break;	// 상부슬래브 종점좌측 둔각부 배력철근
		case US_REBAR_OB_ER	: sMark	= bInput ? "SDU" : "D"; break;	// 상부슬래브 종점우측 둔각부 배력철근

		case US_REBAR_OB_SLL : sMark	= bInput ? "SDL" : "D"; break;	// 상부슬래브 시점좌측 둔각부 하면 배력철근
		case US_REBAR_OB_SRL : sMark	= bInput ? "SDL" : "D"; break;	// 상부슬래브 시점우측 둔각부 하면 배력철근
		case US_REBAR_OB_ELL : sMark	= bInput ? "SDL" : "D"; break;	// 상부슬래브 종점좌측 둔각부 하면 배력철근
		case US_REBAR_OB_ERL : sMark	= bInput ? "SDL" : "D"; break;	// 상부슬래브 종점우측 둔각부 하면 배력철근

		// 아치리브
		case AR_REBAR_S_U1:  // 아치리브 상면 1단 배력철근
		case AR_REBAR_S_U2:	// 아치리브 상면 2단 배력철근
		case AR_REBAR_S_U3:	// 아치리브 상면 3단 배력철근

		case AR_REBAR_S_L1:	// 아치리브 하면 1단 배력철근
		case AR_REBAR_S_L2:	// 아치리브 하면 2단 배력철근
		case AR_REBAR_S_L3 : sMark	= bInput ? "RUD" : "RD"; break;	// 아치리브 하면 3단 배력철근
	}

	if(!bInput)
	{
		sMark	+= COMMA(nNum);
		nNum++;
	}

	return sMark;
}

CString CRcBridgeRebar::GetMarkRebarSupport(long nType, BOOL bInput, BOOL bForBM, BOOL bOnlyInit, CString sDescription)
{
	static long nNum	= 1;
	if(bOnlyInit)
	{
		nNum	= 1;
		return "";
	}
	if(!bInput && !bForBM)
	{
		CString sMark	= _T("");

		CRebar *pRB	= GetRebarSupportByDescription(sDescription);
		if(pRB)
		{
			sMark	= pRB->m_sMark;
		}
		
		return sMark;
	}

	CString sMark	= _T("");
	
	// 상부슬래브
	switch(nType)
	{
		case US_REBAR_S_U1 : sMark	= bInput ? "DU1" : "D"; break;	// 상부슬래브 배력철근 상면 1단.
		case US_REBAR_S_U2 : sMark	= bInput ? "DU2" : "D"; break;	// 상부슬래브 배력철근 상면 2단.
		case US_REBAR_S_U3 : sMark	= bInput ? "DU3" : "D"; break;	// 상부슬래브 배력철근 상면 3단.
		case US_REBAR_S_L1 : sMark	= bInput ? "DL1" : "D"; break;	// 상부슬래브 배력철근 하면 1단.
		case US_REBAR_S_L2 : sMark	= bInput ? "DL2" : "D"; break;	// 상부슬래브 배력철근 하면 2단.
		case US_REBAR_S_L3 : sMark	= bInput ? "DL3" : "D"; break;	// 상부슬래브 배력철근 하면 3단.

		case LS_REBAR_S_U1 : sMark	= bInput ? "DU1" : "D"; break;	// 하부슬래브 배력철근 상면 1단.
		case LS_REBAR_S_U2 : sMark	= bInput ? "DU2" : "D"; break;	// 하부슬래브 배력철근 상면 2단.
		case LS_REBAR_S_U3 : sMark	= bInput ? "DU3" : "D"; break;	// 하부슬래브 배력철근 상면 3단.
		case LS_REBAR_S_L1 : sMark	= bInput ? "DL1" : "D"; break;	// 하부슬래브 배력철근 하면 1단.
		case LS_REBAR_S_L2 : sMark	= bInput ? "DL2" : "D"; break;	// 하부슬래브 배력철근 하면 2단.
		case LS_REBAR_S_L3 : sMark	= bInput ? "DL3" : "D"; break;	// 하부슬래브 배력철근 하면 3단.

		// 시점측 벽체
		case SW_REBAR_S_O1 : sMark	= bInput ? "DO1" : "D"; break;	// 시점측벽체 배력철근 외측 1단.
		case SW_REBAR_S_O2 : sMark	= bInput ? "DO2" : "D"; break;	// 시점측벽체 배력철근 외측 2단.
		case SW_REBAR_S_O3 : sMark	= bInput ? "DO3" : "D"; break;	// 시점측벽체 배력철근 외측 3단.
		case SW_REBAR_S_I1 : sMark	= bInput ? "DI1" : "D"; break;	// 시점측벽체 배력철근 내측 1단.
		case SW_REBAR_S_I2 : sMark	= bInput ? "DI2" : "D"; break;	// 시점측벽체 배력철근 내측 2단.
		case SW_REBAR_S_I3 : sMark	= bInput ? "DI3" : "D"; break;	// 시점측벽체 배력철근 내측 3단.

		// 종점측 벽체
		case EW_REBAR_S_O1 : sMark	= bInput ? "DO1" : "D"; break;	// 종점측벽체 배력철근 외측 1단.
		case EW_REBAR_S_O2 : sMark	= bInput ? "DO2" : "D"; break;	// 종점측벽체 배력철근 외측 2단.
		case EW_REBAR_S_O3 : sMark	= bInput ? "DO3" : "D"; break;	// 종점측벽체 배력철근 외측 3단.
		case EW_REBAR_S_I1 : sMark	= bInput ? "DI1" : "D"; break;	// 종점측벽체 배력철근 내측 1단.
		case EW_REBAR_S_I2 : sMark	= bInput ? "DI2" : "D"; break;	// 종점측벽체 배력철근 내측 2단.
		case EW_REBAR_S_I3 : sMark	= bInput ? "DI3" : "D"; break;	// 종점측벽체 배력철근 내측 3단.

		// 시점벽체 헌치부 철근
		case SW_REBAR_SH : sMark	= bInput ? "DH1" : "D"; break;	// 시점벽체 헌치부

		// 종점벽체 헌치부 철근
		case EW_REBAR_SH : sMark	= bInput ? "DH1" : "D"; break;	// 종점벽체 헌치부

		// 외측벽체 하단 예각부 배력근
		case SW_REBAR_AC_L : sMark	= bInput ? "ODS" : "D"; break;	// 시점벽체 좌측 예각부 배력철근
		case SW_REBAR_AC_R : sMark	= bInput ? "ODS" : "D"; break;	// 시점벽체 우측 예각부 배력철근
		case EW_REBAR_AC_L : sMark	= bInput ? "ODS" : "D"; break;	// 종점벽체 좌측 예각부 배력철근
		case EW_REBAR_AC_R : sMark	= bInput ? "ODS" : "D"; break;	// 종점벽체 우측 예각부 배력철근

		// 상부슬래브 둔각부 배력근
		case US_REBAR_OB_SL : sMark	= bInput ? "SDU" : "D"; break;	// 상부슬래브 시점좌측 둔각부 배력철근
		case US_REBAR_OB_SR : sMark	= bInput ? "SDU" : "D"; break;	// 상부슬래브 시점우측 둔각부 배력철근
		case US_REBAR_OB_EL	: sMark	= bInput ? "SDU" : "D"; break;	// 상부슬래브 종점좌측 둔각부 배력철근
		case US_REBAR_OB_ER	: sMark	= bInput ? "SDU" : "D"; break;	// 상부슬래브 종점우측 둔각부 배력철근

		case US_REBAR_OB_SLL : sMark	= bInput ? "SDL" : "D"; break;	// 상부슬래브 시점좌측 둔각부 하면 배력철근
		case US_REBAR_OB_SRL : sMark	= bInput ? "SDL" : "D"; break;	// 상부슬래브 시점우측 둔각부 하면 배력철근
		case US_REBAR_OB_ELL : sMark	= bInput ? "SDL" : "D"; break;	// 상부슬래브 종점좌측 둔각부 하면 배력철근
		case US_REBAR_OB_ERL : sMark	= bInput ? "SDL" : "D"; break;	// 상부슬래브 종점우측 둔각부 하면 배력철근

		// 하부슬래브 둔각부 배력근
		case LS_REBAR_OB_SL : sMark	= bInput ? "SDU" : "D"; break;	// 하부슬래브 시점좌측 둔각부 배력철근
		case LS_REBAR_OB_SR : sMark	= bInput ? "SDU" : "D"; break;	// 하부슬래브 시점우측 둔각부 배력철근
		case LS_REBAR_OB_EL	: sMark	= bInput ? "SDU" : "D"; break;	// 하부슬래브 종점좌측 둔각부 배력철근
		case LS_REBAR_OB_ER	: sMark	= bInput ? "SDU" : "D"; break;	// 하부슬래브 종점우측 둔각부 배력철근

		case LS_REBAR_OB_SLL : sMark	= bInput ? "SDL" : "D"; break;	// 하부슬래브 시점좌측 둔각부 하면 배력철근
		case LS_REBAR_OB_SRL : sMark	= bInput ? "SDL" : "D"; break;	// 하부슬래브 시점우측 둔각부 하면 배력철근
		case LS_REBAR_OB_ELL : sMark	= bInput ? "SDL" : "D"; break;	// 하부슬래브 종점좌측 둔각부 하면 배력철근
		case LS_REBAR_OB_ERL : sMark	= bInput ? "SDL" : "D"; break;	// 하부슬래브 종점우측 둔각부 하면 배력철근

		// 아치리브
		case AR_REBAR_S_U1:  // 아치리브 상면 1단 배력철근
		case AR_REBAR_S_U2:	// 아치리브 상면 2단 배력철근
		case AR_REBAR_S_U3:	// 아치리브 상면 3단 배력철근

		case AR_REBAR_S_L1:	// 아치리브 하면 1단 배력철근
		case AR_REBAR_S_L2:	// 아치리브 하면 2단 배력철근
		case AR_REBAR_S_L3 : sMark	= bInput ? "RUD" : "RD"; break;	// 아치리브 하면 3단 배력철근
	}

	if(!bInput)
	{
		sMark	+= COMMA(nNum);
		nNum++;
	}

	return sMark;
}
CString CRcBridgeRebar::GetMarkRebarShearArchRib(long nType, BOOL bInput, BOOL bForBM, BOOL bOnlyInit, CString sDescription)
{
	static long nNum	= 1;
	if(bOnlyInit)
	{
		nNum	= 1;
		return "";
	}
	if(!bInput && !bForBM)
	{
		CString sMark	= _T("");

		CRebar *pRB	= GetRebarShearByDescription(sDescription);
		if(pRB)
		{
			sMark	= pRB->m_sMark;
		}

		return sMark;
	}

	CString sMark	= _T("");
	
	switch(nType)
	{
		case US_REBAR_V : sMark		= bInput ? "V" : "S"; break;	// 상부슬래브 전단철근
		case SW_REBAR_V : sMark		= bInput ? "V" : "S"; break;	// 시점측벽체 전단철근
		case EW_REBAR_V : sMark		= bInput ? "V" : "S"; break;	// 종점측벽체 전단철근
		case SD_REBAR_V1 : sMark	= bInput ? "DV" : "S"; break;	// 시점 단부 스터럽1
		case SD_REBAR_V2 : sMark	= bInput ? "DV" : "S"; break;	// 시점 단부 스터럽2
		case ED_REBAR_V1 : sMark	= bInput ? "DV" : "S"; break;	// 종점 단부 스터럽1
		case ED_REBAR_V2 : sMark	= bInput ? "DV" : "S"; break;	// 종점 단부 스터럽2
		case AR_REBAR_V : sMark		= bInput ? "RV" : "RS"; break;	// 아치리브 전단철근
		case CO_REBAR_VL : sMark	= bInput ? "V" : "S"; break;	// 접합부 스터럽철근 좌측
		case CO_REBAR_VR : sMark	= bInput ? "V" : "S"; break;	// 접합부 스터럽철근 우측
	}

	if(!bInput)
	{
		sMark	+= COMMA(nNum);
		nNum++;
	}

	return sMark;
}

CString CRcBridgeRebar::GetMarkRebarShear(long nType, BOOL bInput, BOOL bForBM, BOOL bOnlyInit, CString sDescription)
{
	static long nNum	= 1;
	if(bOnlyInit)
	{
		nNum	= 1;
		return "";
	}
	if(!bInput && !bForBM)
	{
		CString sMark	= _T("");

		CRebar *pRB	= GetRebarShearByDescription(sDescription);
		if(pRB)
		{
			sMark	= pRB->m_sMark;
		}
		return sMark;
	}

	CString sMark	= _T("");
	
	switch(nType)
	{
		case US_REBAR_V : sMark		= bInput ? "V" : "S"; break;	// 상부슬래브 전단철근
		case LS_REBAR_V : sMark		= bInput ? "V" : "S"; break;	// 하부슬래브 전단철근
		case SW_REBAR_V : sMark		= bInput ? "V" : "S"; break;	// 시점측벽체 전단철근
		case EW_REBAR_V : sMark		= bInput ? "V" : "S"; break;	// 종점측벽체 전단철근
		case SD_REBAR_V1 : sMark	= bInput ? "DV" : "S"; break;	// 시점 단부 스터럽1
		case SD_REBAR_V2 : sMark	= bInput ? "DV" : "S"; break;	// 시점 단부 스터럽2
		case ED_REBAR_V1 : sMark	= bInput ? "DV" : "S"; break;	// 종점 단부 스터럽1
		case ED_REBAR_V2 : sMark	= bInput ? "DV" : "S"; break;	// 종점 단부 스터럽2
		case AR_REBAR_V : sMark		= bInput ? "RV" : "RS"; break;	// 아치리브 전단철근
		case CO_REBAR_VL : sMark	= bInput ? "V" : "S"; break;	// 접합부 스터럽철근 좌측
		case CO_REBAR_VR : sMark	= bInput ? "V" : "S"; break;	// 접합부 스터럽철근 우측
	}

	if(!bInput)
	{
		sMark	+= COMMA(nNum);
		nNum++;
	}

	return sMark;
}

// 내측 벽체로 변환해서 집계한 다음 철근을 가져와서 이름만 변경해주면 된다.
// 혹시나 집계가 잘 못 된다면 CWallApp의 철근집계를 수정해야겠지... 
void CRcBridgeRebar::SetDataDefaultRebarJewon_OutWall_Shear()
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();
	const double dMulti = bLsd? 10 : 1;

	long stt = 0; for(stt = 0; stt < 2; stt++)
	{
		BOOL bStt	= stt == iSTT ? TRUE : FALSE;
		if(!IsOutWall(bStt)) continue;

		long nLastNum	= -1;
		long i = 0; for(i = 0; i < m_pArrRebarShear.GetSize(); i++)
		{
			CRebar *pRB	= m_pArrRebarShear.GetAt(i);
			nLastNum += pRB->IsTrue() ? 1 : 0;
		}

		CWallApp wall;
		MakeWallByOutWall(wall, bStt, TRUE);
		// 가각부 처리
		double dWidthLeftExp	= GetWidthDiffSlabActOrgAndGagak(bStt, TRUE, TRUE);
		double dWidthRightExp	= GetWidthDiffSlabActOrgAndGagak(bStt, FALSE, TRUE);
		if(m_bIsExp)
		{
			wall.m_dWidthExp[iLEFT]		= bStt ? dWidthRightExp : dWidthLeftExp;
			wall.m_dWidthExp[iRIGHT]	= bStt ? dWidthLeftExp : dWidthRightExp;
		}

		wall.m_nTypeAddRate.Attach(&m_nTypeAddRate);		// 0 : 직경별, 1 : 주철근,기타철근
		wall.m_dAddRateLower.Attach(&m_dAddRateLower);		// 하위 할증률
		wall.m_dAddRateUpper.Attach(&m_dAddRateUpper);		// 상위 할증률
		wall.m_dAddRateDiaOrg.Attach(&m_dAddRateDiaOrg);	// 직경별일경우 기준 직경

		wall.SetDataDefaultRebarJewonShear(nLastNum+2);

		long nWallRebarShearSize = wall.m_pArrRebarShear.GetSize();
		if(nWallRebarShearSize > 0)
		{
			CRebar *pRB	= new CRebar;
			*pRB	= *wall.m_pArrRebarShear.GetAt(nWallRebarShearSize-1);
			pRB->m_sDescription.Format("%s 전단철근", bStt ? "시점측벽체" : "종점측벽체");
			pRB->m_Fy = bLsd? GetValueFy(bStt? ePartOutWallStt : ePartOutWallEnd, TRUE) : wall.m_Fy;
			AddOrDeleteRebarInList(&m_pArrRebarShear, pRB);
		}
	}
}

// void CRcBridgeRebar::GetTvRebarShear_CrossSection_OutWall(CTwinVectorArray &tvArr, BOOL bStt)
// {
// 	CWallApp wall;
// 	MakeWallByOutWall(wall, bStt, TRUE);
// 	wall.GetTvRebarShear_Side(tvArr, TRUE);
// }

double CRcBridgeRebar::GetLenShearUpperSlab()
{
	// 표준간격/2 * 감싸는 개수
	double dCTC	= m_dCTC_MainRebar / 2;
	double dLen	= dCTC * m_nCountWrapMainRebarUpperSlab;

	return dLen;
}

// double CRcBridgeRebar::GetLenShearLowerSlab()
// {
// 	// 표준간격/2 * 감싸는 개수
// 	double dCTC	= m_dCTC_MainRebar / 2;
// 	double dLen	= dCTC * m_nCountWrapMainRebarLowerSlab;
// 
// 	return dLen;
// }

// double CRcBridgeRebar::GetLenShearOutWall(BOOL bStt)
// {
// 	// 표준간격/2 * 감싸는 개수
// 	double dCTC	= m_dCTC_MainRebar / 2;
// 	double dLen	= dCTC * m_nCountWrapMainRebarForOutWall[bStt ? iSTT : iEND];
// 
// 	return dLen;
// }

// double CRcBridgeRebar::GetLenShearBracket(BOOL bStt)
// {
// 	// 표준간격/2 * 감싸는 개수
// 	double dCTC	= m_dCTC_MainRebar / 2;
// 	double dLen	= dCTC * m_nCountWrapMainRebarForBracket[bStt ? iSTT : iEND];
// 
// 	return dLen;
// }


double CRcBridgeRebar::GetLenShearArchRib()
{
	// 표준간격/2 * 감싸는 개수
	double dCTC	= m_dCTC_MainRebar / 2;
	double dLen	= dCTC * m_nCountWrapMainRebarForArchRib;

	return dLen;
}

// double CRcBridgeRebar::GetLenShearDanbuStirrup(BOOL bUpper, BOOL bStt)
// {
// 	// 표준간격/2 * 감싸는 개수
// 	double dCTC	= m_dCTC_MainRebar / 2;
// 	double dLen	= dCTC * m_nCountStirrupCtcMainRebar[bUpper ? iUPPER : iLOWER][bStt ? iSTT : iEND];
// 
// 	return dLen;
// }

// 전단철근 권고안
// 집계 방식 변경
void CRcBridgeRebar::SetDataDefaultRebarJewon_UpperSlab_Shear()
{
	ClearRebarList(2);

	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();

	CHgBaseConcStd baseConc;
	CBasicConcInfo concInfo;
	double dLenMaxA(0), dLenMinA(0);
	double dLenMaxB(0), dLenMinB(0);
//	double dLenMaxADanbuSt(0);
	
	double dCover(0);
	double dRebarSpace	= 0;
	
	dCover		= m_dCoverUpper_UpperSlab[0];
	dRebarSpace	= GetCTCRebarShear_UpperSlab();


	// 전단철근이 들어가는 전체 스테이션을 구함.(벽체는 제외함(무조건 안들어간다 치고.))
	BOOL bVertDir	= IsVertDir();
	double dStaStt	= min(GetStationByTarget(BRIDGE_OFF_STT_STT, -1, TRUE), GetStationByTarget(BRIDGE_OFF_STT_STT, 1, TRUE));
	double dStaEnd	= max(GetStationByTarget(BRIDGE_OFF_END_END, -1, TRUE), GetStationByTarget(BRIDGE_OFF_END_END, 1, TRUE));
	if(bVertDir)
	{
		dStaStt	= GetStationOnJijum(0, 0, bVertDir);
		dStaEnd	= GetStationOnJijum(m_nQtyJigan, 0, bVertDir);
	}
	double dStaSttCen	= GetStationOnJijum(0, 0, bVertDir);
	double dStaEndCen	= GetStationOnJijum(m_nQtyJigan, 0, bVertDir);

	// 입력된 전단철근과 빈공간에 자동으로 넣을 전단철근의 sta들을 구함.
	// 전단철근 높이
	CTwinVectorArray tvArr, tvArrHunch, tvArrRib;
	CTwinVectorArray tvArrTot;
	GetTvRebarShear_VertSection_UpperSlab(tvArr, tvArrHunch, tvArrRib);
	tvArrTot.AddFromTvArray(tvArr);
	tvArrTot.AddFromTvArray(tvArrHunch);
	CDoubleArray dArrStaShear;
	
	double dCTC	= m_dCTC_ShearRebar[iUPPER];
	double dStaCur	= dStaSttCen - dCTC;
	while(dStaCur > dStaStt)
	{
		dArrStaShear.InsertAt(0, dStaCur);
		dStaCur -= dCTC;
	}
	long i = 0; for(i = 0; i < tvArr.GetSize(); i++)
		dArrStaShear.Add(tvArr.GetAt(i).m_v1.x);
	for(i = 0; i < tvArrHunch.GetSize(); i++)
		dArrStaShear.Add(tvArrHunch.GetAt(i).m_v1.x);
	dStaCur	= dStaEndCen + dCTC;
	while(dStaCur < dStaEnd)
	{
		dArrStaShear.Add(dStaCur);
		dStaCur += dCTC;
	}


	// 스테이션 별 슬래브 폭으로 전단철근 개수 구함
	long nCountTot	= 0;
	CTwinVectorArray tvArrPlane, tvArrPlaneOrg;
	GetTvRebarOut_Plane_UpperSlabStd(tvArrPlane, 0, TRUE);
	GetTvRebarOut_Plane_UpperSlabStd(tvArrPlaneOrg, 0, FALSE);

	CLineInfo *pLine	= GetLineBase(bVertDir);
	CDPoint vAngShear	= pLine->GetAngleAzimuth(dStaStt).Rotate90();
	CDPoint vAngLineOfShear	= CDPoint(0, 1);
	if(m_nTypePlacingSupportRebar_UpperSlab == 0)
	{
		vAngShear	= GetAngleAzimuthJijum(0);
		vAngLineOfShear	= GetAngleJijum(0, bVertDir);
	}
	else if(m_nTypePlacingSupportRebar_UpperSlab == 1)
	{
		vAngShear	= GetAngleAzimuthJijum(m_nQtyJigan);
		vAngLineOfShear	= GetAngleJijum(m_nQtyJigan, bVertDir);
	}

	

	CRebarPlacing rb;
	
	
	double dCTCMainRebar	= GetCtcRebarMain(TRUE)/vAngLineOfShear.y;

	// 원곡선인 경우 해당 sta의 폭중 최대 최소를 이용해서 전단철근의 최대최소 길이를 구해야 된다.
	// 10000을 기준으로 한 폭으로 계산함.
	double dStdWidth	= 10000;
	double dMaxWidth	= 0;
	double dMinWidth	= 0;
	BOOL bFirst	= TRUE;
	////////////////////////////////////////////////////////////////////////////////////////////////////
	BOOL bIncludeArc	= !IsIncludeOnlyLineInBridge();
	for(i = 0; i < dArrStaShear.GetSize(); i++)
	{
		double dSta	= dArrStaShear.GetAt(i);
		CDPoint xy	= pLine->GetXyLine(bVertDir ? dSta-m_dStationBridgeStt : dSta);
		CDPoint xyDir	= vAngShear;
		if(m_nTypePlacingSupportRebar_UpperSlab > 1 && bIncludeArc)
		{
			xyDir	= pLine->GetAngleAzimuth(bVertDir ? dSta-m_dStationBridgeStt : dSta).Rotate90();
		}

		CDPointArray xyArrMatch;
		rb.GetXyMatchTvArrAndLine(tvArrPlane, xy, xyDir, xyArrMatch);
		double dDist	= 0;
		if(xyArrMatch.GetSize() > 1)
		{
			
			long j = 0; for(j = 0; j < xyArrMatch.GetSize()-1; j++)
			{
				for(long k = j + 1; k < xyArrMatch.GetSize(); k++)
				{
					dDist = max(~(xyArrMatch.GetAt(j)-xyArrMatch.GetAt(k)), dDist);
				}
			}
		}

		if(dDist > 0)
		{
			long nCount	= (long)(dDist / (dCTCMainRebar * m_nCountWrapMainRebarUpperSlab));
			if(dDist - (dCTCMainRebar * m_nCountWrapMainRebarUpperSlab) > (dCTCMainRebar * m_nCountWrapMainRebarUpperSlab)/2)
				nCount ++;
			nCountTot += nCount;

			// 철근이 들어간 곳의 폭 구함.
			// 원곡선이고 배근방법이 시점이나 종점방향으로 배근 되었을 경우에만 구하면 된다
			// 그리고 사보강 배치가 아닐경우
			if(bIncludeArc && (m_nTypePlacingSupportRebar_UpperSlab == 0 || m_nTypePlacingSupportRebar_UpperSlab == 1) && !bVertDir)
			{
				CDPoint xy		= pLine->GetXyLine(dSta);
				double staL(0), staR(0);
				pLine->GetStationMatchByXyAndAngle(xy, vAngShear, staL, -dStdWidth/2);
				pLine->GetStationMatchByXyAndAngle(xy, vAngShear, staR, dStdWidth/2);
				CDPoint xyLeft	= pLine->GetXyLineDis(staL, -dStdWidth/2);
				CDPoint xyRight	= pLine->GetXyLineDis(staR, dStdWidth/2);
				if(bFirst)
				{
					dMaxWidth	= ~(xyLeft - xyRight);
					dMinWidth	= ~(xyLeft - xyRight);
					bFirst	= FALSE;
				}
				else
				{
					dMaxWidth	= max(~(xyLeft - xyRight), dMaxWidth);
					dMinWidth	= min(~(xyLeft - xyRight), dMinWidth);
				}
			}
		}
	}
	

	// 전체 개수를 구했으면 헌치부와 슬래브부의 철근 비율을 이용해서 평면상의 개수도 나눈다.
	double dRateNormal	= (double)tvArrTot.GetSize() / (double)tvArr.GetSize();
	long nCountNormal	= (long)((double)nCountTot / dRateNormal);
	long nCountHunch	= nCountTot - nCountNormal;
	long nCountRib		= 0;


	// 아치리브 까지 뻗은 전단철근 개수
	if(m_nTypeBridge == BRIDGE_TYPE_ARCH)
	{
		double dW	= GetWidthArchRib(0) - m_dCoverSide_UpperSlab[0] * 2;
		nCountRib	= (long)(dW / (dCTCMainRebar * m_nCountWrapMainRebarUpperSlab) * tvArrRib.GetSize());
	}

	
	
	// 정착장
	CPlaceRebarByBlock *pPlace	= &m_placeByBlock_ShearRebar_UpperSlab;
	double dSettle	= m_pARcBridgeDataStd->GetValueJoint((long)pPlace->m_dDia, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
	double dFck	= GetValueFck(ePartUpperSlab);
	double dFy	= GetValueFy(ePartUpperSlab, FALSE);

	double dDiaMainLower	= GetDiaMainRebarUpperSlab(0, 0, FALSE, 0, 0);
	double dDiaMainUpper	= GetDiaMainRebarUpperSlab(0, 0, TRUE, 0, 0);

	// 철근 길이 구해주자(현재 원곡선부분 빼고는 모두 같음)
	dLenMaxA	= dCTCMainRebar/2 * m_nCountWrapMainRebarUpperSlab;
	dLenMinA	= dLenMaxA;

	if(bIncludeArc && !bVertDir && (m_nTypePlacingSupportRebar_UpperSlab == 0 || m_nTypePlacingSupportRebar_UpperSlab == 1))
	{
		double dRateMin	= dStdWidth / dMinWidth;
		double dRateMax	= dStdWidth / dMaxWidth;

		dLenMaxA	= (GetCtcRebarMain(TRUE)/2 * m_nCountWrapMainRebarUpperSlab) / dRateMax;
		dLenMinA	= (GetCtcRebarMain(TRUE)/2 * m_nCountWrapMainRebarUpperSlab) / dRateMin;
	}

	

	// 전단철근 동일 길이인거
	if(tvArr.GetSize() > 0)
	{
		// 변화치수인것과 정상치수인것을 구분한다.
		CTwinVectorArray tvArrRebarCross, tvArrRebarCross2;

		// (37296) 슬래브교에서는 교량시점에서는 주철근을 찾을수 없기 때문에 아래 함수를 사용한겨우 철근을 만들지 못한다.
		// 왜 교량 중심Station을 쓰다가 시점 Station으로 변경했을까....
		// 일단 슬래브 교일때만 교량 중심을 사용하는걸로...
		GetTvRebarShear_CrossSection_UpperSlab(tvArrRebarCross, tvArrRebarCross2, (IsRcSlab() || IsPiRahmen())? GetStationBridgeMid() : dStaSttCen, 0, FALSE, FALSE, FALSE, TRUE);
		long nCountCrossTot	= tvArrRebarCross.GetSize() + tvArrRebarCross2.GetSize();
	
		dLenMaxB	= tvArr.GetLengthMax();
		dLenMinB	= tvArr.GetLengthMin();

		CRebar *pRB	= new CRebar;
		pRB->m_Fy			= bLsd? GetValueFy(ePartUpperSlab, TRUE) : m_pARcBridgeDataStd->m_Fy;
		pRB->m_sDescription.Format("상부슬래브 전단철근1");
		pRB->m_sMark		= GetMarkRebarShear(US_REBAR_V, FALSE, TRUE, FALSE);
		m_RebarShearDetail_UpperSlab.SetRB(pRB, dDiaMainUpper, dDiaMainLower, dLenMaxA, dLenMaxB, dSettle);
		m_RebarShearDetail_UpperSlab.SetMin(dLenMinA, dLenMinB);
		m_RebarShearDetail_UpperSlab.SetDataDefaultRebarJewon();
		pRB->m_bMainRebar	= FALSE;
		pRB->m_nEa	= (long)((double)nCountNormal * ((double)tvArrRebarCross.GetSize()/(double)nCountCrossTot));
		long nCount	= pRB->m_nEa;
		baseConc.OptimizationRebar(pRB);	// 철근 최적화
		concInfo.SetLengthRebar(dFck, dFy, pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
		pRB->m_dRateAdd	= MAKE_RATE;
		AddOrDeleteRebarInList(&m_pArrRebarShear, pRB);

		// 전단철근 동일인거 중에 모서리 부분에 변화 치수인거
		if(tvArrRebarCross2.GetSize() > 0)
		{
			double dHeightMax	= tvArrRebarCross2.GetLengthMax();
			double dHeightMin	= tvArrRebarCross2.GetLengthMin();

			pRB	= new CRebar;
			pRB->m_Fy			= bLsd? GetValueFy(ePartUpperSlab, TRUE) : m_pARcBridgeDataStd->m_Fy;
			pRB->m_sDescription.Format("상부슬래브 전단철근1_1");
			pRB->m_sMark		= GetMarkRebarShear(US_REBAR_V, FALSE, TRUE, FALSE);
			m_RebarShearDetail_UpperSlab.SetRB(pRB, dDiaMainUpper, dDiaMainLower, dLenMaxA, dHeightMax, dSettle);
			m_RebarShearDetail_UpperSlab.SetMin(dLenMinA, dHeightMin);
			m_RebarShearDetail_UpperSlab.SetDataDefaultRebarJewon();
			pRB->m_bMainRebar	= FALSE;
			pRB->m_nEa			= nCountNormal - nCount;
			baseConc.OptimizationRebar(pRB);	// 철근 최적화
			concInfo.SetLengthRebar(dFck, dFy, pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
			pRB->m_dRateAdd	= MAKE_RATE;
			AddOrDeleteRebarInList(&m_pArrRebarShear, pRB);
		}
	}


	// 전단철근 헌치부까지 확장되어 변화길이인거
	if(tvArrHunch.GetSize() > 0)
	{
		dLenMaxB	= tvArrHunch.GetLengthMax();
		dLenMinB	= tvArrHunch.GetLengthMin();

		CRebar *pRB	= new CRebar;
		pRB->m_Fy			= bLsd? GetValueFy(ePartUpperSlab, TRUE) : m_pARcBridgeDataStd->m_Fy;
		pRB->m_sDescription.Format("상부슬래브 전단철근2");
		pRB->m_sMark		= GetMarkRebarShear(US_REBAR_V, FALSE, TRUE, FALSE);
		m_RebarShearDetail_UpperSlab.SetRB(pRB, dDiaMainUpper, dDiaMainLower, dLenMaxA, dLenMaxB, dSettle);
		m_RebarShearDetail_UpperSlab.SetMin(dLenMinA, dLenMinB);
		m_RebarShearDetail_UpperSlab.SetDataDefaultRebarJewon();
		pRB->m_bMainRebar	= FALSE;
		pRB->m_nEa			= nCountHunch;
		baseConc.OptimizationRebar(pRB);	// 철근 최적화
		concInfo.SetLengthRebar(dFck, dFy, pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
		pRB->m_dRateAdd	= MAKE_RATE;
		AddOrDeleteRebarInList(&m_pArrRebarShear, pRB);
	}

	// 전단철근 리브까지 확장되어 변화길이인거
	if(tvArrRib.GetSize() > 0)
	{
		dLenMaxB	= tvArrRib.GetLengthMax();
		dLenMinB	= tvArrRib.GetLengthMin();

		CRebar *pRB	= new CRebar;
		pRB->m_Fy			=  bLsd? GetValueFy(ePartUpperSlab, TRUE) : m_pARcBridgeDataStd->m_Fy;
		pRB->m_sDescription.Format("상부슬래브 전단철근3");
		pRB->m_sMark		= GetMarkRebarShear(US_REBAR_V, FALSE, TRUE, FALSE);
		m_RebarShearDetail_ArchRib.SetRB(pRB, dDiaMainUpper, dDiaMainLower, dLenMaxA, dLenMaxB, dSettle);
		m_RebarShearDetail_ArchRib.SetMin(dLenMinA, dLenMinB);
		m_RebarShearDetail_ArchRib.SetDataDefaultRebarJewon();
		pRB->m_bMainRebar	= FALSE;
		pRB->m_nEa			= nCountRib;
		baseConc.OptimizationRebar(pRB);	// 철근 최적화
		concInfo.SetLengthRebar(dFck, dFy, pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
		pRB->m_dRateAdd	= MAKE_RATE;
		AddOrDeleteRebarInList(&m_pArrRebarShear, pRB);
	}


	CString strSlab = _T("");
	if(IsBoxType()) strSlab = _T("상부슬래브");
	// 단부 스터럽 철근
	long nCountDanbuStt(0);
 	double dW	= m_bIsExp ? GetWidthSlabActByGagak(m_dStationBridgeStt, GetAngleJijum(0)) : GetWidthSlabAct(m_dStationBridgeStt, GetAngleJijum(0));
 	nCountDanbuStt	= (long)(dW / (dCTCMainRebar * m_nCountWrapMainRebarUpperSlab));
	

	dW	= m_bIsExp ? GetWidthSlabActByGagak(m_dStationBridgeStt+m_dLengthBridge, GetAngleJijum(m_nQtyJigan)) : GetWidthSlabAct(m_dStationBridgeStt+m_dLengthBridge, GetAngleJijum(m_nQtyJigan));
	
	long stt = 0; for(stt = 0; stt < 2; stt++)
	{
		BOOL bStt	= stt == iSTT;

		dRebarSpace	= GetCTCRebarShear_DanbuStirrup(TRUE, bStt);
		// 단부 스터럽 철근은 시종점 사각 적용
		CDPoint vAngLineOfShearForStirrup	= bStt ? GetAngleJijum(0) : GetAngleJijum(m_nQtyJigan);
		dCTCMainRebar	= m_nTypePlacingMainRebar_UpperSlab == 0? GetCtcRebarMain(TRUE) / vAngLineOfShearForStirrup.y : GetCtcRebarMain(TRUE);
		double dLenMaxADanbuSt	= dCTCMainRebar/2 * m_nCountStirrupCtcMainRebar[iUPPER][bStt? 0:1];

		long nCountDanbu = (long)(dW / (dCTCMainRebar * m_nCountStirrupCtcMainRebar[iUPPER][bStt? 0:1]));

		CTwinVectorArray tvArrDanbu;
		GetTvRebarShear_VertSection_UpperSlabDanbu(tvArrDanbu, bStt, 0);
		dDiaMainLower	= GetDiaMainRebarUpperSlabHunch(0, bStt ? 0 : m_nQtyJigan);
		dDiaMainUpper	= GetDiaMainRebarUpperSlab(0, 0, TRUE, bStt ? 0 : m_nQtyJigan-1, bStt ? 0 : -1);
		if(dDiaMainLower == 0)
			dDiaMainLower	= GetDiaMainRebarUpperSlab(0, 0, FALSE, bStt ? 0 : m_nQtyJigan-1, bStt ? 0 : -1);

		long i = 0; for(i = 0; i < tvArrDanbu.GetSize(); i++)
		{
			long nTypeRebar		= bStt ? SD_REBAR_V1 : ED_REBAR_V1;
			CTwinVector tv		= tvArrDanbu.GetAt(i);

			CRebar *pRB	= new CRebar;
			pRB->m_Fy			=  bLsd? GetValueFy(bStt? ePartOutWallStt : ePartOutWallEnd, TRUE) :  m_pARcBridgeDataStd->m_Fy;
			pRB->m_sDescription.Format("%s %s 우각부 보강 조립철근%d", strSlab, bStt ? "시점" : "종점", i+1);
			pRB->m_sMark		= GetMarkRebarShear(nTypeRebar, FALSE, TRUE, FALSE);
			pRB->m_dDia			= GetDiaRebarStirrupDanbu(bStt, i, TRUE);
			pRB->m_dLengthMax_A	= dLenMaxADanbuSt + max(dDiaMainUpper, dDiaMainLower) + pRB->m_dDia;
			pRB->m_dLengthMin_A	= 0;
			pRB->m_dLengthMax_B	= tv.GetLength() + dDiaMainUpper/2 + dDiaMainLower/2 + pRB->m_dDia;
			pRB->m_dLengthMin_B	= 0;
			pRB->m_dLengthMax_C	= 100;
			pRB->m_dLengthMin_C	= 0;
			pRB->m_nTypeRebar	= 16;
			pRB->m_bMainRebar	= FALSE;
			pRB->m_nEa = nCountDanbu;
			baseConc.OptimizationRebar(pRB);	// 철근 최적화
			concInfo.SetLengthRebar(dFck, dFy, pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
			pRB->m_dRateAdd	= MAKE_RATE;
			AddOrDeleteRebarInList(&m_pArrRebarShear, pRB);
		}
	}

	// 아치교 접합부 스터럽 철근 
	// 아치교는 어짜피 확폭사교 없으니 시점 전단철근 개수와 같음
	if(m_nTypeBridge == BRIDGE_TYPE_ARCH)
	{
		dRebarSpace	= GetCTCRebarShear_ArchRib();
		CTwinVectorArray tvArrStirrup[2];
		GetTvRebarStirrup_VertSection_ConnectSection(tvArrStirrup[iLEFT], tvArrStirrup[iRIGHT]);
		long left = 0; for(left = 0; left < 2; left++)
		{
			BOOL bLeft	= left == iLEFT;
			CTwinVectorArray *pTvArr	= &tvArrStirrup[left];
			if(pTvArr->GetSize() == 0) continue;

			dDiaMainLower	= m_placeByBlock_ShearRebar_UpperSlab.m_dDia;
			dDiaMainUpper	= dDiaMainLower;
			
			long nTypeRebar		= bLeft ? CO_REBAR_VL : CO_REBAR_VR;
			CTwinVector tv		= pTvArr->GetAt(0);

			CRebar *pRB	= new CRebar;
			pRB->m_Fy			=  m_pARcBridgeDataStd->m_Fy;
			pRB->m_sDescription.Format("접합부 %s 스터럽 철근", bLeft ? "좌측" : "우측");
			pRB->m_sMark		= GetMarkRebarShear(nTypeRebar, FALSE, TRUE, FALSE);
			pRB->m_dDia			= m_placeByBlock_StirrupRebar_ConnectSection[left].m_dDia;
			pRB->m_dLengthMax_A	= tv.GetLength() + (2 * ConstPi * (dDiaMainUpper/2 + dDiaMainLower/2 + pRB->m_dDia) / 4);
			pRB->m_dLengthMin_A	= 0;
			pRB->m_dLengthMax_B	= GetCtcRebarMain(TRUE)*3;
			pRB->m_dLengthMin_B	= 0;
			pRB->m_dLengthMax_C	= dSettle;
			pRB->m_dLengthMin_C	= 0;
			pRB->m_nTypeRebar	= 17;
			pRB->m_bMainRebar	= FALSE;
			pRB->m_nEa			= nCountDanbuStt * pTvArr->GetSize();
			baseConc.OptimizationRebar(pRB);	// 철근 최적화
			concInfo.SetLengthRebar(dFck, dFy, pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
			pRB->m_dRateAdd	= MAKE_RATE;
			AddOrDeleteRebarInList(&m_pArrRebarShear, pRB);
		}
	}
}

// 전단철근 잘라내는 영역 구하기
// 0 : 좌우측에 따라 반씩 자름
// 1 : 좌우측에 따라 원(중심에서 좌우로 이동한 위치에 있음)
void CRcBridgeRebar::GetTvCuttingArea_UpperSlab_Shear(CTwinVectorArray &tvArr, long nDrawLeft)
{
	tvArr.RemoveAll();
	CLineInfoApp *pLine	= static_cast<CLineInfoApp*>(GetLineBase());
	if(!pLine) return;
	if(nDrawLeft == 0) return;

	// 0 : 좌우측에 따라 반씩 자름
	// 1 : 좌우측에 따라 원(중심에서 좌우로 이동한 위치에 있음)
	const long nTypeCuttingShear	= 1;

	// 중심선형
	CTwinVectorArray tvArrCenter;
	tvArrCenter.AddFromLSClothoid(pLine, m_dStationBridgeStt-m_dWS, m_dStationBridgeStt+m_dLengthBridge+m_dWE, 0, 5000);
	
	CRebarPlacing rb;
	
	if(nTypeCuttingShear == 0)
	{
		CTwinVectorArray tvArrPlane;
		GetTvRebarOut_Plane_UpperSlabStd(tvArrPlane, 0);
	
		if(nDrawLeft == -1 || nDrawLeft == 1)
		{
			BOOL bLeft	= nDrawLeft == 1;
			rb.TrimTvArrayByTvArray(tvArrPlane, tvArrCenter, bLeft, TRUE);
		}
	}
	else if(nTypeCuttingShear == 1)
	{
		double dWidthSlab	= GetWidthSlabAct(GetStationSmallestWidthOfUpperSlab(FALSE), CDPoint(0, 1), 0);
		// 원..
		CTwinVector tv;
		CDPoint vAng	= ToDPointFrDegree((GetAngleJijum(m_nQtyJigan-1).GetAngleDegree() + GetAngleJijum(m_nQtyJigan-1).GetAngleDegree())/2);
		double dSta		= GetStationOnJijum(m_nQtyJigan-1, 0) + GetLengthJigan(m_nQtyJigan-1)/2;
		double dDistMid	= GetDistMidOfSlab(dSta);
		double dR		= dWidthSlab / 6;
		if(dR > m_dLengthBridge/6) dR = m_dLengthBridge/6;
		double dDist	= dDistMid + dWidthSlab / 4 * nDrawLeft;
		if(GetAngleJijum(0).GetAngleDegree() > 90)
			dDist	= dDistMid - dWidthSlab/4 * nDrawLeft;
		CDPoint xyCen	= pLine->GetXyLineByLengthAndAngle(dSta, dDist/vAng.y, vAng);
		
		tv.m_v1	= pLine->GetXyLineByLengthAndAngle(dSta, (dDist-dR)/vAng.y, vAng);
		tv.m_v2	= pLine->GetXyLineByLengthAndAngle(dSta, (dDist+dR)/vAng.y, vAng);
		tv.m_v1.z	= -1;
		tv.m_v2.z	= dR;
		tvArr.Add(tv);

		tv.m_v1	= pLine->GetXyLineByLengthAndAngle(dSta, (dDist+dR)/vAng.y, vAng);
		tv.m_v2	= pLine->GetXyLineByLengthAndAngle(dSta, (dDist-dR)/vAng.y, vAng);
		tv.m_v1.z	= -1;
		tv.m_v2.z	= dR;
		tvArr.Add(tv);
	}
}

// 상부슬래브 평면에 비치된 배력근의 각도를 구함
// dSta에 따라서 배력근 각도가 달라 질 수 있기 때문임.
// 속도가 좀 많이 걸리는 함수임.. 호출도 엄청 많이 됨 .. 수정 반드시 필요.
// sta마다 하나씩 가져오면시간이 엄청 걸리므로 일괄적으로 스테이션별 각도를 모두 리턴함.
// void CRcBridgeRebar::GetXyDirRebarSupport_Plane_UpperSlab(CDPointArray &xyArr, BOOL bUpper, BOOL bLeft)
// {	
// 	// 모든 배력근의 스테이션
// 	CDoubleArray dArrSta;
// 	GetStaRebarSupport_VertSection_Slab(dArrSta, bUpper, 0);
// 
// 	// 스테이션별 배력근의 각도 가져옴
// 	long nLeft	= bLeft ? -1 : 1;
// 	CTwinVectorArray tvArrSup, tvArrAngStt, tvArrAngEnd, tvArrRAngStt, tvArrRAngEnd;
// 	GetTvRebarSupport_Plane_Slab_Std(TRUE, tvArrSup, tvArrAngStt, tvArrAngEnd, tvArrRAngStt, tvArrRAngEnd, bUpper, 0, nLeft, TRUE);
// 
// 	// 변수하나에 합침
// 	tvArrAngStt.AddFromTvArray(tvArrSup);
// 	tvArrAngStt.AddFromTvArray(tvArrAngEnd);
// 	
// 	// 스테이션과 각도를 묶음
// 	CDPoint xyR(0, 0);
// 	long nSize	= dArrSta.GetSize();
// 	long i = 0; for(i = 0; i < nSize; i++)
// 	{
// 		xyR.x	= dArrSta[i];
// 		if(tvArrAngStt.GetSize() > i)
// 			xyR.y	= tvArrAngStt[i].GetXyDir().GetAngleDegree();
// 		xyArr.Add(xyR);
// 	}
// }


// 거더부 철근 모두
void CRcBridgeRebar::SetDataDefaultRebarJewon_Girder_All(BOOL bUpperSlabGirder)
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();
	const double dMulti = bLsd? 10 : 1;

	double dCover		= 0;
	double dSpace		= GetCtcRebarMain();
	long nCountStirrup	= 1;	// 스터럽 철근 개수는 계산 따로 해야 됨.
	CTwinVectorArray tvArr;
	CTwinVectorArray tvArrShearCross;
	CHgBaseConcStd baseConc;
	CString strSlab = _T("");
	if(IsBoxType())
		strSlab = bUpperSlabGirder ? _T("상부") : _T("하부");

	BOOL bStt	= TRUE;
	BOOL bLeft	= TRUE;
	BOOL bGagak	= TRUE;
	BOOL bJongGirder	= FALSE;
	
	for(long nJ	= 0; nJ <= m_nQtyJigan; nJ++)
	{
		if(bJongGirder)
		{
			if(!IsGirderRebarJong(bStt, bLeft, bGagak)) continue;
		}
		else
		{
			if(!IsGirderRebar(nJ, bUpperSlabGirder)) continue;
		}

		CGirderSectionRebar *pGirder	= bJongGirder ? GetGirderRebarJong(bStt, bLeft, bGagak) : &m_SlabGirderRebar[bUpperSlabGirder ? iUPPER : iLOWER][nJ];
		dCover	= pGirder->m_dCoverUpper[0];
		
		// 스트럽 철근 좌표 구함.
		GetTvRebarStirrup_SlabGrider(tvArr, nJ, bStt, bLeft, bGagak, bJongGirder);

		// 횡단면상의 전단철근 개수
		GetTvRebarShear_CrossSection_UpperSlabGirder(tvArrShearCross, nJ);
		nCountStirrup	= tvArrShearCross.GetSize();

		//  거더 스터럽 철근 /////////////////////////////////////////////
		// 가로 세로 최대 최소 길이를 구함.
		double dLenMaxHor(0), dLenMaxVer(0), dLenMinHor(0), dLenMinVer(0);

		long i = 0; for(i = 0; i < pGirder->m_nCountStirrup; i++)
		{
			CTwinVector tvVer, tvHor;
			tvVer	= tvArr.GetTvByInfo("좌"+COMMA(i+1));
			tvHor	= tvArr.GetTvByInfo("상"+COMMA(i+1));

			if(i==0)
			{
				dLenMaxHor	= tvHor.GetLength();
				dLenMaxVer	= tvVer.GetLength();
				dLenMinHor	= tvHor.GetLength();
				dLenMinVer	= tvVer.GetLength();
			}
			else
			{
				dLenMaxHor	= max(tvHor.GetLength(), dLenMaxHor);
				dLenMaxVer	= max(tvVer.GetLength(), dLenMaxVer);
				dLenMinHor	= min(tvHor.GetLength(), dLenMinHor);
				dLenMinVer	= min(tvVer.GetLength(), dLenMinVer);
			}
		}

		CRebar *pRB	= new CRebar;
		pRB->m_Fy			=  bLsd? GetValueFy(ePartUpperSlab, TRUE) : m_pARcBridgeDataStd->m_Fy;
		pRB->m_sDescription.Format("지점%d %s거더부 수직전단철근", nJ+1, strSlab);
		pRB->m_sMark	= GetMarkRebarEtc(G_REBAR_ST, FALSE, TRUE, FALSE, "", TRUE);
		pRB->m_dDia		= pGirder->m_dDiaStirrup;
		double disMaxB	= dLenMaxVer;
		double disMinB	= dLenMinVer;
		double disMaxC	= max(m_pARcBridgeDataStd->GetValueJoint(pRB->m_dDia, JOINT_TENS_NORMAL_B, dCover, dSpace), disMaxB);
		double disMinC	= min(disMaxC, disMinB);
		pRB->m_dLengthMax_A = dLenMaxHor;
		pRB->m_dLengthMin_A = dLenMinHor;
		pRB->m_dLengthMax_B = disMaxB;
		pRB->m_dLengthMin_B = disMinB;
		pRB->m_dLengthMax_C = disMaxC;
		pRB->m_dLengthMin_C = disMinC;
		pRB->m_nTypeRebar	= 18;
		pRB->m_bMainRebar	= FALSE;
		pRB->m_dRateAdd		= MAKE_RATE;
		pRB->m_nEa			= pGirder->m_nCountStirrup * nCountStirrup;
		baseConc.OptimizationRebar(pRB);
		AddOrDeleteRebarInList(&m_pArrRebarGirder, pRB);
		//  거더 스터럽 철근 /////////////////////////////////////////////

		CTwinVectorArray tvArrUpper, tvArrLower;
		GetTvRebarSupport_Plane_SlabGirder(tvArrUpper, bUpperSlabGirder, nJ, 0, TRUE, 0);
		GetTvRebarSupport_Plane_SlabGirder(tvArrLower, bUpperSlabGirder, nJ, 0, FALSE, 0);

		// 거더 좌우측 수평전단철근 /////////////////////////////////////
		dSpace				= pGirder->m_dF;
		if(Compare(dSpace, 0.0, "=")) 
			dSpace	= pGirder->m_dF1;
		pRB					= new CRebar;
		pRB->m_Fy			=  bLsd? GetValueFy(ePartUpperSlab, TRUE) : m_pARcBridgeDataStd->m_Fy;
		pRB->m_sDescription.Format("지점%d %s거더부 수평전단철근", nJ+1, strSlab);
		pRB->m_sMark		= GetMarkRebarEtc(G_REBAR_HORV, FALSE, TRUE, FALSE, "", TRUE);
		pRB->m_dDia			= pGirder->m_dDiaSide;
		pRB->m_nTypeRebar	= 22;

		// 수평전단철근 너비 
		CDRect rect	= tvArr.GetRect();
		disMaxB		= rect.Width();
		disMinB		= 0;
		pRB->m_dLengthMax_A		= tvArrUpper.GetLengthMax();
		pRB->m_dLengthMin_A		= 0;
		pRB->m_dLengthMax_B		= disMaxB;
		pRB->m_dLengthMin_B		= 0;
		
		// 철근지름에 의한 길이 보정 
		pRB->m_dLengthMax_A += 2*ConstPi*(pRB->m_dDia/2+pGirder->m_dDiaStirrup/2)/2;

		pRB->m_bMainRebar	= FALSE;
		pRB->m_dRateAdd		= MAKE_RATE;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dSpace);
		if (pRB->m_nJoint%2!=0)
			pRB->m_nJoint += 1;	
		long nCountOneLine	= 0;	// 스트럽 한 라인당 수평철근 개수
		nCountOneLine	= pGirder->m_dF1 > 0 ? 1 : 0;
		nCountOneLine	+= pGirder->m_nE*pGirder->m_dF > 0 ? pGirder->m_nE : 0;
		pRB->m_nEa	= nCountOneLine;
		baseConc.OptimizationRebar(pRB);
		AddOrDeleteRebarInList(&m_pArrRebarGirder, pRB);
		// 거더 좌우측 수평전단철근 /////////////////////////////////////

		// 거더 내측 수평전단철근 ////////////////////////////////////////
		pRB					= new CRebar;
		pRB->m_Fy			=  bLsd? GetValueFy(ePartUpperSlab, TRUE) : m_pARcBridgeDataStd->m_Fy;
		pRB->m_sDescription.Format("지점%d %s거더부 내측 수평전단철근", nJ+1, strSlab);
		pRB->m_sMark		= GetMarkRebarEtc(G_REBAR_HORV_I, FALSE, TRUE, FALSE, "", TRUE);
		pRB->m_dDia			= pGirder->m_dDiaSide_I;
		pRB->m_dLengthMax_A	= tvArrUpper.GetLengthMax();
		pRB->m_dLengthMin_B	= 0;
		/*
		pRB->m_dLengthMax_A = pRB->m_dLengthMax_A + pRB->m_dDia;
		if(!Compare(pRB->m_dLengthMin_A, 0.0, "="))
			pRB->m_dLengthMin_A	= pRB->m_dLengthMin_A + pRB->m_dDia;
			*/
		double D			= pRB->m_dDia;
		pRB->m_R			= RoundUp(3*D/10, 0) * 10;
		pRB->m_dLengthMax_B = 2*pRB->m_R*ConstPi*135/360;
		pRB->m_dLengthMin_B	= 0;
		pRB->m_dLengthMax_C = RoundUp(6*D/10, 0) * 10;
		pRB->m_dLengthMin_C	= 0;
		pRB->m_dLengthMax_D	= 0;
		pRB->m_dLengthMin_D	= 0;
		pRB->m_nTypeRebar	= 61;
		pRB->m_bMainRebar	= FALSE;
		pRB->m_dRateAdd		= MAKE_RATE;
		m_Util.SetLengthRebar(pRB,JOINT_TENS_NORMAL_B, dCover, dSpace);
		pRB->m_nEa			= (pGirder->m_nCountStirrup*2-2) * nCountOneLine;
		AddOrDeleteRebarInList(&m_pArrRebarGirder, pRB);
		// 거더 내측 수평전단철근 ////////////////////////////////////////

		// 거더 상하부 보강철근 ///////////////////////////////////////////
		CDPointArray xyArr, xyArrDirApplyScale;
		long upper = 0; for(upper = 0; upper < 2; upper++)
		{
			BOOL bUpper	= upper == iUPPER;
			CString sUpper	= bUpper ? "상면" : "하면";
			long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
			{
				long nTypeRebar	= bUpper ? G_REBAR_M_U1+dan : G_REBAR_M_L1+dan;
				if(dan == 0)
					GetxyRebarSupport_SlabGirder(xyArr, xyArrDirApplyScale, upper, nJ,  bStt, bLeft, bGagak, bJongGirder, bUpperSlabGirder);
				else
					GetXyRebarSupport_SlabGirderInner(xyArr, nJ, upper, dan, bStt, bLeft, bGagak, bJongGirder);

				if(xyArr.GetSize() == 0) continue;
				
				pRB					= new CRebar;
				pRB->m_Fy			=  bLsd? GetValueFy(ePartUpperSlab, TRUE) : m_pARcBridgeDataStd->m_Fy;
				pRB->m_sDescription.Format("지점%d %s거더부 %s 주철근 %d단", nJ+1, strSlab, sUpper, dan+1);
				pRB->m_sMark		= GetMarkRebarEtc(nTypeRebar, FALSE, TRUE, FALSE, "", TRUE);
				pRB->m_dDia			= pGirder->m_dDiaUL[upper][dan];
				pRB->m_dLengthMax_A	= bUpper ? tvArrUpper.GetLengthMax() : tvArrLower.GetLengthMax();
				pRB->m_dLengthMin_A	= bUpper ? tvArrUpper.GetLengthMin() : tvArrLower.GetLengthMax();
				pRB->m_nTypeRebar	= 1;
				pRB->m_bMainRebar	= TRUE;
				pRB->m_dRateAdd		= MAKE_RATE;
				SetRebarLsdOptionGirderMain(pRB->m_pOptionLsd, bUpper, nJ, bLeft, FALSE, bJongGirder, FALSE, bUpperSlabGirder, bUpper, dan);
				if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
				m_Util.SetLengthRebar(pRB,JOINT_TENS_NORMAL_B, dCover, dSpace);
				pRB->m_nEa			= xyArr.GetSize();
				AddOrDeleteRebarInList(&m_pArrRebarGirder, pRB);
			}
		}
		// 거더 상하부 보강철근 ///////////////////////////////////////////
	}
}

// 보기둥 철근 집계
void CRcBridgeRebar::SetDataDefaultRebarJewonColumnAndGirderStd()
{
	// 보기둥 철근 클리어
	// 기둥 철근
	long nCountInWall	= GetCountInWall();
	long nLastNum	= 0;

	for(long wall = 0; wall < nCountInWall; wall++)
	{
		CWallApp *pWall	= GetInWall(wall);
		if(pWall)
		{
			if(pWall->m_bTopIsColumn)
			{
				pWall->m_nTypeAddRate.Attach(&m_nTypeAddRate);		// 0 : 직경별, 1 : 주철근,기타철근
				pWall->m_dAddRateLower.Attach(&m_dAddRateLower);		// 하위 할증률
				pWall->m_dAddRateUpper.Attach(&m_dAddRateUpper);		// 상위 할증률
				pWall->m_dAddRateDiaOrg.Attach(&m_dAddRateDiaOrg);	// 직경별일경우 기준 직경

				pWall->SetDataDefaultRebarJewonColumn(wall==0 ? nLastNum+1 : -1, wall + 1);
			}
		}
	}

	// 거더철근 클리어
	ClearRebarList(4);
	GetMarkRebarEtc(0, FALSE, TRUE, TRUE, "" , TRUE);
	SetDataDefaultRebarJewon_Girder_All(TRUE);
	if(IsBoxType())
		SetDataDefaultRebarJewon_Girder_All(FALSE);
	SetDataDefaultRebarJewon_GirderJong_All();
}


// 시종점 부상방지저판 철근
void CRcBridgeRebar::MakeRebarInfoCycle_BFooting(long nVertDir)
{
	AhTPADelete(&m_pArrRCMainBoxLowerPRF_Cycle1[iSTT], (CRebarInfoCycle*)0);
	AhTPADelete(&m_pArrRCMainBoxLowerPRF_Cycle1[iEND], (CRebarInfoCycle*)0);
	AhTPADelete(&m_pArrRCMainBoxLowerPRF_Cycle2[iSTT], (CRebarInfoCycle*)0);
	AhTPADelete(&m_pArrRCMainBoxLowerPRF_Cycle2[iEND], (CRebarInfoCycle*)0);

	BOOL bVertDir	= IsVertDir();
	if(nVertDir!=0)
		bVertDir	= nVertDir == -1 ? TRUE : FALSE;

	GetMarkRebarEtc(BF_REBAR_M, FALSE, TRUE, TRUE);
	long cycle = 0; for(cycle = 0; cycle < 2; cycle++)
	{
		long stt = 0; for(stt = 0; stt < 2; stt++)
		{
			BOOL bStt		= stt == iSTT;
			double sw = bStt ? 1.0 : -1.0;
			if(!m_bExistProtectionRiseFooting || (cycle>0 && m_bPRF_SameCTC_Main)) continue;

			CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC	= bStt ? &m_pArrRCMainBoxLowerPRF_Cycle1[stt] : &m_pArrRCMainBoxLowerPRF_Cycle1[iEND];
			if(cycle == 1)
				pArrRC	= bStt ? &m_pArrRCMainBoxLowerPRF_Cycle2[stt] : &m_pArrRCMainBoxLowerPRF_Cycle2[iEND];

			pArrRC->Add(new CRebarInfoCycle);

			CRebarInfoCycle *pRC	= pArrRC->GetAt(pArrRC->GetSize()-1);
			pRC->m_xyStt	= pRC->m_xyMid1 = pRC->m_xyMid2 = pRC->m_xyEnd = CDPoint(0, 0);
			pRC->m_Dia		= m_dPRF_Dia_Main;
			pRC->m_bUseTvArrRebar	= FALSE;
			pRC->m_tvArrRebar.RemoveAll();

			CString sStt	= bStt ? "시점" : "종점";
			CDPoint vAng	= bVertDir ? CDPoint(0, 1) : GetAngleJijum(bStt ? 0 : m_nQtyJigan);
			double dCover	= m_dCoverWallOut[0] / vAng.y;
			pRC->m_szMark	= GetMarkRebarEtc(BF_REBAR_M, FALSE, TRUE, FALSE);

			// 마크기호를 집계할때와 맞춰주기 위해서 부득이하게 임의로 넘버를 증가시킴 //////
			GetMarkRebarEtc(BF_REBAR_M, FALSE, TRUE, FALSE);	// 배력근용 마크
			GetMarkRebarEtc(BF_REBAR_M, FALSE, TRUE, FALSE);	// 전단철근용 마크pRC->m_xyStt
			/////////////////////////////////////////////////////////////////////////////////

			CDPoint xyMatch(0, 0), xyInner(0, 0);
			CTwinVector tvUpper, tvSide, tvLower;

			tvUpper	= m_tvArrVertSection.GetTvByInfo(sStt+"부상방지저판상면");
			tvSide	= m_tvArrVertSection.GetTvByInfo(sStt+"부상방지저판바깥측면");
			tvLower	= m_tvArrVertSection.GetTvByInfo(sStt+"부상방지저판하단");
			//tvInner	= GetTvOffset_OutWall(0, bStt, TRUE, bVertDir);

			xyInner.y = tvLower.m_v1.y;
			xyInner.x = GetStationOnJijum(bStt ? 0 : m_nQtyJigan) + -sw * (m_dCoverWallIn[0]/vAng.y);
			if( (bStt && xyInner.x < tvUpper.GetXyLeft().x) || (bStt == FALSE && xyInner.x > tvUpper.GetXyRight().x) )
				xyInner.x = bStt? GetTvOffset_OutWall(0, bStt, TRUE, bVertDir).GetXyLeft().x : GetTvOffset_OutWall(0, bStt, TRUE, bVertDir).GetXyRight().x ;

			// offset
			Offset(tvUpper.m_v1, tvUpper.m_v2, sw * m_dCoverUpper_LowerSlab[0]);
			Offset(tvSide.m_v1, tvSide.m_v2, sw * m_dCoverSide_Footing[0]);
			Offset(tvLower.m_v1, tvLower.m_v2, sw * m_dCoverLower_LowerSlab[0]);

			// 교차점 정리
			CDPoint xyMatchUpper, xyMatchLower, xyMatchMid[2];
			GetXyMatchLineAndLine(tvUpper.m_v1, tvUpper.GetXyDir(), xyInner, CDPoint(0, 1), xyMatchUpper);
			GetXyMatchLineAndLine(tvLower.m_v1, tvLower.GetXyDir(), xyInner, CDPoint(0, 1), xyMatchLower);
			GetXyMatchLineAndLine(tvUpper.m_v1, tvUpper.GetXyDir(), tvSide.m_v1, CDPoint(0, 1), xyMatchMid[0]);
			GetXyMatchLineAndLine(tvLower.m_v1, tvLower.GetXyDir(), tvSide.m_v1, CDPoint(0, 1), xyMatchMid[1]);

			tvUpper.m_v1 = xyMatchMid[0];
			tvUpper.m_v2 = xyMatchUpper;
			tvSide.m_v1 = xyMatchMid[1];
			tvSide.m_v2 = xyMatchMid[0];
			tvLower.m_v1 = xyMatchLower;
			tvLower.m_v2 = xyMatchMid[1];

			// 철근 생성
			pRC->m_tvArrRebar.Add(tvUpper);
			pRC->m_tvArrRebar.Add(tvSide);
			pRC->m_tvArrRebar.Add(tvLower);

			pRC->m_R_Mid	= 0;
			pRC->m_nPosStt	= bStt ? REBARINFO_POS_STTWALL_OUTTER : REBARINFO_POS_ENDWALL_OUTTER;
			pRC->m_nPosEnd	= pRC->m_nPosStt;
			pRC->m_bUseTvArrRebar	= TRUE;
		}
	}
}

//부상방지저판 수평철근
long CRcBridgeRebar::GetXyRebarSupport_VertSection_BFooting(CDPointArray &xyArr, BOOL bStt, double dDomScale, BOOL bOnlyLower)
{
	xyArr.RemoveAll();
	if(!m_bExistProtectionRiseFooting) return 0;

	BOOL bVertDir	= IsVertDir();
	long stt		= bStt ? iSTT : iEND;
	double sw = bStt ? -1.0 : 1.0;
	CString sStt = bStt ? "시점" : "종점";
	CDPoint vAng = bVertDir ? CDPoint(0, 1) : GetAngleJijum(bStt ? 0 : m_nQtyJigan);

	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = &m_pArrRCMainBoxLowerPRF_Cycle1[stt];
	if(pArrRC->GetSize() == 0) pArrRC = &m_pArrRCMainBoxLowerPRF_Cycle2[stt];
	if(pArrRC->GetSize() == 0) return 0;
	CRebarInfoCycle *pRC	= pArrRC->GetAt(0);

	//외측벽체 철근 좌표 가져오기
	double nxPosInWall = GetStationOnJijum(bStt ? 0 : m_nQtyJigan);
	double nThickWall = m_dWS / vAng.y;
	double xPosOutWall = nxPosInWall + sw * (nThickWall - m_dCoverWallIn[0]/vAng.y);

	//부상방지저판 주철근 좌표
	CTwinVectorArray tvArrBFooting;
	tvArrBFooting.AddFromTvArray(pRC->m_tvArrRebar);

	CTwinVector tvUpper, tvLower, tvSide;
	tvUpper= tvArrBFooting.GetTvByInfo(sStt+"부상방지저판상면");
	tvSide = tvArrBFooting.GetTvByInfo(sStt+"부상방지저판바깥측면");
	tvLower= tvArrBFooting.GetTvByInfo(sStt+"부상방지저판하단");
	
	CDPoint xyUpper(0,0),xyLower(0,0),xyLeft(0,0);
	long nRebarCount = 0;
	long nCountHori = 0;
	CDPoint xyPos = tvSide.GetXyMid();
	CDPoint xyStt = tvSide.m_v2;
	//수평
	while(1)
	{
		if(m_dPRF_CTC_Support < 0) break;
		xyPos.x = xyStt.x - nRebarCount*m_dPRF_CTC_Support*sw;
		if(bStt && xyPos.x >= xPosOutWall) break;
		if(!bStt && xyPos.x <= xPosOutWall) break;

		GetXyMatchLineAndLine(tvUpper.m_v1, tvUpper.GetXyDir(), xyPos, CDPoint(0,1), xyUpper);
		GetXyMatchLineAndLine(tvLower.m_v1, tvLower.GetXyDir(), xyPos, CDPoint(0,-1), xyLower);

		if(nRebarCount == 0)
		{
			xyUpper.x -= REBAR_SYMBOL_RADIUS*dDomScale/50.0*sw;
			xyLower.x -= REBAR_SYMBOL_RADIUS*dDomScale/50.0*sw;
		}
		xyUpper.y -= REBAR_SYMBOL_RADIUS*dDomScale/50.0;
		xyLower.y += REBAR_SYMBOL_RADIUS*dDomScale/50.0;
		if(!bOnlyLower) xyArr.Add(xyUpper);
		xyArr.Add(xyLower);
		nRebarCount++;
	}
	nCountHori = nRebarCount;

	//수직
	nRebarCount = 1;
	xyPos.x = tvSide.m_v1.x;
	while(1)
	{
		if(m_dPRF_CTC_SupportVert<0) break;
		xyPos.y = tvSide.m_v2.y - nRebarCount*m_dPRF_CTC_SupportVert;
		if(xyPos.y <= tvSide.m_v1.y + MIN_REBAR_SPACE) break;

		GetXyMatchLineAndLine(tvSide.m_v1, tvSide.GetXyDir(), xyPos, CDPoint(1,0), xyLeft);
		xyLeft.x -= REBAR_SYMBOL_RADIUS*dDomScale/50.0*sw;
		if(!bOnlyLower) 
		{
			xyArr.Add(CDPoint(xyLeft));
		}
		nRebarCount++;
	}
	return nCountHori;
}

// 부상방지저판 전단철근
long CRcBridgeRebar::GetTvRebarShear_VertSection_BFooting(CTwinVectorArray &tvArr, BOOL bStt)
{
	tvArr.RemoveAll();
	if(!m_bExistProtectionRiseFooting) return 0;

	BOOL bVertDir	= IsVertDir();
	long stt		= bStt ? iSTT : iEND;
	double se			= bStt ? -1.0 : 1.0;
	CString sStt	= bStt ? "시점" : "종점";

	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = &m_pArrRCMainBoxLowerPRF_Cycle1[stt];
	if(pArrRC->GetSize() == 0) pArrRC = &m_pArrRCMainBoxLowerPRF_Cycle2[stt];
	if(pArrRC->GetSize() == 0) return 0;
	CRebarInfoCycle *pRC	= pArrRC->GetAt(0);

	CDPoint vAng	= bVertDir ? CDPoint(0, 1) : GetAngleJijum(bStt ? 0 : m_nQtyJigan);
	
	//부상방지저판 주철근 좌표
	CTwinVectorArray tvArrBFooting;
	tvArrBFooting.AddFromTvArray(pRC->m_tvArrRebar);

	//외측벽체 철근 좌표 가져오기
	double nxPosInWall = GetStationOnJijum(bStt ? 0 : m_nQtyJigan);
	double nThickWall = m_dWS / vAng.y;
	double nxPosOutWall = nxPosInWall + se * (nThickWall - m_dCoverWallIn[0]/vAng.y);
	double dCtcShear   = m_dPRF_CTC_Shear; 

	CTwinVector tvUpper, tvLower, tvSide, tvShear;
	tvUpper= tvArrBFooting.GetTvByInfo(sStt+"부상방지저판상면");
	tvSide = tvArrBFooting.GetTvByInfo(sStt+"부상방지저판바깥측면");
	tvLower= tvArrBFooting.GetTvByInfo(sStt+"부상방지저판하단");

	CDPoint xyPos = tvLower.m_v1;
	xyPos.x = tvSide.m_v1.x;

	long nCountShear = 0;
	//시종점 증가가 반대로됨.
	se = se * -1;
	if(m_dPRF_Dia_Shear > 0 && dCtcShear>0)
	{
		while(1)
		{
			xyPos.x += se * m_dPRF_CTC_Shear;
			if(bStt && xyPos.x > nxPosOutWall) break;
			if(!bStt && xyPos.x < nxPosOutWall) break;

			GetXyMatchLineAndLine(xyPos, CDPoint(0,1), tvUpper.m_v1, tvUpper.GetXyDir(), tvShear.m_v1);
			GetXyMatchLineAndLine(xyPos, CDPoint(0,1), tvLower.m_v1, tvLower.GetXyDir(), tvShear.m_v2);

			tvArr.Add(tvShear);
			nCountShear++;
		}
	}
	return nCountShear;
}

// 시종점 브라켓 철근 
void CRcBridgeRebar::MakeRebarInfoCycle_OutWall_Bracket(long nVertDir)
{
	AhTPADelete(&m_pArrRCMainOutWallBracket_Cycle1[iSTT], (CRebarInfoCycle*)0);
	AhTPADelete(&m_pArrRCMainOutWallBracket_Cycle1[iEND], (CRebarInfoCycle*)0);
	AhTPADelete(&m_pArrRCMainOutWallBracket_Cycle2[iSTT], (CRebarInfoCycle*)0);
	AhTPADelete(&m_pArrRCMainOutWallBracket_Cycle2[iEND], (CRebarInfoCycle*)0);

	BOOL bVertDir	= IsVertDir();
	if(nVertDir!=0)
		bVertDir	= nVertDir == -1 ? TRUE : FALSE;

	GetTvVertSection_Std(0, !bVertDir, FALSE, FALSE);

	GetMarkRebarEtc(BR_REBAR_M, FALSE, TRUE, TRUE);
	long cycle = 0; for(cycle = 0; cycle < 2; cycle++)
	{
		long stt = 0; for(stt = 0; stt < 2; stt++)
		{
			BOOL bStt		= stt == iSTT;
			if(!IsBracketRebar(bStt, cycle)) continue;

			CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC	= bStt ? &m_pArrRCMainOutWallBracket_Cycle1[stt] : &m_pArrRCMainOutWallBracket_Cycle1[iEND];
			if(cycle == 1)
				pArrRC	= bStt ? &m_pArrRCMainOutWallBracket_Cycle2[stt] : &m_pArrRCMainOutWallBracket_Cycle2[iEND];

			pArrRC->Add(new CRebarInfoCycle);
			
			CRebarInfoCycle *pRC	= pArrRC->GetAt(pArrRC->GetSize()-1);
			pRC->m_xyStt	= pRC->m_xyMid1 = pRC->m_xyMid2 = pRC->m_xyEnd = CDPoint(0, 0);
			pRC->m_Dia		= cycle == 0 ? m_dDiaRebarMain_Bracket_Cycle1[stt] : m_dDiaRebarMain_Bracket_Cycle2[stt];
			pRC->m_bUseTvArrRebar	= FALSE;
			pRC->m_tvArrRebar.RemoveAll();

			
			CString sStt	= bStt ? "시점" : "종점";
			CDPoint vAng	= bVertDir ? CDPoint(0, 1) : GetAngleJijum(bStt ? 0 : m_nQtyJigan);
			double dCover	= m_dCoverWallOut[0] / vAng.y;
			pRC->m_szMark	= GetMarkRebarEtc(BR_REBAR_M, FALSE, TRUE, FALSE);

			// 마크기호를 집계할때와 맞춰주기 위해서 부득이하게 임의로 넘버를 증가시킴 //////
			GetMarkRebarEtc(BR_REBAR_M, FALSE, TRUE, FALSE);	// 배력근용 마크
			GetMarkRebarEtc(BR_REBAR_M, FALSE, TRUE, FALSE);	// 전단철근용 마크pRC->m_xyStt
			/////////////////////////////////////////////////////////////////////////////////

			CDPoint xyMatch(0, 0);
			CTwinVector tvUpper, tvSide, tvHunch, tvInner;

			tvUpper	= m_tvArrVertSection.GetTvByInfo(sStt+"브라켓상면");
			tvSide	= m_tvArrVertSection.GetTvByInfo(sStt+"브라켓측면");
			tvHunch	= m_tvArrVertSection.GetTvByInfo(sStt+"브라켓헌치");
			tvInner	= GetTvOffset_OutWall(0, bStt, TRUE, bVertDir);

			tvUpper.m_dAngle	= 90;
			tvSide.m_dAngle		= 90;
			tvHunch.m_dAngle	= 90;

			
			// offset
			Offset(tvUpper.m_v1, tvUpper.m_v2, dCover);
			Offset(tvSide.m_v1, tvSide.m_v2, dCover);
			Offset(tvHunch.m_v1, tvHunch.m_v2, dCover);

			// 교차점 정리
			CDPoint xy[4];
			GetXyMatchLineAndLine(tvUpper.m_v1, tvUpper.GetXyDir(), tvInner.m_v1, tvInner.GetXyDir(), xy[0]);
			GetXyMatchLineAndLine(tvUpper.m_v1, tvUpper.GetXyDir(), tvSide.m_v1, tvSide.GetXyDir(), xy[1]);
			GetXyMatchLineAndLine(tvSide.m_v1, tvSide.GetXyDir(), tvHunch.m_v1, tvHunch.GetXyDir(), xy[2]);
			GetXyMatchLineAndLine(tvHunch.m_v1, tvHunch.GetXyDir(), tvInner.m_v1, tvInner.GetXyDir(), xy[3]);
			tvUpper.m_v1	= xy[0];
			tvUpper.m_v2	= xy[1];
			tvSide.m_v1		= xy[1];
			tvSide.m_v2		= xy[2];
			tvHunch.m_v1	= xy[2];
			tvHunch.m_v2	= xy[3];

			// 철근 생성
			pRC->m_tvArrRebar.Add(tvUpper);
			pRC->m_tvArrRebar.Add(tvSide);
			pRC->m_tvArrRebar.Add(tvHunch);

			pRC->m_R_Mid	= 0;
			pRC->m_nPosStt	= bStt ? REBARINFO_POS_STTWALL_OUTTER : REBARINFO_POS_ENDWALL_OUTTER;
			pRC->m_nPosEnd	= pRC->m_nPosStt;
			pRC->m_bUseTvArrRebar	= TRUE;
		}
	}

	GetTvVertSection_Std(0, !bVertDir, FALSE, TRUE);
}

// 브라켓 배력 철근
void CRcBridgeRebar::GetXyRebarSupport_VertSection_Bracket(CDPointArray &xyArr, BOOL bStt)
{
	xyArr.RemoveAll();
	if(!IsOutWall(bStt)) return;
	if(!IsBracket(bStt)) return;
	
	long stt		= bStt ? iSTT : iEND;
	CString sStt	= bStt ? "시점" : "종점";
	double sw		= bStt ? 1 : -1;

	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = &m_pArrRCMainOutWallBracket_Cycle1[stt];
	if(pArrRC->GetSize() == 0) pArrRC = &m_pArrRCMainOutWallBracket_Cycle2[stt];
	if(pArrRC->GetSize() == 0) return;
	
	CRebarInfoCycle *pRC	= pArrRC->GetAt(0);
	CTwinVectorArray tvArrBracket;
	tvArrBracket.AddFromTvArray(pRC->m_tvArrRebar);
	CTwinVector tvSide	= tvArrBracket.GetTvByInfo(sStt + "브라켓측면");
	CTwinVector tvHunch	= tvArrBracket.GetTvByInfo(sStt + "브라켓헌치");
	CDPoint xy	= tvSide.GetXyTop();
	xy.x += REBAR_RADIUS*sw;
	xy.y -= REBAR_RADIUS;
	xyArr.Add(xy);

	xy	= tvSide.GetXyBottom();
	double dAngHunch	= tvHunch.GetXyDir().GetAngleDegree()-360;
	double dAngSide		= tvSide.GetXyDir(TRUE).GetAngleDegree();
	double dAng			= dAngHunch + (dAngSide-dAngHunch)/2;

	xy	+= ToDPointFrDegree(dAng) * REBAR_RADIUS * sw;
	
	xyArr.Add(xy);
}

// 브라켓 전단철근(사실 전단철근인지 그냥 보강철근인지 명확하지 않음)
void CRcBridgeRebar::GetTvRebarShear_VertSection_Bracket(CTwinVectorArray &tvArr, BOOL bStt)
{
	tvArr.RemoveAll();
	if(!IsOutWall(bStt)) return;

	BOOL bVertDir	= IsVertDir();
	long stt		= bStt ? iSTT : iEND;
	CString sStt	= bStt ? "시점" : "종점";

	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = &m_pArrRCMainOutWallBracket_Cycle1[stt];
	if(pArrRC->GetSize() == 0) pArrRC = &m_pArrRCMainOutWallBracket_Cycle2[stt];
	if(pArrRC->GetSize() == 0) return;

	CRebarInfoCycle *pRC	= pArrRC->GetAt(0);

	CTwinVectorArray tvArrBracket;
	tvArrBracket.AddFromTvArray(pRC->m_tvArrRebar);
	CTwinVector tvInner	= GetTvOffset_OutWall(0, bStt, TRUE, bVertDir);
	CTwinVector tv;
	CDRect rect	= tvArrBracket.GetRect();
	tv.m_v1.x	= bStt ? rect.left : rect.right;
	tv.m_v1.y	= rect.bottom;
	tv.m_v2.x	= tvInner.m_v1.x;
	tv.m_v2.y	= rect.bottom;
	
	CRebarPlacing rb;
	CDPointArray xyArrMatch;
	m_placeByBlock_ShearRebar_Bracket[stt].FitCount();
	long i = 0; for(i = 0; i < m_placeByBlock_ShearRebar_Bracket[stt].m_nCountBlock; i++)
	{
		CDPoint xyR	= m_placeByBlock_ShearRebar_Bracket[stt].m_xyArr.GetAt(i);
		long j = 0; for(j = 0; j < xyR.x; j++)
		{
			tv.m_v1.y += xyR.y;
			tv.m_v2.y += xyR.y;
			
			rb.GetXyMatchTvArrAndLine(tvArrBracket, tv.m_v1, CDPoint(1, 0), xyArrMatch);
			if(xyArrMatch.GetSize() > 0)
				tv.m_v1	= xyArrMatch.GetAt(0);

			tvArr.Add(tv);
		}
	}
}

// 브라켓 철근들..
void CRcBridgeRebar::SetDataDefaultRebarJewon_Bracket_All()
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();
	const double dMulti = bLsd? 10 : 1;

	CHgBaseConcStd baseConc;
	CBasicConcInfo concInfo;
	double dCover	= m_dCoverWallOut[0];
	double dSpace	= GetCtcRebarMain();

	long stt = 0; for(stt = 0; stt < 2; stt++)
	{
		BOOL bStt		= stt == iSTT;
		CString sStt	= bStt ? "시점" : "종점";
		if(!IsOutWall(bStt)) continue;
		
		// 브라켓 주철근
		long cycle = 0; for(cycle = 0; cycle < 2; cycle++)
		{
			CTwinVectorArray tvArrBracketMain;
			GetTvRebarMain_Plane_UpperSlabBracket(tvArrBracketMain, bStt, cycle);

			CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = cycle == 0 ? &m_pArrRCMainOutWallBracket_Cycle1[stt] : &m_pArrRCMainOutWallBracket_Cycle2[stt];
			if(pArrRC->GetSize() == 0) continue;
			CRebarInfoCycle *pRC	= pArrRC->GetAt(0);

			CTwinVector tvUpper	= pRC->m_tvArrRebar.GetTvByInfo(sStt+"브라켓상면");
			CTwinVector tvSide	= pRC->m_tvArrRebar.GetTvByInfo(sStt+"브라켓측면");
			CTwinVector tvHunch	= pRC->m_tvArrRebar.GetTvByInfo(sStt+"브라켓헌치");

			double dCoverTot	= m_dCoverWallIn[0] + m_dCoverWallOut[0];
			double dW			= bStt ? m_dWS : m_dWE;
			double dBW			= bStt ? m_dBHWS : m_dBHWE;
			double dBH			= bStt ? m_dBHHS : m_dBHHE;
			double dRate		= sqrt((dBH*dBH) + (dBW*dBW)) / dBW;
						
			CRebar *pRB	= new CRebar;
			pRB->m_Fy			= bLsd? GetValueFy(bStt? ePartOutWallStt : ePartOutWallEnd) : m_pARcBridgeDataStd->m_Fy;
			pRB->m_sMark		= GetMarkRebarEtc(BR_REBAR_M, FALSE, TRUE, FALSE);
			pRB->m_sDescription.Format("%s 브라켓 주철근%s", sStt, m_pARcBridgeDataStd->GetStringCircleNum(cycle+1));
			pRB->m_dDia			= cycle == 0 ? m_dDiaRebarMain_Bracket_Cycle1[stt] : m_dDiaRebarMain_Bracket_Cycle2[stt];
			pRB->m_nTypeRebar	= 101;
			pRB->m_dLengthMax_A	= dW + dBW - dCoverTot;
			pRB->m_dLengthMax_B	= tvSide.GetLength();
			pRB->m_dLengthMax_C	= pRB->m_dLengthMax_A * dRate;
			pRB->m_dLengthMax_D	= 100;


			tvHunch.Sort(FALSE, TRUE);
			if(bStt)
				pRB->m_dAngleX1	= 450 - tvHunch.GetXyDir().GetAngleDegree();
			else
				pRB->m_dAngleX1	= tvHunch.GetXyDir().GetAngleDegree() - 90;
			
			pRB->m_nEa			= tvArrBracketMain.GetSize();
			baseConc.OptimizationRebar(pRB);			
			m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dSpace);
			pRB->m_dRateAdd	= MAKE_RATE;
			AddOrDeleteRebarInList(&m_pArrRebarEtc, pRB);
		}

		// 브라켓 배력근은 편경사 먹지 않음
		
		/*
		// 편구배 고려된 길이와 평면상 길이와의 비율을 계산해서 평면상의 길이에 적용하자!!! ///
		CTwinVectorArray tvArrCross;
		GetTvCrossSection(tvArrCross, bStt ? m_dStationBridgeStt : m_dStationBridgeStt + m_dLengthBridge, CDPoint(0, 1), FALSE, FALSE, FALSE, 0, FALSE, FALSE, FALSE, TRUE);
		double dRateLenPyungSlopAndPlane	= tvArrCross.GetLength() / tvArrCross.GetHorLength();
		//////////////////////////////////////////////////////////////////////////////////////////
		*/


		
		CDPointArray xyArr;
		CDPoint vAng	= GetAngleByTarget(bStt ? BRIDGE_OFF_STT_SLAB : BRIDGE_OFF_END_SLAB, 0);
		double dWidth	= GetLengthBracket(bStt);
		GetXyRebarSupport_VertSection_Bracket(xyArr, bStt);

		CRebar *pRB	= new CRebar;
		pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
		pRB->m_sMark	= GetMarkRebarEtc(BR_REBAR_M, FALSE, TRUE, FALSE);
		pRB->m_sDescription.Format("%s 브라켓 배력철근", sStt);
		pRB->m_dDia		= m_dDiaRebarSupport_Bracket[stt];
		pRB->m_nTypeRebar	= 1;
		pRB->m_dLengthMax_A	= (dWidth - m_dCoverSide_UpperSlab[0] * 2);	// 길이 다시 산정해야 됨
		pRB->m_nEa			= xyArr.GetSize();
		baseConc.OptimizationRebar(pRB);
		SetRebarLsdOptionOutWallBracketSupport(pRB->m_pOptionLsd, bStt);
		if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dSpace);
		pRB->m_dRateAdd	= MAKE_RATE;
		AddOrDeleteRebarInList(&m_pArrRebarEtc, pRB);

		// 브라켓 전단철근
		CDPoint vAngLineOfShear	= bStt ? GetAngleJijum(0) : GetAngleJijum(m_nQtyJigan);
		double dCTC		= m_nTypePlacingMainRebar_UpperSlab == 0? GetCtcRebarMain(TRUE)/2/ vAngLineOfShear.y : GetCtcRebarMain(TRUE)/2;
		//double dCTC		= GetCtcRebarMain(TRUE)/2/vAngLineOfShear.y;

		// 브라켓 철근 2cycle이 없는 경우..
		if(!m_bIsBracketRebar[1][stt])
			dCTC *= 2;

		double dCover	= GetCoverSide_UpperSlab(0);
		CTwinVectorArray tvArrVert;
		CTwinVectorArray tvArrPlane;
		GetTvRebarShear_VertSection_Bracket(tvArrVert, bStt);
		pRB	= new CRebar;
		pRB->m_Fy			= bLsd? GetValueFy(bStt? ePartOutWallStt : ePartOutWallEnd, TRUE) : m_pARcBridgeDataStd->m_Fy;
		pRB->m_sMark	= GetMarkRebarEtc(BR_REBAR_M, FALSE, TRUE, FALSE);
		pRB->m_sDescription.Format("%s 브라켓 전단철근", sStt);
		
		double dWidthMax	= (dCTC * m_nCountWrapMainRebarForBracket[stt]);
		double dWidthMin	= dWidthMax;
		double dHeightMax	= tvArrVert.GetLengthMax();
		double dHeightMin	= tvArrVert.GetLengthMin();
		m_RebarShearDetail_Bracket[stt].SetRB(pRB, m_dDiaRebarMain_Bracket_Cycle1[stt], GetDiaMainRebarOutWall(0, 0, bStt, TRUE, 0), dWidthMax, dHeightMax, 0);
		m_RebarShearDetail_Bracket[stt].SetMin(dWidthMin, dHeightMin);
		m_RebarShearDetail_Bracket[stt].SetDataDefaultRebarJewon();
		pRB->m_bMainRebar	= FALSE;
		pRB->m_nEa		= (long)(((dWidth - dCover) / (dCTC * m_nCountWrapMainRebarForBracket[stt])) * tvArrVert.GetSize());
		pRB->m_dRateAdd	= MAKE_RATE;
		AddOrDeleteRebarInList(&m_pArrRebarEtc, pRB);
	}
}

// 평면 브라켓 주철근
void CRcBridgeRebar::GetTvRebarMain_Plane_UpperSlabBracket(CTwinVectorArray &tvArr, BOOL bStt, long nCycle)
{
	tvArr.RemoveAll();

	// 브라켓 주철근도 상부슬래브 주철근과 ctc가 같으므로 구지 따로 구할 필요 없이
	CTwinVectorArray tvArrHidden;
	GetTvRebarMain_Plane_Slab_Ortho(tvArr, tvArrHidden, nCycle, TRUE, bStt, FALSE, 0, FALSE, FALSE, 0, TRUE);
}

// 평면 단부 주철근(상부슬래브 주철근과 함께 감)
// void CRcBridgeRebar::GetTvRebarMain_Plane_UpperSlabDanBu(CTwinVectorArray &tvArr, BOOL bStt, long nDan, long nCycle)
// {
// 	tvArr.RemoveAll();
// 
// 	// 브라켓 주철근도 상부슬래브 주철근과 ctc가 같으므로 구지 따로 구할 필요 없이
// 	CTwinVectorArray tvArrHidden;
// 	GetTvRebarMain_Plane_Slab_Ortho(tvArr, tvArrHidden, nCycle, FALSE, FALSE, FALSE, 0, bStt, !bStt, nDan, TRUE);
// }

// 평면도 브라켓 배력철근(브라켓은 배력철근 한줄 밖에 없으므로 외측벽체 배력철근 포함시킴)
void CRcBridgeRebar::GetTvRebarSupport_Plane_UpperSlabBracket(CTwinVectorArray &tvArr, BOOL bStt, long nVertDir)
{
	tvArr.RemoveAll();

	BOOL bVertDir	= IsVertDir();
	if(nVertDir!=0)
		bVertDir	= nVertDir == -1 ? TRUE : FALSE;

	long stt		= bStt ? iSTT : iEND;
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = &m_pArrRCMainOutWallBracket_Cycle1[stt];
	if(pArrRC->GetSize() == 0) pArrRC = &m_pArrRCMainOutWallBracket_Cycle2[stt];
	if(pArrRC->GetSize() == 0) return;

	//#0031858 
	MakeRebarInfoCycle_OutWall_Bracket(nVertDir);


	// 브라켓과 외측벽체 배력근을 하나씩만 가져옴.(평면상에서 배력근을 그릴때는 주철근 중심을 기준으로 그린다.)
	CDPointArray xyArr;
	CTwinVector tv;

	if(pArrRC->GetSize() > 0)
	{
		CTwinVectorArray tvArrBracket;
		CString sStt	= bStt ? "시점" : "종점";

		tvArrBracket.AddFromTvArray(pArrRC->GetAt(0)->m_tvArrRebar);
		if(tvArrBracket.GetTvByInfo(sStt+"브라켓측면", tv))
			xyArr.Add(tv.GetXyTop());
	}

	CDPointArray xyArrSup;
	long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
	{
		GetXyRebarSupport_VertSection_OutWall(xyArrSup, bStt, TRUE, dan);
		if(xyArrSup.GetSize() > 0)
		{
			tv	= GetTvOffset_OutWall(dan, bStt, TRUE, bVertDir);
			xyArr.Add(tv.GetXyTop());
		}

		GetXyRebarSupport_VertSection_OutWall(xyArrSup, bStt, FALSE, dan);
		if(xyArrSup.GetSize() > 0)
		{
			tv	= GetTvOffset_OutWall(dan, bStt, FALSE, bVertDir);
			xyArr.Add(tv.GetXyTop());
		}
	}



	// 스테이션 이 작은 순대로 정렬
	xyArr.Sort(TRUE);

	// 지점별 배력철근 구함
	long nJ	= bStt ? 0 : m_nQtyJigan;

	GetTvRebarSupport_Plane_UpperSlab_JijumAngle(tvArr, xyArr, nJ, 0);
}

// 종단면 브라켓 배력근 sta 모음
// 주철근 마킹을 위한 sta만큼 브라켓만의 배력근으론 부족함
// 외측벽체 sta 포함시키자.
void CRcBridgeRebar::GetStaRebarSupport_UpperSlabBracket(CDoubleArray &dArrSta, BOOL bStt, long nVertDir)
{
	dArrSta.RemoveAll();

	CTwinVectorArray tvArr;
	GetTvRebarSupport_Plane_UpperSlabBracket(tvArr, bStt, nVertDir);
	long i = 0; for(i = 0; i < tvArr.GetSize(); i++)
		dArrSta.Add(tvArr.GetAt(i).m_v1.x);
}

// 사이클간 동기화 적용
// 1 -> 3, 2 -> 4
// 4cycle 지원되지 않는 경우 필요 없는 함수임
void CRcBridgeRebar::SyncCycleMainRebar(long nCycleSrc, long nCycleDest)
{
	if(nCycleSrc == 0)
	{
		if(nCycleDest != 2) return;
	}
	if(nCycleSrc == 1)
	{
		if(nCycleDest != 3) return;
	}
	
	if(GetCountCycleMainRebar() == 4)
	{
		// CYCLE1~4 ///////////////////////////////////////////////////////////////////
		// 이음 간격
		if(nCycleSrc == 0)	// 1,3사이클은 권고안을 해야 됨
		{
			// 상부슬래브
			long upper = 0; for(upper = 0; upper < 2; upper++)
			{
				BOOL bUpper	= upper == iUPPER;
				if(bUpper && m_nTypeDefaultCycle3_OutRebar == 0) continue;
				if(!bUpper && m_nTypeDefaultCycle3_UpperSlabLower == 0) continue;

				SetDataDefaultRebarInfoCycle_UpperSlab(nCycleDest, bUpper, !bUpper, FALSE, 0);
				AhTPACopy(&m_pArrDistLowerSlab[nCycleDest][upper][0], &m_pArrDistLowerSlab[nCycleSrc][upper][0], (CDoubleArray*)0);
			}

			// 외측벽체
			long stt = 0; for(stt = 0; stt < 2; stt++)
			{
				for(long inner = 0; inner < 2; inner++)
				{
					BOOL bInner	= inner == iINNER;

					if(bInner && m_nTypeDefaultCycle3_OutWallInner == 0) continue;
					if(!bInner && m_nTypeDefaultCycle3_OutRebar == 0) continue;

					SetDataDefaultRebarInfoCycle_OutWall(nCycleDest, !bInner, bInner, FALSE, 0);
				}
			}

			// 내측벽체
			long nCountInWall	= GetCountInWall();
			for(long wall = 0; wall < nCountInWall; wall++)
			{
				CWallApp *pWall	= GetInWall(wall);
				if(!pWall) continue;

				pWall->m_nTypeDefaultCycle3	= m_nTypeDefaultCycle3_OutWallInner;
				pWall->SetDataDefaultRebarInfoCycle(nCycleDest, FALSE, 0);
			}

			// 기초 
			long nCountFooting	= GetCountFooting();
			for(long footing = 0; footing < nCountFooting; footing++)
			{
				CFootingApp *pFooting	= GetFooting(footing);
				if(!pFooting) continue;

				pFooting->SetDataDefaultRebarInfoCycle(nCycleDest);
				
			}
		}
		else	// 2,4사이클은 2->4로 값을 복사하면 됨
		{
			// 상부슬래브
			long upper = 0; for(upper = 0; upper < 2; upper++)
			{
				AhTPACopy(&m_pArrDistUpperSlab[nCycleDest][upper][0], &m_pArrDistUpperSlab[nCycleSrc][upper][0], (CDoubleArray*)0);
				AhTPACopy(&m_pArrDistLowerSlab[nCycleDest][upper][0], &m_pArrDistLowerSlab[nCycleSrc][upper][0], (CDoubleArray*)0);
			}

			// 외측벽체
			long stt = 0; for(stt = 0; stt < 2; stt++)
			{
				for(long inner = 0; inner < 2; inner++)
				{
					long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
					{
						m_pArrDistOutWall[nCycleDest][stt][inner][dan]	= m_pArrDistOutWall[1][stt][inner][dan];	// 시좀점, 내외측 외측벽체 1사이클 이음 간격
					}
				}
			}

			// 내측벽체
			long nCountInWall	= GetCountInWall();
			for(long wall = 0; wall < nCountInWall; wall++)
			{
				CWallApp *pWall	= GetInWall(wall);
				if(!pWall) continue;

				long left = 0; for(left = 0; left < 2; left++)
				{
					long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
					{
						pWall->m_dArrDistRC[nCycleDest][left][dan]	= pWall->m_dArrDistRC[nCycleSrc][left][dan];
					}
				}
			}

			// 기초
			long nCountFooting	= GetCountFooting();
			for(long footing = 0; footing < nCountFooting; footing++)
			{
				CFootingApp *pFooting	= GetFooting(footing);
				if(!pFooting) continue;

				long upper = 0; for(upper = 0; upper < 2; upper++)
				{
					// 상면
					pFooting->m_dDistMainRebarVert[nCycleDest][upper]		= pFooting->m_dDistMainRebarVert[nCycleSrc][upper];	
					pFooting->m_dDistMainRebarVertExt[nCycleDest][upper]	= pFooting->m_dDistMainRebarVertExt[nCycleSrc][upper];
					pFooting->m_dDistMainRebarHor[nCycleDest][upper]		= pFooting->m_dDistMainRebarHor[nCycleSrc][upper];	
				}
			}
		}

		// 철근 지름 복사 ////////////////////////////////////////////////
		// 상부슬래브
		long upper = 0; for(upper = 0; upper < 2; upper++)
		{
			AhTPACopy(&m_pArrDiaUpperSlab[nCycleDest][upper][0], &m_pArrDiaUpperSlab[nCycleSrc][upper][0], (CDoubleArray*)0);
			AhTPACopy(&m_pArrDiaLowerSlab[nCycleDest][upper][0], &m_pArrDiaLowerSlab[nCycleSrc][upper][0], (CDoubleArray*)0);
		}

		// 외측벽체
		long stt = 0; for(stt = 0; stt < 2; stt++)
		{
			long left = 0; for(left = 0; left < 2; left++)
			{
				m_pArrDiaOutWall[nCycleDest][stt][left][0]	= m_pArrDiaOutWall[nCycleSrc][stt][left][0];		// 시종점, 좌우측 외측벽체 1사이클 철근 지름
			}
		}

		// 내측벽체
		long nCountInWall	= GetCountInWall();
		for(long wall = 0; wall < nCountInWall; wall++)
		{
			CWallApp *pWall	= GetInWall(wall);
			if(!pWall) continue;

			long left = 0; for(left = 0; left < 2; left++)
			{
				long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
				{
					pWall->m_dArrDiaRC[nCycleDest][left][dan]	= pWall->m_dArrDiaRC[nCycleSrc][left][dan];
				}
			}
		}


		// 기초
		long nCountFooting	= GetCountFooting();
		for(long footing = 0; footing < nCountFooting; footing++)
		{
			CFootingApp *pFooting	= GetFooting(footing);
			if(!pFooting) continue;

			pFooting->m_setRebarDan[iUPPER].m_dDia[nCycleDest][0]	= pFooting->m_setRebarDan[iUPPER].m_dDia[nCycleSrc][0];
			pFooting->m_setRebarDan[iLOWER].m_dDia[nCycleDest][0]	= pFooting->m_setRebarDan[iLOWER].m_dDia[nCycleSrc][0];
		}


		// 헌치부 철근
		// 헌치부 철근은 1이든 2이든 무조건 .. 적용되어야 함
		m_dArrDiaUpperSlabHunch[2]	= m_dArrDiaUpperSlabHunch[0];
		m_dArrDiaUpperSlabHunch[3]	= m_dArrDiaUpperSlabHunch[1];
		/////////////////////////////////////////////////////////////////// CYCLE1~4 //		
	}
}

// cycle3 배근방식에 따른 이음 이동 거리 리턴
// 상부슬래브 철근
// 방식 -> 
// 0 : 수동입력
// 1 : 1cycle과 같은 위치
// 2 : 우측으로 이음길이 1/2 이동
// 3 : 좌측으로 이음길이 1/2 이동
// 4 : 우측으로 이음길이 만큼 이동
// 5 : 좌측으로 이음길이 만큼 이동
double CRcBridgeRebar::GetDistMoveJointCycle13_UpperSlab(BOOL bUpper, BOOL bCycle3, long nJigan, long nJoint)
{
	if(GetCountCycleMainRebar() < 4) return 0;
	double dDist		= 0;
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;

	long cycle		= bCycle3 ? 2 : 0;
	long upper		= bUpper ? iUPPER : iLOWER;
	double dCover	= bUpper ? m_dCoverUpper_UpperSlab[0] : m_dCoverLower_UpperSlab[0];
	double dSpace	= m_dCTC_MainRebar/2;
	long nType		= bUpper && m_nSelectJointUpperRange != 2 ? JOINT_TENS_UPPER_A : JOINT_TENS_NORMAL_A;
	CDoubleArray *pDArr	= m_pArrDiaUpperSlab[cycle][upper][0][nJigan];
	double dDia		= pDArr->GetSize() > nJoint ? pDArr->GetAt(nJoint) : 0;
	double dDiaNext	= pDArr->GetSize() > nJoint+1 ? pDArr->GetAt(nJoint+1) : 0;
	double dLenJoint(0);
	if(pStd->IsLsdDesign())
	{
		SRebarEnvOption LsdRebarOpt;
		SetRebarLsdOptionSlab(&LsdRebarOpt, TRUE, bUpper, TRUE, cycle, 0);
		dLenJoint = pStd->m_pBasicConcInfo->GetValueJoint(dDia, &LsdRebarOpt);
	}
	else
	{
		dLenJoint = pStd->GetValueJoint(max(dDia, dDiaNext), nType, dCover, dSpace, 2, 1);
	}
	
	if(bUpper)
	{
		if(m_nTypeDefaultCycle3_OutRebar != 0)
		{
			dDist	= GetDistMoveJointByTypeDefaultCycle3(m_nTypeDefaultCycle3_OutRebar, dLenJoint);
		}
	}
	else
	{
		if(m_nTypeDefaultCycle3_UpperSlabLower != 0)
		{
			dDist	= GetDistMoveJointByTypeDefaultCycle3(m_nTypeDefaultCycle3_UpperSlabLower, dLenJoint);
		}
	}

	if(!bCycle3)
		dDist	= -dDist;

	return dDist;
}

// cycle3 배근방식에 따른 이음 이동 거리 리턴
// 외측벽체 철근
// 방식 -> 
// 0 : 수동입력
// 1 : 1cycle과 같은 위치
// 2 : 우측으로 이음길이 1/2 이동
// 3 : 좌측으로 이음길이 1/2 이동
// 4 : 우측으로 이음길이 만큼 이동
// 5 : 좌측으로 이음길이 만큼 이동
double CRcBridgeRebar::GetDistMoveJointCycle13_OutWall(BOOL bStt, BOOL bInner, BOOL bCycle3, long nJoint)
{
	if(GetCountCycleMainRebar() < 4) return 0;
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;

	double dDist	= 0;
	
	long cycle		= bCycle3 ? 2 : 0;
	long stt		= bStt ? iSTT : iEND;
	long inner		= bInner ? iINNER : iOUTTER;
	double dCover	= bStt ? (bInner ? m_dCoverWallIn[0] : m_dCoverWallOut[0]) : 
							(bInner ? m_dCoverWallIn[0] : m_dCoverWallOut[0]);
	double dSpace	= m_dCTC_MainRebar/2;
	long nType		= JOINT_TENS_NORMAL_A;
	CDoubleArray *pDArr	= &m_pArrDiaOutWall[cycle][stt][inner][0];
	double dDia		= pDArr->GetSize() > nJoint ? pDArr->GetAt(nJoint) : 0;
	double dDiaNext	= pDArr->GetSize() > nJoint+1 ? pDArr->GetAt(nJoint+1) : 0;
	double dLenJoint(0);
	if(pStd->IsLsdDesign())
	{
		SRebarEnvOption LsdRebarOpt;
		SetRebarLsdOptionOutWall(&LsdRebarOpt, bStt, bInner, TRUE, cycle, 0);
		pStd->m_pBasicConcInfo->GetValueJoint(max(dDia, dDiaNext), &LsdRebarOpt);
	}
	else
	{
		dLenJoint = pStd->GetValueJoint(max(dDia, dDiaNext), nType, dCover, dSpace, 2, 1);
	}

	if(bStt)
	{
		if(bInner)
		{
			if(m_nTypeDefaultCycle3_OutWallInner != 0)
			{
				dDist	= GetDistMoveJointByTypeDefaultCycle3(m_nTypeDefaultCycle3_OutWallInner, dLenJoint);
			}
		}
		else
		{
			if(m_nTypeDefaultCycle3_OutRebar != 0)
			{
				dDist	= GetDistMoveJointByTypeDefaultCycle3(m_nTypeDefaultCycle3_OutRebar, dLenJoint);
			}
		}
	}
	else
	{
		if(bInner)
		{
			if(m_nTypeDefaultCycle3_OutWallInner != 0)
			{
				dDist	= GetDistMoveJointByTypeDefaultCycle3(m_nTypeDefaultCycle3_OutWallInner, dLenJoint);
			}
		}
		else
		{
			if(m_nTypeDefaultCycle3_OutRebar != 0)
			{
				dDist	= GetDistMoveJointByTypeDefaultCycle3(m_nTypeDefaultCycle3_OutRebar, dLenJoint) * -1;
			}
		}
	}

	if(!bCycle3)
		dDist	= -dDist;

	return dDist;
}

// 타입에 따라서 이동 되어야 하는 거리 리턴
// 0 : 수동입력
// 1 : 1cycle과 같은 위치
// 2 : 우측으로 이음길이 1/2 이동
// 3 : 좌측으로 이음길이 1/2 이동
// 4 : 우측으로 이음길이 만큼 이동
// 5 : 좌측으로 이음길이 만큼 이동
double CRcBridgeRebar::GetDistMoveJointByTypeDefaultCycle3(long nTypeDefaultCycle3, double dLenJoint)
{
	if(GetCountCycleMainRebar() < 4) return 0;

	if(nTypeDefaultCycle3 == 0) return 0;
	if(nTypeDefaultCycle3 == 1) return 0;
	if(nTypeDefaultCycle3 == 2) return dLenJoint/4;
	if(nTypeDefaultCycle3 == 3) return -dLenJoint/4;
	if(nTypeDefaultCycle3 == 4) return dLenJoint/2;
	if(nTypeDefaultCycle3 == 5) return -dLenJoint/2;

	return 0;
}


// long nType
// 부위별로 철근 가져오는 함수(출력할때 사용할려고..)
// -1 : 전체
// 0 : 본체
// 1 : 중간벽체
// 2 : 기초
// 3 : 날개벽
// 4 : 상세부철근
// 5 : 기둥
// 6 : 벽식기둥식 구분하지 않음(거더철근)
// 9 ; 교명주
// 10; 현장타설말뚝
// 이 함수를 사용하는 곳에서는 반드시 메모리 해제를 해줘야 된다.
// 여기서 메모리를 엄청 생성하기 때문이다. 
// bStt, bLeft : 날개벽일경우 옵션
// nIdxInWall : 보기둥일경우 옵션
// BOOL bGetRebar : 포인터만 가져옴.(철근할증률 설정때문임, 모든 철근을 다 가져옴)
// BOOL bIncludePile : 현장타설말뚝 철근 포함 //삭제 현장 타설 말뚝은 항상 출력 되도록 수정
void CRcBridgeRebar::MakeRebarList(CTypedPtrArray <CObArray, CRebar*> *pArrRebar, long nType, BOOL bStt, BOOL bLeft, long nJ, BOOL bGetRebar)
{
	long i = 0;


	// 본체
	if(nType == 0 || nType == -1 || bGetRebar)
	{
		// 주철근
		for(i = 0; i < m_pArrRebarMain.GetSize(); i++)
		{
			CRebar *pRB = m_pArrRebarMain.GetAt(i);
			if(pRB->IsTrue())
			{
				pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
			}
		}

		// 배력철근
		for(i = 0; i < m_pArrRebarSupport.GetSize(); i++)
		{
			CRebar *pRB = m_pArrRebarSupport.GetAt(i);
			if(pRB->IsTrue())
			{
				pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
			}
		}

		// 전단철근
		for(i = 0; i < m_pArrRebarShear.GetSize(); i++)
		{
			CRebar *pRB = m_pArrRebarShear.GetAt(i);
			if(pRB->IsTrue())
			{
				pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
			}
		}

		// 브라켓 철근
		for(i = 0; i < m_pArrRebarEtc.GetSize(); i++)
		{
			CRebar *pRB = m_pArrRebarEtc.GetAt(i);
			if(pRB->IsTrue())
			{
				pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
			}
		}

		// 종거더 철근
		for(i = 0; i < m_pArrRebarGirder.GetSize(); i++)
		{
			CRebar *pRB	= m_pArrRebarGirder.GetAt(i);
			if(pRB->m_sDescription.Find("종거더", 0) == -1) continue;
			if(pRB->IsTrue())
			{
				pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
			}
		}

		// 추가철근
		for(i = 0; i < m_pArrRebarMain_User.GetSize(); i++)
		{
			CRebar *pRB = m_pArrRebarMain_User.GetAt(i);
			if(pRB->IsTrue())
			{
				pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
			}
		}
	}

	// 중간벽체(벽식이나 기둥식을 구분해서 수집)
	if(nType == 1 || nType == 5 || nType == -1 || bGetRebar)
	{
		long stt	= (bGetRebar || nType == -1) ? 0 : nJ-1;
		long end	= (bGetRebar || nType == -1) ? GetCountInWall() : nJ-1;
		for(long wall = stt; wall <= end; wall++)
		{
			CWallApp *pWall	= GetInWall(wall);
			if(pWall)
			{
				if((nType == 1 && !pWall->m_bTopIsColumn)  || (nType == 5 && pWall->m_bTopIsColumn) || (bGetRebar || nType == -1))
				{
					if(!pWall->m_bTopIsColumn)
					{
						// 주철근
						for(i = 0; i < pWall->m_pArrRebarMain.GetSize(); i++)
						{
							CRebar *pRB = pWall->m_pArrRebarMain.GetAt(i);
							if(pRB->IsTrue())
							{
								pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
							}
						}

						// 배력철근
						for(i = 0; i < pWall->m_pArrRebarSupport.GetSize(); i++)
						{
							CRebar *pRB = pWall->m_pArrRebarSupport.GetAt(i);
							if(pRB->IsTrue())
							{
								pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
							}
						}

						// 전단철근
						for(i = 0; i < pWall->m_pArrRebarShear.GetSize(); i++)
						{
							CRebar *pRB = pWall->m_pArrRebarShear.GetAt(i);
							if(pRB->IsTrue())
							{
								pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
							}
						}
					}
					else
					{
						// 기둥철근
						for(i = 0; i < pWall->m_pArrRebarColumn.GetSize(); i++)
						{
							CRebar *pRB = pWall->m_pArrRebarColumn.GetAt(i);
							if(pRB->IsTrue())
							{
								pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
							}
						}
						// 첫번째 기둥위치에 추가철근을 더한다.
						for(long ix = 1; ix < m_nQtyJigan; ix++)
						{
							CWallApp *pWall = GetInWall(ix - 1);
							if(pWall->m_bTopIsColumn && ix == nJ)
							{
								for(i = 0; i < m_pArrRebarGirder_User.GetSize(); i++)
								{
									CRebar *pRB = m_pArrRebarGirder_User.GetAt(i);
									if(pRB->IsTrue())
									{
										pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// 기초
	if(nType == 2 || nType == -1 || bGetRebar)
	{
		long nCountFooting	= GetCountFooting();
		for(long footing = 0; footing < nCountFooting; footing++)
		{
			CFootingApp *pFooting	= GetFooting(footing);
			if(pFooting)
			{
				// 주철근
				for(i = 0; i < pFooting->m_pArrRebarMain.GetSize(); i++)
				{
					CRebar *pRB = pFooting->m_pArrRebarMain.GetAt(i);
					if(pRB->IsTrue())
					{
						pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
					}
				}

				// 배력철근
				for(i = 0; i < pFooting->m_pArrRebarSupport.GetSize(); i++)
				{
					CRebar *pRB = pFooting->m_pArrRebarSupport.GetAt(i);
					if(pRB->IsTrue())
					{
						pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
					}
				}

				// 전단철근
				for(i = 0; i < pFooting->m_pArrRebarShear.GetSize(); i++)
				{
					CRebar *pRB = pFooting->m_pArrRebarShear.GetAt(i);
					if(pRB->IsTrue())
					{
						pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
					}
				}

				// 기타철근
				for(i = 0; i < pFooting->m_pArrRebarEtc.GetSize(); i++)
				{
					CRebar *pRB = pFooting->m_pArrRebarEtc.GetAt(i);
					if(pRB->IsTrue())
					{
						pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
					}
				}
				
	
			}
		}
	}

	// 현장타설말뚝
	if(nType == 10 || nType == -1 || bGetRebar)
	{
		long nCountFooting	= GetCountFooting();
		long nStt		= (nJ == -1 || nType == -1)? 0 : nJ;
		long nEnd	= (nJ == -1 || nType == -1)? GetCountFooting() : nJ+1;
		for(long footing = nStt; footing < nEnd; footing++)
		{
			CFootingApp *pFooting	= GetFooting(footing);
			if(pFooting == NULL) continue;
			
			if(pFooting->m_exFooting.m_nType == EXFOOTING_TYPE_PILE)
			{
				CExPileApp *pPile	= &pFooting->m_exFooting.m_Pile;
				if(pPile->m_nType == PILE_TYPE_HYUNJANG)
				{
					for(i = 0; i < pPile->m_pHyunTa->m_pArrRebar.GetSize(); i++)
					{
						CRebar *pRB = pPile->m_pHyunTa->m_pArrRebar.GetAt(i);
						if(pRB->IsTrue())
						{
							pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
						}
					}
				}
			}
		}		
	}

	// 날개벽
	if(nType == 3 || nType == -1 || bGetRebar)
	{
		if(bGetRebar)
		{
			long stt = 0; for(stt = 0; stt < 2; stt++)
			{
				BOOL bSttTmp	= stt == iSTT;
				
				long left = 0; for(left = 0; left < 2; left++)
				{
					BOOL bLeftTmp	= left == iLEFT;

					if(IsWingWall(bSttTmp, bLeftTmp))
					{
						CWingWall *pWing	= GetWingWall(bSttTmp, bLeftTmp);
						if(pWing)
						{
							for(i = 0; i < pWing->m_pArrRebar.GetSize(); i++)
							{
								CRebar *pRB = pWing->m_pArrRebar.GetAt(i);
								if(pRB->IsTrue())
								{
									pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
								}
							}
							for(i = 0; i < pWing->m_pArrRebar_User.GetSize(); i++)
							{
								CRebar *pRB = pWing->m_pArrRebar_User.GetAt(i);
								if(pRB->IsTrue())
								{
									pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
								}
							}
						}
					}
				}
			}
		}
		else
		{
			for (HGINT32 stt = 0; stt < 2; ++stt)
			{
				if (nType >= 0 && bStt == FALSE && stt == 0)
					continue;

				if (nType >= 0 && bStt && stt == 1)
					continue;

				HGBOOL bSttTemp = stt == 0;
				for (HGINT32 left = 0; left < 2; ++left)
				{
					if (nType >= 0 && bLeft == FALSE && left == 0)
						continue;

					if (nType >= 0 && bLeft && left == 1)
						continue;

					HGBOOL bLeftTemp = left == 0;

					if(IsWingWall(bSttTemp, bLeftTemp))
					{
						CWingWall *pWing	= GetWingWall(bSttTemp, bLeftTemp);
						if(pWing)
						{
							for(i = 0; i < pWing->m_pArrRebar.GetSize(); i++)
							{
								CRebar *pRB = pWing->m_pArrRebar.GetAt(i);
								if(pRB->IsTrue())
								{
									pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
								}
							}
							for(i = 0; i < pWing->m_pArrRebar_User.GetSize(); i++)
							{
								CRebar *pRB = pWing->m_pArrRebar_User.GetAt(i);
								if(pRB->IsTrue())
								{
									pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
								}
							}
						}
					}
				}
			}
			
		}
	}

	// 상세부 철근 - 교명주 받침
	if(nType == 4 || nType == -1 || bGetRebar)
	{
		for(i = 0; i < m_pArrRebarMonument.GetSize(); i++)
		{
			CRebar *pRB = m_pArrRebarMonument.GetAt(i);
			if(pRB->IsTrue())
			{
				pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
			}
		}
	}

	// 보기둥 아닌 경우의 거더 철근
	if(nType == 6 || nType == -1 || bGetRebar)
	{
		BOOL bOk	= TRUE;
		CWallApp *pWall	= GetInWall(nJ-1);
		if(pWall)
		{
			if(pWall->m_bTopIsColumn)
				bOk	= FALSE;
		}

		if(bOk)
		{
			// 거더철근
			if(IsGirderRebar(nJ, TRUE))
			{
				CString sJijum	= _T("");
				sJijum.Format("지점%d", nJ+1);
				for(i = 0; i < m_pArrRebarGirder.GetSize(); i++)
				{
					CRebar *pRB	= m_pArrRebarGirder.GetAt(i);

					if(pRB->IsTrue())
					{
						if(bGetRebar || pRB->m_sDescription.Find(sJijum, 0) != -1)
						{
							pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
						}
					}
				}
			}
		}
	}

	// 보기둥의 거더 철근
	if(nType == 7 || nType == -1 || bGetRebar)
	{
		BOOL bOk	= FALSE;
		CWallApp *pWall	= GetInWall(nJ-1);
		if(pWall)
		{
			if(pWall->m_bTopIsColumn)
				bOk	= TRUE;
		}

		if(bOk)
		{
			// 거더철근
			if(IsGirderRebar(nJ, TRUE))
			{
				CString sJijum	= _T("");
				sJijum.Format("지점%d", nJ+1);
				for(i = 0; i < m_pArrRebarGirder.GetSize(); i++)
				{
					CRebar *pRB	= m_pArrRebarGirder.GetAt(i);
					if(pRB->IsTrue())
					{
						if(bGetRebar || pRB->m_sDescription.Find(sJijum, 0) != -1)
						{
							pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
						}
					}
				}
			}
		}
	}

	// 방호벽
	if(nType == 8 || nType == -1 || bGetRebar)
	{
		long stt	= nType == -1 || nJ == -1 || bGetRebar ? 0 : nJ;
		long end	= nType == -1 || nJ == -1 || bGetRebar ? GetQtyHDan()-1 : nJ;
		long dan = 0; for(dan = stt; dan <= end; dan++)
		{
			CGuardWallRC* pGW	= GetGuardWallByHDan(dan);
			if(!pGW) continue;

			if(pGW->IsTypeHDanRoadTotalGuardWall() && !pGW->IsTypeHDanNonRebarConcrete())				
			{
				for(i = 0; i < pGW->m_pArrRebar.GetSize(); i++)
				{
					CRebar *pRB = pGW->m_pArrRebar.GetAt(i);
					if(pRB->IsTrue())
					{
						pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
					}
				}
			}
		}
	}

	// 교명주
	if(nType == 9)	// nType == -1, bGetRebar == TRUE 일때 상세부 철근 - 교명주 받침에서 이미 함
	{
		for(i = 0; i < m_pArrRebarMonument.GetSize(); i++)
		{
			CRebar *pRB = m_pArrRebarMonument.GetAt(i);
			if(pRB->IsTrue())
			{
				pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
			}
		}
	}

	// 접속슬래브
	if(nType == -1 || bGetRebar)
	{
		long stt = 0; for(stt = 0; stt < 2; stt++)
		{
			BOOL bStt	= stt == iSTT;
			long left = 0; for(left = 0; left < 2; left++)
			{
				CApsApp *pAps	= bStt ? &m_apsStt[left] : &m_apsEnd[left];
				if(pAps->m_bIs)
				{
					for(i = 0; i < pAps->m_pArrRebar.GetSize(); i++)
					{
						CRebar *pRB	= pAps->m_pArrRebar.GetAt(i);
						if(pRB->IsTrue())
						{
							pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
						}
					}
				}

				for(long cns = 0; cns < 2; cns++)
				{
					CApsApp *pCns	= bStt ? &m_cnsStt[left][cns] : &m_cnsEnd[left][cns];
					if(pCns->m_bIs)
					{
						for(i = 0; i < pCns->m_pArrRebar.GetSize(); i++)
						{
							CRebar *pRB	= pCns->m_pArrRebar.GetAt(i);
							if(pRB->IsTrue())
							{
								pArrRebar->Add(bGetRebar ? pRB : new CRebar(pRB));
							}
						}
					}
				}
			}
		}
	}
}

// 철근 배치를 직거리 방향으로 하는지?
// 주로 단경간일때 사용하는 방법
BOOL CRcBridgeRebar::IsVertDir()
{
	return m_nTypePlacingMainRebar_UpperSlab != 0;
}

// 교명주 받침 정면도 선철근 포인트
void CRcBridgeRebar::GetXyRebarMonuFront(CDPoint *xy, BOOL bLeft)
{
	double dW	= m_dMonuW;
	double dD	= m_dMonuD;
	double dH1	= m_dMonuH1;
	double dH2	= m_dMonuH2;
	double dH3	= m_dMonuH3;
	double dRA1 = m_dMonuR_A1;
	double dRC	= m_dMonuR_C;
	double dRC1 = m_dMonuR_C1;
	double dRC2 = m_dMonuR_C2;
	double dRC3 = m_dMonuR_C3;
	double dRH	= m_dMonuR_H;
	double dRL	= m_dMonuR_L;
	int nRnC	= m_nMonuR_nC;
	int nRnD	= m_nMonuR_nD;
	CDPoint vX(1, 0), vY(0, 1);

	if(bLeft)
	{
		CBasicConcInfo concInfo;
		double dFck		= m_dMonuFck;
		double dFy		= m_dMonuR_Fy;
		double dDia		= m_dMonuR_DiaHor;
		double dSettle	= concInfo.GetValueSettle(dFck, dFy, (long)dDia, SETTLE_TENS_NORMAL, dRC1, nRnD);
		CDPoint xy1		= CDPoint(-dW, dH1);
		CDPoint xy21	= CDPoint(-dW, dH1-dH2);
		CDPoint xy22	= xy21;
		CDPoint xy3		= CDPoint(dD-dW, dH1-dH2-dH3);
		Offset(xy1, xy21, -dRC1);
		Offset(xy22, xy3, -dRC1);

		xy[0] = xy1 - dRA1*vY;
		GetXyMatchSegAndSeg(xy1, xy21, xy22, xy3, xy[1]);
		GetXyMatchSegAndLine(xy22, xy3, CDPoint(dD-dW, 0), vY, xy[2]);
		xy[2] += dSettle*(xy3-xy22).Unit();
	}
	else
	{
		xy[0] = CDPoint(dRC1-dW, dH1-dRH);
		xy[1] = xy[0] + (dRC2+nRnC*dRC+dRC3)*vX;
		xy[2] = xy[1] - dRL*vY;
	}
}

// 교명주 받침 정면도 점철근 측면(상에서 하로)
void CRcBridgeRebar::GetDimArrayRebarMonuFrontSide(CDPointArray &xyArr)
{
	xyArr.RemoveAll();

	double dRA	= m_dMonuR_A;
	int nRnA	= m_nMonuR_nA;
	CDPoint xyL[3];
	GetXyRebarMonuFront(xyL, TRUE);

	xyArr.Add(CDPoint(1, xyL[0].y-xyL[1].y-nRnA*dRA));
	xyArr.Add(CDPoint(nRnA, dRA));
}

// 교명주 받침 정면도 점철근 하단(좌에서 우로)
void CRcBridgeRebar::GetDimArrayRebarMonuFrontLower(CDPointArray &xyArr)
{
	xyArr.RemoveAll();

	double dRB	= m_dMonuR_B;
	int nRnB	= m_nMonuR_nB;

	xyArr.Add(CDPoint(nRnB, dRB));
}

// 교명주 받침 평면도 수평 철근(하에서 상으로)
int CRcBridgeRebar::GetDimArrayRebarMonuPlaneHor(CDPointArray &xyArr)
{
	xyArr.RemoveAll();

	double dRD1 = m_dMonuR_D1;
	double dRD2 = m_dMonuR_D2;
	double dRD3 = m_dMonuR_D3;
	double dRD  = m_dMonuR_D;
	int nRnD    = m_nMonuR_nD;

	int nCount = 0;
	if(dRD1>0)
	{
		xyArr.Add(CDPoint(1, dRD1));
		nCount++;
	}
	if(dRD2>0)
	{
		xyArr.Add(CDPoint(1, dRD2));
		nCount++;
	}
	xyArr.Add(CDPoint(nRnD, dRD));
	nCount += nRnD;
	if(dRD3>0)
	{
		xyArr.Add(CDPoint(1, dRD3));
		nCount++;
	}

	return nCount;
}

// 교명주 받침 평면도 수직 철근(좌에서 우로)
int CRcBridgeRebar::GetDimArrayRebarMonuPlaneVer(CDPointArray &xyArr)
{
	xyArr.RemoveAll();

	double dRC1 = m_dMonuR_C1;
	double dRC2 = m_dMonuR_C2;
	double dRC3 = m_dMonuR_C3;
	double dRC  = m_dMonuR_C;
	int dRnC    = m_nMonuR_nC;

	int nCount = 0;
	if(dRC1>0)
	{
		xyArr.Add(CDPoint(1, dRC1));
		nCount++;
	}
	if(dRC2>0)
	{
		xyArr.Add(CDPoint(1, dRC2));
		nCount++;
	}
	xyArr.Add(CDPoint(dRnC, dRC));
	nCount += dRnC;
	if(dRC3>0)
	{
		xyArr.Add(CDPoint(1, dRC3));
		nCount++;
	}

	return nCount;
}

// 교명주 받침 철근 제원
void CRcBridgeRebar::MakeMonumentRebarJewon()
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();

	long i = 0; for(i = 0; i < MO_REBAR_COUNT; i++)
	{
		CRebar* pRB = m_pArrRebarMonument[i];
		if(pRB->m_bLock) continue;
		pRB->InitData();
	}
	if(m_nMonumenu==0) return;
	
	int nCountMonu	= m_nMonumenu;	//GetCountWingWall();
	double dFy		= bLsd? GetValueFy(ePartUpperSlab) : m_dMonuR_Fy;
	double dW		= m_dMonuW;
	double dH1		= m_dMonuH1;
	double dRA		= m_dMonuR_A;
	double dRA1		= m_dMonuR_A1;
	double dRB		= m_dMonuR_B;
	double dRC		= m_dMonuR_C;
	double dRC1		= m_dMonuR_C1;
	double dRC2		= m_dMonuR_C2;
	double dRC3		= m_dMonuR_C3;
	double dRD		= m_dMonuR_D;
	double dRD2		= m_dMonuR_D2;
	double dRD3		= m_dMonuR_D3;
	double dRH		= m_dMonuR_H;
	double dDiaHor	= m_dMonuR_DiaHor;
	double dDiaVer	= m_dMonuR_DiaVer;
	int nRnA		= m_nMonuR_nA;
	int nRnB		= m_nMonuR_nB;
	int nRnC		= m_nMonuR_nC;
	int nRnD		= m_nMonuR_nD;
	CDPoint xyL[3], xyR[3];
	GetXyRebarMonuFront(xyL, TRUE);
	GetXyRebarMonuFront(xyR, FALSE);
	CDPointArray xyArr;

	CRebar* pRB = m_pArrRebarMonument[MO_REBAR_M1];
	if(pRB->m_bLock == FALSE)
	{
		pRB->m_nIdxNumber = MO_REBAR_M1;
		pRB->m_sMark = _T("M1");
		pRB->m_sDescription = _T("주철근1");
		pRB->m_dDia = dDiaHor;
		pRB->m_nEa = GetDimArrayRebarMonuPlaneHor(xyArr)*nCountMonu;
		pRB->m_nTypeRebar = 8;
		pRB->m_dLengthMax_A = ~(xyL[1]-xyL[0]);
		pRB->m_dLengthMax_B = ~(xyL[2]-xyL[1]);
		pRB->m_bMainRebar = TRUE;
		pRB->m_dRateAdd	= MAKE_RATE;
		pRB->m_Fy = dFy;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dRC1, dRD);
	}

	pRB = m_pArrRebarMonument[MO_REBAR_M2];
	if(pRB->m_bLock == FALSE)
	{
		pRB->m_nIdxNumber = MO_REBAR_M2;
		pRB->m_sMark = _T("M2");
		pRB->m_sDescription = _T("주철근2");
		pRB->m_dDia = dDiaHor;
		pRB->m_nEa = GetDimArrayRebarMonuPlaneHor(xyArr)*nCountMonu;
		pRB->m_nTypeRebar = 2;
		pRB->m_dLengthMax_A = ~(xyR[1]-xyR[0]);
		pRB->m_dLengthMax_B = ~(xyR[2]-xyR[1]);
		pRB->m_bMainRebar = TRUE;
		pRB->m_dRateAdd	= MAKE_RATE;
		pRB->m_Fy = dFy;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dW-(dRC1+dRC2+nRnC*dRC+dRC3), dRD);
	}

	pRB = m_pArrRebarMonument[MO_REBAR_S_U];
	if(pRB->m_bLock == FALSE)
	{
		pRB->m_nIdxNumber = MO_REBAR_S_U;
		pRB->m_sMark = _T("M3");
		pRB->m_sDescription = _T("상면 배력근");
		pRB->m_dDia = dDiaVer;
		pRB->m_nEa = GetDimArrayRebarMonuPlaneVer(xyArr)*nCountMonu;
		pRB->m_nTypeRebar = 1;
		pRB->m_dLengthMax_A = dRD2+nRnD*dRD+dRD3;
		pRB->m_bMainRebar = FALSE;
		pRB->m_dRateAdd	= MAKE_RATE;
		pRB->m_Fy = dFy;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dRH, dRC);
	}

	pRB = m_pArrRebarMonument[MO_REBAR_S_S];
	if(pRB->m_bLock == FALSE)
	{
		pRB->m_nIdxNumber = MO_REBAR_S_S;
		pRB->m_sMark = _T("M4");
		pRB->m_sDescription = _T("측면 배력근");
		pRB->m_dDia = dDiaVer;
		pRB->m_nEa = (nRnA+1)*nCountMonu;
		pRB->m_nTypeRebar = 3;
		pRB->m_dLengthMax_A = dRD2+nRnD*dRD+dRD3;
		pRB->m_dLengthMax_B = ~(xyR[1]-xyR[0]);
		pRB->m_bMainRebar = FALSE;
		pRB->m_dRateAdd	= MAKE_RATE;
		pRB->m_Fy = dFy;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dRC1, dRA);
	}

	pRB = m_pArrRebarMonument[MO_REBAR_S_L];
	if(pRB->m_bLock == FALSE)
	{
		pRB->m_nIdxNumber = MO_REBAR_S_L;
		pRB->m_sMark = _T("M5");
		pRB->m_sDescription = _T("하면 배력근");
		pRB->m_dDia = dDiaVer;
		pRB->m_nEa = nRnB*nCountMonu;
		pRB->m_nTypeRebar = 3;
		pRB->m_dLengthMax_A = dRD2+nRnD*dRD+dRD3;
		CDPoint xyFir(dRC1+dRB-dW, dH1-dRA1), xySec(dRC1+nRnB*dRB-dW, dH1-dRA1);
		CDPoint xyMatchFir(0, 0), xyMatchSec(0, 0);
		GetXyMatchSegAndLine(xyL[1], xyL[2], xyFir, CDPoint(0, 1), xyMatchFir);
		GetXyMatchSegAndLine(xyL[1], xyL[2], xySec, CDPoint(0, 1), xyMatchSec);
		pRB->m_dLengthMax_B = ~(xyMatchFir-xyFir);
		pRB->m_dLengthMin_B = ~(xyMatchSec-xySec);
		pRB->m_bMainRebar = FALSE;
		pRB->m_dRateAdd	= MAKE_RATE;
		pRB->m_Fy = dFy;
		m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dRC1, dRB);
	}
}

// 상부슬래브 주철근 정보 리턴
// ret : x : 철근 지름, y : CTC
CDPoint CRcBridgeRebar::GetInfoMainRebar_UpperSlab(BOOL bUpper, long nSpan, long nCycle, long nDan, long nLeft)
{
	CDPoint xyInfo	= CDPoint(0, 0);
	double dDia	= 0;
	double dCTC	= GetCtcRebarMain(TRUE);
	if(nSpan == 0 && nLeft == -1 && bUpper)
	{
		if(!IsExistMainRebarUpperSlab(nCycle, nDan, bUpper, nSpan, 0)) xyInfo = CDPoint(0, 0);
		else
		{
			xyInfo.x	= GetDiaMainRebarUpperSlab(nCycle, nDan, bUpper, nSpan, 0);
			xyInfo.y	= dCTC;
		}
		return xyInfo;
	}
	else if(nSpan == m_nQtyJigan-1 && nLeft == 1 && bUpper)
	{
		if(!IsExistMainRebarUpperSlab(nCycle, nDan, bUpper, nSpan, -1)) xyInfo = CDPoint(0, 0);
		else
		{
			xyInfo.x	= GetDiaMainRebarUpperSlab(nCycle, nDan, bUpper, nSpan, -1);
			xyInfo.y	= dCTC;
		}
		return xyInfo;
	}
	
	// 걸려야 되는 위치
	// 상면은 각 지점에 걸리면 되고, 하면은 지간의 중앙sta에 걸리면 된다.
	double dStaCheck	= 0;	// 철근이 걸려야 되는 sta
	BOOL bVertDir		= m_bMakedRebarInfoCycleByVertUpperSlab;//IsVertDir(); 현재 주철근이 직거리로 만들어 졌는지 사거리로 만들어 졌는지 알아야 된다.
	if(nLeft==-1 || nLeft==1)
	{
		long nJ	= nLeft==-1 ? nSpan : nSpan+1;
		dStaCheck	= GetStationOnJijum(nJ, 0, bVertDir);
		if(IsRcSlab() || IsPiRahmen())
		{
			CJijum *pJ = GetJijum(nJ);
			if(nSpan==0 && nLeft==-1)
			{
				dStaCheck = GetStationOnJijum(nJ, 0, bVertDir) + pJ->m_dLengthUgan[1] + pJ->m_dLengthSlabToShoe[1];
			}
			if(nSpan==m_nQtyJigan-1 && nLeft==1)
			{
				dStaCheck = GetStationOnJijum(nJ, 0, bVertDir) - pJ->m_dLengthUgan[0] - pJ->m_dLengthSlabToShoe[0];
			}
		}
	}
	else if(nLeft == 0)
	{
		long nJL	= nSpan;
		long nJR	= nSpan+1;
		dStaCheck	= (GetStationOnJijum(nJL, 0, bVertDir) + GetStationOnJijum(nJR, 0, bVertDir))/2;
	}

	if(m_nTypeBridge == BRIDGE_TYPE_ARCH)
	{
		long nJ = GetJijumConnectRibAndSlab();
		if(nSpan == nJ-1 || nSpan==nJ)
		{
			CWallApp *pWall = GetInWall(nJ-1);

			if(pWall != NULL)
			{
				double dDistOffset = pWall->m_dW/2;

				if(nSpan == nJ-1 && nLeft==0)
					dStaCheck -= dDistOffset/2;
				else if(nSpan == nJ && nLeft==0)
					dStaCheck += dDistOffset/2;
			}
		}
	}

	// 걸리는 철근을 찾는다.
	long upper	= bUpper ? iUPPER : iLOWER;
//	double dXLeft	= 0;
//	double dXRight	= 0;
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC	= &m_pArrRCMainUpperSlab[nCycle][upper][nDan];
	long nCount	= pArrRC->GetSize();
	for(long rc = 0; rc < nCount; rc++)
	{
		CRebarInfoCycle *pRC	= pArrRC->GetAt(rc);
		double dXLeft	= pRC->m_xyStt.x;
		double dXRight	= pRC->m_nPosStt == pRC->m_nPosEnd ? pRC->m_xyMid1.x : pRC->m_xyEnd.x;
		if(pRC->m_bUseEndExt)
			dXRight	= pRC->m_xyEndExt.x;
		if(dXRight < dXLeft)
			GetSwap(dXRight, dXLeft);
		
		if(dXLeft <= dStaCheck && dXRight >= dStaCheck && pRC->m_bExist)
		{
			dDia	= pRC->m_Dia;
			break;
		}
	}

	xyInfo.x	= dDia;
	xyInfo.y	= Compare(dDia, 0.0, "=") ? 0 : dCTC;
	return xyInfo;
}

CDPoint CRcBridgeRebar::GetInfoMainRebar_LowerSlab(BOOL bLower, long nSpan, long nCycle, long nDan, long nLeft)
{
	CDPoint xyInfo	= CDPoint(0, 0);
	double dDia	= 0;
	double dCTC	= GetCtcRebarMain(TRUE);
	if(nSpan == 0 && nLeft == -1 && bLower)
	{
		if(!IsExistMainRebarLowerSlab(nCycle, nDan, FALSE, nSpan, 0)) xyInfo = CDPoint(0, 0);
		else
		{
			xyInfo.x	= GetDiaMainRebarLowerSlab(nCycle, nDan, FALSE, nSpan, 0);
			xyInfo.y	= dCTC;
		}
		return xyInfo;
	}
	else if(nSpan == m_nQtyJigan-1 && nLeft == 1 && bLower)
	{
		if(!IsExistMainRebarLowerSlab(nCycle, nDan, FALSE, nSpan, -1)) xyInfo = CDPoint(0, 0);
		else
		{
			xyInfo.x	= GetDiaMainRebarLowerSlab(nCycle, nDan, FALSE, nSpan, -1);
			xyInfo.y	= dCTC;
		}
		return xyInfo;
	}

	// 걸려야 되는 위치
	// 상면은 각 지점에 걸리면 되고, 하면은 지간의 중앙sta에 걸리면 된다.
	double dStaCheck	= 0;	// 철근이 걸려야 되는 sta
	BOOL bVertDir		= m_bMakedRebarInfoCycleByVertUpperSlab;
	if(nLeft==-1 || nLeft==1)
	{
		long nJ	= nLeft==-1 ? nSpan : nSpan+1;
		dStaCheck	= GetStationOnJijum(nJ, 0, bVertDir);
	}
	else if(nLeft == 0)
	{
		long nJL	= nSpan;
		long nJR	= nSpan+1;
		dStaCheck	= (GetStationOnJijum(nJL, 0, bVertDir) + GetStationOnJijum(nJR, 0, bVertDir))/2;
	}

	// 걸리는 철근을 찾는다.
	long upper	= bLower ? iLOWER : iUPPER;
//	double dXLeft	= 0;
//	double dXRight	= 0;
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC	= &m_pArrRCMainLowerSlab[nCycle][upper][nDan];
	long nCount	= pArrRC->GetSize();
	for(long rc = 0; rc < nCount; rc++)
	{
		CRebarInfoCycle *pRC	= pArrRC->GetAt(rc);
		double dXLeft	= pRC->m_xyStt.x;
		double dXRight	= pRC->m_nPosStt == pRC->m_nPosEnd ? pRC->m_xyMid1.x : pRC->m_xyEnd.x;
		if(pRC->m_bUseEndExt)
			dXRight	= pRC->m_xyEndExt.x;
		if(dXRight < dXLeft)
			GetSwap(dXRight, dXLeft);

		if(dXLeft <= dStaCheck && dXRight >= dStaCheck && pRC->m_bExist)
		{
			dDia	= pRC->m_Dia;
			break;
		}
	}

	xyInfo.x	= dDia;
	xyInfo.y	= Compare(dDia, 0.0, "=") ? 0 : dCTC;
	return xyInfo;
}

// 기초 주철근 정보 리턴
// ret : x : 철근 지름, y : CTC
CDPoint CRcBridgeRebar::GetInfoMainRebar_Footing(long nJ, BOOL bUpper, long nCycle, long nDan, BOOL bLeft)
{
	CDPoint xyInfo	= CDPoint(0, 0);

	CFootingApp *pFooting	= GetFootingByJijumNumber(nJ);
	if(!pFooting) return xyInfo;
	if(!pFooting->m_bIs) return xyInfo;
	if(nCycle >= pFooting->GetCountCycleMainRebar()) return xyInfo;

	CHgBaseConcStd baseConc;
	double dDia	= 0;
	// CTC는 무조건 1단 간격으로...
	double dCTC	= pFooting->m_placeByBlock_Main_Side[bUpper? 1:0][0].GetCTC(); // pFooting->m_dCTC_MainRebar;
	double dCover = bUpper? m_dCoverUpper_Footing[nDan] : (IsPileBase(nJ)? m_dCoverLower_Footing_Pile[nDan] : m_dCoverLower_Footing_Lean[nDan]);
	double dWidth = pFooting->GetWidth();

	BOOL bBack = ((nJ==0 && bLeft) || (nJ==m_nQtyJigan && !bLeft));
	
	// 걸려야 되는 위치
//	BOOL bVertDir		= IsVertDir();
//	double dStaCheck	= GetStationOnJijum(nJ, 0, bVertDir);
//	경사교각일때는 지점Station에서 찾으면 안되고 Footing에 있는 m_dSta를 쓴다..
//	double dTickWall	= GetThickWall(nJ);
	double dStaCheck	= pFooting->m_xyBottomCenter.x - dWidth/2;
	
//	if(nJ==m_nQtyJigan && !bLeft) dStaCheck += dTickWall;
//	else dStaCheck -= dTickWall;

	//long nTypeFoot = pFooting->GetTypeByInputValue();
	long nTypeFoot = pFooting->m_nType;

	if(nTypeFoot == FOOTING_TYPE_LEFTSLOPE) 
		dStaCheck += (bLeft) ? 0 : pFooting->m_dFW;
	else if(nTypeFoot == FOOTING_TYPE_RIGHTSLOPE) 
		dStaCheck += (bLeft) ? dWidth-pFooting->m_dFW : 0;
	else if(nTypeFoot == FOOTING_TYPE_BASIC_LEFTSLOPE) 
	{
		if(pFooting->m_dFELW > 0 || pFooting->m_dFSLW > 0)
			dStaCheck += (bLeft) ? (pFooting->m_dFELW+pFooting->m_dFSLW) : dWidth-pFooting->m_dFWR;
		else
			dStaCheck += (bLeft) ? pFooting->m_dFWL/2 : dWidth-pFooting->m_dFWR;
	}
	else if(nTypeFoot == FOOTING_TYPE_BASIC_RIGHTSLOPE) 
	{
		if(pFooting->m_dFERW > 0 || pFooting->m_dFSRW > 0)
			dStaCheck += (bLeft) ? pFooting->m_dFWL : dWidth-(pFooting->m_dFERW+pFooting->m_dFSRW);
		else
			dStaCheck += (bLeft) ? pFooting->m_dFWL : dWidth-pFooting->m_dFWR/2;
	}
	else 
		dStaCheck += (bLeft) ? pFooting->m_dFWL : dWidth-pFooting->m_dFWR;

	// REV. HA 2007.02.27
	if(nTypeFoot==FOOTING_TYPE_BASIC_RIGHTSLOPE && bLeft==FALSE && m_nTypeBridge == BRIDGE_TYPE_ARCH) 
		dStaCheck = m_tvArrVertSectionRib[iLOWER].GetAt(0).m_v1.x;
	if(nTypeFoot==FOOTING_TYPE_BASIC_LEFTSLOPE && bLeft==TRUE && m_nTypeBridge == BRIDGE_TYPE_ARCH) 
		dStaCheck = m_tvArrVertSectionRib[iLOWER].GetAt(m_tvArrVertSectionRib[iLOWER].GetSize()-1).m_v2.x;
	// REV. HA 2007.02.27
	// 걸리는 철근을 찾는다.
	long upper	= bUpper ? iUPPER : iLOWER;
	double dXLeft	= 0;
	double dXRight	= 0;
	CRebarInfoCycle *pRC	= NULL;
	switch(nCycle)
	{
		case 0: pRC	= &pFooting->m_rebarInfoCycle_Cycle1[upper][nDan]; break;
		case 1: pRC	= &pFooting->m_rebarInfoCycle_Cycle2[upper][nDan]; break;
		case 2: pRC	= &pFooting->m_rebarInfoCycle_Cycle3[upper][nDan]; break;
		case 3: pRC	= &pFooting->m_rebarInfoCycle_Cycle4[upper][nDan]; break;
		default: break;
	}
	if(!pRC || pRC->m_bExist == FALSE) return xyInfo;

	dXLeft	= pRC->m_xyStt.x;
	dXRight	= pRC->m_nPosStt == pRC->m_nPosEnd ? pRC->m_xyMid1.x : pRC->m_xyEnd.x;
	if(dXLeft > dXRight) GetSwap(dXLeft, dXRight);
	if(Compare(dXLeft, dXRight, _T("="), 10)) return xyInfo;
	
	if((bLeft && (dXLeft <= dStaCheck || dXRight <= dStaCheck)) || 
		(!bLeft && (dXLeft >= dStaCheck || dXRight >= dStaCheck)))
	{
		// 뒷굽 하면일때는 벽체부근에서 체크하지말고 철근직경을 받아서 정착길이까지 들어갔는지 확인한다..
		if(bBack && !bUpper)
		{
			// 이런 부분까지 한계상태 이음으로 적용할 필요가 있나...
			double dSettle = m_pARcBridgeDataStd->GetValueSettle(pRC->m_Dia, SETTLE_TENS_NORMAL, toCm(dCover), toCm(dCTC));
			dStaCheck += bLeft? - dSettle : dSettle;
			if((bLeft && (dXLeft <= dStaCheck || dXRight <= dStaCheck)) || 
				(!bLeft && (dXLeft >= dStaCheck || dXRight >= dStaCheck)))
			{
				dDia = pRC->m_Dia;
			}
		}
		else
		{
			dDia = pRC->m_Dia;
		}
	}

	xyInfo.x = dDia;
	xyInfo.y = Compare(dDia, 0.0, "=") ? 0 : dCTC;
	return xyInfo;
}

// 벽체 주철근 정보 리턴
// ret : x : 철근 지름, y : CTC
// nUpper : -1 하단, +1 상단, 0 가운데
CDPoint CRcBridgeRebar::GetInfoMainRebar_Wall(long nJ, long nCycle, long nDan, long nUpper, BOOL bInner)
{
	CDPoint xyInfo	= CDPoint(0, 0);
	CHgBaseConcStd baseConc;
	double dDia	= 0;
	double dCTC	= 0;
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC	= NULL;
	CRebarInfoCycle *pRC	= NULL;
	CWallApp wall;
	BOOL bStt = TRUE;
	BOOL bAddRc = FALSE;
	if(nJ == 0 || nJ == m_nQtyJigan)
	{	
		bStt	= nJ == 0;
		if(!IsOutWall(bStt)) return xyInfo;
		long stt	= bStt ? iSTT : iEND;
		long inner	= bInner ? iINNER : iOUTTER;
		pArrRC	=&m_pArrRCMainOutWall[nCycle][stt][inner][nDan];

		if(!bInner)
		{
			CRebarInfoCycle *pRCTmp = GetRebarInfoCycleUpperSlab(nCycle, nDan, TRUE, bStt ? 0 : -1);
			if(pRCTmp && pRCTmp->m_bExist && pRCTmp->m_Dia)
			{
				if(!ComparePt(pRCTmp->m_xyMid1, pRCTmp->m_xyEnd, "="))
				{	
					CRebarInfoCycle *pRC	= new CRebarInfoCycle;
					*pRC	= *pRCTmp;
					pArrRC->Add(pRC);
					
					bAddRc = TRUE;
				}
			}
			if(IsBoxType() && nUpper == -1 || nUpper == 0)
			{
				CRebarInfoCycle *pRCTmp = GetRebarInfoCycleLowerSlab(nCycle, nDan, FALSE, bStt ? 0 : -1);
				if(pRCTmp && pRCTmp->m_bExist && pRCTmp->m_Dia)
				{
					if(!ComparePt(pRCTmp->m_xyMid1, pRCTmp->m_xyEnd, "="))
					{	
						CRebarInfoCycle *pRC	= new CRebarInfoCycle;
						*pRC	= *pRCTmp;
						pArrRC->Add(pRC);

						bAddRc = TRUE;
					}
				}
			}
		}
		MakeWallByOutWall(wall, bStt, FALSE);
		dCTC	= GetCTCRebarSupport_OutWall(bStt, bInner, nDan);
	}
	else
	{
		long nIdxWall	= nJ - 1;
		CWallApp *pWall	= GetInWall(nIdxWall);
		if(!pWall) return xyInfo;
		if(!pWall->m_bIs) return xyInfo;
		if(nCycle >= pWall->GetCountCycleMainRebar()) return xyInfo;
		long left	= bInner ? iLEFT : iRIGHT;
		pArrRC	=&pWall->m_pArrRCMain[nCycle][left][nDan];
		wall		= *pWall;
		dCTC	= pWall->m_dCTC_MainRebar;
	}

	if(pArrRC->GetSize() == 0) return xyInfo;
	pRC	= pArrRC->GetAt(0);
	
	// 걸려야 되는 위치
	double dELCheck		= 0;

	double dElH = 0;
	CDPoint xyPoint(0, 0);
	if(nJ == 0 || nJ == m_nQtyJigan)
	{
		CString strDir = (nJ==0)? _T("시점") : _T("종점");
		CTwinVector tv;
		tv = m_tvArrVertSection.GetTvByInfo(strDir+"브라켓상부측면");
		xyPoint = (nJ==0)? tv.m_v2 : tv.m_v1;

		xyPoint.y -= m_dTS;
		dElH = xyPoint.y;
	}
	else
	{
		xyPoint = wall.GetXyWallTopCen(TRUE);
		dElH = xyPoint.y;
	}
	double dElL = wall.m_dELB;
	if(IsBoxType())
	{
		dElL += m_dTS_Lower - wall.m_dELBDiff; // 함형인 경우 기초두께를 추가
	}
	else
	{
		dElL += wall.m_footing.GetHeight() - wall.m_dELBDiff;
	}
	
	if(nUpper==-1 || nUpper==1)
	{
		dELCheck	= (nUpper == -1) ? dElL : dElH;
	}
	else if(nUpper == 0)
	{
		dELCheck	= (dElH + dElL)/2;
	}

	// 걸리는 철근을 찾는다.
//	double dTop	= 0;
//	double dBottom	= 0;
	long i = 0; for(i = 0; i < pArrRC->GetSize(); i++)
	{
		CRebarInfoCycle *pRC	= pArrRC->GetAt(i);
		double dTop = pRC->m_xyStt.y;
		double dBottom	= pRC->m_nPosStt == pRC->m_nPosEnd ? pRC->m_xyMid1.y : pRC->m_xyEnd.y;
		if(pRC->m_bUseEndExt)
		{
			dBottom	= pRC->m_xyEndExt.y;

			// 시점벽체부터 종점벽체까지 이어진 철근이있다.
			if(pRC->m_nPosStt == REBARINFO_POS_STTWALL_OUTTER && pRC->m_nPosEnd == REBARINFO_POS_ENDWALL_OUTTER)
			{
				if(nJ == 0)
				{
					dTop = pRC->m_xyStt.y;
					dBottom = pRC->m_xyEnd.y;
				}
				else if(nJ == m_nQtyJigan)
				{
					dTop = pRC->m_xyEndExt.y;
					dBottom = pRC->m_xyEnd.y;
				}
			}
		}
		if(dTop < dBottom)
		{
			GetSwap(dTop, dBottom);
		}
		if( Compare(dTop, dELCheck, ">=") && Compare(dBottom, dELCheck, "<=") && pRC->m_bExist)
		{
			dDia	= pRC->m_Dia;
			break;
		}
	}

	if(bAddRc && pArrRC)
	{
		long nSize = pArrRC->GetSize();
		if(nSize > 0)
		{
			delete pArrRC->GetAt(nSize-1);
			pArrRC->RemoveAt(nSize-1);
		}
	}

	xyInfo.x	= dDia;
	xyInfo.y	= Compare(dDia, 0.0, "=") ? 0 : dCTC;
	return xyInfo;
}

CDPoint CRcBridgeRebar::GetInfoSupportRebar_UpperSlab(BOOL bUpper, long nSpan, long nDan, long nLeft)
{
	CDPoint xyInfo	= CDPoint(0, 0);
	double dDia	= 0;
	double dCTC	= 0;
	double dStaCheck	= 0;	// 철근이 걸려야 되는 sta
	if(nLeft==-1 || nLeft==1)
	{
		long nJ	= nLeft==-1 ? nSpan : nSpan+1;
		dStaCheck	= GetStationOnJijum(nJ, 0, IsVertDir());
		if(nJ !=0 && nJ != m_nQtyJigan)
		{
			CWallApp *pWall = GetInWall(nJ-1);
			dStaCheck += (nLeft * pWall->m_dW/2 * -1);
		}
		else if(!IsOutsideWall())
		{
			dStaCheck -= 300 * nLeft;
		}
	}
	else if(nLeft == 0)
	{
		long nJL	= nSpan;
		long nJR	= nSpan+1;
		dStaCheck	= (GetStationOnJijum(nJL, 0, IsVertDir()) + GetStationOnJijum(nJR, 0, IsVertDir()))/2;
//		주철근 배근 방법에 따라 지간을 다르게 사용한다.
//		dStaCheck	= GetStationOnJijum(nJL, 0) + GetLengthBridge(m_nTypePlacingMainRebar_UpperSlab!=0) / 2;
	}

	if(m_nTypeBridge == BRIDGE_TYPE_ARCH)
	{
		long nJ = GetJijumConnectRibAndSlab();
		if(nSpan == nJ-1 || nSpan==nJ)
		{
			CWallApp *pWall = GetInWall(nJ-1);

			if(pWall != NULL)
			{
				double dDistOffset = pWall->m_dW/2;

				if(nSpan == nJ-1 && nLeft==0)
					dStaCheck -= dDistOffset/2;
				else if(nSpan == nJ && nLeft==0)
					dStaCheck += dDistOffset/2;
			}
		}
	}
	
	BOOL bVertDir	= IsVertDir();
	long upper	= bUpper ? iUPPER : iLOWER;
	double dXLeft	= 0;
	double dXRight	= 0;
	CDPointArray xyArr;
	CDPoint xyC = CDPoint(0,0);
	dDia = m_placeByBlock_SupportRebar_UpperSlab[upper][nDan].m_dDia;
	/*
	//GetXyRebarSupport_VertSection_UpperSlab(xyArr, bUpper, nDan);
	xyArr.Add(CDPoint(m_dStationBridgeStt, 0));
	long nCount	= xyArr.GetSize();
	if(nCount == 0) return xyInfo;
	double dStt = xyArr.GetAt(0).x;
	*/
	long nCount	= 0;
	if(nDan == 0)
	{
		xyArr = m_placeByBlock_SupportRebar_UpperSlab[upper][nDan].m_xyArr;
		nCount	= xyArr.GetSize();
		if(nCount == 0) return xyInfo;
		
		// dStt는 배력 쳘근이 배근되기 시작한 위치이고 치수의 시작 위치와는 다르다.. 그래서 첫번째 배열 간격만큼 빼준다.
		CDPoint vAng	= GetAngleJijum(0, bVertDir);
		double dLenRound	= 0;
		CRebarInfoCycle *pRC	= GetRebarInfoCycleUpperSlab(0, 0, TRUE, 0);
		if(pRC && IsOutWall(TRUE))
			dLenRound	= GetLenRebarAtEdge(pRC->m_Dia) / sqrt(2.);
		
		dXRight = GetStationByTarget(BRIDGE_OFF_STT_SLAB, 0, TRUE) + m_dCoverWallOut[0]/vAng.y + dLenRound;//dXRight = dStt - (xyArr.GetAt(0).y);
		dXLeft	= dXRight;
		for(long rc = 0; rc < nCount; rc++)
		{
			xyC = xyArr.GetAt(rc);
			dXRight += xyC.x * xyC.y;
			if((dXLeft < dStaCheck && dXRight >= dStaCheck))
			{
				if(xyC.x > 1)
				{
					dCTC = xyC.y;
					break;
				}
				else
				{
					if(nLeft == 1)
					{
						long i=0; for(i=1; i<rc; i++)
						{
							if(rc-i < 0) continue;
							xyC = xyArr.GetAt(rc-i);
							if(xyC.x > 1) break;
						}
					}
					else
					{
						long i=0; for(i=1; i<nCount-rc; i++)
						{
							xyC = xyArr.GetAt(rc+i);
							if(xyC.x > 1) break;
						}
					}
					
					dCTC = xyC.y;
					break;
				}
			}
			else if(rc == nCount-1 && dStaCheck > dXRight)
			{
				if(xyC.x > 1)
				{
					dCTC = xyC.y;
					break;
				}
				else
				{
					long i=0; for(i=1; i<nCount; i++)
					{
						if(rc-i < 0) continue;
						xyC = xyArr.GetAt(rc-i);
						if(xyC.x > 1) break;
					}
					dCTC = xyC.y;
					break;
				}
			}
			
			dXLeft = dXRight;
		}
	}
	else
	{
		GetXyRebarSupport_VertSection_UpperSlab(xyArr, bUpper, nDan);
		CDPoint xyTemp1(0, 0), xyTemp2(0, 0);

		nCount = xyArr.GetSize();
		if(nCount == 0) return xyInfo;
		
		if(nLeft == -1) dStaCheck += 300;
		else if(nLeft == 1) dStaCheck -= 300;
		
		for(long rc = 0; rc < nCount-1; rc++)
		{
			xyTemp1 = xyArr.GetAt(rc);
			xyTemp2 = xyArr.GetAt(rc+1);
			dXLeft = xyTemp1.x;
			dXRight	= xyTemp2.x;
			
			if((dXLeft < dStaCheck && dXRight >= dStaCheck))
			{
				dCTC = dXRight - dXLeft;
				if(dCTC > 600) dDia = 0;
				break; 
			}
			else dCTC = 0;
		}
	}
	if(dCTC == 0) dDia = 0;
	xyInfo.x	= dDia;
	xyInfo.y	= Compare(dDia, 0.0, "=") ? 0 : dCTC;
	return xyInfo;
}

CDPoint CRcBridgeRebar::GetInfoSupportRebar_LowerSlab(BOOL bLower, long nSpan, long nDan, long nLeft)
{
	CDPoint xyInfo	= CDPoint(0, 0);
	double dDia	= 0;
	double dCTC	= 0;
	double dStaCheck	= 0;	// 철근이 걸려야 되는 sta
	if(nLeft==-1 || nLeft==1)
	{
		long nJ	= nLeft==-1 ? nSpan : nSpan+1;
		dStaCheck	= GetStationOnJijum(nJ, 0, IsVertDir());
		if(nJ !=0 && nJ != m_nQtyJigan)
		{
			CWallApp *pWall = GetInWall(nJ-1);
			dStaCheck += (nLeft * pWall->m_dW/2 * -1);
		}
		else if(!IsOutsideWall())
		{
			dStaCheck -= 300 * nLeft;
		}
	}
	else if(nLeft == 0)
	{
		long nJL	= nSpan;
		long nJR	= nSpan+1;
		dStaCheck	= (GetStationOnJijum(nJL, 0, IsVertDir()) + GetStationOnJijum(nJR, 0, IsVertDir()))/2;
	}

	
	BOOL bVertDir	= IsVertDir();
	long upper	= bLower ? iLOWER : iUPPER;
	double dXLeft	= 0;
	double dXRight	= 0;
	CDPointArray xyArr;
	CDPoint xyC = CDPoint(0,0);
	dDia = m_placeByBlock_SupportRebar_LowerSlab[upper][nDan].m_dDia;
	long nCount	= 0;
	if(nDan == 0)
	{
		xyArr = m_placeByBlock_SupportRebar_LowerSlab[upper][nDan].m_xyArr;
		nCount	= xyArr.GetSize();
		if(nCount == 0) return xyInfo;
		
		// dStt는 배력 쳘근이 배근되기 시작한 위치이고 치수의 시작 위치와는 다르다.. 그래서 첫번째 배열 간격만큼 빼준다.
		CDPoint vAng	= GetAngleJijum(0, bVertDir);
		double dLenRound	= 0;
		CRebarInfoCycle *pRC	= GetRebarInfoCycleLowerSlab(0, 0, TRUE, 0);
		if(pRC && IsOutWall(TRUE))
			dLenRound	= GetLenRebarAtEdge(pRC->m_Dia) / sqrt(2.);
		
		dXRight = GetStationByTarget(BRIDGE_OFF_STT_SLAB, 0, TRUE) + m_dCoverWallOut[0]/vAng.y + dLenRound;//dXRight = dStt - (xyArr.GetAt(0).y);
		dXLeft	= dXRight;
		for(long rc = 0; rc < nCount; rc++)
		{
			xyC = xyArr.GetAt(rc);
			dXRight += xyC.x * xyC.y;
			if((dXLeft < dStaCheck && dXRight >= dStaCheck))
			{
				if(xyC.x > 1)
				{
					dCTC = xyC.y;
					break;
				}
				else
				{
					if(nLeft == 1)
					{
						long i=0; for(i=1; i<rc; i++)
						{
							if(rc-i < 0) continue;
							xyC = xyArr.GetAt(rc-i);
							if(xyC.x > 1) break;
						}
					}
					else
					{
						long i=0; for(i=1; i<nCount-rc; i++)
						{
							xyC = xyArr.GetAt(rc+i);
							if(xyC.x > 1) break;
						}
					}
					
					dCTC = xyC.y;
					break;
				}
			}
			else if(rc == nCount-1 && dStaCheck > dXRight)
			{
				if(xyC.x > 1)
				{
					dCTC = xyC.y;
					break;
				}
				else
				{
					long i=0; for(i=1; i<nCount; i++)
					{
						if(rc-i < 0) continue;
						xyC = xyArr.GetAt(rc-i);
						if(xyC.x > 1) break;
					}
					dCTC = xyC.y;
					break;
				}
			}
			
			dXLeft = dXRight;
		}
	}
	else
	{
		GetXyRebarSupport_VertSection_LowerSlab(xyArr, !bLower, nDan);
		CDPoint xyTemp1(0, 0), xyTemp2(0, 0);

		nCount = xyArr.GetSize();
		if(nCount == 0) return xyInfo;
		
		if(nLeft == -1) dStaCheck += 300;
		else if(nLeft == 1) dStaCheck -= 300;
		
		for(long rc = 0; rc < nCount-1; rc++)
		{
			xyTemp1 = xyArr.GetAt(rc);
			xyTemp2 = xyArr.GetAt(rc+1);
			dXLeft = xyTemp1.x;
			dXRight	= xyTemp2.x;
			
			if((dXLeft < dStaCheck && dXRight >= dStaCheck))
			{
				dCTC = dXRight - dXLeft;
				if(dCTC > 600) dDia = 0;
				break; 
			}
			else dCTC = 0;
		}
	}
	if(dCTC == 0) dDia = 0;
	xyInfo.x	= dDia;
	xyInfo.y	= Compare(dDia, 0.0, "=") ? 0 : dCTC;
	return xyInfo;
}

CDPoint CRcBridgeRebar::GetInfoSupportRebar_Wall(BOOL bInner, long nJ, long nDan, long nLeft)
{
	BOOL bStt = TRUE;
	CDPoint xyInfo	= CDPoint(0, 0);
	double dDia	= 0;
	double dCTC	= 0;
	double dHCheck = 0;
	CWallApp pWall;
	CPlaceRebarByBlock RebarPlace;
	
	if(nJ == 0 || nJ == GetCountJijum()-1)
	{
		bStt = (nJ == 0)? TRUE:FALSE;
		if(!IsOutWall(bStt)) return xyInfo;
		MakeWallByOutWall(pWall, bStt, FALSE);
		long stt	= bStt ? iSTT : iEND;
		long nInner = bInner ? iINNER : iOUTTER;
		RebarPlace = m_placeByBlock_SupportRebar_OutWall[stt][nInner][nDan];
	}
	else 
	{
		long nIdxWall	= nJ - 1;
		long nInner = bInner ? iINNER : iOUTTER;
		CWallApp *ppWall	= GetInWall(nIdxWall);
		if(!ppWall) return xyInfo;
		if(!ppWall->m_bIs) return xyInfo;
		pWall		= *ppWall;

		RebarPlace = pWall.m_placeByBlock_SupportRebar[nInner][nDan];
	}
	dDia = RebarPlace.m_dDia;


	CDPoint xyPoint = pWall.GetXyWallTopCen(TRUE);
	// 상부쪽은 수평이든 경사이든 이미 적용이 되어 EL을 구하기 때문에 m_dELBDiff를 또 빼줄 필요는없다.
	//double dElH = xyPoint.y - pWall.m_dELBDiff;
	double dElH = xyPoint.y;
//	double dElL = pWall.m_dELB + pWall.m_footing.GetHeight() - pWall.m_dELBDiff;
	pWall.m_footing.GetTvFront();
	double dElL = pWall.m_footing.m_tvArrFront.GetXyBottom().y + pWall.m_footing.GetHeight();
	if(IsBoxType())
	{
		dElL = m_dELSB + m_dTS_Lower;
	}
	
	if(nLeft==-1 || nLeft==1)
	{
		dHCheck	= (nLeft == -1) ? dElL : dElH;
	}
	else if(nLeft == 0)
	{
		dHCheck	= (dElH + dElL)/2;
	}
	// 철근 하단 Round가 기초보다 높을때 임시 처리
	if(nLeft == -1) dHCheck += 200;

	double dYTop	= 0;
	double dYBottom	= 0;
	CDPoint xyC = CDPoint(0,0);
	CDPointArray xyArr;
	
	if(nJ == 0 || nJ == GetCountJijum()-1) GetXyRebarSupport_VertSection_OutWall(xyArr, bStt, bInner, nDan);
	else pWall.GetXyRebarSupport_Front(xyArr, bInner, nDan, FALSE);

	long nCount	= xyArr.GetSize();
	if(nCount == 0) return xyInfo;

//	double dStt = 0;
	
	if(nDan == 0)
	{
		double dStt	= xyArr.GetAt(0).y;
		xyArr	= RebarPlace.m_xyArr;
		nCount	= xyArr.GetSize();
		if(nCount == 0) return xyInfo;
		// dStt는 배력 쳘근이 배근되기 시작한 높이이고 치수의 시작위치와는 다르다.. 그래서 첫번째 배열 간격만큼 빼준다.
		
		dYBottom = dYTop = dStt - (xyArr.GetAt(0).y);

		for(long rc = 0; rc < nCount; rc++)
		{

			xyC = xyArr.GetAt(rc);
			dYTop += xyC.x * xyC.y;

			if((dYBottom <= dHCheck && dYTop >= dHCheck))
			{
				if(xyC.x > 1)
				{
					dCTC = xyC.y;
					break;
				}
				else
				{
					long nRetry = (nLeft == 1)? rc:nCount-rc;
					long i=0; for(i=1; i<nRetry; i++)
					{
						if(nLeft == 1)
						{
							if(rc-i < 0) continue;
							xyC = xyArr.GetAt(rc-i);
						}
						else
						{
							if(rc+i >= nCount) continue;
							xyC = xyArr.GetAt(rc+i);
						}
						
						if(xyC.x > 1) break;
					}
					dCTC = xyC.y;
					break;
				}
			}
			else if(rc == nCount-1 && dHCheck > dYTop)
			{
				if(xyC.x > 1)
				{
					dCTC = xyC.y;
					break;
				}
				else
				{
					long i=0; for(i=1; i<nCount; i++)
					{
						if(rc-i < 0) continue;
						xyC = xyArr.GetAt(rc-i);
						if(xyC.x > 1) break;
					}
					dCTC = xyC.y;
					break;
				}
			}
/*			else if(rc == 0 && dHCheck < dYBottom)
			{
				dCTC = xyC.y;
				break;
			}*/
			
			dYBottom = dYTop;
		}
	}
	else
	{
		CDPoint xyTemp1(0, 0), xyTemp2(0, 0);

		if(nLeft == -1) dHCheck += 300;
		else if(nLeft == 1) dHCheck -= 300;

		for(long rc = 0; rc < nCount-1; rc++)
		{
			xyTemp1 = xyArr.GetAt(rc);
			xyTemp2 = xyArr.GetAt(rc+1);
			dYBottom = xyTemp1.y;
			dYTop	= xyTemp2.y;

			if((dYBottom <= dHCheck && dYTop >= dHCheck))
			{
				dCTC = dYTop - dYBottom;
				if(dCTC > 600) dDia = 0;
				break; 
			}
			else dCTC = 0;
		}
	}

	if(dCTC == 0) dDia = 0;
	xyInfo.x	= dDia;
	xyInfo.y	= Compare(dDia, 0.0, "=") ? 0 : dCTC;
	return xyInfo;
}
CDPoint CRcBridgeRebar::GetInfoShearRebar_UpperSlab(long nSpan, long nLeft)
{
	CDPoint xyInfo	= CDPoint(0, 0);
	double dDia	= 0;
	double dCTC	= 0;
	double dStaCheck	= 0;	// 철근이 걸려야 되는 sta
	if(nLeft==-1 || nLeft==1)
	{
		long nJ	= nLeft==-1 ? nSpan : nSpan+1;
		dStaCheck	= GetStationOnJijum(nJ, 0, IsVertDir());

		// 가장 끝에 짜투리 치수가 잡하는걸 피해주기 위해..
		dStaCheck	+= (nLeft==-1)? 200 : -200;
	}
	else if(nLeft == 0)
	{
		long nJL	= nSpan;
		long nJR	= nSpan+1;
		dStaCheck	= (GetStationOnJijum(nJL, 0, IsVertDir()) + GetStationOnJijum(nJR, 0, IsVertDir()))/2;
	}

	if(m_nTypeBridge == BRIDGE_TYPE_ARCH)
	{
		long nJ = GetJijumConnectRibAndSlab();
		if(nSpan == nJ-1 || nSpan==nJ)
		{
			CWallApp *pWall = GetInWall(nJ-1);

			if(pWall != NULL)
			{
				double dDistOffset = pWall->m_dW/2;

				if(nSpan == nJ-1 && nLeft==0)
					dStaCheck -= dDistOffset/2;
				else if(nSpan == nJ && nLeft==0)
					dStaCheck += dDistOffset/2;
			}
		}
	}
	
	double dXLeft	= 0;
	double dXRight	= 0;

	// 치수선의 시작점은 벽체 외측이므로 시점에서 벽체 두께를 더 빼준다.
	double dStt = (IsOutsideWall())? m_dStationBridgeStt - m_dWS/GetAngleJijum(0).y : m_dStationBridgeStt;
	CDPoint xyC = CDPoint(0, 0);
	CDPointArray xyArr;
	dDia = m_placeByBlock_ShearRebar_UpperSlab.m_dDia;
	xyArr = m_placeByBlock_ShearRebar_UpperSlab.m_xyArr;
	
	long nCount	= xyArr.GetSize();
	if(nCount == 0) return xyInfo;
	
	dXLeft = dXRight = dStt;
	for(long rc = 0; rc < nCount; rc++)
	{
		xyC = xyArr.GetAt(rc);
		dXRight += xyC.x * xyC.y;
		if((dXLeft <= dStaCheck && dXRight >= dStaCheck))
		{
			if(xyC.x > 1)
			{
				dCTC = xyC.y;
				break;
			}
			else
			{
				long i=0; for(i=1; i<nCount-rc; i++)
				{
					if(nLeft == 1)
					{
						if(rc-i < 0) continue;
						xyC = xyArr.GetAt(rc-i);
					}
					else 
					{
						if(rc+i >= nCount) continue;
						xyC = xyArr.GetAt(rc+i);
					}
					
					if(xyC.x > 1) break;
				}
				dCTC = xyC.y;
				break;
			}
		}
		else if(rc == nCount-1 && dStaCheck > dXRight)
		{
			if(xyC.x > 1)
			{
				dCTC = xyC.y;
				break;
			}
			else
			{
				long i=0; for(i=1; i<nCount; i++)
				{
					if(nLeft == 1)
					{
						if(rc-i < 0) continue;
						xyC = xyArr.GetAt(rc-i);
					}
					else
					{
						if(rc+i >= 0) continue;
						xyC = xyArr.GetAt(rc+i);
					}
					
					if(xyC.x > 1) break;
				}
				dCTC = xyC.y;
				break;
			}
		}
		
		dXLeft = dXRight;
	}
	
	xyInfo.x	= dDia;
	xyInfo.y	= Compare(dDia, 0.0, "=") ? 0 : dCTC;
	return xyInfo;
}

CDPoint CRcBridgeRebar::GetInfoShearRebar_LowerSlab(long nSpan, long nLeft)
{
	CDPoint xyInfo	= CDPoint(0, 0);
	double dDia	= 0;
	double dCTC	= 0;
	double dStaCheck	= 0;	// 철근이 걸려야 되는 sta
	if(nLeft==-1 || nLeft==1)
	{
		long nJ	= nLeft==-1 ? nSpan : nSpan+1;
		dStaCheck	= GetStationOnJijum(nJ, 0, IsVertDir());

		// 가장 끝에 짜투리 치수가 잡하는걸 피해주기 위해..
		dStaCheck	+= (nLeft==-1)? 200 : -200;
	}
	else if(nLeft == 0)
	{
		long nJL	= nSpan;
		long nJR	= nSpan+1;
		dStaCheck	= (GetStationOnJijum(nJL, 0, IsVertDir()) + GetStationOnJijum(nJR, 0, IsVertDir()))/2;
	}


	double dXLeft	= 0;
	double dXRight	= 0;

	// 치수선의 시작점은 벽체 외측이므로 시점에서 벽체 두께를 더 빼준다.
	double dStt = m_dStationBridgeStt - m_dWS/GetAngleJijum(0).y;
	CDPoint xyC = CDPoint(0, 0);
	CDPointArray xyArr;
	dDia = m_placeByBlock_ShearRebar_LowerSlab.m_dDia;
	xyArr = m_placeByBlock_ShearRebar_LowerSlab.m_xyArr;

	long nCount	= xyArr.GetSize();
	if(nCount == 0) return xyInfo;

	dXLeft = dXRight = dStt;
	for(long rc = 0; rc < nCount; rc++)
	{
		xyC = xyArr.GetAt(rc);
		dXRight += xyC.x * xyC.y;
		if((dXLeft <= dStaCheck && dXRight >= dStaCheck))
		{
			if(xyC.x > 1)
			{
				dCTC = xyC.y;
				break;
			}
			else
			{
				long i=0; for(i=1; i<nCount-rc; i++)
				{
					if(nLeft == 1)
					{
						if(rc-i < 0) continue;
						xyC = xyArr.GetAt(rc-i);
					}
					else 
					{
						if(rc+i >= nCount) continue;
						xyC = xyArr.GetAt(rc+i);
					}

					if(xyC.x > 1) break;
				}
				dCTC = xyC.y;
				break;
			}
		}
		else if(rc == nCount-1 && dStaCheck > dXRight)
		{
			if(xyC.x > 1)
			{
				dCTC = xyC.y;
				break;
			}
			else
			{
				long i=0; for(i=1; i<nCount; i++)
				{
					if(nLeft == 1)
					{
						if(rc-i < 0) continue;
						xyC = xyArr.GetAt(rc-i);
					}
					else
					{
						if(rc+i >= 0) continue;
						xyC = xyArr.GetAt(rc+i);
					}

					if(xyC.x > 1) break;
				}
				dCTC = xyC.y;
				break;
			}
		}

		dXLeft = dXRight;
	}

	xyInfo.x	= dDia;
	xyInfo.y	= Compare(dDia, 0.0, "=") ? 0 : dCTC;
	return xyInfo;
}
CDPoint CRcBridgeRebar::GetInfoShearRebar_Wall(long nJ, long nLeft)
{
	BOOL bStt = TRUE;
	CDPoint xyInfo	= CDPoint(0, 0);
	double dDia	= 0;
	double dCTC	= 0;
	double dHCheck = 0;
	CWallApp pWall;
	CPlaceRebarByBlock RebarPlace;
	
	if(nJ == 0 || nJ == GetCountJijum()-1)
	{
		bStt = (nJ == 0)? TRUE:FALSE;
		if(!IsOutWall(bStt)) return xyInfo;
		MakeWallByOutWall(pWall, bStt, FALSE);
		long stt	= bStt ? iSTT : iEND;
		RebarPlace = m_placeByBlock_ShearRebar_OutWall[stt];
	}
	else 
	{
		long nIdxWall	= nJ - 1;
		CWallApp *ppWall	= GetInWall(nIdxWall);
		if(!ppWall) return xyInfo;
		if(!ppWall->m_bIs) return xyInfo;
		pWall		= *ppWall;

		RebarPlace = pWall.m_placeByBlock_ShearRebar;
	}
	dDia = RebarPlace.m_dDia;
	
	CDPoint xyPoint = pWall.GetXyWallTopCen(TRUE);
	double dElH = xyPoint.y;
	double dElL = pWall.m_dELB + pWall.m_footing.GetHeight() - pWall.m_dELBDiff;	
	if(IsBoxType())
	{
		dElL += m_dTS_Lower; // 함형인 경우 기초두께를 추가
	}

	if(nLeft==-1 || nLeft==1)
	{
		dHCheck	= (nLeft == -1)? (dElL+600):(dElH-200);
	}
	else if(nLeft == 0)
	{
		dHCheck	= (dElH + dElL)/2;
	}
	
	double dYTop	= 0;
	double dYBottom	= 0;
	double dStt = pWall.m_dELB - pWall.m_dELBDiff;
	CDPoint xyC = CDPoint(0, 0);
	CDPointArray xyArr = RebarPlace.m_xyArr;
	
	double nCount	= xyArr.GetSize();
	if(nCount == 0) return xyInfo;
	
	dYBottom = dYTop = dStt;

	for(long rc = 0; rc < nCount; rc++)
	{
		xyC = xyArr.GetAt(rc);
		dYTop += xyC.x * xyC.y;
		if((dYBottom <= dHCheck && dYTop >= dHCheck))
		{
			if(xyC.x > 1)
			{
				dCTC = xyC.y;
				break;
			}
			else
			{
				long nRetry = (long)((nLeft == 1) ? rc : nCount - rc);
				long i=0; for(i=1; i<nRetry; i++)
				{
					if(nLeft == 1)
					{
						if(rc-i < 0) continue;
						xyC = xyArr.GetAt(rc-i);
					}
					else
					{
						if(rc+i >= 0) continue;
						xyC = xyArr.GetAt(rc+i);
					}
					
					if(xyC.x > 1) break;
				}
				dCTC = xyC.y;
				break;
			}
		}
		else if(rc == nCount-1 && dHCheck > dYTop)
		{
			if(xyC.x > 1)
			{
				dCTC = xyC.y;
				break;
			}
			else
			{
				long i=0; for(i=1; i<nCount; i++)
				{
					if(nLeft == 1)
					{
						if(rc-i < 0) continue;
						xyC = xyArr.GetAt(rc-i);
					}
					else
					{
						if(rc+i >= nCount) continue;
						xyC = xyArr.GetAt(rc+i);
					}
					
					if(xyC.x > 1) break;
				}
				dCTC = xyC.y;
				break;
			}
		}
		
		dYBottom = dYTop;
	}
	
	xyInfo.x	= dDia;
	xyInfo.y	= Compare(dDia, 0.0, "=") ? 0 : dCTC;
	return xyInfo;
}

void CRcBridgeRebar::SetConcDataBasic(CConcBasic *pConc, EPartOfBridge ePos, BOOL UpAndFront, ELSDLoadGroupKind eGroupKind)
{
	CARcBridgeDataStd *pStd = m_pARcBridgeDataStd;

	pConc->m_nTypeUnit		= pStd->m_nTypeUnit; //0-CGS,1-SI
	pConc->m_nTypeKciCode	= pStd->m_nTypeKciCode;

	pConc->m_Fck	= GetValueFck(ePos);
	pConc->m_Fy		= GetValueFy(ePos, FALSE);
	pConc->m_FyShear	= GetValueFy(ePos, TRUE);
	pConc->m_Ec		= GetValueEc(ePos);
	pConc->m_Es		= pStd->m_Es;
	pConc->m_Pi_C	= pStd->m_Pi_C;
	pConc->m_Pi_F	= pStd->m_Pi_F;
	pConc->m_Pi_V	= pStd->m_Pi_V;
	pConc->m_Pi_Cobel	= pStd->m_Pi_F_Cobel;

	BOOL bLsd = pStd->IsLsdDesign();
	pConc->m_nTypeConcDesign = pStd->GetTypeConcDesign();

	if(bLsd)
	{
		CLsdResistCoefMatCtl *pResistCoefCtl = &(pStd->m_plsdEnv->GetLsdResistCoefMatCtl());
		if(pResistCoefCtl->GetResistCoefSize() > eLSD_COMBINE_SERVICE_I)
		{
			//CLsdResistCoefMat *pResistCoef = pResistCoefCtl->GetResistCoefPAt(eComboKind);

			ELSDCombKind eComboKind(eLSD_COMBINE_LIMIT_I);

			if(eGroupKind == eLSD_COMBINATION_LIMIT)
			{
				eComboKind = eLSD_COMBINE_LIMIT_I;
			}
			else if(eGroupKind == eLSD_COMBINATION_EXTREME)
			{
				eComboKind = eLSD_COMBINE_EXTREME_I;
			}
			else
				eComboKind = eLSD_COMBINE_SERVICE_I;

			pConc->m_Pi_C = pResistCoefCtl->GetCoefficient(eComboKind, eResistCoefMaterial_Concrete);
			pConc->m_Pi_S = pResistCoefCtl->GetCoefficient(eComboKind, eResistCoefMaterial_Ferro);

			pConc->m_Pi_C_use = pResistCoefCtl->GetCoefficient(eLSD_COMBINE_SERVICE_I, eResistCoefMaterial_Concrete);
			pConc->m_Pi_S_use = pResistCoefCtl->GetCoefficient(eLSD_COMBINE_SERVICE_I, eResistCoefMaterial_Ferro);
		}
		else
		{
			pConc->m_Pi_C = 0.65;
			pConc->m_Pi_S = 0.90;
		}

		CLsdDesignRatingCtl * pDesignRatingCtl = &(m_plsdEnvRating->GetLsdDesignRatingCtl());
		
		long nIndex = GetLsdMatrialIndex(ePos, UpAndFront);
		pConc->m_dCriticalCrackWidth = pDesignRatingCtl->GetLimitCrackWidth(pDesignRatingCtl->GetMaterialGrade(nIndex));
		pConc->m_strDesignDegree = pDesignRatingCtl->GetRatingCharacterByInteger(pDesignRatingCtl->GetMaterialGrade(nIndex));

		pConc->m_dThetaShearDesign = m_dThetaShearDesign;
		pConc->m_bCheckDeltaTR = m_bCheckDeltaTR;
		pConc->m_dElasticModularRatioUseCheck = m_dElasticModularRatioUseCheck;
		pConc->m_nSelectUsebilityCheck = m_nSelectUsebilityCheck;
		pConc->m_nTypeCrackWidthCondition = m_nTypeCrackWidthCondition;
		pConc->m_nCheckSupportBarRate = SUPPORTBAR_CHECK_SLAB;
		pConc->m_bCheckSuppoerBarAreaRate = TRUE;
	}
	else
	{
		pConc->m_nSelectApplyFs = m_nSelectApplyFs;
	}
}

void CRcBridgeRebar::SetConcDataSlab(const ETypeEnvComboLsd eTypeEnv)
{
	AhTPADelete(&m_pArrConcSlab[eTypeEnv],   (CConcBasic*)0);	

	if (IsValidComboEnvType(eTypeEnv) == FALSE)
		return;

	CHgBaseConcStd HgConcStd; 
	CARcBridgeDataStd *pStd = m_pARcBridgeDataStd;
	
	const HGBOOL bLsd = pStd->IsLsdDesign();

	long nJijumConnect = GetJijumConnectRibAndSlab();
	long nCnt = m_nQtyJigan*2 + 1;
	long nPos = 0, nPosCheck = 0;;
	long nSpan = 0;
	CString sHead = _T("");

	// 상부슬래브
	for(long iUD = iUPPER; iUD <= iLOWER; iUD++)
	{
		if(iUD == iLOWER && IsBoxType() == FALSE)
		{
			break;
		}
		if(IsBoxType())
		{
			sHead = iUD == iUPPER ? _T("상부슬래브 ") : _T("하부슬래브 ");
		}
		BOOL bUpperSlab = iUD == iUPPER ? TRUE : FALSE;
		for(long k=0; k<nCnt; k++)
		{
			CConcBasic *pData= new CConcBasic;
			pData->m_nTypeUnit		= pStd->m_nTypeUnit; //0-CGS,1-SI
			pData->m_nTypeKciCode	= pStd->m_nTypeKciCode;
			pData->m_nTypeSection	= SECTION_SINGLE; // 단면의 타입,SECTION_SINGLE
			BOOL bInJijum = FALSE;
			if(k==0) 
			{
				pData->m_sTitle.Format(_T("%s%s"), sHead,_T("좌측단부"));
				pData->m_Hunch = min(bUpperSlab ? m_dHWS : m_dWSHW, bUpperSlab ? m_dHHS*3 : m_dWSHH*3); // 헌치폭
				nPos = -1;
				nPosCheck = CHECK_POS_LEFT;
			}
			else if(k==nCnt-1)
			{
				pData->m_sTitle.Format(_T("%s%s"), sHead,_T("우측단부"));
				pData->m_Hunch	= min(bUpperSlab ? m_dHWE : m_dWEHW, bUpperSlab ? m_dHHE*3 : m_dWEHH*3);
				nPos = 1;
				nPosCheck = CHECK_POS_RIGHT;
			}
			else if(k%2 == 0)
			{
				if(k/2 == nJijumConnect) 
					pData->m_sTitle.Format(_T("%s%s"), sHead,_T("아치리브 접합부"));
				else 
					pData->m_sTitle.Format(_T("%s%s%d"), sHead,_T("중간지점"), k/2);
				pData->m_Hunch	= min(min(m_dHLW[k/2-1][iUD], m_dHHL[k/2-1][iUD]*3), min(m_dHRW[k/2-1][iUD], m_dHHR[k/2-1][iUD]*3));	// modified by jaeho(2005.04.12) - 헌치폭이 좌우 다르게 입력하도록 하게 되면서 수정
				nPos = 1;
				nPosCheck = CHECK_POS_RIGHT;
				bInJijum = TRUE;
			}
			else if(k%2 == 1)
			{
				pData->m_sTitle.Format(_T("%s%s%d)"), sHead,_T("중앙부(지간"), k/2 + 1);
				pData->m_Hunch	= 0;
				nPos = 0;
				nPosCheck = CHECK_POS_CENTER;
			}
			nSpan = (k-1)/2;

			SetConcDataBasic(pData, bUpperSlab? ePartUpperSlab : ePartLowerSlab, (nPos == 0)? FALSE : TRUE, GetGroupKindByEnvType(eTypeEnv));
			if(bUpperSlab)
			{
				pData->m_nCheckSupportBarRate = SUPPORTBAR_CHECK_SLAB;
				pData->m_bCheckSuppoerBarAreaRate = m_bCheckSupportSlabDryingShrinkage;
				pData->m_bHoriRebarCheckByReqRebar = m_bCheckSupportSlabByReqRebar;
				pData->m_bCheckSupportBarMainRate20 = m_bCheckSupportSlabMainRate;
				pData->m_bCheckSupportBarMainRateSpan = m_bCheckSupportSlabMainRateSpan;
				pData->m_bParallelMainRebar = TRUE;
				pData->m_LnSpan = m_dLengthJigan[nSpan];
			}
			else
			{
				pData->m_nCheckSupportBarRate = SUPPORTBAR_CHECK_FOOTING;
				pData->m_bCheckSuppoerBarAreaRate = m_bCheckSupportFootDryingShrinkage;

			}
			pData->m_Bo		= frM(UNIT_METER);
			pData->m_Ho		= bUpperSlab ? m_dTS : m_dTS_Lower; // 슬래브두께
			// 슬래브교 형식일때는 헌치 두께는 따로 고려하지 않고 전체를 슬래브 두께로 쓴다.
			if(m_nTypeBridge == BRIDGE_TYPE_SLAB && m_bSelectHunchDesignCheck)
			{
				double dHunchH = 0;
				if(k==0) dHunchH = m_dHHS;
				else if(k==nCnt-1) dHunchH = m_dHHE;
				else if(k%2 == 0) dHunchH = min(m_dHHL[k/2-1][iUD], m_dHHR[k/2-1][iUD]);
				else if(k%2 == 1) dHunchH = 0;

				pData->m_Ho		= m_dTS + dHunchH;
				pData->m_Hunch	= 0; // 헌치폭
			}

			pData->m_nEnvTypeCrack = m_nTypeCrackDesignSlab;
			pData->m_bMinAvCheck   = m_bApplyMinAvSlab;
			// 값이 CGS단위가 아닌 것은 변환을 하여 저장하여 줌.....
			if( bInJijum && m_nTypeBridge == BRIDGE_TYPE_TRAP/* || m_nTypeBridge == BRIDGE_TYPE_TRAP*/)
			{
				BOOL bLeft(TRUE);
				if(bLsd)
				{
					bLeft = SetDesignForceSlab_Lsd(pData, nSpan, nPos, nPosCheck, bUpperSlab, bInJijum, eTypeEnv);
				}
				else
				{
					bLeft = SetDesignForceSlab_Usd(pData, nSpan, nPos, nPosCheck, bUpperSlab, bInJijum);
				}

				double HuW = IsRoundHunch(k/2, bLeft, bUpperSlab) ? GetCalcLenRHunch(k/2, bLeft) : (bLeft ? m_dHLW[k/2-1][iUD] : m_dHRW[k/2-1][iUD]);
				double HuH = IsRoundHunch(k/2, bLeft, bUpperSlab) ? GetCalcLenRHunch(k/2, bLeft) : (bLeft ? m_dHHL[k/2-1][iUD] : m_dHHR[k/2-1][iUD]);
				double dAngS = GetAnglHunchWithSlabOrWall(k/2, bLeft, TRUE);
				double dAngW = GetAnglHunchWithSlabOrWall(k/2, bLeft, FALSE);

				double HuW_ = ((dAngS+dAngW) < 90)? HuW : (HuW - fabs(HuH*cos(ToRadian(180-(dAngS+dAngW)))));
				pData->m_Hunch = min(HuW_, (HuW_*tan(ToRadian(dAngS)))*3);
			}

			long nCntMainCycle	= 2;
			BOOL bOut = (nPos == 0) ? FALSE : TRUE; // 상부슬래브 상면 / 하부슬래브 하면
			double dDia = 0;
			double dDc =0;
			double dCtc = m_dCTC_MainRebar;
			double dB = pData->m_Bo/dCtc;
			// 벽체기준간격이고 선형방향 배치인 경우
			if(m_nTypeStandardCTCRebarMain==1 && m_nTypePlacingMainRebar_UpperSlab==0)
			{
				CDPoint vAng1 = GetAngleJijum(0);
				double dCtcTemp = dCtc*vAng1.y;
				dB = Round(pData->m_Bo/dCtcTemp,3);
			}
			CDPoint xyInfo	= CDPoint(0, 0);
			int i=0; for(i=0; i<nCntMainCycle; i++)
			{
				int j=0; for(j=0; j<MAX_REBAR_DAN; j++)
				{
					// 인장철근
					if(bUpperSlab)
					{
						dDc = (bOut)? m_dCoverUpper_UpperSlab[j]:m_dCoverLower_UpperSlab[j];
						xyInfo = GetInfoMainRebar_UpperSlab(bOut, nSpan, i, j, nPos);
					}
					else
					{
						dDc = (bOut) ? m_dCoverLower_LowerSlab[j] : m_dCoverUpper_LowerSlab[j];
						xyInfo = GetInfoMainRebar_LowerSlab(bOut, nSpan, i, j, nPos);
					}
					dDia = xyInfo.x;
					if(i == 0)
					{
						pData->m_RbT1C_DIA[j] = dDia; // 철근의 직경
						if(dDia>0)
						{
							pData->m_RbT1C_dc[j] = dDc;  // 철근의 중심거리 피복 + 100*단수(-1)
							pData->m_RbT1C_B [j] = dB;  // 철근의 개수 (1000/CTC)
						}
					}
					else
					{
						pData->m_RbT2C_DIA[j] = dDia; // 철근의 직경
						if(dDia>0)
						{
							pData->m_RbT2C_dc[j] = dDc;  // 철근의 중심거리 피복 + 100*단수(-1)
							pData->m_RbT2C_B [j] = dB;  // 철근의 개수 (1000/CTC)
						}
					}

					// 압축철근
					if(bUpperSlab)
					{
						dDc = (!bOut) ? m_dCoverUpper_UpperSlab[j]:m_dCoverLower_UpperSlab[j];
						xyInfo	= GetInfoMainRebar_UpperSlab(!bOut, nSpan, i, j, nPos);
					}
					else
					{
						dDc = (!bOut) ? m_dCoverLower_LowerSlab[j] : m_dCoverUpper_LowerSlab[j];
						xyInfo = GetInfoMainRebar_LowerSlab(!bOut, nSpan, i, j, nPos);
					}
					dDia = xyInfo.x;
					if(i == 0)
					{
						pData->m_RbC1C_DIA[j] = dDia; // 철근의 직경
						if(dDia>0)
						{
							pData->m_RbC1C_dc[j] = dDc;  // 철근의 중심거리 피복 + 100*단수(-1)
							pData->m_RbC1C_B [j] = dB;  // 철근의 개수 (1000/CTC)
						}
					}
					else
					{
						pData->m_RbC2C_DIA[j] = dDia; // 철근의 직경
						if(dDia>0)
						{
							pData->m_RbC2C_dc[j] = dDc;  // 철근의 중심거리 피복 + 100*단수(-1)
							pData->m_RbC2C_B [j] = dB;  // 철근의 개수 (1000/CTC)
						}
					}
				}
			}

			for(i=0; i<MAX_REBAR_DAN; i++)
			{
				xyInfo = bUpperSlab ? GetInfoSupportRebar_UpperSlab(!bOut, nSpan, i, nPos) : GetInfoSupportRebar_LowerSlab(!bOut, nSpan, i, nPos);
				pData->m_CSupportBarDia[i] = xyInfo.x;
				pData->m_CSupportBarCTC[i] = xyInfo.y;
				xyInfo = bUpperSlab ? GetInfoSupportRebar_UpperSlab(bOut, nSpan, i, nPos) : GetInfoSupportRebar_LowerSlab(bOut, nSpan, i, nPos);
				pData->m_TSupportBarDia[i] = xyInfo.x;
				pData->m_TSupportBarCTC[i] = xyInfo.y;
			}

			BOOL bCalcShear = (m_RebarShearDetail_UpperSlab.m_nType==TYPE_SHEAR_SPACER)? FALSE : TRUE;
			if(bUpperSlab == FALSE)
			{
				bCalcShear = (m_RebarShearDetail_LowerSlab.m_nType==TYPE_SHEAR_SPACER)? FALSE : TRUE;
			}
			if(bCalcShear)
			{
				xyInfo = bUpperSlab ? GetInfoShearRebar_UpperSlab(nSpan, nPos) : GetInfoShearRebar_LowerSlab(nSpan, nPos);
				pData->m_SvDia = xyInfo.x;
				pData->m_SvCtc = xyInfo.y;
				if(bUpperSlab)
				{

					double dSvEa  = frM(UNIT_METER)/(m_nCountWrapMainRebarUpperSlab*GetCtcRebarMain()/2);
					pData->m_SvEa = (m_RebarShearDetail_UpperSlab.m_nType == TYPE_SHEAR_DIGUT || m_RebarShearDetail_UpperSlab.m_nType == TYPE_SHEAR_SINGLE_HOOK)? dSvEa/2 : dSvEa;
				}
				else
				{
					double dSvEa  = frM(UNIT_METER)/(m_nCountWrapMainRebarLowerSlab*GetCtcRebarMain()/2);
					pData->m_SvEa = (m_RebarShearDetail_LowerSlab.m_nType == TYPE_SHEAR_DIGUT || m_RebarShearDetail_LowerSlab.m_nType == TYPE_SHEAR_SINGLE_HOOK)? dSvEa/2 : dSvEa;
				}
			}
			else
			{
				pData->m_SvDia	= 0;
				pData->m_SvCtc	= 0;
				pData->m_SvEa	= 0;
			}
			if(m_bSelectHunchDesignCheck == FALSE)
			{
				pData->m_Hunch = 0;
			}

			// 전단검토 위치 옵션 적용 때문에 부재력 집계는 철근 집계가 된다음에 해줘야한다.
			if(bLsd)
			{
				SetDesignForceSlab_Lsd(pData, nSpan, nPos, nPosCheck, bUpperSlab, bInJijum, eTypeEnv);
			}
			else
			{
				SetDesignForceSlab_Usd(pData, nSpan, nPos, nPosCheck, bUpperSlab, bInJijum);
			}

			m_pArrConcSlab[eTypeEnv].Add(pData);
		}
	}
}

BOOL CRcBridgeRebar::SetDesignForceSlab_Usd( CConcBasic *pConc, long nSpan, long nPos, long nPosCheck, BOOL bUpperSlab, BOOL bInJijum )
{
	CARcBridgeDataStd *pStd = m_pARcBridgeDataStd;

	BOOL bLeft(TRUE);
	double Moment=0,MomentUse=0, MomentEq=0, Shear=0, ShearEq = 0, MomentEq_2=0, ShearEq_2 = 0;
	BOOL bCalc3DUlt = IsCalc3D(COMBO_ULTIMATE);
	BOOL bCalc3DUse = IsCalc3D(COMBO_SERVICE);

	double dDistShear = GetDistCheckShearSlab(nSpan, nPosCheck, bUpperSlab, pConc);

	Moment	  = fabs(GetOutValueSlab(nSpan, nPosCheck, COMBO_ULTIMATE, ELE_MOMENT2, TRUE, FALSE, bUpperSlab));
	MomentEq  = fabs(GetOutValueSlab(nSpan, nPosCheck, COMBO_EARTHQUAKE, ELE_MOMENT2, TRUE, FALSE, bUpperSlab));
	MomentUse = fabs(GetOutValueSlab(nSpan, nPosCheck, COMBO_SERVICE, ELE_MOMENT2, TRUE, FALSE, bUpperSlab));
	Shear	  = fabs(GetOutValueSlab(nSpan, nPosCheck, COMBO_ULTIMATE, ELE_SHEAR_2, TRUE, FALSE, bUpperSlab, eEnvLimit, dDistShear));
	ShearEq	  = fabs(GetOutValueSlab(nSpan, nPosCheck, COMBO_EARTHQUAKE, ELE_SHEAR_2, TRUE, FALSE, bUpperSlab, eEnvLimit, dDistShear));
	if(m_nSelectModelingCountEQ==2)
	{
		MomentEq_2	= fabs(GetOutValueSlab(nSpan, nPosCheck, COMBO_EARTHQUAKE2, ELE_MOMENT2, TRUE, FALSE, bUpperSlab));
		ShearEq_2	= fabs(GetOutValueSlab(nSpan, nPosCheck, COMBO_EARTHQUAKE2, ELE_SHEAR_2, TRUE, FALSE, bUpperSlab, eEnvLimit, dDistShear));
		MomentEq	= (fabs(MomentEq) > fabs(MomentEq_2))? MomentEq : MomentEq_2;
		ShearEq		= (fabs(ShearEq) > fabs(ShearEq_2))? ShearEq : ShearEq_2;
	}
	if(bInJijum)
	{
		long nSpan2 = nSpan+1;
		long nPosCheck2 = CHECK_POS_LEFT;

		double Moment2	  = fabs(GetOutValueSlab(nSpan2, nPosCheck2, COMBO_ULTIMATE, ELE_MOMENT2, TRUE, FALSE, bUpperSlab));
		double MomentEq2  = fabs(GetOutValueSlab(nSpan2, nPosCheck2, COMBO_EARTHQUAKE, ELE_MOMENT2, TRUE, FALSE, bUpperSlab));
		double MomentUse2 = fabs(GetOutValueSlab(nSpan2, nPosCheck2, COMBO_SERVICE, ELE_MOMENT2, TRUE, FALSE, bUpperSlab));
		double Shear2	  = fabs(GetOutValueSlab(nSpan2, nPosCheck2, COMBO_ULTIMATE, ELE_SHEAR_2, TRUE, FALSE, bUpperSlab, eEnvLimit, dDistShear));
		double ShearEq2	  = fabs(GetOutValueSlab(nSpan2, nPosCheck2, COMBO_EARTHQUAKE, ELE_SHEAR_2, TRUE, FALSE, bUpperSlab, eEnvLimit, dDistShear));
		if(m_nSelectModelingCountEQ==2)
		{
			MomentEq_2	= fabs(GetOutValueSlab(nSpan2, nPosCheck2, COMBO_EARTHQUAKE2, ELE_MOMENT2, TRUE, FALSE, bUpperSlab));
			ShearEq_2	= fabs(GetOutValueSlab(nSpan2, nPosCheck2, COMBO_EARTHQUAKE2, ELE_SHEAR_2, TRUE, FALSE, bUpperSlab, eEnvLimit, dDistShear));
			MomentEq2	= (fabs(MomentEq2) > fabs(MomentEq_2))? MomentEq2 : MomentEq_2;
			ShearEq2	= (fabs(ShearEq2) > fabs(ShearEq_2))? ShearEq2 : ShearEq_2;
		}

		bLeft = (Moment >= Moment2)? TRUE : FALSE;
		
		Moment	  = max(Moment, Moment2);
		MomentEq  = max(MomentEq, MomentEq2);
		MomentUse = max(MomentUse, MomentUse2);
		Shear	  = max(Shear, Shear2);
		ShearEq	  = max(ShearEq, ShearEq2);
	}
	Moment	  = max(Moment, MomentEq);
	Shear	  = max(Shear, ShearEq);
	if(bCalc3DUlt)
	{
		if(bInJijum)
		{
			double Moment3D = max(fabs(GetOutValueSlabShell(nSpan,CHECK_POS_RIGHT,COMBO_ULTIMATE,ELE_MOMENT2, bUpperSlab)), fabs(GetOutValueSlabShell(nSpan+1,CHECK_POS_LEFT,COMBO_ULTIMATE,ELE_MOMENT2, bUpperSlab)));
			double Shear3D = max(fabs(GetOutValueSlabShell(nSpan,CHECK_POS_RIGHT,COMBO_ULTIMATE,ELE_SHEAR_2, bUpperSlab)), fabs(GetOutValueSlabShell(nSpan+1,CHECK_POS_LEFT,COMBO_ULTIMATE,ELE_SHEAR_2, bUpperSlab)));
			Moment	= max(Moment, Moment3D);
			Shear	= max(Shear, Shear3D);
		}
		else
		{
			Moment	= max(Moment, fabs(GetOutValueSlabShell(nSpan,nPosCheck,COMBO_ULTIMATE,ELE_MOMENT2, bUpperSlab)));
			Shear	= max(Shear, fabs(GetOutValueSlabShell(nSpan,nPosCheck,COMBO_ULTIMATE,ELE_SHEAR_2, bUpperSlab)));
		}
	}
	if(bCalc3DUse)
	{
		if(bInJijum)
		{
			double MomentUse3D = max(fabs(GetOutValueSlabShell(nSpan,CHECK_POS_RIGHT,COMBO_SERVICE ,ELE_MOMENT2, bUpperSlab)), fabs(GetOutValueSlabShell(nSpan+1,CHECK_POS_LEFT,COMBO_SERVICE ,ELE_MOMENT2, bUpperSlab)));
			MomentUse = max(MomentUse, MomentUse3D);
		}
		else MomentUse = max(MomentUse, fabs(GetOutValueSlabShell(nSpan,nPosCheck,COMBO_SERVICE ,ELE_MOMENT2, bUpperSlab)));
	}

	pConc->m_Moment		= GetValueUnitChange(Moment,pStd->m_szTonfM,UNIT_CGS_TONFM);
	pConc->m_Shear		= GetValueUnitChange(Shear,pStd->m_szTonf,UNIT_CGS_TONF);
	pConc->m_MomentUse	= GetValueUnitChange(MomentUse,pStd->m_szTonfM,UNIT_CGS_TONFM);
	pConc->m_MomentCrack	= pConc->m_MomentUse;

	return bLeft;
}

BOOL CRcBridgeRebar::SetDesignForceSlab_Lsd( CConcBasic *pConc, long nSpan, long nPos, long nPosCheck, BOOL bUpperSlab, BOOL bInJijum, const ETypeEnvComboLsd eTypeEnv )
{
	CARcBridgeDataStd *pStd = m_pARcBridgeDataStd;

	BOOL bLeft(TRUE);
	BOOL bCalc3DUlt = IsCalc3D(COMBO_ULTIMATE);
	double Moment=0, Shear=0;

	double dDistShear = GetDistCheckShearSlab(nSpan, nPosCheck, bUpperSlab, pConc);;

	if(eTypeEnv == eEnvExtremeI || eTypeEnv == eEnvExtremeII)
	{
		Moment	  = fabs(GetOutValueSlabEQ(nSpan, nPosCheck, ELE_MOMENT2, bUpperSlab, eTypeEnv));
		Shear	  = fabs(GetOutValueSlabEQ(nSpan, nPosCheck, ELE_SHEAR_2, bUpperSlab, eTypeEnv, dDistShear));
	}
	else
	{
		Moment	= fabs(GetOutValueSlab(nSpan, nPosCheck, COMBO_ULTIMATE, ELE_MOMENT2, TRUE, FALSE, bUpperSlab, eTypeEnv));
		Shear	  = fabs(GetOutValueSlab(nSpan, nPosCheck, COMBO_ULTIMATE, ELE_SHEAR_2, TRUE, FALSE, bUpperSlab, eTypeEnv, dDistShear));
	}

	if(bInJijum)
	{
		long nSpan2 = nSpan+1;
		long nPosCheck2 = CHECK_POS_LEFT;

		double Moment2=0, Shear2=0;
		if(eTypeEnv == eEnvExtremeI || eTypeEnv == eEnvExtremeII)
		{
			Moment2	  = fabs(GetOutValueSlabEQ(nSpan2, nPosCheck2, ELE_MOMENT2, bUpperSlab, eTypeEnv));
			Shear2	  = fabs(GetOutValueSlabEQ(nSpan2, nPosCheck2, ELE_SHEAR_2, bUpperSlab, eTypeEnv, dDistShear));
		}
		else
		{
			Moment2	= fabs(GetOutValueSlab(nSpan2, nPosCheck2, COMBO_ULTIMATE, ELE_MOMENT2, TRUE, FALSE, bUpperSlab, eTypeEnv));
			Shear2	  = fabs(GetOutValueSlab(nSpan2, nPosCheck2, COMBO_ULTIMATE, ELE_SHEAR_2, TRUE, FALSE, bUpperSlab, eTypeEnv, dDistShear));
		}

		bLeft = (Moment >= Moment2)? TRUE : FALSE;

		Moment	  = max(Moment, Moment2);
		Shear	  = max(Shear, Shear2);
	}
	
	if(bCalc3DUlt)
	{
		if(bInJijum)
		{
			double Moment3D = max(fabs(GetOutValueSlabShell(nSpan,CHECK_POS_RIGHT,COMBO_ULTIMATE,ELE_MOMENT2, bUpperSlab, eTypeEnv)), fabs(GetOutValueSlabShell(nSpan+1,CHECK_POS_LEFT,COMBO_ULTIMATE,ELE_MOMENT2, bUpperSlab, eTypeEnv)));
			double Shear3D = max(fabs(GetOutValueSlabShell(nSpan,CHECK_POS_RIGHT,COMBO_ULTIMATE,ELE_SHEAR_2, bUpperSlab, eTypeEnv)), fabs(GetOutValueSlabShell(nSpan+1,CHECK_POS_LEFT,COMBO_ULTIMATE,ELE_SHEAR_2, bUpperSlab, eTypeEnv)));
			Moment	= max(Moment, Moment3D);
			Shear	= max(Shear, Shear3D);
		}
		else
		{
			Moment	= max(Moment, fabs(GetOutValueSlabShell(nSpan,nPosCheck,COMBO_ULTIMATE,ELE_MOMENT2, bUpperSlab, eTypeEnv)));
			Shear	= max(Shear, fabs(GetOutValueSlabShell(nSpan,nPosCheck,COMBO_ULTIMATE,ELE_SHEAR_2, bUpperSlab, eTypeEnv)));
		}
	}
	
	// mm당 부재력 이므로 검토단면 폭을 곱해준다.
	double dWidth = frM(UNIT_METER);
	pConc->m_Moment		= GetValueUnitChange(Moment,pStd->m_szTonfM,UNIT_CGS_TONFM) * dWidth;
	pConc->m_Shear		= GetValueUnitChange(Shear,pStd->m_szTonf,UNIT_CGS_TONF) * dWidth;
	pConc->m_MomentUse	= GetValueUnitChange(Moment,pStd->m_szTonfM,UNIT_CGS_TONFM) * dWidth;
	if(eTypeEnv == eEnvService)
	{
		Moment	= fabs(GetOutValueSlab(nSpan, nPosCheck, COMBO_ULTIMATE, ELE_MOMENT2, TRUE, FALSE, bUpperSlab, eEnvService_Crack));
		
		if(bInJijum)
		{
			long nSpan2 = nSpan+1;
			long nPosCheck2 = CHECK_POS_LEFT;

			Moment	  = max(Moment, fabs(GetOutValueSlab(nSpan2, nPosCheck2, COMBO_ULTIMATE, ELE_MOMENT2, TRUE, FALSE, bUpperSlab, eEnvService_Crack)));
		}
		if(bCalc3DUlt)
		{
			if(bInJijum)
			{
				double Moment3D = max(fabs(GetOutValueSlabShell(nSpan,CHECK_POS_RIGHT,COMBO_ULTIMATE,ELE_MOMENT2, bUpperSlab, eEnvService_Crack)), fabs(GetOutValueSlabShell(nSpan+1,CHECK_POS_LEFT,COMBO_ULTIMATE,ELE_MOMENT2, bUpperSlab, eEnvService_Crack)));
				Moment	= max(Moment, Moment3D);
			}
			else
			{
				Moment	= max(Moment, fabs(GetOutValueSlabShell(nSpan,nPosCheck,COMBO_ULTIMATE,ELE_MOMENT2, bUpperSlab, eEnvService_Crack)));
			}
		}
		pConc->m_MomentCrack	= GetValueUnitChange(Moment,pStd->m_szTonfM,UNIT_CGS_TONFM) * dWidth;
	}
	else
	{
		pConc->m_MomentCrack	= pConc->m_MomentUse;
	}

	return bLeft;
}

void CRcBridgeRebar::SetConcDataSlab()
{
	InitConcSlab();

	CARcBridgeDataStd *pStd = m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();
	HGINT32 icTypeEnv = bLsd ? COUNT_CONC_LSD : eEnvLimit + 1;
	for (HGINT32 ix = eEnvLimit; ix < icTypeEnv; ++ix)
	{
		SetConcDataSlab((ETypeEnvComboLsd)ix);
	}
}

void CRcBridgeRebar::SetConcDataPRF()
{
	InitConcPRF();

	CARcBridgeDataStd *pStd = m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();
	HGINT32 icTypeEnv = bLsd ? COUNT_CONC_LSD : eEnvLimit + 1;
	for (HGINT32 ix = eEnvLimit; ix < icTypeEnv; ++ix)
	{
		SetConcDataPRF((ETypeEnvComboLsd)ix);
	}
}

void CRcBridgeRebar::SetConcDataPRF( const ETypeEnvComboLsd eTypeEnv )
{
	AhTPADelete(&m_pArrConcPRF[eTypeEnv],   (CConcBasic*)0);	

	if(m_bExistProtectionRiseFooting == FALSE) return;
	if(IsValidComboEnvType(eTypeEnv) == FALSE) return;

	CHgBaseConcStd HgConcStd; 
	CARcBridgeDataStd *pStd = m_pARcBridgeDataStd;

	const HGBOOL bLsd = pStd->IsLsdDesign();

	long nCnt = m_nQtyJigan*2 + 1;
	long nPosCheck = 0;;
	CString sHead = _T("");

	// 상부슬래브
	
	sHead = _T("부상방지저판");
	for(long iSE=iSTT; iSE<=iEND; ++iSE) //k
	{
		BOOL bStt = iSE == iSTT;

		CConcBasic *pData= new CConcBasic;

		SetConcDataBasic(pData, ePartLowerSlab, FALSE, GetGroupKindByEnvType(eTypeEnv));
		
		pData->m_nTypeSection	= SECTION_SINGLE; // 단면의 타입,SECTION_SINGLE
		BOOL bInJijum = FALSE;
		
		pData->m_sTitle.Format(_T("%s %s"), sHead, bStt ? _T("좌측") : _T("우측"));
		pData->m_Hunch = 0;

		double dCtc = GetCTCRebarPRF_Main();
		double EaRebar = 1000.0 / dCtc;

		pData->m_Bo		= frM(UNIT_METER);
		pData->m_Ho		= m_dPRF_H1+m_dPRF_H2;
		
		pData->m_nEnvTypeCrack = m_nTypeCrackDesignSlab;
		pData->m_bMinAvCheck   = m_bApplyMinAvSlab;

		pData->m_nCheckSupportBarRate = SUPPORTBAR_CHECK_FOOTING;
		pData->m_bCheckSuppoerBarAreaRate = m_bCheckSupportFootDryingShrinkage;
		
		pData->m_RbT1C_dc[0] = pData->m_RbT2C_dc[0] = m_dCoverLower_LowerSlab[0];
		pData->m_RbT1C_DIA[0] = m_dPRF_Dia_Main;
		pData->m_RbT1C_B[0] = EaRebar;		

		// 수평철근 : 상,하면 동일하게 적용
		pData->m_TSupportBarDia[0] = m_dPRF_Dia_Support;
		pData->m_TSupportBarCTC[0] = m_dPRF_CTC_Support;
		pData->m_CSupportBarDia[0] = m_dPRF_Dia_Support;
		pData->m_CSupportBarCTC[0] = m_dPRF_CTC_Support;

		//전단철근
		if(m_nPRF_Type_Shear<TYPE_SHEAR_SPACER && m_dPRF_CTC_Shear>0)
		{
			pData->m_SvDia = m_dPRF_Dia_Shear;
			pData->m_SvCtc = m_dPRF_CTC_Shear;
			pData->m_SvEa = GetCountShearRebarBFooting();
		}

		// 전단검토 위치 옵션 적용 때문에 부재력 집계는 철근 집계가 된다음에 해줘야한다.
		if(bLsd)
		{
			SetDesignForcePRF_Lsd(pData, bStt, nPosCheck, eTypeEnv);
		}
		else
		{
			SetDesignForcePRF_Usd(pData, bStt, nPosCheck);
		}

		m_pArrConcPRF[eTypeEnv].Add(pData);
	}	
}

void CRcBridgeRebar::SetConcDataFooting(BOOL bReverse, BOOL bCheckAdd)
{
	CHgBaseConcStd HgConcStd; 
	CARcBridgeDataStd *pStd = m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();
	
	if(bCheckAdd) 
	{
		InitConcFootCheckAdd();
	}
	else if(!bReverse) 
	{
		InitConcFoot();
	}
	else 
	{
		InitConcFootRev();
	}

	if(IsBoxType() || IsRcSlab()) return;

	CFootingApp *pFooting;

	BOOL bCalcShear = FALSE;
	BOOL bLeft = TRUE;
	BOOL bUpper = TRUE;
	BOOL bFront = TRUE;
	BOOL bIsOutWall = (IsOutsideWall()); 
	long nCntSE = (IsOutWall(TRUE)? 2:0) + (IsOutWall(FALSE)? 2:0);
	long nCnt = bCheckAdd? 4 : ((bIsOutWall)? (nCntSE+GetCountInWall()):GetCountInWall());
	long nJijum = 0;

	if(bCheckAdd && (m_nTypeBridge!=BRIDGE_TYPE_ARCH && m_nTypeBridge!=BRIDGE_TYPE_TRAP2)) return;
	if(bCheckAdd && m_bCheckFrontFootTrap2)
		nCnt = 8;

	BOOL bVertDir	= IsVertDir();
//	long nTypeJongOld = m_nTypeJongdanForRebar;
	GetTvVertSection_Std(0, TRUE, FALSE, FALSE, bVertDir? -1 : 1);
	SyncBridgeRebar(FALSE, -1, TRUE);

	const HGINT32 icEnvType = bLsd ? COUNT_CONC_LSD : eEnvLimit + 1;
	for (HGINT32 ixEnvType = eEnvLimit; ixEnvType < icEnvType; ++ixEnvType)
	{
		const ETypeEnvComboLsd eTypeEnv = static_cast<ETypeEnvComboLsd>(ixEnvType);
		if (IsValidComboEnvType(eTypeEnv) == FALSE)
			continue;

		long k=0; for(k=0; k<nCnt; k++)
		{
			//		if(!bIsOutWall && 4>k) continue;
			long nIndex = (bIsOutWall)? k:k+4;
			CConcBasic *pData= new CConcBasic;
			
			pData->m_nTypeUnit		= pStd->m_nTypeUnit; //0-CGS,1-SI
			pData->m_nTypeKciCode	= pStd->m_nTypeKciCode;
			pData->m_nTypeSection	= SECTION_SINGLE; // 단면의 타입,SECTION_SINGLE

			if(bCheckAdd)
			{
				// 			if(nIndex % 4 < 2) nJijum = 0;
				// 			else if(nIndex % 4 < 4)	nJijum = m_nQtyJigan;
				// 			else nJijum = nIndex % 4 - 3;
				// SonarQube Issue 처리 - nIndex % 4 는 무조건 4보다 작다.
				if(nIndex % 4 < 2) nJijum = 0;
				else	nJijum = m_nQtyJigan;
			}
			else
			{
				if(nIndex<2) nJijum = 0;
				else if(nIndex<4) nJijum = m_nQtyJigan;
				else nJijum = nIndex-3;
			}

			pFooting = GetFootingByJijumNumber(nJijum);
			if(pFooting == NULL) continue;

			bCalcShear = (pFooting->m_rebarShearDetail.m_nType==TYPE_SHEAR_SPACER)? FALSE : TRUE;

			if(bCheckAdd)
			{
				bReverse = (nIndex%2 == 1)? TRUE : FALSE;
				if(nIndex == 0 || nIndex == 1) 
				{
					pData->m_sTitle = "시점측(앞굽2)";
					pData->m_Hunch	= 0;
					bUpper = (bReverse)? TRUE:FALSE;
					bLeft = FALSE;
					bFront = TRUE;
				}
				else if(nIndex == 2 || nIndex == 3)
				{
					pData->m_sTitle = "종점측(앞굽2)";
					pData->m_Hunch	= 0;
					bUpper = (bReverse)? TRUE:FALSE;
					bLeft = TRUE;
					bFront = TRUE;
				}
				if(nIndex == 4 || nIndex == 5) 
				{
					pData->m_sTitle = "시점측(앞굽3)";
					pData->m_Hunch	= 0;
					bUpper = (bReverse)? TRUE:FALSE;
					bLeft = FALSE;
					bFront = TRUE;
				}
				else if(nIndex == 6 || nIndex == 7)
				{
					pData->m_sTitle = "종점측(앞굽3)";
					pData->m_Hunch	= 0;
					bUpper = (bReverse)? TRUE:FALSE;
					bLeft = TRUE;
					bFront = TRUE;
				}
			}
			else
			{
				//		CString m_sTitle;
				if(nIndex==0) 
				{
					pData->m_sTitle = "시점측(앞굽)";
					pData->m_Hunch	= 0;
					bUpper = (bReverse)? TRUE:FALSE;
					bLeft = FALSE;
					bFront = TRUE;
				}
				else if(nIndex==1)
				{
					pData->m_sTitle = "시점측(뒷굽)";
					pData->m_Hunch	= 0;
					bUpper = (bReverse)? FALSE:TRUE;
					bLeft = TRUE;
					bFront = FALSE;
				}
				else if(nIndex==2)
				{
					pData->m_sTitle = "종점측(앞굽)";
					pData->m_Hunch	= 0;
					bUpper = (bReverse)? TRUE:FALSE;
					bLeft = TRUE;
					bFront = TRUE;
				}
				else if(nIndex==3)
				{
					pData->m_sTitle = "종점측(뒷굽)";
					pData->m_Hunch	= 0;
					bUpper = (bReverse)? FALSE:TRUE;
					bLeft = FALSE;
					bFront = FALSE;
				}
				else
				{
					pData->m_sTitle.Format("중간지점%d", nIndex-3);
					pData->m_Hunch	= 0;
					bUpper = (bReverse)? TRUE:FALSE;
					bLeft = (pFooting->m_nType==FOOTING_TYPE_RIGHTSLOPE)? TRUE : FALSE;
					bFront = TRUE;
				}
			}

			EPartOfBridge ePartBri = (nJijum==0)? ePartFootStt : ((nJijum==m_nQtyJigan)? ePartFootEnd : ePartInFoot);
			SetConcDataBasic(pData, ePartBri, bUpper, (ELSDLoadGroupKind)ixEnvType);
			pData->m_nCheckSupportBarRate = SUPPORTBAR_CHECK_FOOTING;
			pData->m_bCheckSuppoerBarAreaRate =  m_bCheckSupportFootDryingShrinkage;
			pData->m_bSkipAsMinCheckByHoriRebar = m_bSkipAsMinCheckByHoriRebar;

			// 단면의 모양
			pData->m_Bo				= frM(UNIT_METER);
			pData->m_Ho	= pFooting->GetHeight(!bFront);				// 기초높이
			pData->m_nEnvTypeCrack = m_nTypeCrackDesignFoot;
			pData->m_bMinAvCheck   = m_bApplyMinAvFoot;

			long nCntMainCycle	= 2;

			long nDanComp = pFooting->GetDanMainRebar(1, !bUpper);
			long nDanTens = pFooting->GetDanMainRebar(1, bUpper);

			double dDia = 0;
			double dDc =0;
			double dCtc = pFooting->m_placeByBlock_Main_Side[bUpper? 1:0][0].GetCTC();
			double dB = pData->m_Bo/dCtc;
			CDPoint xyInfo	= CDPoint(0, 0);

			int i=0; for(i=0; i<nCntMainCycle; i++)
			{
				int j=0; for(j=0; j<MAX_REBAR_DAN; j++)
				{
					dDc = (bUpper)? pFooting->m_dCoverUpper[j]:pFooting->m_dCoverLower[j];
					xyInfo	= GetInfoMainRebar_Footing(nJijum, bUpper, i, j, bLeft);
					dDia = xyInfo.x;

					if(j >= nDanTens) continue;
					if(i == 0)
					{
						pData->m_RbT1C_DIA[j] = dDia; // 철근의 직경
						pData->m_RbT1C_dc[j] = dDc;  // 철근의 중심거리 피복 + 100*단수(-1)
						if(dDia>0)
						{
							dB = pData->m_Bo/xyInfo.y;
							pData->m_RbT1C_B [j] = dB;  // 철근의 개수 (1000/CTC)
						}
					}
					else
					{
						pData->m_RbT2C_DIA[j] = dDia; // 철근의 직경
						pData->m_RbT2C_dc[j] = dDc;  // 철근의 중심거리 피복 + 100*단수(-1)
						if(dDia>0)
						{
							dB = pData->m_Bo/xyInfo.y;
							pData->m_RbT2C_B [j] = dB;  // 철근의 개수 (1000/CTC)
						}
					}

					// 압축쪽 철근도 집계한다.
					dDc = (bUpper)? pFooting->m_dCoverLower[j] : pFooting->m_dCoverUpper[j];
					xyInfo	= GetInfoMainRebar_Footing(nJijum, !bUpper, i, j, bLeft);
					dDia = xyInfo.x;
					if(i == 0)
					{
						pData->m_RbC1C_DIA[j] = dDia; // 철근의 직경
						pData->m_RbC1C_dc[j] = dDc;  // 철근의 중심거리 피복 + 100*단수(-1)
						if(dDia>0)
						{
							dB = pData->m_Bo/xyInfo.y;
							pData->m_RbC1C_B [j] = dB;  // 철근의 개수 (1000/CTC)
						}
					}
					else
					{
						pData->m_RbC2C_DIA[j] = dDia; // 철근의 직경
						pData->m_RbC2C_dc[j] = dDc;  // 철근의 중심거리 피복 + 100*단수(-1)
						if(dDia>0)
						{
							dB = pData->m_Bo/xyInfo.y;
							pData->m_RbC2C_B [j] = dB;  // 철근의 개수 (1000/CTC)
						}
					}
				}
			}
			// 배력철근
			for(i=0; i<MAX_REBAR_DAN; i++)
			{
				long nC = (bUpper)? 1:0;
				long nT = (bUpper)? 0:1;
				if(i < nDanComp)
				{
					pData->m_CSupportBarDia[i] = pFooting->m_placeByBlock_Support_Front[nC][i].m_dDia;
					pData->m_CSupportBarCTC[i] = pFooting->GetInfoRebarSupport(!bUpper, bLeft, i).y;
				}
				if(i < nDanTens)
				{
					pData->m_TSupportBarDia[i] = pFooting->m_placeByBlock_Support_Front[nT][i].m_dDia;
					pData->m_TSupportBarCTC[i] = pFooting->GetInfoRebarSupport(bUpper, bLeft, i).y;
				}
			}

			// 수직전단철근
			if(bCalcShear)
			{
				pData->m_SvDia = pFooting->m_placeByBlock_Shear_Front.m_dDia;
				pData->m_SvCtc = pFooting->GetInfoRebarShear(bUpper, bLeft).y;
				long nCntWrap = pFooting->m_nCountWrapMainRebar;
				double dSvEa = frM(UNIT_METER)/(nCntWrap*GetCtcRebarMain()/2);
				long nTypeSv = pFooting->m_rebarShearDetail.m_nType;
				pData->m_SvEa = (nTypeSv == TYPE_SHEAR_DIGUT || nTypeSv == TYPE_SHEAR_SINGLE_HOOK) ? dSvEa/2 : dSvEa;
			}
			else
			{
				pData->m_SvDia	= 0;
				pData->m_SvCtc	= 0;
				pData->m_SvEa	= 0;
			}

			if(bCheckAdd) m_pArrConcFootCheckAdd[ixEnvType].Add(pData);
			else if(bReverse) m_pArrConcFootRev[ixEnvType].Add(pData);
			else m_pArrConcFoot[ixEnvType].Add(pData);
		}
	}	
	
//	m_nTypeJongdanForRebar = nTypeJongOld;
//	m_nTypeJongdanForRebarOld = nTypeJongOld;
	GetTvVertSection_Std(0, TRUE, FALSE, TRUE, bVertDir? -1 : 1);

//	GetTvVertSection_Std(0, TRUE, FALSE, FALSE, nTypeJongOld);
//	SyncBridgeRebar(FALSE, 0, TRUE);
//	GetTvVertSection_Std(0, TRUE, FALSE, TRUE, nTypeJongOld);
}

void CRcBridgeRebar::SetConcDataOutWall(const ETypeEnvComboLsd eTypeEnv)
{
	AhTPADelete(&m_pArrConcWall[eTypeEnv],   (CConcBasic*)0);

	if (IsValidComboEnvType(eTypeEnv) == FALSE)
		return;

	CARcBridgeDataStd *pStd = m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();

	// (ARCBRIDGE-2816) 브라켓 STM모델에서 벽체 concdata를 사용한다. 그렇다고 concdata를 만들어주면 벽체단면검토가 출력된다.
	if(bLsd && m_nSelectWallSectionDesign == 1) // 한계상태에서는 휨압축부재로 검토일때 계산하지 않는다.
		return;
	
	BOOL bIsOutWall  = (IsOutsideWall());

	// 값이 CGS단위가 아닌 것은 변환을 하여 저장하여 줌.....
	// 값을 집계하기 전에 종단Type을 모델링과 맞춰준다..
	BOOL bArch = (m_nTypeBridge == BRIDGE_TYPE_ARCH || m_nTypeBridge == BRIDGE_TYPE_TRAP2);
	long nTypeJongOld = m_nTypeJongdanForRebar;
	m_nTypeJongdanForRebar = bArch? 1 : 0;
	SyncBridge(0, FALSE, FALSE, FALSE);
	SyncBridgeRebar(TRUE, -1, TRUE);
	//	GetTvVertSection_Std(0, TRUE, FALSE, FALSE, bArch? 1 : 0);

	long nCnt = (bIsOutWall)? (5*2):0;
	for(long k=0; k<nCnt; k++)
	{
		if(!bIsOutWall && 10>k) continue;
		long nIndex = (bIsOutWall)? k:k+10;

		CConcBasic *pData = new CConcBasic;
		SetConcDataOutWall(pData, eTypeEnv, nIndex);
		m_pArrConcWall[eTypeEnv].Add(pData);
	}

	m_nTypeJongdanForRebar = nTypeJongOld;
	m_nTypeJongdanForRebarOld = nTypeJongOld;
	SyncBridge(0, FALSE, FALSE, FALSE);
	// GetTvVertSection_Std(0, TRUE, FALSE, TRUE);
}

void CRcBridgeRebar::SetConcDataOutWall(CConcBasic *pData, const ETypeEnvComboLsd eTypeEnv, HGINT32 nIndex)
{
	CARcBridgeDataStd *pStd = m_pARcBridgeDataStd;
	
	const HGBOOL bLsd = pStd->IsLsdDesign();

	BOOL bInner = TRUE;
	const HGBOOL bIsOutWall  = (IsOutsideWall());
	BOOL bGirderCalc = FALSE;
	BOOL bOutSideWall= TRUE; // TRUE-배면,FALSE-전면
	
	long nPos = 0, nPosCheck = 0;
	long nJijum = 0;
	long nWallPos = 0;		// 0:시점벽체, 1:종점벽체, 2:중간펵체

	pData->m_nTypeUnit		= pStd->m_nTypeUnit; //0-CGS,1-SI
	pData->m_nTypeKciCode	= pStd->m_nTypeKciCode;
	pData->m_nTypeSection	= SECTION_SINGLE; // 단면의 타입,SECTION_SINGLE
	//		CString m_sTitle;

	// 시종점벽체 벽체로 검토 - 한계상태일때만.
	if(bLsd && m_nSelectWallSectionDesign == 1)
	{
		pData->m_nTypeSection	= SECTION_WALL;
		// (ARCBRIDGE-2601) 벽체로 검토 했을때 사용철근량은 상단 중앙 하단 중에 작은 걸로
		double dAs_min = 0;
		nJijum = (nIndex<5)? 0 : m_nQtyJigan;
		for(long nPos=0; nPos<3; ++nPos)
		{
			long nIndexPos = 0;
			switch (nPos)
			{
			case CHECK_POS_TOP:
				nIndexPos = 1;	break;
			case CHECK_POS_CENTER:
				nIndexPos = 0;	break;
			case CHECK_POS_BOTTOM:
				nIndexPos = -1;	break;
			}

			double dAs = 0;
			for(long nCycle=0; nCycle<2; ++nCycle)
			{
				for(long nDan=0; nDan<MAX_REBAR_DAN; ++nDan)
				{
					for(long ix=0;ix<2; ++ix)
					{
						CDPoint xyInfo	= GetInfoMainRebar_Wall(nJijum, nCycle, nDan, nIndexPos, (ix == 0));
						if(xyInfo.x > 0 && xyInfo.y)
							dAs += pData->GetAreaRebar(xyInfo.x, 1000/xyInfo.y);
					}
				}
			}
			
			if(nPos == 0 || dAs < dAs_min)
			{
				dAs_min = dAs;
				switch (nPos)
				{
				case CHECK_POS_TOP:
					nIndex = nJijum == 0 ? 0 : 5;	break;
				case CHECK_POS_CENTER:
					nIndex = nJijum == 0 ? 1 : 6;	break;
				case CHECK_POS_BOTTOM:
					nIndex = nJijum == 0 ? 4 : 9;	break;
				}
			}
		}
	}

	if(nIndex==4 || nIndex==9) 
	{
		pData->m_sTitle = (nIndex==4)? "시점벽체 하단(배면)":"종점벽체 하단(배면)";
		if(m_nTypeBridge == BRIDGE_TYPE_TRAP2 || m_nTypeBridge == BRIDGE_TYPE_ARCH || m_nTypeBridge == BRIDGE_TYPE_BOX)
		{
			pData->m_Hunch	= (nIndex==4)? min(m_dWSHH, m_dWSHW*3) : min(m_dWEHH, m_dWEHW*3);
		}
		else pData->m_Hunch	= 0;

		nPos = -1;
		nPosCheck = CHECK_POS_BOTTOM;
		bInner = FALSE;
		bOutSideWall = TRUE;
		nWallPos = (nIndex==4)? 0 : 1;
	}
	else if(nIndex==3 || nIndex==8) 
	{
		pData->m_sTitle = (nIndex==3)? "시점벽체 하단(전면)":"종점벽체 하단(전면)";
		pData->m_Hunch	= 0;
		nPos = -1;
		nPosCheck = CHECK_POS_BOTTOM;
		bInner = TRUE;
		bOutSideWall = FALSE;
		nWallPos = (nIndex==3)? 0 : 1;
	}
	else if(nIndex==2 || nIndex==7)
	{
		pData->m_sTitle = (nIndex==2)? "시점벽체 중앙(배면)":"종점벽체 중앙(배면)";
		pData->m_Hunch	= 0;
		nPos = 0;
		nPosCheck = CHECK_POS_CENTER;
		bInner = FALSE;
		bOutSideWall = TRUE;
		nWallPos = (nIndex==2)? 0 : 1;
	}
	else if(nIndex==1 || nIndex==6)
	{
		pData->m_sTitle = (nIndex==1)? "시점벽체 중앙(전면)":"종점벽체 중앙(전면)";
		pData->m_Hunch	= 0;
		nPos = 0;
		nPosCheck = CHECK_POS_CENTER;
		bInner = TRUE;
		bOutSideWall = FALSE;
		nWallPos = (nIndex==1)? 0 : 1;
	}
	else if(nIndex==0 || nIndex==5)
	{
		pData->m_sTitle = (nIndex==0)? "시점벽체 상단부":"종점벽체 상단부";
		pData->m_Hunch	= (nIndex==0)? min(m_dHHS, m_dHWS*3) : min(m_dHHE, m_dHWE*3);
		nPos = 1;
		nPosCheck = CHECK_POS_TOP;
		bInner = FALSE;
		nWallPos = (nIndex==0)? 0 : 1;
	}
	else
	{
		pData->m_nTypeSection	= SECTION_WALL;
		pData->m_sTitle.Format("지점%d", nIndex-8);
		pData->m_Hunch	= 0;
		nPos = -1;
		nPosCheck = CHECK_POS_BOTTOM;
		bInner = FALSE;
		nWallPos = 2;
	}

	if(nIndex<5) nJijum = 0;
	else if(nIndex<10) nJijum = m_nQtyJigan;
	else return;

	EPartOfBridge ePartBri = (nWallPos == 0)? ePartOutWallStt : ((nWallPos == 1)? ePartOutWallEnd : ePartInWall);
	BOOL bCalcShear = (m_RebarShearDetail_OutWall[nWallPos].m_nType==TYPE_SHEAR_SPACER)? FALSE : TRUE;
	SetConcDataBasic(pData, ePartBri, bInner, GetGroupKindByEnvType(eTypeEnv));
	pData->m_nCheckSupportBarRate = SUPPORTBAR_CHECK_WALL;
	pData->m_bCheckSuppoerBarAreaRate = m_bCheckSupportWallDryingShrinkage;
	pData->m_bCheckSupportBarMainRate20 = m_bCheckSupportWallMainRate;

	// 단면의 모양
	pData->m_Bo				= frM(UNIT_METER);
	CDPoint vAngleJijum = CDPoint(0,1);
	if(nJijum == 0)
	{
		pData->m_Ho	= m_dWS; // 벽체두께
		vAngleJijum = (m_nTypePlacingMainRebar_UpperSlab==0) ? GetAngleJijum(nJijum) : CDPoint(0,1);
	}
	else if(nJijum == m_nQtyJigan)
	{
		pData->m_Ho	= m_dWE; // 벽체두께
		vAngleJijum = (m_nTypePlacingMainRebar_UpperSlab==0) ? GetAngleJijum(nJijum) : CDPoint(0,1);
	}
	else
	{
		pData->m_Ho	= GetInWall(nJijum-1)->m_dW;
	}
	pData->m_nEnvTypeCrack = m_nTypeCrackDesignWall;
	pData->m_bMinAvCheck   = m_bApplyMinAvWall;

	long nCntMainCycle	= 2;

	double dDia = 0;
	double dDc =0;
	double dCtc = GetCtcRebarMain(TRUE);
	// 		double dB = pData->m_Bo/dCtc;

	double dB = pData->m_Bo/(dCtc/vAngleJijum.y);

	CDPoint xyInfo	= CDPoint(0, 0);

	int i=0; for(i=0; i<nCntMainCycle; i++)
	{
		int j=0; for(j=0; j<MAX_REBAR_DAN; j++)
		{
			// 인장 철근
			if(nJijum > 0 && nJijum < m_nQtyJigan) dDc = m_dCoverWallMid[j];
			else dDc = (bInner)? m_dCoverWallIn[j]:m_dCoverWallOut[j];
			xyInfo	= GetInfoMainRebar_Wall(nJijum, i, j, nPos, bInner); 

			dDia = xyInfo.x;
			if(i == 0)
			{
				pData->m_RbT1C_DIA[j] = dDia; // 철근의 직경
				if(dDia>0)
				{
					pData->m_RbT1C_dc[j] = dDc;  // 철근의 중심거리 피복 + 100*단수(-1)
					pData->m_RbT1C_B [j] = dB;  // 철근의 개수 (1000/CTC)
				}
			}
			else
			{
				if(dDia>0)
				{
					if(pData->m_RbT1C_DIA[j]==dDia)
					{
						pData->m_RbT1C_B [j] += dB;  // 철근의 개수 (1000/CTC)
					}
					else
					{
						pData->m_RbT2C_DIA[j] = dDia; // 철근의 직경
						pData->m_RbT2C_dc[j]  = dDc;  // 철근의 중심거리 피복 + 100*단수(-1)
						pData->m_RbT2C_B [j]  = dB;  // 철근의 개수 (1000/CTC)
					}
				}
			}

			// 압축 철근
			if(nJijum > 0 && nJijum < m_nQtyJigan) dDc = m_dCoverWallMid[j];
			else dDc = (!bInner)? m_dCoverWallIn[j]:m_dCoverWallOut[j];
			xyInfo	= GetInfoMainRebar_Wall(nJijum, i, j, nPos, !bInner); 

			dDia = xyInfo.x;
			if(i == 0)
			{
				pData->m_RbC1C_DIA[j] = dDia; // 철근의 직경
				if(dDia>0)
				{
					pData->m_RbC1C_dc[j] = dDc;  // 철근의 중심거리 피복 + 100*단수(-1)
					pData->m_RbC1C_B [j] = dB;  // 철근의 개수 (1000/CTC)
				}
			}
			else
			{
				if(dDia>0)
				{
					if(pData->m_RbC1C_DIA[j]==dDia)
					{
						pData->m_RbC1C_B [j] += dB;  // 철근의 개수 (1000/CTC)
					}
					else
					{
						pData->m_RbC2C_DIA[j] = dDia; // 철근의 직경
						pData->m_RbC2C_dc[j]  = dDc;  // 철근의 중심거리 피복 + 100*단수(-1)
						pData->m_RbC2C_B [j]  = dB;  // 철근의 개수 (1000/CTC)
					}
				}
			}

		}
	}
	// 배력철근
	for(i=0; i<MAX_REBAR_DAN; i++)
	{
		xyInfo = GetInfoSupportRebar_Wall(!bInner, nJijum, i, nPos);
		pData->m_CSupportBarDia[i] = xyInfo.x;
		pData->m_CSupportBarCTC[i] = xyInfo.y;
		xyInfo = GetInfoSupportRebar_Wall(bInner, nJijum, i, nPos);
		pData->m_TSupportBarDia[i] = xyInfo.x;
		pData->m_TSupportBarCTC[i] = xyInfo.y;
	}

	// 수직전단철근
	if(bCalcShear)
	{
		xyInfo = GetInfoShearRebar_Wall(nJijum, nPos);
		CWallApp *pWall = nWallPos==2 ? GetInWall(nJijum-1) : NULL;
		
		pData->m_SvDia = xyInfo.x;
		pData->m_SvCtc = xyInfo.y;
		long nCntWrap = (nWallPos==2 && pWall) ? pWall->m_nCountWrapMainRebar : m_nCountWrapMainRebarForOutWall[nWallPos];
		double dSvEa = frM(UNIT_METER)/(nCntWrap*GetCtcRebarMain()/2);
		pData->m_SvEa = (m_RebarShearDetail_OutWall[(nIndex<5)? 0:1].m_nType == TYPE_SHEAR_DIGUT || m_RebarShearDetail_OutWall[(nIndex<5)? 0:1].m_nType == TYPE_SHEAR_SINGLE_HOOK) ? dSvEa/2 : dSvEa;
		
	}
	else
	{
		pData->m_SvDia	= 0;
		pData->m_SvCtc	= 0;
		pData->m_SvEa	= 0;
	}
	if(m_bSelectHunchDesignCheck == FALSE || m_nSelectWallSectionDesign == 1)
	{
		// (ARCBRIDGE-3170) 휨압축부재로 검토시 헌치 유효단면 고려 안함
		pData->m_Hunch = 0;
	}

	// 전단검토 위치 옵션 적용 때문에 부재력 집계는 철근 집계가 된다음에 해줘야한다.
	if(bLsd)
		SetDesignForceWall_Lsd(pData, nJijum, nPosCheck, bGirderCalc, bOutSideWall, eTypeEnv);
	else
		SetDesignForceWall_Usd(pData, nJijum, nPosCheck, bGirderCalc, bOutSideWall);
}

void CRcBridgeRebar::SetDesignForceWall_Usd( CConcBasic *pConc, long nJijum, long nPosCheck, BOOL bGirderCalc, BOOL bOutSideWall )
{
	CARcBridgeDataStd *pStd = m_pARcBridgeDataStd;

	const HGBOOL bCalc3DUlt = IsCalc3D(COMBO_ULTIMATE);
	const HGBOOL bCalc3DUse = IsCalc3D(COMBO_SERVICE);

	double Moment=0,MomentUse=0, MomentEq = 0, Shear=0, ShearEq=0, Axial=0, AxialEq=0;
	double dDistShear = GetDistCheckShearWall(nJijum, nPosCheck, pConc);

	Axial	  = fabs(GetOutValueWall(nJijum, nPosCheck, COMBO_ULTIMATE, ELE_AXFORCE, bGirderCalc, bOutSideWall));
	AxialEq   = fabs(GetOutValueWall(nJijum, nPosCheck, COMBO_EARTHQUAKE, ELE_AXFORCE, bGirderCalc, bOutSideWall));
	Moment	  = fabs(GetOutValueWall(nJijum, nPosCheck, COMBO_ULTIMATE, ELE_MOMENT2, bGirderCalc, bOutSideWall));
	MomentEq  = fabs(GetOutValueWall(nJijum, nPosCheck, COMBO_EARTHQUAKE, ELE_MOMENT2, bGirderCalc, bOutSideWall));
	MomentUse = fabs(GetOutValueWall(nJijum, nPosCheck, COMBO_SERVICE, ELE_MOMENT2, bGirderCalc, bOutSideWall));
	Shear	  = fabs(GetOutValueWall(nJijum, nPosCheck, COMBO_ULTIMATE, ELE_SHEAR_2, bGirderCalc, bOutSideWall, eEnvLimit, dDistShear));
	ShearEq	  = fabs(GetOutValueWall(nJijum, nPosCheck, COMBO_EARTHQUAKE, ELE_SHEAR_2, bGirderCalc, bOutSideWall, eEnvLimit, dDistShear));

	if(m_nSelectModelingCountEQ==2)
	{
		double AxialEq_2	= fabs(GetOutValueWall(nJijum, nPosCheck, COMBO_EARTHQUAKE2, ELE_AXFORCE, bGirderCalc, bOutSideWall));
		double MomentEq_2	= fabs(GetOutValueWall(nJijum, nPosCheck, COMBO_EARTHQUAKE2, ELE_MOMENT2, bGirderCalc, bOutSideWall));
		double ShearEq_2	= fabs(GetOutValueWall(nJijum, nPosCheck, COMBO_EARTHQUAKE2, ELE_SHEAR_2, bGirderCalc, bOutSideWall, eEnvLimit, dDistShear));
		AxialEq  	= (fabs(MomentEq) >= fabs(MomentEq_2))? AxialEq : AxialEq_2;
		MomentEq	= (fabs(MomentEq) >= fabs(MomentEq_2))? MomentEq : MomentEq_2;
		ShearEq		= (fabs(ShearEq)  >= fabs(ShearEq_2)) ? ShearEq  : ShearEq_2;
	}
	Axial	  = (Moment >= MomentEq) ? Axial : AxialEq;
	Moment	  = max(Moment, MomentEq);
	Shear	  = max(Shear, ShearEq);
	if(bCalc3DUlt)
	{
		Moment	= max(Moment, fabs(GetOutValueWallShell(nJijum,nPosCheck,COMBO_ULTIMATE,ELE_MOMENT2,bGirderCalc,bOutSideWall)));
		Shear	= max(Shear,  fabs(GetOutValueWallShell(nJijum,nPosCheck,COMBO_ULTIMATE,ELE_SHEAR_2,bGirderCalc,bOutSideWall)));
	}
	if(bCalc3DUse) MomentUse = max(MomentUse, fabs(GetOutValueWallShell(nJijum,nPosCheck,COMBO_SERVICE ,ELE_MOMENT2,bGirderCalc,bOutSideWall)));

	pConc->m_Axial      = 0;
	pConc->m_Moment		= GetValueUnitChange(Moment,pStd->m_szTonfM,UNIT_CGS_TONFM);
	pConc->m_Shear		= GetValueUnitChange(Shear,pStd->m_szTonf,UNIT_CGS_TONF);
	pConc->m_MomentUse	= GetValueUnitChange(MomentUse,pStd->m_szTonfM,UNIT_CGS_TONFM);
	pConc->m_MomentCrack	= pConc->m_MomentUse;
	if(m_nSelectWallSectionDesign==1)
	{
		pConc->m_Axial = GetValueUnitChange(Axial,pStd->m_szTonf,UNIT_CGS_TONF);;
		pConc->m_Mux   = pConc->m_Moment;
		pConc->m_nTypeSection = SECTION_WALL;
	}
}

void CRcBridgeRebar::SetDesignForceWall_Lsd( CConcBasic *pConc, long nJijum, long nPosCheck, BOOL bGirderCalc, BOOL bOutSideWall, const ETypeEnvComboLsd eTypeEnv )
{
	CARcBridgeDataStd *pStd = m_pARcBridgeDataStd;
	const HGBOOL bCalc3DUlt = IsCalc3D(COMBO_ULTIMATE);
	
	double Moment(0), Shear(0);
	double dDistShear = GetDistCheckShearWall(nJijum, nPosCheck, pConc);

	if(eTypeEnv == eEnvExtremeI || eTypeEnv == eEnvExtremeII)
	{
//		Axial	  = fabs(GetOutValueWallEQ(nJijum, nPosCheck, ELE_AXFORCE, bGirderCalc, bOutSideWall, eTypeEnv));
		Moment	  = fabs(GetOutValueWallEQ(nJijum, nPosCheck, ELE_MOMENT2, bGirderCalc, bOutSideWall, eTypeEnv));
		Shear	  = fabs(GetOutValueWallEQ(nJijum, nPosCheck, ELE_SHEAR_2, bGirderCalc, bOutSideWall, eTypeEnv, dDistShear));
	}
	else
	{
//		Axial	  = fabs(GetOutValueWall(nJijum, nPosCheck, COMBO_ULTIMATE, ELE_AXFORCE, bGirderCalc, bOutSideWall, eTypeEnv));
		Moment	  = fabs(GetOutValueWall(nJijum, nPosCheck, COMBO_ULTIMATE, ELE_MOMENT2, bGirderCalc, bOutSideWall, eTypeEnv));
		Shear	  = fabs(GetOutValueWall(nJijum, nPosCheck, COMBO_ULTIMATE, ELE_SHEAR_2, bGirderCalc, bOutSideWall, eTypeEnv, dDistShear));

		if(bCalc3DUlt)
		{
			Moment	= max(Moment, fabs(GetOutValueWallShell(nJijum,nPosCheck,COMBO_ULTIMATE,ELE_MOMENT2,bGirderCalc,bOutSideWall, eTypeEnv)));
			Shear	= max(Shear,  fabs(GetOutValueWallShell(nJijum,nPosCheck,COMBO_ULTIMATE,ELE_SHEAR_2,bGirderCalc,bOutSideWall, eTypeEnv)));
		}
	}
	
	double dWidth = frM(UNIT_METER);
	pConc->m_Axial      = 0;
	pConc->m_Moment		= GetValueUnitChange(Moment,pStd->m_szTonfM,UNIT_CGS_TONFM) * dWidth;
	pConc->m_Shear		= GetValueUnitChange(Shear,pStd->m_szTonf,UNIT_CGS_TONF) * dWidth;
	pConc->m_MomentUse	= GetValueUnitChange(Moment,pStd->m_szTonfM,UNIT_CGS_TONFM) * dWidth;
	if(eTypeEnv == eEnvService)
	{
		Moment	  = fabs(GetOutValueWall(nJijum, nPosCheck, COMBO_ULTIMATE, ELE_MOMENT2, bGirderCalc, bOutSideWall, eEnvService_Crack));
		if(bCalc3DUlt)
		{
			Moment	= max(Moment, fabs(GetOutValueWallShell(nJijum,nPosCheck,COMBO_ULTIMATE,ELE_MOMENT2,bGirderCalc,bOutSideWall, eEnvService_Crack)));
		}
		pConc->m_MomentCrack	= GetValueUnitChange(Moment,pStd->m_szTonfM,UNIT_CGS_TONFM) * dWidth;
	}
	else
	{
		pConc->m_MomentCrack	= pConc->m_MomentUse;
	}
}

void CRcBridgeRebar::SetConcDataInWall(const ETypeEnvComboLsd eTypeEnv)
{
	AhTPADelete(&m_pArrConcInWall[eTypeEnv],   (CConcBasic*)0);
	
	if (IsValidComboEnvType(eTypeEnv) == FALSE)
		return;

	// [내측벽체 단면 검토] 옵션이 벽체인경우 안만들어도 된다. 
	if(m_nSelectInWallSectionDesign == 1)
		return;

	CARcBridgeDataStd *pStd = m_pARcBridgeDataStd;

	const HGBOOL bLsd = pStd->IsLsdDesign();

	BOOL bInner = TRUE;
	BOOL bIsOutWall  = (IsOutsideWall());
	BOOL bGirderCalc = FALSE;
	BOOL bOutSideWall= TRUE; // TRUE-배면,FALSE-전면
	long nCnt = (bIsOutWall)? (5*2):0;
	long nPos = 0, nPosCheck = 0;
	long nWallPos = 0;		// 0:시점벽체, 1:종점벽체, 2:중간펵체

	// 값이 CGS단위가 아닌 것은 변환을 하여 저장하여 줌.....
	// 값을 집계하기 전에 종단Type을 모델링과 맞춰준다..
	BOOL bArch = (m_nTypeBridge == BRIDGE_TYPE_ARCH || m_nTypeBridge == BRIDGE_TYPE_TRAP2);
	long nTypeJongOld = m_nTypeJongdanForRebar;
	m_nTypeJongdanForRebar = bArch? 1 : 0;
	SyncBridge(0, FALSE, FALSE, FALSE);
	SyncBridgeRebar(TRUE, -1, TRUE);
	//	GetTvVertSection_Std(0, TRUE, FALSE, FALSE, bArch? 1 : 0);

	long nSize = GetCountInWall();
	for(long nIdx = 0; nIdx < nSize; nIdx++)
	{
		CWallApp   *pWall   = GetInWall(nIdx);
		if(!pWall || pWall->m_bTopIsColumn)
			continue;

		nCnt = 6;	// 내측벽체는 6부분 검토
		for(long k = 0; k < nCnt; k++)
		{
			CConcBasic *pData= new CConcBasic;
			pData->m_nTypeUnit		= pStd->m_nTypeUnit; //0-CGS,1-SI
			pData->m_nTypeKciCode	= pStd->m_nTypeKciCode;
			pData->m_nTypeSection	= SECTION_SINGLE; // 단면의 타입,SECTION_SINGLE

			if(k == 0) 
			{
				pData->m_sTitle.Format("중간벽체%d 하단(배면)", nIdx + 1);
				pData->m_Hunch	= 0;
				nPos = -1;
				nPosCheck = CHECK_POS_BOTTOM;
				bInner = FALSE;
				bOutSideWall = TRUE;
				nWallPos = 2;
			}
			else if(k == 1) 
			{
				pData->m_sTitle.Format("중간벽체%d 하단(전면)", nIdx + 1);
				pData->m_Hunch	= 0;
				nPos = -1;
				nPosCheck = CHECK_POS_BOTTOM;
				bInner = TRUE;
				bOutSideWall = FALSE;
				nWallPos = 2;
			}
			else if(k == 2)
			{
				pData->m_sTitle.Format("중간벽체%d 중앙(배면)", nIdx + 1);
				pData->m_Hunch	= 0;
				nPos = 0;
				nPosCheck = CHECK_POS_CENTER;
				bInner = FALSE;
				bOutSideWall = TRUE;
				nWallPos = 2;
			}
			else if(k == 3)
			{
				pData->m_sTitle.Format("중간벽체%d 중앙(전면)", nIdx + 1);
				pData->m_Hunch	= 0;
				nPos = 0;
				nPosCheck = CHECK_POS_CENTER;
				bInner = TRUE;
				bOutSideWall = FALSE;
				nWallPos = 2;
			}
			else if(k == 4)
			{
				pData->m_sTitle.Format("중간벽체%d 상단(배면)", nIdx + 1);
				pData->m_Hunch	= 0;
				nPos = 1;
				nPosCheck = CHECK_POS_TOP;
				bInner = FALSE;
				nWallPos = 2;
			}
			else if(k == 5)
			{
				pData->m_sTitle.Format("중간벽체%d 상단(전면)", nIdx + 1);
				pData->m_Hunch	= 0;
				nPos = 1;
				nPosCheck = CHECK_POS_TOP;
				bInner = TRUE;
				bOutSideWall = FALSE;
				nWallPos = 2;
			}

			BOOL bCalcShear = (pWall->m_rebarShearDetail.m_nType==TYPE_SHEAR_SPACER)? FALSE : TRUE;
			SetConcDataBasic(pData, ePartInWall, TRUE, GetGroupKindByEnvType(eTypeEnv));
			pData->m_nCheckSupportBarRate = SUPPORTBAR_CHECK_WALL;
			pData->m_bCheckSuppoerBarAreaRate = m_bCheckSupportWallDryingShrinkage;
			pData->m_bCheckSupportBarMainRate20 = m_bCheckSupportWallMainRate;

			// 단면의 모양
			pData->m_Bo				= frM(UNIT_METER);
			pData->m_Ho	= pWall->m_dW;
			pData->m_nEnvTypeCrack = m_nTypeCrackDesignWall;
			pData->m_bMinAvCheck   = m_bApplyMinAvWall;

			long nCntMainCycle	= 2;

			double dDia = 0;
			double dDc =0;
			double dCtc = GetCtcRebarMain(TRUE)/GetAngleJijum(nIdx+1).y;//	pWall->m_Column.m_dCTCMainRebar;//GetCtcRebarMain(TRUE);
			// 			double dB = Round(pData->m_Bo/dCtc,3);

			double dB = pData->m_Bo / dCtc;

			CDPoint xyInfo	= CDPoint(0, 0);

			int i=0; for(i=0; i<nCntMainCycle; i++)
			{
				int j=0; for(j=0; j<MAX_REBAR_DAN; j++)
				{
					// 인장 철근
					dDc = m_dCoverWallMid[j];
					xyInfo	= GetInfoMainRebar_Wall(nIdx + 1, i, j, nPos, bInner); 

					dDia = xyInfo.x;
					if(i == 0)
					{
						pData->m_RbT1C_DIA[j] = dDia; // 철근의 직경
						if(dDia>0)
						{
							pData->m_RbT1C_dc[j] = dDc;  // 철근의 중심거리 피복 + 100*단수(-1)
							pData->m_RbT1C_B [j] = dB;  // 철근의 개수 (1000/CTC)
						}
					}
					else
					{
						if(dDia>0)
						{
							if(pData->m_RbT1C_DIA[j]==dDia)
							{
								pData->m_RbT1C_B [j] += dB;  // 철근의 개수 (1000/CTC)
							}
							else
							{
								pData->m_RbT2C_DIA[j] = dDia; // 철근의 직경
								pData->m_RbT2C_dc[j]  = dDc;  // 철근의 중심거리 피복 + 100*단수(-1)
								pData->m_RbT2C_B [j]  = dB;  // 철근의 개수 (1000/CTC)
							}
						}
					}

					// 압축 철근
					dDc = m_dCoverWallMid[j];
					xyInfo	= GetInfoMainRebar_Wall(nIdx + 1, i, j, nPos, !bInner); 

					dDia = xyInfo.x;
					if(i == 0)
					{
						pData->m_RbC1C_DIA[j] = dDia; // 철근의 직경
						if(dDia>0)
						{
							pData->m_RbC1C_dc[j] = dDc;  // 철근의 중심거리 피복 + 100*단수(-1)
							pData->m_RbC1C_B [j] = dB;  // 철근의 개수 (1000/CTC)
						}
					}
					else
					{
						if(dDia>0)
						{
							if(pData->m_RbC1C_DIA[j]==dDia)
							{
								pData->m_RbC1C_B [j] += dB;  // 철근의 개수 (1000/CTC)
							}
							else
							{
								pData->m_RbC2C_DIA[j] = dDia; // 철근의 직경
								pData->m_RbC2C_dc[j]  = dDc;  // 철근의 중심거리 피복 + 100*단수(-1)
								pData->m_RbC2C_B [j]  = dB;  // 철근의 개수 (1000/CTC)
							}
						}
					}

				}
			}
			// 배력철근
			for(i=0; i<MAX_REBAR_DAN; i++)
			{
				xyInfo = GetInfoSupportRebar_Wall(!bInner, nIdx + 1, i, nPos);
				pData->m_CSupportBarDia[i] = xyInfo.x;
				pData->m_CSupportBarCTC[i] = xyInfo.y;
				xyInfo = GetInfoSupportRebar_Wall(bInner, nIdx + 1, i, nPos);
				pData->m_TSupportBarDia[i] = xyInfo.x;
				pData->m_TSupportBarCTC[i] = xyInfo.y;
			}

			// 수직전단철근
			if(bCalcShear)
			{
				xyInfo = GetInfoShearRebar_Wall(nIdx + 1, nPos);
				pData->m_SvDia = xyInfo.x;
				pData->m_SvCtc = xyInfo.y;
				long nCntWrap = (nWallPos==2)? pWall->m_nCountWrapMainRebar : m_nCountWrapMainRebarForOutWall[nWallPos];
				double dSvEa = frM(UNIT_METER)/(nCntWrap*GetCtcRebarMain()/2);
				pData->m_SvEa = (pWall->m_rebarShearDetail.m_nType == TYPE_SHEAR_DIGUT || pWall->m_rebarShearDetail.m_nType == TYPE_SHEAR_SINGLE_HOOK) ? dSvEa/2 : dSvEa;
			}
			else
			{
				pData->m_SvDia	= 0;
				pData->m_SvCtc	= 0;
				pData->m_SvEa	= 0;
			}
			if(m_bSelectHunchDesignCheck == FALSE)
			{
				pData->m_Hunch = 0;
			}

			// 전단검토 위치 옵션 적용 때문에 부재력 집계는 철근 집계가 된다음에 해줘야한다.
			if(bLsd)
				SetDesignForceWall_Lsd(pData, nIdx + 1, nPosCheck, bGirderCalc, bOutSideWall, eTypeEnv);
			else
				SetDesignForceWall_Usd(pData, nIdx + 1, nPosCheck, bGirderCalc, bOutSideWall);

			m_pArrConcInWall[eTypeEnv].Add(pData);
		}
	}

	m_nTypeJongdanForRebar = nTypeJongOld;
	m_nTypeJongdanForRebarOld = nTypeJongOld;
	SyncBridge(0, FALSE, FALSE, FALSE);
	// GetTvVertSection_Std(0, TRUE, FALSE, TRUE);
}

void CRcBridgeRebar::SetConcDataWall()
{
	InitConcWall();
	InitConcInWall();

	CARcBridgeDataStd *pStd = m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();
	HGINT32 icTypeEnv = bLsd ? COUNT_CONC_LSD : eEnvLimit + 1;
	for (HGINT32 ix = eEnvLimit; ix < icTypeEnv; ++ix)
	{
		SetConcDataOutWall((ETypeEnvComboLsd)ix);
		SetConcDataInWall((ETypeEnvComboLsd)ix);
	}
}

void CRcBridgeRebar::SetConcDataGirder()
{
	AhTPADelete(&m_pArrConcGirder, (CConcBasic*)0);
}

void CRcBridgeRebar::SetConcData(BOOL bSlab, BOOL bWall, BOOL bFooting, BOOL bWingWall, BOOL bPRF)
{
	if(bSlab)
		SetConcDataSlab();
	if(!IsRcSlab())
	{
		if(bWall)
			SetConcDataWall();
		if(bFooting)
		{
			SetConcDataFooting(FALSE);
			SetConcDataFooting(TRUE);
			SetConcDataFooting(FALSE, TRUE);
		}
		SetConcDataGirder();
		if(bPRF)
			SetConcDataPRF();
	}
	if(!IsRcSlab() && !IsPiRahmen() && bWingWall)
	{
		SetConcDataWingWall();
	}
}

// 보기둥 권고안 전체적으로 다 함(벽식에서 기둥식으로 바뀌거나 처음 입력창에 접근할때 사용하면 좋음)
// 보기둥입력창에서 교대교각부 거더철근도 입력받으므로 시종점에 대한 거더부 철근도 권고안 처리함.
void CRcBridgeRebar::SetDataDefaultRebarColumnStd(long nJ)
{
	if(nJ == 0 || nJ == m_nQtyJigan)
	{
		SetDataDefaultRebarMainInGirder_Girder(nJ);
		SetDataDefaultRebarGirder(nJ, FALSE);
	}
	else
	{
		long nIdxInWall	= nJ - 1;
		CWallApp *pWall	= GetInWall(nIdxInWall);
		if(pWall)
		{
			SetDataDefaultRebarGirder(nJ, FALSE);
			SetDataDefaultRebarMainInGirder_Girder(nJ);
			if(IsBoxType())
			{
				SetDataDefaultRebarGirder(nJ, FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE);
				SetDataDefaultRebarMainInGirder_Girder(nJ, TRUE, TRUE, TRUE, FALSE, FALSE);
			}
			
			pWall->m_Column.SetDataDefaultRebarMain_Plane();
			pWall->m_Column.SetDataDefaultRebarCrossTie_Plane();
			SetDataDefaultRebarRoundAndCrossTie_VertSection_InWall(nIdxInWall);
		}
	}
}

// 상부/하부슬래브 헌치 주철근
void CRcBridgeRebar::SetDataDefaultRebarJewonSlabHunch(BOOL bUpper)
{
	if(!bUpper && !IsBoxType()) return;

	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();

	long cycle(0), left(0), nJ(0);
	BOOL bLeft(TRUE);
	CString sUpper(_T("")), sCycle(_T("")), sStt(_T("")), sLeft(_T("")), sInner(_T(""));

	CHgBaseConcStd baseConc;
	CRebarPlacing rb;
	
	CTwinVectorArray tvArr, tvArrAngLeft, tvArrAngRight;
	CTwinVectorArray tvArrLeftHalf, tvArrRightHalf;
	CTwinVector tv;
	CRebarInfoCycle *pRC	= NULL;
	double dLenMax		= 0;	// 최대길이
	double dLenMin		= 0;	// 최소길이
	double dCover		= 0;	// 피복
	double dRebarSpace	= 0;	// 간격
	double dSettle		= 0;

	// 주철근
	dRebarSpace	= GetCtcRebarMain(TRUE);
	CTwinVector tvSlab;
	if(bUpper)	
		GetTvOffset_UpperSlab(0, TRUE, -1.0, -1.0, IsVertDir());	// 헌치 철근의 각도를 구하기 위함.
	else
		GetTvOffset_LowerSlab(0, FALSE, -1.0, -1.0, IsVertDir());
	tvSlab.Sort(TRUE);

	// 상부/하부 슬래브
	for(cycle = 0; cycle < GetCountCycleMainRebar(); cycle++)
	{
		sCycle	= m_pARcBridgeDataStd->GetStringCircleNum(cycle+1);
		if(bUpper) dCover	= m_dCoverLower_UpperSlab[0];
		else dCover = m_dCoverUpper_LowerSlab[0];
		
		for(nJ = 0; nJ < GetCountJijum(); nJ++)
		{
			for(left = 0; left < 2; left++)
			{
				bLeft	= left == iLEFT;

				tvArr.RemoveAll();
				tvArrAngLeft.RemoveAll();
				tvArrAngRight.RemoveAll();
				tvArrLeftHalf.RemoveAll();
				tvArrRightHalf.RemoveAll();

				//pRC	= GetRebarInfoCycleUpperSlab_Hunch(cycle, nIdx++);
				

				pRC	= GetTvRebarMain_Plane_SlabHunch(tvArr, tvArrAngLeft, tvArrAngRight, cycle, GetStationOnJijum(nJ), bLeft ? -1 : 1, 0, bUpper);
				if(!pRC) continue;
				if(!pRC->m_bExist) continue;
				if(tvArr.GetSize() == 0 && tvArrAngLeft.GetSize() == 0 && tvArrAngRight.GetSize() == 0) continue;

				if(m_nTypePlacingMainRebar_UpperSlab == 2)
				{
					m_Util.DivideVertMainRebarBySabogang(tvArr, tvArrLeftHalf, tvArrRightHalf);
				}

				for(long ang = 0; ang < 5; ang++)
				{
					CTwinVectorArray *pTvArr;
					CString sSideDes	= _T("");
					switch(ang)
					{
					case 0: pTvArr	= &tvArr; break;
					case 1: pTvArr	= &tvArrAngLeft; sSideDes = "좌1"; break;
					case 2: pTvArr	= &tvArrAngRight; sSideDes = "우1"; break;
					case 3: pTvArr	= &tvArrLeftHalf; sSideDes = "좌2"; break;
					case 4: pTvArr	= &tvArrRightHalf; sSideDes = "우2"; break;
					default: pTvArr	= NULL; break;
					}
					if(!pTvArr) continue;
					if(pTvArr->GetSize() == 0) continue;

					// 헌치철근은 경사진부분 수평부분이 나눠져서 보관되므로 인덱스로 같은 철근임을 판단해야 된다.
					long nCount	= 0;
					CString sInfoVer	= _T("");
					long s = 0; for(s = 0; s < pTvArr->GetSize(); s++)
					{
						tv	= pTvArr->GetAt(s);
						if(s == 0)
						{
							nCount++;
							sInfoVer	= tv.m_sInfoVer;
						}
						else if(sInfoVer != tv.m_sInfoVer)
						{
							nCount++;
							sInfoVer	= tv.m_sInfoVer;
						}
					}


					// 평면상에서 최대와 최소 길이를 판단해서 철근 집계함.
					dLenMax	= pTvArr->GetLengthMax();
					dLenMin	= pTvArr->GetLengthMin();
					double dLenMaxOrg	= tvArr.GetLengthMax();
					double dRateMinByMax	= dLenMin / dLenMax;
					double dRateMaxByOrg	= dLenMax / dLenMaxOrg;
					
					BOOL bIncludeArc	= FALSE;
					if(nJ == 0 && m_dHRS > 0) bIncludeArc = TRUE;
					else if(nJ == GetCountJijum()-1 && m_dHRE > 0) bIncludeArc	= TRUE;
					else if(m_dHLR[nJ-1][bUpper? iUPPER : iLOWER] > 0 || m_dHRR[nJ-1][bUpper? iUPPER : iLOWER] > 0) bIncludeArc	= TRUE;
						 
					if(m_pARcBridgeDataStd->IsLsdDesign())
					{
						SRebarEnvOption LsdRebarOpt;
						SetRebarLsdOptionSlab(&LsdRebarOpt, bUpper, !bUpper, TRUE, 0, 0);
						dSettle = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueSettle(pRC->m_Dia, &LsdRebarOpt);
					}
					else
					{
						dSettle	= m_pARcBridgeDataStd->GetValueSettleByCalc((long)pRC->m_Dia, SETTLE_TENS_NORMAL, dCover, dRebarSpace, 2, 1);
					}
					
					CRebar *pRB	= new CRebar;
					pRB->m_Fy	= bLsd? GetValueFy(bUpper? ePartUpperSlab : ePartLowerSlab) : m_pARcBridgeDataStd->m_Fy;
					if(ang == 0)
					{
						pRB->m_sDescription	= pRC->m_sDescription;
						pRB->m_sMark		= pRC->m_szMark;
					}
					else
					{
						pRB->m_sDescription.Format("%s(%s)", pRC->m_sDescription, sSideDes);
						pRB->m_sMark.Format("%s-%d", pRC->m_szMark, ang);
					}
					
					
					pRB->m_dDia			= pRC->m_Dia;
					if(bIncludeArc)
					{
						pRB->m_nTypeRebar	= 9;
						pRB->m_dLengthMax_A	= pRC->m_tvArrRebar.GetLengthMax() * dRateMaxByOrg;
						if(ang >= 3)
							pRB->m_dLengthMin_A	= pRB->m_dLengthMax_A * dRateMinByMax;
						pRB->m_dLengthMax_B	= dSettle;

						if(pRC->m_tvArrRebar.GetSize() > 0)
						{
							CTwinVector tvHunch	= pRC->m_tvArrRebar.GetAt(0);
							tvHunch.Sort(FALSE, TRUE);
							pRB->m_dAngleX1	= fabs(tvSlab.GetXyDir().GetAngleDegree() - tvHunch.GetXyDir().GetAngleDegree());
							pRB->m_dAngleX2	= fabs(270 - tvHunch.GetXyDir().GetAngleDegree());
							if(pRB->m_dAngleX1 < 90)
								pRB->m_dAngleX1	= 180 - pRB->m_dAngleX1;
							else if(pRB->m_dAngleX1 > 180)
								pRB->m_dAngleX1 = 360 - pRB->m_dAngleX1;
							else if(pRB->m_dAngleX1 < 0)
								pRB->m_dAngleX1	= 360 + pRB->m_dAngleX1;

							if(pRB->m_dAngleX2 < 90)
								pRB->m_dAngleX2	= 180 - pRB->m_dAngleX2;
							else if(pRB->m_dAngleX2 > 180)
								pRB->m_dAngleX2	= 360 - pRB->m_dAngleX2;
							else if(pRB->m_dAngleX2 < 0)
								pRB->m_dAngleX2	= 360 + pRB->m_dAngleX2;
						}
					}
					else if(pRC->m_tvArrRebar.GetSize() == 1 && !bIncludeArc)
					{
						pRB->m_nTypeRebar	= 9;
						pRB->m_dLengthMax_A	= pRC->m_tvArrRebar.GetLengthMax() * dRateMaxByOrg;
						if(ang >= 3)
							pRB->m_dLengthMin_A	= pRB->m_dLengthMax_A * dRateMinByMax;
						pRB->m_dLengthMax_B	= dSettle;
			
						if(pRC->m_tvArrRebar.GetSize() > 0)
						{
							CTwinVector tvHunch	= pRC->m_tvArrRebar.GetAt(0);
							tvHunch.Sort(FALSE, TRUE);
							pRB->m_dAngleX1	= fabs(tvSlab.GetXyDir().GetAngleDegree() - tvHunch.GetXyDir().GetAngleDegree());
							pRB->m_dAngleX2	= fabs(270 - tvHunch.GetXyDir().GetAngleDegree());
							if(pRB->m_dAngleX1 < 90)
								pRB->m_dAngleX1	= 180 - pRB->m_dAngleX1;
							else if(pRB->m_dAngleX1 > 180)
								pRB->m_dAngleX1 = 360 - pRB->m_dAngleX1;
							else if(pRB->m_dAngleX1 < 0)
								pRB->m_dAngleX1	= 360 + pRB->m_dAngleX1;

							if(pRB->m_dAngleX2 < 90)
								pRB->m_dAngleX2	= 180 - pRB->m_dAngleX2;
							else if(pRB->m_dAngleX2 > 180)
								pRB->m_dAngleX2	= 360 - pRB->m_dAngleX2;
							else if(pRB->m_dAngleX2 < 0)
								pRB->m_dAngleX2	= 360 + pRB->m_dAngleX2;
						}
					}
					else if(pRC->m_tvArrRebar.GetSize() == 3 && !bIncludeArc)
					{
						double dA	= pRC->m_tvArrRebar.GetAt(1).GetLength();
						double dB	= pRC->m_tvArrRebar.GetAt(0).GetLength();
						double dC	= pRC->m_tvArrRebar.GetAt(2).GetLength();

						pRB->m_nTypeRebar	= 62;
						pRB->m_dLengthMax_A	= dA * dRateMaxByOrg;
						if(ang >= 3)
							pRB->m_dLengthMin_A	= pRB->m_dLengthMax_A * dRateMinByMax;
						pRB->m_dLengthMax_B	= dB;
						pRB->m_dLengthMax_C	= dC;
						if(pRB->m_dLengthMax_B == pRB->m_dLengthMax_C)
						{
							pRB->m_nTypeRebar	= 9;
							pRB->m_dLengthMax_C	= 0;
						}
			
						if(pRC->m_tvArrRebar.GetSize() > 0)
						{
							CTwinVector tvHunch	= pRC->m_tvArrRebar.GetAt(1);
							CTwinVector tvSettle1	= pRC->m_tvArrRebar.GetAt(0);
							CTwinVector tvSettle2	= pRC->m_tvArrRebar.GetAt(2);
							tvHunch.Sort(FALSE, TRUE);

							pRB->m_dAngleX1	= fabs(tvSettle1.GetXyDir().GetAngleDegree() - tvHunch.GetXyDir().GetAngleDegree());
							pRB->m_dAngleX2	= fabs(tvSettle2.GetXyDir().GetAngleDegree() - tvHunch.GetXyDir().GetAngleDegree());
							if(pRB->m_dAngleX1 < 90)
								pRB->m_dAngleX1	= 180 - pRB->m_dAngleX1;
							else if(pRB->m_dAngleX1 > 180)
								pRB->m_dAngleX1 = 360 - pRB->m_dAngleX1;
							else if(pRB->m_dAngleX1 < 0)
								pRB->m_dAngleX1	= 360 + pRB->m_dAngleX1;
							if(pRB->m_dAngleX2 < 90)
								pRB->m_dAngleX2	= 180 - pRB->m_dAngleX2;
							else if(pRB->m_dAngleX2 > 180)
								pRB->m_dAngleX2	= 360 - pRB->m_dAngleX2;
							else if(pRB->m_dAngleX2 < 0)
								pRB->m_dAngleX2	= 360 + pRB->m_dAngleX2;
						}
					}
					// 위 두가지가 아니라면 헌치에 R이 들어간 경우임(헌치 모양 대로 집계됨)
					// 그러나 현재는 헌치에 R이 있는 경우 V형 철근을 지원하지 않으므로 전혀 쓸모 없는 코드임
					// 다만 차후에 필요할 지도 몰라서 그냥 놔둠.(2005.09.13)
					else 
					{
						long nSize	= pRC->m_tvArrRebar.GetSize();
						if(nJ == 0 || nJ == GetCountJijum()-1)
						{
							if(nSize == 2)
							{
								pRB->m_nTypeRebar	= 5;
								if(nJ == 0)
								{
									pRB->m_dLengthMax_A	= pRC->m_tvArrRebar.GetAt(0).GetLength();
									pRB->m_R			= fabs(pRC->m_tvArrRebar.GetAt(1).m_v2.z);
									pRB->m_dLengthMax_B	= pRC->m_tvArrRebar.GetAt(1).GetLength() * dRateMaxByOrg;
									if(ang >= 3)
										pRB->m_dLengthMin_B	= pRB->m_dLengthMax_B * dRateMinByMax;

									pRB->m_dLengthMax_C	= pRC->m_tvArrRebar.GetAt(2).GetLength();
								}
								else
								{
									pRB->m_dLengthMax_C	= pRC->m_tvArrRebar.GetAt(0).GetLength();
									pRB->m_R			= fabs(pRC->m_tvArrRebar.GetAt(1).m_v2.z);
									pRB->m_dLengthMax_B	= pRC->m_tvArrRebar.GetAt(1).GetLength() * dRateMaxByOrg;
									if(ang >= 3)
										pRB->m_dLengthMin_B	= pRB->m_dLengthMax_B * dRateMinByMax;
									pRB->m_dLengthMax_A	= pRC->m_tvArrRebar.GetAt(2).GetLength();
								}
							}
							else if(nSize == 4)
							{
								pRB->m_nTypeRebar	= 43;
								if(nJ == 0)
								{
									pRB->m_dLengthMax_A		= pRC->m_tvArrRebar.GetAt(nSize-1).GetLength();
									pRB->m_dLengthMax_B		= pRC->m_tvArrRebar.GetAt(nSize-2).GetLength() * dRateMaxByOrg;
									if(ang >= 3)
										pRB->m_dLengthMin_B	= pRB->m_dLengthMax_B * dRateMinByMax;
									pRB->m_dLengthMax_C		= 0;
									pRB->m_dLengthMax_R1	= fabs(pRC->m_tvArrRebar.GetAt(nSize-3).m_v2.z);
									pRB->m_dLengthMax_C1	= pRC->m_tvArrRebar.GetAt(nSize-3).GetLength();
									pRB->m_dLengthMin_R1	= pRB->m_dLengthMax_R1;
									pRB->m_dLengthMin_C1	= pRB->m_dLengthMax_C1;
									pRB->m_dLengthMax_D		= pRC->m_tvArrRebar.GetAt(0).GetLength();
								}
								else
								{
									pRB->m_dLengthMax_A		= pRC->m_tvArrRebar.GetAt(0).GetLength();
									pRB->m_dLengthMax_B		= pRC->m_tvArrRebar.GetAt(1).GetLength() * dRateMaxByOrg;
									if(ang >= 3)
										pRB->m_dLengthMin_B	= pRB->m_dLengthMax_B * dRateMinByMax;
									pRB->m_dLengthMax_C		= 0;
									pRB->m_dLengthMax_R1	= fabs(pRC->m_tvArrRebar.GetAt(2).m_v2.z);
									pRB->m_dLengthMax_C1	= pRC->m_tvArrRebar.GetAt(2).GetLength();
									pRB->m_dLengthMin_R1	= pRB->m_dLengthMax_R1;
									pRB->m_dLengthMin_C1	= pRB->m_dLengthMax_C1;
									pRB->m_dLengthMax_D		= pRC->m_tvArrRebar.GetAt(3).GetLength();
								}
							}
						}
						else
						{
							pRB->m_nTypeRebar	= 42;
							if(nSize == 5)
							{
								pRB->m_dLengthMax_A		= pRC->m_tvArrRebar.GetAt(nSize-1).GetLength();
								pRB->m_dLengthMax_R1	= fabs(pRC->m_tvArrRebar.GetAt(nSize-2).m_v2.z);
								pRB->m_dLengthMax_C1	= pRC->m_tvArrRebar.GetAt(nSize-2).GetLength();
								pRB->m_dLengthMin_R1	= pRB->m_dLengthMax_R1;
								pRB->m_dLengthMin_C1	= pRB->m_dLengthMax_C1;
								pRB->m_dLengthMax_B		= 0;
								pRB->m_dLengthMax_C		= pRC->m_tvArrRebar.GetAt(nSize-3).GetLength() * dRateMaxByOrg;
								if(ang >= 3)
									pRB->m_dLengthMin_C	= pRB->m_dLengthMax_C * dRateMinByMax;
								pRB->m_dLengthMax_D		= 0;
								pRB->m_dLengthMax_R2	= fabs(pRC->m_tvArrRebar.GetAt(nSize-4).m_v2.z);
								pRB->m_dLengthMax_C2	= pRC->m_tvArrRebar.GetAt(nSize-4).GetLength();
								pRB->m_dLengthMin_R2	= pRB->m_dLengthMax_R2;
								pRB->m_dLengthMin_C2	= pRB->m_dLengthMax_C2;
								pRB->m_E				= pRC->m_tvArrRebar.GetAt(nSize-5).GetLength();
							}
						}
					}
					
					pRB->m_bMainRebar	= TRUE;
					pRB->m_nEa			= nCount;//pTvArr->GetSize();//tvArr.GetSize() + tvArrAngLeft.GetSize() + tvArrAngRight.GetSize();
					// (37039) 라운드헌치 철근이 시종점 벽체 헌치에는 적용되지 않는다.
					if(bIncludeArc && (nJ > 0 && nJ < GetCountJijum()-1))
					{
						pRB->m_nEa		= pRB->m_nEa * pRC->m_tvArrRebar.GetSize();
					}

					baseConc.OptimizationRebar(pRB);	// 철근 최적화
					m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
					pRB->m_dRateAdd	= MAKE_RATE;

					AddOrDeleteRebarInList(&m_pArrRebarMain, pRB);
				}

				//nIdx++;
			}
		}
	} // end of 상부슬래브

}

// 헌치부 철근
// 평면 우측에 대상 지점에 판다.
// 모든 지점이 대상이 될 수 있다.
void CRcBridgeRebar::GetTvCuttingArea_Plane_SlabHunch(CTwinVectorArray &tvArr, long nJ, BOOL bUpperSlab)
{
	tvArr.RemoveAll();
	if(!IsHunch(nJ, bUpperSlab)) return;

	// 트랙 제원
	// 이번센 세워진 뭉퉁한 트랙이 될것이다.
	// 하면쪽에만 판다.

	
	CLineInfo *pLineC	= GetLineBase();

	//#0031774 기본은 우측에 대상지점을 파는것으로 설정(수정전 우측에만 생성)
	BOOL bRight = TRUE;
	
	//#0031774 선형이 같은 경우에 좌, 우측을 판별
	if(m_nLineLeft == m_nLineRight)
	{
		//선형좌측
		if( (m_dExpSttW[0] > 0 && m_dExpSttH[0] > 0) || (m_dExpEndW[0] > 0 && m_dExpEndH[0] > 0) )
		{
			bRight = FALSE;
		}

		//선형우측
		if( (m_dExpSttW[1] > 0 && m_dExpSttH[1] > 0) || (m_dExpEndW[1] > 0 && m_dExpEndH[1] > 0) )
		{
			bRight = TRUE;
		}
	}

	if(bUpperSlab == FALSE) bRight = !bRight;
	
	//우측
	if(bRight)
	{
		CLineInfo *pLineR	= GetLineLeftRight(FALSE);
		double dStaRight	= GetStationOnJijum(nJ, 1);
		CDPoint xyR	= pLineR->GetXyLine(dStaRight);
		double dSta			= GetStationOnJijum(nJ, 0);
		pLineC->GetStationMatchVerticalByXy(xyR, dSta);

		double dWid			= GetWidthSlabAct(dSta, CDPoint(0, 1), 0);
		double dR			= dWid/6;		// 트랙의 원의 반지름
		if(m_dLengthBridge/6 < dR) dR = m_dLengthBridge/6;
		double dMinLenJigan	= 0;
		for(long jigan = 0; jigan < m_nQtyJigan; jigan++)
			dMinLenJigan = jigan == 0 ? GetLengthJigan(jigan) : min(GetLengthJigan(jigan), dMinLenJigan);
		if(dMinLenJigan > 0 && dMinLenJigan/4 < dR) dR = dMinLenJigan/4;

		double dB			= dR/4;			// 트랙의 수직선 길이
		double dDist		= GetWidthSlabAct(dSta, CDPoint(0, 1), 1);
		if(m_bIsExp && (nJ == 0 || nJ == m_nQtyJigan))
		{
			double dHDiff	= nJ == 0 ? m_dExpSttH[1] : m_dExpEndH[1];
			dDist += dHDiff/2;
			dB += dHDiff;
		}

		if(nJ == 0) dSta += (dR-m_dWS+100);
		else if(nJ == m_nQtyJigan) dSta -= (dR-m_dWE+100);

		// 구하자.
		GetTvTrack_Plane(tvArr, dSta, dDist, dR, dB, TRUE);	
	}

	//좌측
	if(!bRight)
	{
		CLineInfo *pLineL	= GetLineLeftRight(TRUE);
		double dStaLeft	= GetStationOnJijum(nJ, -1);
		CDPoint xyL	= pLineL->GetXyLine(dStaLeft);
		double dSta			= GetStationOnJijum(nJ, 0);
		pLineC->GetStationMatchVerticalByXy(xyL, dSta);

		double dWid			= GetWidthSlabAct(dSta, CDPoint(0, 1), 0);
		double dR			= dWid/6;		// 트랙의 원의 반지름
		if(m_dLengthBridge/6 < dR) dR = m_dLengthBridge/6;
		double dMinLenJigan	= 0;
		for(long jigan = 0; jigan < m_nQtyJigan; jigan++)
			dMinLenJigan = jigan == 0 ? GetLengthJigan(jigan) : min(GetLengthJigan(jigan), dMinLenJigan);
		if(dMinLenJigan > 0 && dMinLenJigan/4 < dR) dR = dMinLenJigan/4;

		double dB			= dR/4;			// 트랙의 수직선 길이
		double dDist		= GetWidthSlabAct(dSta, CDPoint(0, 1), -1);
		if(m_bIsExp && (nJ == 0 || nJ == m_nQtyJigan))
		{
			double dHDiff	= nJ == 0 ? m_dExpSttH[1] : m_dExpEndH[1];
			dDist += dHDiff/2;
			dB += dHDiff;
		}

		if(nJ == 0) dSta += (dR-m_dWS+100);
		else if(nJ == m_nQtyJigan) dSta -= (dR-m_dWE+100);

		// 구하자.
		GetTvTrack_Plane(tvArr, dSta, -dDist, dR, dB, TRUE);	
	}
	
	// 
	tvArr.SetTvInfoByInfo("시점측아크1", "그릴때제거1");
	tvArr.SetTvInfoByInfo("시점측아크2", "그릴때제거2");
	tvArr.SetTvInfoByInfo("시점측아크3", "그릴때제거3");
	tvArr.SetTvInfoByInfo("시점측아크4", "그릴때제거4");
}



// 기본 철근 상세로부터 각도에 따른 철근 상세를 구한다.
int CRcBridgeRebar::GetWingWallRebarDetail(BOOL bStt, BOOL bLeft, int nBaseRebar)
{
	CDPoint vWing = GetAngleWingWallBetweenWall(bStt, bLeft);

	if(vWing.x==0)
		return nBaseRebar;

	int nRebar = 0;
	switch(nBaseRebar)
	{
	case 2:
		if(vWing.x<0)
			nRebar = 8;
		else
			nRebar = 46;
		break;
	case 4:
		if(vWing.x<0)
			nRebar = 13;
		else
			nRebar = 21;
		break;
	case 33:
		if(vWing.x<0)
			nRebar = 47;
		else
			nRebar = 48;
		break;
	}

	return nRebar;
}
// 시점이나 종점방향으로 배력근을 배치하는 구간 거리 설정
// 이 함수는 지점각도가 바뀔 경우에만 자동으로 호출하며, 다른 경우에는 절대로 호출 하면 안된다.
// 여기서 셋팅되는 값은 사용자에게 입력을 받을 수도 있도록 해야 되기 때문에 호출시 각별한 주의 요망
void CRcBridgeRebar::SetDataDefaultDistJijumDirPlacing()
{
	long nType	= m_nTypePlacingSupportRebar_UpperSlab;

	CLineInfo *pLine		= GetLineBase(IsVertDir());
	if(!pLine) return;

	CTwinVector tvJijumStt	= GetTvJijum(0, 0);
	CTwinVector tvJijumEnd	= GetTvJijum(m_nQtyJigan, 0);

	if(nType == 2 || nType == 3)
	{
		// 시점측
		GetTvSttEndOfSlab(tvJijumStt, tvJijumEnd, FALSE);

		double dStaSttLeft		= m_dStationBridgeStt;
		double dStaSttRight		= m_dStationBridgeStt;

		pLine->GetStationMatchVerticalByXy(tvJijumStt.m_v1, dStaSttLeft);
		pLine->GetStationMatchVerticalByXy(tvJijumStt.m_v2, dStaSttRight);
		m_dDistSttJijumDirPlacing[0]	= fabs(dStaSttLeft-dStaSttRight);//max(fabs(dStaSttLeft - m_dStationBridgeStt), fabs(dStaSttRight - m_dStationBridgeStt)) * 2;


		// 종점측
		double dStaEndLeft		= m_dStationBridgeStt + m_dLengthBridge;
		double dStaEndRight		= m_dStationBridgeStt + m_dLengthBridge;

		pLine->GetStationMatchVerticalByXy(tvJijumEnd.m_v1, dStaEndLeft);
		pLine->GetStationMatchVerticalByXy(tvJijumEnd.m_v2, dStaEndRight);
		m_dDistEndJijumDirPlacing[0]	= fabs(dStaEndLeft-dStaEndRight);//(fabs(m_dStationBridgeStt + m_dLengthBridge - dStaEndLeft), fabs(m_dStationBridgeStt + m_dLengthBridge - dStaEndRight)) * 2;

		if(nType == 3)
		{
			m_dDistSttJijumDirPlacing[0] /= 2;
			m_dDistEndJijumDirPlacing[0] /= 2;
		}
	}
	else
	{
		CDPoint xyMove	= tvJijumStt.m_v1 - tvJijumEnd.m_v1;
		tvJijumEnd.m_v1 += xyMove;
		tvJijumEnd.m_v2 += xyMove;
		
		CDPoint xy1	= tvJijumEnd.m_v2;
		CDPoint xy2	= tvJijumStt.m_v2;
		CDPoint xyMatch(0, 0);
		GetXyMatchLineAndLine(xy2, tvJijumStt.GetXyDir().Rotate90(), xy1, tvJijumEnd.GetXyDir(), xyMatch);
		double dDiff	= ~(xy2 - xyMatch);
		/*
		double dSta1(0), dSta2(0);
		pLine->GetStationMatchVerticalByXy(xy1, dSta1);
		pLine->GetStationMatchVerticalByXy(xy2, dSta2);
		double dDiff	= fabs(dSta1-dSta2);
		*/
		if(nType == 0)	// 시점 각도 기준일경우
		{
			m_dDistSttJijumDirPlacing[0]	= 0;
			m_dDistEndJijumDirPlacing[0]	= dDiff;
		}
		else if(nType == 1)
		{
			m_dDistSttJijumDirPlacing[0]	= dDiff;
			m_dDistEndJijumDirPlacing[0]	= 0;
		}
	}

	// (ARCBRIDGE-3221) 가각 또는 확폭이 있는경우 그만큼 폭을 벌려줘야 한다.
	CTwinVector tvRealStt, tvRealEnd;
	GetTvSttEndOfSlab(tvRealStt, tvRealEnd);

	m_dDistSttJijumDirPlacing[0] *= 1 + (tvRealStt.GetLength() / tvJijumStt.GetLength() - 1)/2.;
	m_dDistEndJijumDirPlacing[0] *= 1 + (tvRealEnd.GetLength() / tvJijumEnd.GetLength() - 1)/2.;


	m_dDistSttJijumDirPlacing[1]	= m_dDistSttJijumDirPlacing[0];
	m_dDistEndJijumDirPlacing[1]	= m_dDistEndJijumDirPlacing[0];

	// 신축이음인 경우 상면 철근의 사방향 철근 범위는 변경 될 수 있다.
	// 신축이음이 있는 부분의 상면 철근은 무조건 사방향이어야 하기 때문.
	if(IsBlockOut(TRUE))
	{
		double dWidth	= m_fxJointStt.m_dWidth + m_dCoverWallOut[0];
		if(!IsVertDir())
		{
			dWidth = dWidth/GetAngleJijum(0).y;
		}

		if(m_dDistSttJijumDirPlacing[iUPPER] < dWidth)
			m_dDistSttJijumDirPlacing[iUPPER] = dWidth;
	}

	if(IsBlockOut(FALSE))
	{
		double dWidth	= m_fxJointEnd.m_dWidth + m_dCoverWallOut[0];
		if(!IsVertDir())
		{
			dWidth = dWidth/GetAngleJijum(m_nQtyJigan).y;
		}

		if(m_dDistEndJijumDirPlacing[iUPPER] < dWidth)
			m_dDistEndJijumDirPlacing[iUPPER] = dWidth;
	}
}

// 배력근의 중심 sta을 받아서 이 철근이 시점방향 철근인지 종점방향 철근인지 직방향 철근인지 판단
// ret -> -1 : 시점방향, 0 : 직방향, 1 : 종점방향
// 배력근 배치 타입 m_nTypePlacingSupportRebar_UpperSlab
// 0 : 시점각도기준 경사방향 배치
// 1 : 종점각도기준 경사방향 배치
// 2 : 사보강
long CRcBridgeRebar::GetDirSupportRebar(double dSta, BOOL bUpper)
{
	long upper	= bUpper ? iUPPER : iLOWER;
	if(m_nTypePlacingSupportRebar_UpperSlab == 0)
	{
		double dStaEnd	= GetStationByTarget(BRIDGE_OFF_END_SLAB, 0, TRUE);
		if(dSta > dStaEnd - m_dDistEndJijumDirPlacing[upper])
			return 1;
		else 
			return -1;
		return -1;
	}
	else if(m_nTypePlacingSupportRebar_UpperSlab == 1) 
	{
		double dStaStt	= GetStationByTarget(BRIDGE_OFF_STT_SLAB, 0, TRUE);
		if(dSta < dStaStt + m_dDistEndJijumDirPlacing[upper])
			return -1;
		else
			return 1;
		return 1;
	}
	else
	{
		double dStaStt	= GetStationByTarget(BRIDGE_OFF_STT_SLAB, 0, TRUE);
		double dStaEnd	= GetStationByTarget(BRIDGE_OFF_END_SLAB, 0, TRUE);
		if(dSta < dStaStt + m_dDistEndJijumDirPlacing[upper])
			return -1;
		else if(dSta > dStaEnd - m_dDistEndJijumDirPlacing[upper])
			return 1;
		else 
			return 0;
	}

	return 0;
}

// 거더철근이 있는지?
// 기둥식 벽체위, 시종점 교대위(외측벽체 없을때), 중간지점 벽체 없는 경우에 존재한다.
BOOL CRcBridgeRebar::IsGirderRebar(long nJ, BOOL bUpperSlab)
{
	if(bUpperSlab == FALSE && IsBoxType() == FALSE) return FALSE;

	BOOL bGirder	= FALSE;
	if(nJ == 0 || nJ == m_nQtyJigan)
	{
		if(bUpperSlab)
		{
			BOOL bStt	= nJ == 0;
			bGirder		= !IsOutWall(bStt);
		}
	}
	else
	{
		long nJijumConnect = GetJijumConnectRibAndSlab();
		long nIdxInWall	= nJ - 1;
		CWallApp *pWall	= GetInWall(nIdxInWall);
		if(pWall && nJ != nJijumConnect)
		{
			bGirder	= !pWall->m_bIs || pWall->m_bTopIsColumn;
		}
	}

	return bGirder;
}

// 거더 스터럽 철근 평면 좌표
// void CRcBridgeRebar::GetTvRebarStirrup_Plane_Girder(CTwinVectorArray &tvArr, CTwinVectorArray &tvArrAngLeft, CTwinVectorArray &tvArrAngRight, long nJ, long nDrawLeft, BOOL bUpperSlabGirder)
// {
// 	tvArr.RemoveAll();
// 	tvArrAngLeft.RemoveAll();
// 	tvArrAngRight.RemoveAll();
// 
// 	if(!IsGirderRebar(nJ, bUpperSlabGirder)) return;
// 
// 	// 거더 스터럽도 상부슬래브 주철근과 ctc가 같으므로 구지 따로 구할 필요 없이
// 	// 상부슬래브 주철근 구하는 함수를 이용하자.
// }

// 확폭지원이 안되는 경우를 고려한 거리임
void CRcBridgeRebar::SetDataDefaultDistLeftDirPlacing(BOOL bHunch)
{
	CLineInfo *pLine	= GetLineBase();
	if(!pLine) return;

	// 2005.06.16 부로 주철근 사보강 배치(절반) 옵션 없어짐 /////////
	// 하부장님 정차장님과 상의 함.
	// 2006.1.2일부로 다시 살려서 작업함.
	/*
	if(m_nTypePlacingMainRebar_UpperSlab == 2) 
		m_nTypePlacingMainRebar_UpperSlab	= 1;
		*/
	////////////////////////////////////////////////////////////////
	CDPoint xyDirVert	= IsVertDir() ? GetAngleAzimuthJijum(0).Rotate90() : pLine->GetAngleAzimuth(m_dStationBridgeStt);
	CTwinVectorArray tvArrStt, tvArrEnd;
	GetTvPlaneSttEndLine(tvArrStt, TRUE, TRUE, 0, FALSE);
	GetTvPlaneSttEndLine(tvArrEnd, FALSE, TRUE, 0, FALSE);

	CRebarPlacing rb;

	CDPoint xyMove(0,0);
	CTwinVectorArray tvArrCenterLine, tvArrCenTmp;
	GetTvCenterPlane_UpperSlab(tvArrCenterLine, TRUE, TRUE, 0, IsVertDir());
	
	BOOL bExtCenter = IsExtLine() && tvArrCenterLine.GetSize() > 0 ? TRUE : FALSE;

	// 왼쪽 구간 거리
	CDPoint xyStt(0, 0), xyEnd(0, 0);
	CDPointArray xyArrMatch;
	CDPoint xyMatch(0, 0);
	CDPoint vAngleStt	= GetJijum(0)->m_vAngle;
	CDPoint vAngleEnd	= GetJijum(m_nQtyJigan)->m_vAngle;
	double dStaStt		= IsOutWall(TRUE) ? m_dStationBridgeStt - m_dWS/vAngleStt.y : m_dStationBridgeStt;
	double dStaEnd		= IsOutWall(FALSE) ? m_dStationBridgeStt + m_dLengthBridge + m_dWS/vAngleEnd.y : m_dStationBridgeStt + m_dLengthBridge;
	double dStaBase	= GetStationSmallestWidthOfUpperSlab(IsVertDir(), 0, !IsVertDir()); // 주철근배치 기준위치 
	double dSttWidthSlabAct = -GetWidthSlabAct(dStaStt, vAngleStt, -1);
	double dEndWidthSlabAct =  -GetWidthSlabAct(dStaEnd, vAngleEnd, -1);
	double dSttWidthSlabActRA = -GetWidthSlabAct(dStaStt, CDPoint(0, 1), -1);
	double dEndWidthSlabActRA =  -GetWidthSlabAct(dStaEnd, CDPoint(0, 1), -1);
	double dMIdWidthSlabActRA =  -GetWidthSlabAct((dStaStt + dStaEnd)/2., CDPoint(0, 1), -1);

	xyStt	= pLine->GetXyLineByLengthAndAngle(dStaStt, dSttWidthSlabAct, vAngleStt);
	xyEnd	= pLine->GetXyLineByLengthAndAngle(dStaEnd, dEndWidthSlabAct, vAngleEnd);	

	//확폭일 경우를 대비
	if(m_nTypePlacingMainRebar_UpperSlab == 0 && Compare(dSttWidthSlabActRA, dEndWidthSlabActRA, _T("="), 1.0))
	{
		// (ARCBRIDGE-3664) 선형방향 배치일때 지점 각도에의한 폭차이는 무시해야 한다. 그리고 곡선선형에서 지점각도가 있을때는 Move를 하면 오차가 생긴다.
		m_dDistLeftDirPlacing = 0.0;
	}
	else if(m_nTypePlacingMainRebar_UpperSlab == 0 && fabs(dMIdWidthSlabActRA) > MAX(fabs(dSttWidthSlabActRA), fabs(dEndWidthSlabActRA)))
	{
		// (ARCBRIDGE-3664) 중심선형과 확폭선형의 곡선에의해서 교량중간이 더 넓은경우 예외처리
		// 비교는 직각방향으로 했지만 거리를 구해줄때는 시점 각도 기준으로 
		// 가장 작은위치의 폭은 주철근 배치 기준위치 폭을 써야 철근 배치에 비는 구간이 없다.
		double dBaseWidthSlabAct =  -GetWidthSlabAct(dStaBase, CDPoint(0, 1), -1);
		m_dDistLeftDirPlacing = (fabs(dMIdWidthSlabActRA) - fabs(dBaseWidthSlabAct)) / vAngleStt.y;
	}
	else
	{
		if(bExtCenter && Compare(dSttWidthSlabAct, dEndWidthSlabAct , _T(">"),1))
		{
			tvArrCenTmp.RemoveAll();
			tvArrCenTmp.AddFromTvArray(tvArrCenterLine);

			xyMove = xyStt- tvArrCenTmp.GetAt(0).m_v1;		
			rb.MoveRebar(tvArrCenTmp, xyMove);

			rb.GetXyMatchTvArrAndTvArr(tvArrEnd, tvArrCenTmp, xyArrMatch, FALSE);
		}
		else
		{
			rb.GetXyMatchTvArrAndLine(tvArrEnd, xyStt, xyDirVert, xyArrMatch);
		}	

		if(xyArrMatch.GetSize() > 0)
		{
			xyMatch	= xyArrMatch.GetAt(0);
			m_dDistLeftDirPlacing	= ~(xyEnd - xyMatch);
		}
		else 
		{
			xyArrMatch.RemoveAll();

			if(bExtCenter && Compare(dSttWidthSlabAct, dEndWidthSlabAct , _T("<"),1))
			{
				tvArrCenTmp.RemoveAll();
				tvArrCenTmp.AddFromTvArray(tvArrCenterLine);

				xyMove = xyEnd- tvArrCenTmp.GetAt(tvArrCenTmp.GetSize()-1).m_v2;		
				rb.MoveRebar(tvArrCenTmp, xyMove);

				rb.GetXyMatchTvArrAndTvArr(tvArrStt, tvArrCenTmp, xyArrMatch, FALSE);
			}
			else
			{
				rb.GetXyMatchTvArrAndLine(tvArrStt, xyEnd, xyDirVert, xyArrMatch);
			}		

			if(xyArrMatch.GetSize() > 0)
			{
				xyMatch	= xyArrMatch.GetAt(0);
				m_dDistLeftDirPlacing	= ~(xyStt - xyMatch);
			}
			else
			{
				m_dDistLeftDirPlacing	= 0;
			}
		}
	}

	// 오른쪽 구간 거리
	dSttWidthSlabAct	= GetWidthSlabAct(dStaStt, vAngleStt, 1);
	dEndWidthSlabAct	=  GetWidthSlabAct(dStaEnd, vAngleEnd, 1);
	dSttWidthSlabActRA	= GetWidthSlabAct(dStaStt, CDPoint(0, 1), 1);
	dEndWidthSlabActRA	=  GetWidthSlabAct(dStaEnd, CDPoint(0, 1), 1);
	dMIdWidthSlabActRA =  -GetWidthSlabAct((dStaStt + dStaEnd)/2., CDPoint(0, 1), 1);
	xyStt	= pLine->GetXyLineByLengthAndAngle(dStaStt, dSttWidthSlabAct, vAngleStt);
	xyEnd	= pLine->GetXyLineByLengthAndAngle(dStaEnd, dEndWidthSlabAct, vAngleEnd);

	if(m_nTypePlacingMainRebar_UpperSlab == 0 && Compare(dSttWidthSlabActRA, dEndWidthSlabActRA, _T("="), 1.0))
	{
		// (ARCBRIDGE-3664) 선형방향 배치일때 지점 각도에의한 폭차이는 무시해야 한다. 그리고 곡선선형에서 지점각도가 있을때는 Move를 하면 오차가 생긴다.
		m_dDistRightDirPlacing = 0.0;
	}
	else if(m_nTypePlacingMainRebar_UpperSlab == 0 && fabs(dMIdWidthSlabActRA) > MAX(fabs(dSttWidthSlabActRA), fabs(dEndWidthSlabActRA)))
	{
		// (ARCBRIDGE-3664) 중심선형과 확폭선형의 곡선에의해서 교량중간이 더 넓은경우 예외처리
		// 비교는 직각방향으로 했지만 거리를 구해줄때는 시점 각도 기준으로 
		// 가장 작은위치의 폭은 주철근 배치 기준위치 폭을 써야 철근 배치에 비는 구간이 없다.
		double dBaseWidthSlabAct =  -GetWidthSlabAct(dStaBase, CDPoint(0, 1), 1);
		m_dDistRightDirPlacing = (fabs(dMIdWidthSlabActRA) - fabs(dBaseWidthSlabAct)) / vAngleStt.y;
	}
	else
	{
		if(bExtCenter && Compare(dSttWidthSlabAct, dEndWidthSlabAct , _T(">"),1))
		{
			tvArrCenTmp.RemoveAll();
			tvArrCenTmp.AddFromTvArray(tvArrCenterLine);

			xyMove = xyStt- tvArrCenTmp.GetAt(0).m_v1;		
			rb.MoveRebar(tvArrCenTmp, xyMove);

			rb.GetXyMatchTvArrAndTvArr(tvArrEnd, tvArrCenTmp, xyArrMatch, FALSE);
		}
		else
		{
			rb.GetXyMatchTvArrAndLine(tvArrEnd, xyStt, xyDirVert, xyArrMatch);
		}

		if(xyArrMatch.GetSize() > 0)
		{
			xyMatch	= xyArrMatch.GetAt(0);
			m_dDistRightDirPlacing	= ~(xyEnd - xyArrMatch.GetAt(0));
		}
		else 
		{
			xyArrMatch.RemoveAll();

			if(bExtCenter && Compare(dSttWidthSlabAct, dEndWidthSlabAct , _T("<"),1))
			{
				tvArrCenTmp.RemoveAll();
				tvArrCenTmp.AddFromTvArray(tvArrCenterLine);

				xyMove = xyEnd- tvArrCenTmp.GetAt(tvArrCenTmp.GetSize()-1).m_v2;		
				rb.MoveRebar(tvArrCenTmp, xyMove);

				rb.GetXyMatchTvArrAndTvArr(tvArrStt, tvArrCenTmp, xyArrMatch, FALSE);
			}
			else
			{
				rb.GetXyMatchTvArrAndLine(tvArrStt, xyEnd, xyDirVert, xyArrMatch);
			}		

			if(xyArrMatch.GetSize() > 0)
			{
				m_dDistRightDirPlacing	= ~(xyStt - xyArrMatch.GetAt(0));
			}
			else
			{
				m_dDistRightDirPlacing	= 0;
			}
		}
	}

	/*
	if(Compare(m_dDistLeftDirPlacing, 0.0, ">"))
		m_dDistLeftDirPlacing	+= GetCtcRebarMain();

	if(Compare(m_dDistRightDirPlacing, 0.0, ">"))
		m_dDistRightDirPlacing	+= GetCtcRebarMain();
		*/

	// 헌치부라고 해서 사방향 철근이 들어가는 범위가 변경되지는 않는다.
	// 다만 전체 철근의 개수가 줄어들뿐.. #20710
	// 위와 같은 이유로 막음.
	if(0)//bHunch)
	{
		double dLenL	= (m_dDH[0] + m_dCantilB[0]);
		double dLenR	= (m_dDH[1] + m_dCantilB[1]);

		m_dDistLeftDirPlacing -= dLenL;
		m_dDistRightDirPlacing -= dLenR;
	}


	if(m_nTypePlacingMainRebar_UpperSlab == 2)
	{
		m_dDistLeftDirPlacing	/= 2;
		m_dDistRightDirPlacing	/= 2;
	}
}
// 직방향으로만 배치되는 주철근 구하기
// 브라켓, 거더
// long nIdx : 헌치나 거더의 인덱스
// BOOL bDanbu, long nDanDanbu : 단부, 단부 단.
void CRcBridgeRebar::GetTvRebarMain_Plane_Slab_Ortho(CTwinVectorArray &tvArr, CTwinVectorArray &tvArrHidden, long nCycle, BOOL bBracket, BOOL bSttBracket, BOOL bGirder, long nIdxGirder, BOOL bSttDanbu, BOOL bEndDanbu, long nDanDanbu, BOOL bForDrawing, BOOL bUpperSlabGirder)
{
	tvArr.RemoveAll();

	// 주철근 간격이 지간마다 다를 수 있으므로 해당 지간 가져옴
	CRebarPlacing rb;
	BOOL bUpper	= bUpperSlabGirder;
	long nJ		= nIdxGirder;
	double dCoverSide	= GetCoverSide_UpperSlab(0);
	CTwinVector tvPath;


	// 1. 주철근이 배치되는 기준이 되는 sta들 구함
	double dStaSttRebar	= 0;
	double dStaEndRebar	= 0;
	double dCTC			= GetCtcRebarMain(TRUE);
	CDPoint xyDirRebar	= CDPoint(0, 1);
	if(bBracket)
	{
		dCoverSide	= m_dCoverWallOut[0];
		dCTC		= GetCtcRebarMain() / 2;
		long stt	= bSttBracket ? iSTT : iEND;
		CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = nCycle == 0 ? &m_pArrRCMainOutWallBracket_Cycle1[stt] : &m_pArrRCMainOutWallBracket_Cycle2[stt];

		if(pArrRC->GetSize() > 0)
		{
			CRebarInfoCycle *pRC	= pArrRC->GetAt(0);
			dStaSttRebar	= m_Util.GetStationRebarInfoCycle(pRC, TRUE);
// 			dStaEndRebar	= m_Util.GetStationRebarInfoCycle(pRC, FALSE);
			
			// 직방향 배치 전용 철근은 m_tvArrVertSection의 영향을 받아서는 안된다.
			dStaEndRebar	= dStaSttRebar + (bSttBracket ? (m_dBHWS + m_dWS) - m_dCoverWallOut[0] * 2 
															: (m_dBHWE + m_dWE) - m_dCoverWallOut[0] * 2);
		}

		CTwinVectorArray tvArrPlane;
		GetTvPlaneOutWall(tvArrPlane, bSttBracket, TRUE, FALSE);
		tvPath	= tvArrPlane.GetTvByInfo("브라켓외측");
		GetSwap(tvPath.m_v1, tvPath.m_v2);
		Offset(tvPath.m_v1, tvPath.m_v2, dCoverSide);

		xyDirRebar	= tvPath.GetXyDir().RotateInv90();
	}
	else if(bGirder)
	{
		if(IsGirderRebar(nJ, bUpperSlabGirder))
		{
			CDPoint vAng = GetAngleJijum(nJ);

			CGirderSectionRebar *pGirder	= &m_SlabGirderRebar[bUpper ? iUPPER : iLOWER][nJ];
			double dSta	= 0;
			if(pGirder->m_nType == 0)
				dSta	= pGirder->m_xyOrg.x + pGirder->m_dDist/vAng.y;
			else if(pGirder->m_nType == 1)
				dSta	= pGirder->m_xyOrg.x - (pGirder->m_dDist + pGirder->m_dWidthL + pGirder->m_dWidthR)/vAng.y;
			else if(pGirder->m_nType == 2)
				dSta	= pGirder->m_xyOrg.x - (pGirder->m_dWidthL - pGirder->m_dCoverSide)/vAng.y;
				
			CLineInfo *pLine	= GetLineBase(FALSE);
			double dWidthLeft	= GetWidthSlabAct(dSta, vAng, -1);
			double dWidthRight	= GetWidthSlabAct(dSta, vAng, 1);
			tvPath.m_v1	= pLine->GetXyLineByLengthAndAngle(dSta, -dWidthLeft, vAng);
			tvPath.m_v2	= pLine->GetXyLineByLengthAndAngle(dSta, dWidthRight, vAng);
			
			double dW	=  pGirder->m_dC1[iUPPER][0] + pGirder->m_dC[iUPPER][0] * pGirder->m_nB[iUPPER][0] + pGirder->m_dC2[iUPPER][0];
			dStaSttRebar	= dSta;
			dStaEndRebar	= dStaSttRebar + dW;
			dCTC			= pGirder->m_dCTC;

			xyDirRebar	= tvPath.GetXyDir().Rotate90();
		}
	}
	else if(bSttDanbu || bEndDanbu)
	{
		dCoverSide	= m_dCoverWallOut[0];
		dCTC		= GetCtcRebarMain()/2;
		long stt		= bSttDanbu ? iSTT : iEND;
		if(IsDanbuRebar(bSttDanbu, nDanDanbu, nCycle, TRUE))
		{
			CRebarInfoCycle *pRC	= nCycle == 0 ? &m_rebarInfoCycleDanbu_UpperCycle1[stt][nDanDanbu] : &m_rebarInfoCycleDanbu_UpperCycle2[stt][nDanDanbu];
			dStaSttRebar	= m_Util.GetStationRebarInfoCycle(pRC, TRUE);
			dStaEndRebar	= m_Util.GetStationRebarInfoCycle(pRC, FALSE);
		}

		CTwinVectorArray tvArrPlane;
		GetTvPlaneOutWall(tvArrPlane, bSttDanbu, TRUE, TRUE);
		tvPath	= tvArrPlane.GetTvByInfo("슬래브끝단외측");
		GetSwap(tvPath.m_v1, tvPath.m_v2);
		Offset(tvPath.m_v1, tvPath.m_v2, dCoverSide);

		xyDirRebar	= tvPath.GetXyDir().RotateInv90();
	}

	tvPath.m_v1	+= tvPath.GetXyDir() * dCoverSide;
	tvPath.m_v2 += tvPath.GetXyDir(TRUE) * dCoverSide;

	if(Compare(dStaSttRebar, dStaEndRebar, "=")) return;
	double dLenRebar	= dStaEndRebar  - dStaSttRebar;

		
	// 주철근 간격 구함
	CDPointArray xyArr;
	rb.GetXyDivideLine(xyArr, tvPath.m_v1, tvPath.m_v2, dCTC, FALSE, (int)(dCTC / 2), TRUE, TRUE);

	// 단부, 브라켓은 1cycle, 2cycle이 구분됨.
	if(bSttDanbu || bEndDanbu || bBracket)
	{
		CDPointArray xyArrTmp;
		xyArrTmp	 = xyArr;
		xyArr.RemoveAll();

		long nSize	= xyArrTmp.GetSize();
		long nStt	= nCycle == 0 ? 0 : 1;
		long i = 0; for(i = nStt; i < nSize-1; i+=2)
			xyArr.Add(xyArrTmp.GetAt(i));
	}

	rb.MakePointArrayToLineArray(xyArr, tvArr, xyDirRebar, dLenRebar, FALSE);

	// 철근이 실제 슬래브 너비-피복 보다 바깥쪽에 있으면 뺀다
	// 브라켓은 뺄 필요 없음
	if(tvArr.GetSize() > 0 && !bBracket)
	{
		CLineInfo *pLine	= GetLineBase();
		CTwinVector tv	= tvArr.GetAt(0);
		CDPoint vAng		= GetAngleJijum(nJ);
		double dSta1(0), dSta2(0);
		pLine->GetStationMatchByXyAndAngle(tv.m_v1, vAng, dSta1);
		pLine->GetStationMatchByXyAndAngle(tv.m_v2, vAng, dSta2);
		double dDistLeft1	= -(GetWidthSlabActByGagak(dSta1, CDPoint(0, 1), -1) - m_dCoverSide_UpperSlab[0]);
		double dDistLeft2	= -(GetWidthSlabActByGagak(dSta2, CDPoint(0, 1), -1) - m_dCoverSide_UpperSlab[0]);
		double dDistRight1	= GetWidthSlabActByGagak(dSta1, CDPoint(0, 1), 1) - m_dCoverSide_UpperSlab[0];
		double dDistRight2	= GetWidthSlabActByGagak(dSta2, CDPoint(0, 1), 1) - m_dCoverSide_UpperSlab[0];
		
		BOOL bOK	= TRUE;
		long i = 0; for(i = 0; i < tvArr.GetSize(); i++)
		{
			bOK	= FALSE;
			tv	= tvArr.GetAt(i);
			double dDist1	= pLine->GetDisMatchVerticalByXy(tv.m_v1);
			double dDist2	= pLine->GetDisMatchVerticalByXy(tv.m_v2);

			if(dDist1 >= dDistLeft1 && dDist1 >= dDistLeft2 && dDist1 <= dDistRight1 && dDist1 <= dDistRight2 &&
				dDist2 >= dDistLeft1 && dDist2 >= dDistLeft2 && dDist2 <= dDistRight1 && dDist2 <= dDistRight2)
				bOK	= TRUE;

			if(!bOK)
			{
				tvArr.RemoveAt(i);
				i--;
			}
		}
	}
}


void CRcBridgeRebar::GetTvRebarMain_Plane_SlabGirder(BOOL bUpperSlab, CTwinVectorArray &tvArr, long nJ, long nDrawLeft)
{
	tvArr.RemoveAll();

	// 브라켓 주철근도 상부슬래브 주철근과 ctc가 같으므로 구지 따로 구할 필요 없이
	CTwinVectorArray tvArrHidden;
	GetTvRebarMain_Plane_Slab_Ortho(tvArr, tvArrHidden, 0, FALSE, TRUE, TRUE, nJ, FALSE, FALSE, 0, TRUE, bUpperSlab);
}
// 헌치 철근 타입 리턴(지점별)
long CRcBridgeRebar::GetTypeMainRebarSlabUpperHunch(long nJ, BOOL bLowerSlab)
{
	if(nJ == -1) nJ = m_nQtyJigan;
	if(nJ < 0 || nJ > m_nQtyJigan) return -1;
	
	long nType	= -1;
	if(bLowerSlab)
	{
		long nSize	= m_dArrTypeLowerSlabHunch.GetSize();
		if(nSize-1 < nJ) nType = -1;
		else nType = (long)m_dArrTypeLowerSlabHunch.GetAt(nJ);
	}
	else
	{
		long nSize	= m_dArrTypeUpperSlabHunch.GetSize();
		if(nSize-1 < nJ) nType = -1;
		else nType = (long)m_dArrTypeUpperSlabHunch.GetAt(nJ);
	}

	// 진짜 헌치가 있는지 한번 더 검사.
	if(!IsHunch(nJ)) nType = -1;
	
	return nType;
}

// 종단면상의 슈 위치 가져옴
// 사거리인지 직거리인지는 알아서 판단함.
// 어짜피 구조도에서 출력할 용도 이므로 따로 설정할 필요는 없음
// 무조건 중심선형용임.(현재는)
// BOOL bLeftOfJijum : 신축이음인 경우 지점의 좌측인지?(기본은 좌측)
CDPoint CRcBridgeRebar::GetXyVertSectionShoe(long nJ, BOOL bLeftOfJijum)
{
	BOOL bVertDir		= IsVertDir();

	//도로중심의 슈 스테이션
	double sta	= GetStationShoeOnJijum(nJ, 0, bLeftOfJijum ? 0 : 1, bVertDir);	
		
	return GetXySlabUpperByLenFrSttStation(sta - m_dStationBridgeStt, 0, bVertDir);
}


// nCheckAdd == -1 : FALSE,    0 : 앞굽2,    1 : 앞굽3
CConcBasic* CRcBridgeRebar::GetConcDataFooting(long nJijum, BOOL bFront, BOOL bReverse, long nCheckAdd, ETypeEnvComboLsd eTypeEnv)
{
	CConcBasic *pData;
	long nIndex = 0;
	BOOL bIsOutWall = (IsOutsideWall());
	BOOL bOutWall = (bIsOutWall && (nJijum==0 || nJijum==GetCountJijum()-1))? TRUE:FALSE;

	// 균열판정용 조합은 사용성검토 조합과 같이 써야지.
	if(eTypeEnv == eEnvService_Crack)
		eTypeEnv = eEnvService;

	if(nCheckAdd > -1)
	{
		if(nJijum == 0) nIndex = nCheckAdd == 0 ? 0 : 4;
		else if(nJijum == GetCountJijum()-1) nIndex = nCheckAdd == 0 ? 2 : 6;

		if(bReverse) nIndex++;

		if(nIndex<0 || nIndex > m_pArrConcFootCheckAdd[eTypeEnv].GetSize()-1) return NULL;

		pData = m_pArrConcFootCheckAdd[eTypeEnv].GetAt(nIndex);
	}
	else
	{
		if(!bIsOutWall) nIndex = nJijum-1;
		else if(nJijum == 0) nIndex = 0;
		else if(nJijum == GetCountJijum()-1) nIndex = 2;
		else nIndex = nJijum+3;
		
		if(bOutWall && !bFront) nIndex += 1;
		
		// 중간기초 일때 앞굽을 검토 하려 했으나 경사교각 일때 뒷굽을 검토 해야 하므로 뒷굽을 검토..
		if(!bOutWall && bFront) return NULL;
		
		if(bReverse)
		{
			if(nIndex<0 || nIndex > m_pArrConcFootRev[eTypeEnv].GetSize()-1) return NULL;
			else
				pData = m_pArrConcFootRev[eTypeEnv].GetAt(nIndex);
		}
		else
		{
			if(nIndex<0 || nIndex > m_pArrConcFoot[eTypeEnv].GetSize()-1) return NULL;
			else
				pData = m_pArrConcFoot[eTypeEnv].GetAt(nIndex);
		}
	}
	
	return pData;
}

// CConcBasic* CRcBridgeRebar::GetConcDataFooting_Lsd(HGINT32 ix, CString *pstrType/*=NULL*/)
// {
// 	const HGINT32 icLimit = m_pArrConcFoot[eEnvLimit].GetSize();
// 	const HGINT32 icExtreme1 = m_pArrConcFoot[eEnvExtremeI].GetSize();
// 	const HGINT32 icExtreme2 = m_pArrConcFoot[eEnvExtremeII].GetSize();
// 
// 	std::vector<HGINT32> vecType;
// 	if (icLimit > 0)
// 		vecType.push_back(eEnvLimit);
// 
// 	if (icExtreme1 > 0)
// 		vecType.push_back(eEnvExtremeI);
// 
// 	if (icExtreme2 > 0)
// 		vecType.push_back(eEnvExtremeII);
// 
// 	HGINT32 ixItemTemp = ix;
// 	HGINT32 iMod = ixItemTemp % vecType.size();
// 
// 	HGINT32 ixItem = ixItemTemp / vecType.size();
// 
// 	CConcBasic *pData = m_pArrConcFoot[vecType.at(iMod)].GetAt(ixItem);
// 
// 	if (m_pARcBridgeDataStd->IsLsdDesign() && pstrType)
// 	{
// 		if (vecType.at(iMod) == eEnvLimit)
// 		{
// 			*pstrType = "극한";
// 		}
// 		else if (vecType.at(iMod) == eEnvExtremeI)
// 		{
// 			*pstrType = "극단I";
// 		}
// 		else if (vecType.at(iMod) == eEnvExtremeII)
// 		{
// 			*pstrType = "극단Ⅱ";
// 		}
// 	}
// 
// 	return pData;
// }

// bAllSection : TRUE - 전면,배면 모두 체크하는 경우
// bCheckMomnet : bAllSection 이 False일때 전면과 배면 중 모멘트가 있는것을 retun한다.
CConcBasic* CRcBridgeRebar::GetConcDataWall(long nJijum, long nPos, BOOL bAllSection, BOOL bCheckMomnet)
{
	CConcBasic *pData;
	long nIndex = GetIndexConcDataWall(nJijum, nPos, bAllSection);
	
	if(nIndex > m_pArrConcWall[eEnvLimit].GetSize()-1) return NULL;
	
	pData = m_pArrConcWall[eEnvLimit].GetAt(nIndex);

	// 모멘트를 확인해서 전면과 배면중에 모멘트가 있는것을 리턴한다.
	if(!bAllSection && bCheckMomnet && Compare(pData->m_Moment, 0.0, _T("="), 1.0))
	{
		BOOL bIsOutWall = (IsOutsideWall());
		BOOL bOutWall = (bIsOutWall && (nJijum==0 || nJijum==GetCountJijum()-1))? TRUE:FALSE;
		if(bOutWall && nPos != CHECK_POS_TOP)
		{
			nIndex -= 1;
		
			if(nIndex < m_pArrConcWall[eEnvLimit].GetSize())
			{
				pData = m_pArrConcWall[eEnvLimit].GetAt(nIndex);
			}
		}
	}
	return pData;
}

CConcBasic* CRcBridgeRebar::GetConcDataWall(long nIndex, BOOL bAllSection, ETypeEnvComboLsd eTypeEnv, BOOL bCheckMomnet)
{
	CConcBasic *pData;
	if(eTypeEnv == eEnvService_Crack)
		eTypeEnv = eEnvService;

	if(nIndex >= m_pArrConcWall[eTypeEnv].GetSize()) return NULL;

	if(bAllSection)
	{
		pData = m_pArrConcWall[eTypeEnv].GetAt(nIndex);
	}
	else
	{
		double nConvId = 0;
		if(nIndex == 0) nConvId = 0;
		else if(nIndex == 1) nConvId = 1;
		else if(nIndex == 2) nConvId = 4;
		else if(nIndex == 3) nConvId = 5;
		else if(nIndex == 4) nConvId = 6;
		else if(nIndex == 5) nConvId = 9;
		else nConvId = nIndex + 4;

		if(nConvId > m_pArrConcWall[eTypeEnv].GetSize()-1 || nConvId < 0) return NULL;

		pData = m_pArrConcWall[eTypeEnv].GetAt((INT_PTR)nConvId);

		// 모멘트를 확인해서 전면과 배면중에 모멘트가 있는것을 리턴한다.
		if(bCheckMomnet && Compare(pData->m_Moment, 0.0, _T("="), 1.0))
		{
			
			if(nIndex == 1 || nIndex == 4)
			{
				nConvId += 1;

				if(nIndex < m_pArrConcWall[eTypeEnv].GetSize())
				{
					pData = m_pArrConcWall[eTypeEnv].GetAt(nConvId);
				}
			}
		}
	}

	return pData;
}

CConcBasic* CRcBridgeRebar::GetConcDataInWall(long nIndex, BOOL bAllSection, ETypeEnvComboLsd eTypeEnv/*=eEnvLimit*/)
{
	CConcBasic *pData;

	if(eTypeEnv == eEnvService_Crack)
		eTypeEnv = eEnvService;

	if(nIndex > m_pArrConcInWall[eTypeEnv].GetSize()) return NULL;

	if(bAllSection)
	{
		pData = m_pArrConcInWall[eTypeEnv].GetAt(nIndex);
	}
	else
	{
		double nConvId = 0;
		if(nIndex == 0) nConvId = 0;
		else if(nIndex == 1) nConvId = 1;
		else if(nIndex == 2) nConvId = 4;
		else if(nIndex == 3) nConvId = 5;
		else if(nIndex == 4) nConvId = 6;
		else if(nIndex == 5) nConvId = 9;
		else nConvId = nIndex + 4;

		if(nConvId > m_pArrConcInWall[eTypeEnv].GetSize()-1 || nConvId < 0) return NULL;

		pData = m_pArrConcInWall[eTypeEnv].GetAt((INT_PTR)nConvId);
	}

	return pData;
}

CConcBasic* CRcBridgeRebar::GetConcDataWall_Lsd(HGINT32 ix, CString *pstrType/*=NULL*/, HGBOOL bAllSection/*=TRUE*/)
{
	const HGINT32 icLimit = m_pArrConcWall[eEnvLimit].GetSize();
	const HGINT32 icExtreme1 = m_pArrConcWall[eEnvExtremeI].GetSize();
	const HGINT32 icExtreme2 = m_pArrConcWall[eEnvExtremeII].GetSize();

	if(icLimit + icExtreme1 + icExtreme2 == 0)
		return NULL;

	std::vector<HGINT32> vecType;
	if (icLimit > 0)
		vecType.push_back(eEnvLimit);

	if (icExtreme1 > 0)
		vecType.push_back(eEnvExtremeI);

	if (icExtreme2 > 0)
		vecType.push_back(eEnvExtremeII);

	HGINT32 ixItemTemp = ix;
	if (bAllSection == FALSE)
	{
		// 전단철근 요약은 벽체는 상단부 중앙부 하단부로 표시되기 때문에 인덱스를 조정해준다.
		const HGINT32 icValidEnvType = GetCountValidComboEnvType();
		if (ix < 2 * icValidEnvType) // 시점 상단, 중앙
		{
			ixItemTemp = ix;
		}
		else if (ix < 3 * icValidEnvType) // 시점 하단
		{
			ixItemTemp = 4 * icValidEnvType + (ix - 2 * icValidEnvType);
		}
		else if (ix < 4 * icValidEnvType) // 종점 상단
		{
			ixItemTemp = 5 * icValidEnvType + ix - 3 * icValidEnvType;
		}
		else if (ix < 5 * icValidEnvType) // 종점 중앙
		{
			ixItemTemp = 6 * icValidEnvType + ix - 4 * icValidEnvType;
		}
		else if (ix < 6 * icValidEnvType) // 종점 하단
		{
			ixItemTemp = 9 * icValidEnvType + (ix - 5 * icValidEnvType);
		}
	}
		
	const HGINT32 iMod = ixItemTemp % vecType.size();
	const HGINT32 ixItem = ixItemTemp / vecType.size();

	CConcBasic *pData = NULL;
	if(ixItem < m_pArrConcWall[vecType.at(iMod)].GetSize())
	{
		pData = m_pArrConcWall[vecType.at(iMod)].GetAt(ixItem);
	}

	if (m_pARcBridgeDataStd->IsLsdDesign() && pstrType)
	{
		if (vecType.at(iMod) == eEnvLimit)
		{
			*pstrType = "극한";
		}
		else if (vecType.at(iMod) == eEnvExtremeI)
		{
			*pstrType = "극단I";
		}
		else if (vecType.at(iMod) == eEnvExtremeII)
		{
			*pstrType = "극단Ⅱ";
		}
	}	

	return pData;
}

CConcBasic* CRcBridgeRebar::GetConcDataInWall_Lsd(HGINT32 ix, CString *pstrType/*=NULL*/, HGBOOL bAllSection/*=TRUE*/)
{
	const HGINT32 icLimit = m_pArrConcInWall[eEnvLimit].GetSize();
	const HGINT32 icExtreme1 = m_pArrConcInWall[eEnvExtremeI].GetSize();
	const HGINT32 icExtreme2 = m_pArrConcInWall[eEnvExtremeII].GetSize();

	std::vector<HGINT32> vecType;
	if (icLimit > 0)
		vecType.push_back(eEnvLimit);

	if (icExtreme1 > 0)
		vecType.push_back(eEnvExtremeI);

	if (icExtreme2 > 0)
		vecType.push_back(eEnvExtremeII);

	HGINT32 ixItemTemp = ix;
	HGINT32 iMod = ixItemTemp % vecType.size();

	HGINT32 ixItem = ixItemTemp / vecType.size();

	CConcBasic *pData = m_pArrConcInWall[vecType.at(iMod)].GetAt(ixItem);

	if (m_pARcBridgeDataStd->IsLsdDesign() && pstrType)
	{
		if (vecType.at(iMod) == eEnvLimit)
		{
			*pstrType = "극한";
		}
		else if (vecType.at(iMod) == eEnvExtremeI)
		{
			*pstrType = "극단I";
		}
		else if (vecType.at(iMod) == eEnvExtremeII)
		{
			*pstrType = "극단Ⅱ";
		}
	}	

	return pData;
}

CConcBasic* CRcBridgeRebar::GetConcDataSlab(long nJigan, long nPos, BOOL bUpperSlab)
{
	CConcBasic *pData;
	long nIndex = 0;
	
	nIndex = nJigan*2+nPos;
	if(bUpperSlab == FALSE)
		nIndex += (m_nQtyJigan*2 + 1);
	
	if(nIndex > m_pArrConcSlab[eEnvLimit].GetSize()-1) return NULL;
	
	pData = m_pArrConcSlab[eEnvLimit].GetAt(nIndex);
	return pData;
}

CConcBasic* CRcBridgeRebar::GetConcDataPRF( BOOL bStt )
{
	long nIdx = bStt ? 0 : 1;

	return m_pArrConcPRF[eEnvLimit].GetAt(nIdx);
}

CConcBasic* CRcBridgeRebar::GetConcDataSlab_Lsd(HGINT32 ix, CString *pstrType/*=NULL*/)
{
	const HGINT32 icLimit = m_pArrConcSlab[eEnvLimit].GetSize();
	const HGINT32 icExtreme1 = m_pArrConcSlab[eEnvExtremeI].GetSize();
	const HGINT32 icExtreme2 = m_pArrConcSlab[eEnvExtremeII].GetSize();

	std::vector<HGINT32> vecType;
	if (icLimit > 0)
		vecType.push_back(eEnvLimit);

	if (icExtreme1 > 0)
		vecType.push_back(eEnvExtremeI);

	if (icExtreme2 > 0)
		vecType.push_back(eEnvExtremeII);

	HGINT32 ixItemTemp = ix;
	HGINT32 iMod = ixItemTemp % vecType.size();

	HGINT32 ixItem = ixItemTemp / vecType.size();

	CConcBasic *pData = m_pArrConcSlab[vecType.at(iMod)].GetAt(ixItem);

	if (m_pARcBridgeDataStd->IsLsdDesign() && pstrType)
	{
		if (vecType.at(iMod) == eEnvLimit)
		{
			*pstrType = "극한";
		}
		else if (vecType.at(iMod) == eEnvExtremeI)
		{
			*pstrType = "극단I";
		}
		else if (vecType.at(iMod) == eEnvExtremeII)
		{
			*pstrType = "극단Ⅱ";
		}
	}

	return pData;
}

CConcBasic* CRcBridgeRebar::GetConcDataPRF_Lsd( HGINT32 ix, CString *pstrType/*=NULL*/ )
{
	const HGINT32 icLimit = m_pArrConcPRF[eEnvLimit].GetSize();
	const HGINT32 icExtreme1 = m_pArrConcPRF[eEnvExtremeI].GetSize();
	const HGINT32 icExtreme2 = m_pArrConcPRF[eEnvExtremeII].GetSize();

	std::vector<HGINT32> vecType;
	if (icLimit > 0)
		vecType.push_back(eEnvLimit);

	if (icExtreme1 > 0)
		vecType.push_back(eEnvExtremeI);

	if (icExtreme2 > 0)
		vecType.push_back(eEnvExtremeII);

	HGINT32 ixItemTemp = ix;
	HGINT32 iMod = ixItemTemp % vecType.size();

	HGINT32 ixItem = ixItemTemp / vecType.size();

	CConcBasic *pData = m_pArrConcPRF[vecType.at(iMod)].GetAt(ixItem);

	if (m_pARcBridgeDataStd->IsLsdDesign() && pstrType)
	{
		if (vecType.at(iMod) == eEnvLimit)
		{
			*pstrType = "극한";
		}
		else if (vecType.at(iMod) == eEnvExtremeI)
		{
			*pstrType = "극단I";
		}
		else if (vecType.at(iMod) == eEnvExtremeII)
		{
			*pstrType = "극단Ⅱ";
		}
	}

	return pData;
}

// 거더 전단철근 횡단면도
// 기둥식일땐 기둥 사이간격이 같도록 배근하고
// 일반적인경우 첨부터 끝까지 같은 간격으로 배근함.
void CRcBridgeRebar::GetTvRebarShear_CrossSection_UpperSlabGirder(CTwinVectorArray &tvArr, long nJ, BOOL bStt, BOOL bLeft, BOOL bGagak, BOOL bJongGirder, BOOL bUpperSlabGirder)
{
	tvArr.RemoveAll();
	if(!bJongGirder)
	{
		if(!IsGirderRebar(nJ, bUpperSlabGirder)) return;
	}
	else
	{
		if(!IsGirderRebarJong(bStt, bLeft, bGagak)) return;
	}

	CGirderSectionRebar *pGirder	= bJongGirder ? GetGirderRebarJong(bStt, bLeft, bGagak) : &m_SlabGirderRebar[bUpperSlabGirder ? iUPPER : iLOWER][nJ];

	// 상부슬래브를 기준으로 함.
	// 단, 기둥식일 경우 기둥과 기둥 사이를 각각 따로 배근함.
	CTwinVectorArray tvArrPathCross;

	CTwinVector tv;
	double dCTC	= pGirder->m_dCTC;
	CTwinVectorArray tvArrTmp;
	CTwinVectorArray tvArrCross;
	CTwinVectorArray tvArrUpperCross, tvArrLowerCross, tvArrHunchCross;
	GetTvRebarSupport_CrossSection_UpperSlab(tvArrUpperCross, tvArrTmp, tvArrTmp, GetStationOnJijum(nJ, 0), TRUE, 0, 0, FALSE, FALSE, FALSE, 1);
	GetTvRebarSupport_CrossSection_UpperSlab(tvArrLowerCross, tvArrTmp, tvArrTmp, GetStationOnJijum(nJ, 0), FALSE, 0, 0, FALSE, FALSE, FALSE, 1);
	GetTvRebarSupport_CrossSection_UpperSlabHunch(tvArrHunchCross, GetStationOnJijum(nJ, 0), 0, 0, FALSE, FALSE, FALSE, 1);

	tv.m_v1	= tvArrUpperCross.GetXyLeft();
	tv.m_v2	= tvArrUpperCross.GetXyRight();
	tv.m_v2.y	= tv.m_v1.y;

	// 기둥사이를 각각 divide 하다가 그냥 한번에 다 밀어 버리는 걸로 변경
	// 2006년 10월 30일
	tvArrPathCross.Add(tv);

	// 배근되는 패스를 구하면 각각의 패스마다 배근함.ㅋㅋㅋㅋ
	CRebarPlacing rb;
	CDPointArray xyArr;
	BOOL bEndXy(TRUE);
	long nSize	= tvArrPathCross.GetSize();
	for(long path = 0; path < nSize; path++)
	{
		tv	= tvArrPathCross.GetAt(path);
		bEndXy	= (path < nSize-1) ? TRUE : FALSE;
		rb.GetXyDivideLine(xyArr, tv.m_v1, tv.m_v2, dCTC, TRUE, 100, FALSE, bEndXy);
	}

	// 배근위치 구하면 실제 배근함.
	double dHeight	= min(GetThickHunch(nJ, TRUE, TRUE), GetThickHunch(nJ, FALSE, TRUE)) + m_dTS;
	rb.MakePointArrayToLineArray(xyArr, tvArr, CDPoint(0, -1), dHeight, FALSE);

	// 배근 된 것들을 횡단면 윗면과 아랫면에 맞춤
	
		
	CDPointArray xyArrMatch;
	CTwinVector *pTv	= NULL;
	nSize	= tvArr.GetSize();
	long i = 0; for(i = 0; i < nSize; i++)
	{
		pTv	= &tvArr.GetAt(i);

		// 상면으로 뻗음
		rb.GetXyMatchTvArrAndLine(tvArrUpperCross, pTv->m_v1, CDPoint(0, 1), xyArrMatch);
		if(xyArrMatch.GetSize() > 0)
		{
			pTv->m_v1	= xyArrMatch.GetAt(0);
			pTv->m_v1.y -= (pGirder->m_dCoverUpper[0] - m_dCoverUpper_UpperSlab[0]);
		}

		// 헌치로 뻗었다가 없으면 하면으로 뻗음
		rb.GetXyMatchTvArrAndLine(tvArrHunchCross, pTv->m_v2, CDPoint(0, -1), xyArrMatch);
		if(xyArrMatch.GetSize() > 0)
		{
			pTv->m_v2	= xyArrMatch.GetAt(0);
			pTv->m_v2.y += (pGirder->m_dCoverLower[0] - m_dCoverLower_UpperSlab[0]);
		}
		else
		{
			rb.GetXyMatchTvArrAndLine(tvArrLowerCross, pTv->m_v2, CDPoint(0, -1), xyArrMatch);
			if(xyArrMatch.GetSize() > 0)
			{
				pTv->m_v2	= xyArrMatch.GetAt(0);
				pTv->m_v2.y += (pGirder->m_dCoverLower[0] - m_dCoverLower_UpperSlab[0]);
			}
		}
	}
}

// 하부거더 전단철근 횡단면도
void CRcBridgeRebar::GetTvRebarShear_CrossSection_LowerSlabGirder(CTwinVectorArray &tvArr, long nJ, double dStation, long nDrawLeft, BOOL bStt, BOOL bLeft, BOOL bGagak, BOOL bJongGirder)
{
	tvArr.RemoveAll();
	if(!bJongGirder)
	{
		if(!IsGirderRebar(nJ, FALSE)) return;
	}
	else
	{
		if(!IsGirderRebarJong(bStt, bLeft, bGagak)) return;
	}

	CGirderSectionRebar *pGirder	= bJongGirder ? GetGirderRebarJong(bStt, bLeft, bGagak) : &m_SlabGirderRebar[iLOWER][nJ];
	CTwinVectorArray tvArrPathCross, tvArrLowerBox;
	CTwinVector tv;
	CDPoint vAng = GetAngleJijum(nJ);
	double dCTC	= pGirder->m_dCTC;
	
	//하부슬래브 횡단 네모지기를 가져온다.
	GetTv_CrossSection_LowerSlab(tvArrLowerBox, nJ, dStation, vAng, nDrawLeft);
	tv.m_v1 = tvArrLowerBox.GetXyLeft();
	tv.m_v2 = tvArrLowerBox.GetXyRight();
	tv.m_v1.y = tv.m_v2.y = tvArrLowerBox.GetXyBottom().y;
	tvArrPathCross.Add(tv);

	CRebarPlacing rb;
	CDPointArray xyArr;
	BOOL bEndXy(TRUE);
	long nSize	= tvArrPathCross.GetSize();
	for(long path = 0; path < nSize; path++)
	{
		tv	= tvArrPathCross.GetAt(path);
		bEndXy	= (path < nSize-1) ? TRUE : FALSE;
		rb.GetXyDivideLine(xyArr, tv.m_v1, tv.m_v2, dCTC, TRUE, 100, FALSE, bEndXy);
	}

	// 나눠진 xy좌표를 라인으로 만든다.
	double dHeight	= GetThickHunch(nJ, FALSE, TRUE, FALSE) + m_dTS_Lower;
	rb.MakePointArrayToLineArray(xyArr, tvArr, CDPoint(0, 1), dHeight, FALSE);

	//피복만큼 y값 조정.
	CDPointArray xyArrMatch;
	CTwinVector *pTv	= NULL;
	nSize	= tvArr.GetSize();
	long i = 0; for(i = 0; i < nSize; i++)
	{
		pTv	= &tvArr.GetAt(i);
		pTv->m_v1.y += pGirder->m_dCoverUpper[0];
		pTv->m_v2.y -= pGirder->m_dCoverLower[0];
	}
}

void CRcBridgeRebar::GetTvRebarSupport_CrossSection_UpperSlabGirder(CTwinVectorArray &tvArr, long nJ)
{
	tvArr.RemoveAll();
	if(!IsGirderRebar(nJ, TRUE)) return;

	CGirderSectionRebar *pGirder	= &m_SlabGirderRebar[iUPPER][nJ];
	CRebarPlacing rb;

	// 상부슬래브를 기준으로 함.
	CTwinVector tv;
	
	CTwinVectorArray tvArrLeftLimit;
	CTwinVectorArray tvArrRightLimit;

	CTwinVectorArray tvArrCrossHunch;
	CTwinVectorArray tvArrCrossLower;
	CTwinVectorArray tvArrTmp;
	
	// 상부 슬래브
	GetTvRebarSupport_CrossSection_UpperSlab(tvArrCrossLower, tvArrTmp, tvArrTmp, GetStationOnJijum(nJ, 0), FALSE, 0, 0, FALSE, FALSE, TRUE, 1);
	
	// 헌치
	GetTvRebarSupport_CrossSection_UpperSlabHunch(tvArrCrossHunch, GetStationOnJijum(nJ, 0), 0, 0, FALSE, TRUE, FALSE, 1);

	// 철근 잘라낼 좌우측 기준 구함.
	CString sLeft	= nJ == 0 ? "우측" : "좌측";
	CString sRight	= nJ == 0 ? "좌측" : "우측";
	long i = 0; for(i = 0; i < tvArrCrossLower.GetSize(); i++)
	{
		tv	= tvArrCrossLower.GetAt(i);
		if(tv.m_sInfo.Find(sRight, 0) != -1) tvArrRightLimit.Add(tv);
		else if(tv.m_sInfo.Find(sLeft, 0) != -1) tvArrLeftLimit.Add(tv);
	}
	if(tvArrCrossHunch.GetTvByInfo("슬래브헌치"+sRight, tv)) tvArrRightLimit.Add(tv);
	if(tvArrCrossHunch.GetTvByInfo("슬래브헌치"+sLeft, tv)) tvArrLeftLimit.Add(tv);



	// 거더 밑에서 위로 감.
	// 시작 위치
	double dHeightHunch	= min(GetThickHunch(nJ, TRUE, TRUE), GetThickHunch(nJ, FALSE, TRUE)) + m_dTS;
	long nIdx	= 0;

	CTwinVectorArray tvArrCrossUpper;
	GetTvCrossSection(tvArrCrossUpper, GetStationOnJijum(nJ, 0), GetAngleJijum(nJ), FALSE, FALSE, FALSE, 0, FALSE, FALSE, FALSE, TRUE);
	rb.MoveRebar(tvArrCrossUpper, CDPoint(0, -(dHeightHunch-pGirder->m_dCoverLower[0])));
	CDoubleArray dArrDist;
	double dHeightTot	= 0;
	dArrDist.Add(pGirder->m_dF1);
	dHeightTot += pGirder->m_dF1;
	for(i = 0; i < pGirder->m_nE; i++)
	{
		dArrDist.Add(pGirder->m_dF);
		dHeightTot += pGirder->m_dF;
	}
	dArrDist.Add(pGirder->m_dF2);
	dHeightTot += pGirder->m_dF2;

	// 상면 철근도 포함해주자.
	double dDistRemain	= dHeightHunch-pGirder->m_dCoverLower[0]-pGirder->m_dCoverUpper[0]-dHeightTot;
	dArrDist.Add(dDistRemain);


	// 배력철근은 전단철근까지만 뻗도록 해야 된다.
	CTwinVectorArray tvArrShearCross;
	CTwinVector	tvShear;
	GetTvRebarShear_CrossSection_UpperSlabGirder(tvArrShearCross, nJ);
	CDPointArray xyArrMatch;

	CTwinVector tvTmp;
//	double dDist	= 0;
	for(i = -1; i < dArrDist.GetSize(); i++)
	{
		double dDist	= i == -1 ? 0 : dArrDist.GetAt(i);

		rb.MoveRebar(tvArrCrossUpper, CDPoint(0, dDist));

		// 철근의 info를 변경후 tmp에 추가
		tvArrTmp.RemoveAll();
		long j = 0; for(j = 0; j < tvArrCrossUpper.GetSize(); j++)
		{
			tv	= tvArrCrossUpper.GetAt(j);
			tv.m_sInfo.Format("거더배력철근%d", nIdx+1);
			tvArrTmp.Add(tv);
		}

		// 필요한 영역에꺼만 살려냄./////////
		CDPointArray xyArrMatch;
		CDPoint xyMatch(0, 0);
		// 좌측 검사
		for(j = 0; j < tvArrLeftLimit.GetSize(); j++)
		{
			tv	= tvArrLeftLimit.GetAt(j);
			rb.GetXyMatchTvArrAndTv(tvArrTmp, tv, xyArrMatch, TRUE);
			if(xyArrMatch.GetSize() > 0)
			{
				xyMatch	= xyArrMatch.GetAt(0);
				for(long k = 0; k < tvArrTmp.GetSize(); k++)
				{
					tv	= tvArrTmp.GetAt(k);
					
					if(Compare(tv.GetXyLeft().x, xyMatch.x, "<=") && Compare(tv.GetXyRight().x, xyMatch.x, ">="))
					{
						tv.m_v1	= xyMatch;
						tvArrTmp.SetAt(k, tv);
					}
					else if(Compare(tv.GetXyRight().x, xyMatch.x, "<"))
					{
						tvArrTmp.RemoveAt(k);
						k--;
					}
				}

				break;
			}
		}

		// 우측 검사
		for(j = 0; j < tvArrRightLimit.GetSize(); j++)
		{
			tv	= tvArrRightLimit.GetAt(j);
			rb.GetXyMatchTvArrAndTv(tvArrTmp, tv, xyArrMatch, TRUE);
			if(xyArrMatch.GetSize() > 0)
			{
				xyMatch	= xyArrMatch.GetAt(0);
				for(long k = 0; k < tvArrTmp.GetSize(); k++)
				{
					tv	= tvArrTmp.GetAt(k);
					
					if(Compare(tv.GetXyLeft().x, xyMatch.x, "<=") && Compare(tv.GetXyRight().x, xyMatch.x, ">="))
					{
						tv.m_v2	= xyMatch;
						tvArrTmp.SetAt(k, tv);
					}
					else if(Compare(tv.GetXyLeft().x, xyMatch.x, ">"))
					{
						tvArrTmp.RemoveAt(k);
						k--;
					}
				}

				break;
			}
		}
		/////////////////////////////////////

		tvArr.AddFromTvArray(tvArrTmp);
		nIdx++;
	}

}

//하부슬래브 거더 수평전단철근
void CRcBridgeRebar::GetTvRebarSupport_CrossSection_LowerSlabGirder(CTwinVectorArray &tvArr, long nJ, double dStation, CDPoint vAng, long nDrawLeft)
{
	tvArr.RemoveAll();
	if(!IsGirderRebar(nJ, FALSE)) return;

	CGirderSectionRebar *pGirder	= &m_SlabGirderRebar[iLOWER][nJ];
	CRebarPlacing rb;
	CLineInfo *pLine	= GetLineBase();

	//시작위치(상단)
//	long nJijum = GetJijumNumberByStation(dStation);
	double dDistLeft = GetDisSlabLeftActByGagak(dStation, vAng);
	double dDistRight = GetDisSlabRighActByGagak(dStation, vAng);
	double dEl_Plan = pLine->GetElevationPlanEl(dStation);
	double dEL_Foot = dEl_Plan - GetThickPave() - GetHeightBridgeBox(dStation) + m_dTS_Lower;

	CDPoint xy1(dDistLeft, dEL_Foot), xy2(dDistRight, dEL_Foot);
	if(nDrawLeft == -1)
	{
		xy2.x = (dDistLeft + dDistRight) / 2.;
	}
	if(nDrawLeft == 1)
	{
		xy1.x = (dDistLeft + dDistRight) / 2.;
	}

	//하부슬래브 하면 시작점 끝점. 
	CDPoint xyStt(0, 0), xyEnd(0,0);
	xyStt.x = xy1.x + pGirder->m_dCoverSide;
	xyStt.y = xy1.y - m_dTS_Lower + pGirder->m_dC2[iLOWER][0];
	xyEnd.x = xy2.x - pGirder->m_dCoverSide;
	xyEnd.y = xy2.y - m_dTS_Lower + pGirder->m_dC2[iLOWER][0];

	CTwinVector tv;
	tv.m_v1 = xyStt;
	tv.m_v2 = xyEnd;
	tvArr.Add(tv);
	
	//F1
	tv.m_v1.y += pGirder->m_dF1;
	tv.m_v2.y += pGirder->m_dF1;
	tvArr.Add(tv);

	//E@F
	for(long ix = 0; ix < pGirder->m_nE; ix ++)
	{
		tv.m_v1.y += pGirder->m_dF;
		tv.m_v2.y += pGirder->m_dF;
		tvArr.Add(tv);
	}

	//F2
	tv.m_v1.y += pGirder->m_dF2;
	tv.m_v2.y += pGirder->m_dF2;
	tvArr.Add(tv);
}
// 가각부에 대한 주철근 배근
// tvArrCycle1과 tvArrCycle2가 분리 되어 있는 이유는
// 실제로 가각부는 사이클구분이 없으나 길이가 다른 두가지 철근이 들어갈 수 있어서 
// 일부러 사이클처럼 해 놓음
// 철근은 무조건 직선으로 들어가며 철근 각도는 R없는 상태에서의 가각부 각도로 향함.
// 철근배치는 바깥쪽에서 안쪽으로 배치하며, 철근 길이의 기준은 바깥쪽 첫번째 철근을 기준으로 한다.
// nTypeMainRebarOfExp	: 배치타입(0 : 좌우측 기준, 1 : 시종점기준)
// tvArrCycle1과 2에 하부일때는 헌치철근도 같이 들어감.
// BOOL bJongGirder : 종거더인지?
// CDPointArray &xyArrCycle1, CDPointArray &xyArrCycle2 : 가각 내측 철근들
// 헌치부 가각 철근은 선형방향 배치가 적용되지 않음
void CRcBridgeRebar::GetTvRebarMain_Plane_Slab_Exp(BOOL bUpperSlab, CTwinVectorArrayArray *pTvArrCycle1, CTwinVectorArrayArray *pTvArrCycle2, CTwinVectorArrayArray *pTvArrCycle12, CTwinVectorArrayArray *pTvArrCycle22, BOOL bStt, BOOL bLeft, long nDan, BOOL bUpper, CTwinVectorArray &tvArrCycleHunch1, CTwinVectorArray &tvArrCycleHunch2, BOOL bJongGirder, CDPointArray &xyArrCycle1, CDPointArray &xyArrCycle2, CDPointArray &xyArrDimPoint)
{
	AhTPADelete(pTvArrCycle1, (CTwinVectorArray*)0);
	AhTPADelete(pTvArrCycle2, (CTwinVectorArray*)0);
	AhTPADelete(pTvArrCycle12, (CTwinVectorArray*)0);
	AhTPADelete(pTvArrCycle22, (CTwinVectorArray*)0);
	
	if(!IsGagakForLine(bStt, bLeft)) return;

	long stt	= bStt ? iSTT : iEND;
	long left	= bLeft ? iLEFT : iRIGHT;

	// 현재 곡선 철근에 주철근 기준은 지원하지 않음(모양이 너무 이상해서 이차장님과 더 상의 한 후 풀 예정)
	//if(m_nTypeRebarMainRebarOfExp[stt][left] == 1 && m_nTypeOrgMainRebarOfExp[stt][left] == 0)
	//	m_nTypeOrgMainRebarOfExp[stt][left]	= 1;
	AhTPADelete(pTvArrCycle1, (CTwinVectorArray*)0);
	AhTPADelete(pTvArrCycle2, (CTwinVectorArray*)0);
	AhTPADelete(pTvArrCycle12, (CTwinVectorArray*)0);
	AhTPADelete(pTvArrCycle22, (CTwinVectorArray*)0);
	
	tvArrCycleHunch1.RemoveAll();
	tvArrCycleHunch2.RemoveAll();
	xyArrCycle1.RemoveAll();
	xyArrCycle2.RemoveAll();
	xyArrDimPoint.RemoveAll();
	if(nDan >= GetDanMainRebarUpperSlabExp(0, bUpper, bStt)) return;
	if(!m_bIsExp) return;

	// 주철근 배치의 기준이 되는 시종점부 가각부 위치 가져옴
	CTwinVector tvExpRebar;
	CTwinVectorArray tvArrStt, tvArrSttExp;
	// 가각에 철근배치 할때는 끝단 없는 형태의 평면을 구해야 하나
	// 다음과 같은 경우 ModifyPlaneForGagakRebarmain에서 철근배치를 위해 특별히 평면을 수정하므로
	// 끝단 있는 걸로 해야 함
	BOOL bCutEnd	= TRUE;
	if(bStt)
	{
		if(Compare(m_dExpSttR[bLeft ? 0 : 1], 0.0, "<=")) bCutEnd	= FALSE;
		if(m_bExpSttRoundIsTan[bLeft ? 0 : 1]) bCutEnd	= FALSE;
		if(!m_bExpCutStt[bLeft ? 0 : 1]) bCutEnd	= FALSE;
	}
	else
	{
		if(Compare(m_dExpEndR[bLeft ? 0 : 1], 0.0, "<=")) bCutEnd	= FALSE;
		if(m_bExpEndRoundIsTan[bLeft ? 0 : 1]) bCutEnd	= FALSE;
		if(!m_bExpCutEnd[bLeft ? 0 : 1]) bCutEnd	= FALSE;
	}
	for(long e = 0; e < 2; e++)
	{
		CTwinVectorArray *pTvArr	= e == 0 ? &tvArrStt : &tvArrSttExp;

		CTwinVectorArray tvArrPlane;
		GetTvRebarOut_Plane_UpperSlabStd(tvArrPlane, 0, e==0 ? FALSE:TRUE, 2, TRUE, bCutEnd);
		ModifyPlaneForGagakRebarMain(tvArrPlane);
		CString str	= bStt ? "시점" : "종점";
		CTwinVector tv;
		long i = 0; for(i = 0; i < tvArrPlane.GetSize(); i++)
		{
			tv	= tvArrPlane.GetAt(i);
			if(tv.m_sInfo == str)
				pTvArr->Add(tv);
		}
	}

	if(tvArrStt.GetSize() == 0 || tvArrSttExp.GetSize() == 0) return;

	CTwinVector tvStt, tvSttExp;
	tvStt.m_v1	= tvArrStt.GetAt(0).m_v1;
	tvStt.m_v2	= tvArrStt.GetAt(tvArrStt.GetSize()-1).m_v2;
	tvSttExp.m_v1	= tvArrSttExp.GetAt(0).m_v1;
	tvSttExp.m_v2	= tvArrSttExp.GetAt(tvArrSttExp.GetSize()-1).m_v2;
	
	tvSttExp.m_v1.z	= 0;
	tvSttExp.m_v2.z	= 0;

	if(IsOutWall(bStt))
	{
		GetXyMatchLineAndLine(tvStt.m_v1, tvStt.GetXyDir().Rotate90(), tvSttExp.m_v1, tvSttExp.GetXyDir(), tvStt.m_v1);
		GetXyMatchLineAndLine(tvStt.m_v2, tvStt.GetXyDir().Rotate90(), tvSttExp.m_v1, tvSttExp.GetXyDir(), tvStt.m_v2);
	}

	if(bLeft)
	{
		tvExpRebar.m_v1	= bStt ? tvSttExp.m_v2 : tvSttExp.m_v1;
		tvExpRebar.m_v2	= bStt ? tvStt.m_v2 : tvStt.m_v1;
	}
	else
	{
		tvExpRebar.m_v1	= !bStt ? tvSttExp.m_v2 : tvSttExp.m_v1;
		tvExpRebar.m_v2	= !bStt ? tvStt.m_v2 : tvStt.m_v1;
	}

	// (ARCBRIDGE-2819) 주철근 배치 구간과 겹친다고 해도 가각 철근은 무조건 넣는다.
	double dDiff	= GetDiffLeftRightDistForGagakSabogang(bStt, bLeft);
	if(FALSE) //if(dDiff > 0)
	{
		tvExpRebar.m_v2	= tvExpRebar.m_v2 + tvExpRebar.GetXyDir(TRUE) * dDiff;
	}

	// 단 슬래브 둔각부이고, 가각 예각부인경우 //////////////////////////////////////////////////
	// 철근이 가각의 끝부분에서 직방향으로 시(종)점으로 뻗은 교차점 까지 배근함
	// 단 가각의 끝부분이 좌우측 슬래브의 가운데 sta를 넘어선 곳이면 그냥 가운데 sta에서 뻗어서 교차점을 찾는다.
	if(IsObtuseEdgeOfSlab(bStt, bLeft) && !IsObtuseEdgeOfGagak(bStt, bLeft))
	{
		// R이 없어야 정상적으로 적용됨
		if((bStt && m_dExpSttR[bLeft ? 0 : 1] == 0) || (!bStt && m_dExpEndR[bLeft ? 0 : 1] == 0))
		{
			CDPoint vAng	= GetAngleAzimuthJijum(0);
			vAng	= vAng.Rotate90();

			// 가각에 R이 없게 한 뒤에 작업함.
			CTwinVectorArray tvArrExp;
			GetTvPlaneOfExp(tvArrExp, bStt, bLeft, 0);
			if(tvArrExp.GetSize() > 0)
			{
				CDPoint xyEndOfGagak(0, 0);
				if((bStt && bLeft) || (!bStt && !bLeft))
				{
					xyEndOfGagak	= tvArrExp.GetAt(tvArrExp.GetSize()-1).m_v2;
				}
				else
				{
					xyEndOfGagak	= tvArrExp.GetAt(0).m_v1;
					
				}
				
				// 단 가각의 끝부분이 좌우측 슬래브의 가운데 sta를 넘어선 곳이면 그냥 가운데 sta에서 뻗어서 교차점을 찾는다.
				double dStaStt	= GetStationByTarget(BRIDGE_OFF_STT_SLAB, -1, TRUE);
				double dStaEnd	= GetStationByTarget(BRIDGE_OFF_END_SLAB, 1, TRUE);
				CDPoint xyStt	= GetXySlabEdgeAct(dStaStt, GetAngleJijum(0), bLeft);
				CDPoint xyEnd	= GetXySlabEdgeAct(dStaEnd, GetAngleJijum(m_nQtyJigan), bLeft);

				// 좌우측  선형 기준 sta값으로 변환
				CLineInfo *pLine	= GetLineLeftRight(bLeft);
				pLine->GetStationMatchVerticalByXy(xyStt, dStaStt);
				pLine->GetStationMatchVerticalByXy(xyEnd, dStaEnd);
				double dStaMid	= dStaStt + (dStaEnd - dStaStt)/2;
				double dStaEndOfGagak	= dStaMid;

				pLine->GetStationMatchVerticalByXy(xyEndOfGagak, dStaEndOfGagak);
				if((bStt && (dStaMid < dStaEndOfGagak)) || (!bStt && (dStaMid > dStaEndOfGagak)))
				{
					double dDist	= pLine->GetDisMatchVerticalByXy(xyEndOfGagak);
					xyEndOfGagak	= pLine->GetXyLineDis(dStaMid, dDist);
				}

				GetXyMatchLineAndLine(xyEndOfGagak, vAng, tvExpRebar.m_v1, tvExpRebar.GetXyDir(), tvExpRebar.m_v2);
			}
		}
	}
	////////////////////////////////////////////////////////////////////////////////////
	

	// 배치할 위치를 CTC에 맞게 나눔
	CRebarPlacing rb;
	CDPointArray xyArrRebarExp;
	CDPointArray xyArrRebarExpHunch;
	CDPointArray xyArrRebarExpOld;
	if(bJongGirder)
	{
		if(!IsGirderRebarJong(bStt, bLeft, TRUE)) return;

		CGirderSectionRebar *pGirderRB	= GetGirderRebarJong(bStt, bLeft, TRUE);
		if(!pGirderRB) return;

		//CDPoint vAng	= bStt ? GetAngleByTarget(BRIDGE_OFF_STT_SLAB, 0) : GetAngleByTarget(BRIDGE_OFF_END_SLAB, 0);
		CTwinVector tvJijum	= GetTvJijum(bStt ? 0 : m_nQtyJigan, 0);
		CDPoint vAngExp	= GetXyDirExpForRebar(bStt, bLeft);
		CDPoint vAng	= ToDPointFrDegree(tvJijum.GetXyDir().GetAngleDegree() - vAngExp.GetAngleDegree());

		double dDist	= pGirderRB->m_dDist / fabs(vAng.y);
		double dC1		= pGirderRB->m_dC1[iUPPER][0] / fabs(vAng.y);
		long nB			= pGirderRB->m_nB[iUPPER][0];
		double dC		= pGirderRB->m_dC[iUPPER][0] / fabs(vAng.y);
		double dC2		= pGirderRB->m_dC2[iUPPER][0] / fabs(vAng.y);


		CDPoint xy	= tvExpRebar.m_v1 + tvExpRebar.GetXyDir() * dDist;
		xyArrRebarExp.Add(xy);
		if(dC1 > 0)
		{
			xy += tvExpRebar.GetXyDir() * dC1;
			xyArrRebarExp.Add(xy);
		}
		long i = 0; for(i = 0; i < nB; i++)
		{
			xy += tvExpRebar.GetXyDir() * dC;
			xyArrRebarExp.Add(xy);
		}

		if(dC2 > 0)
		{
			xy += tvExpRebar.GetXyDir() * dC2;
			xyArrRebarExp.Add(xy);
		}
	}
	else
	{
		if(!IsNeedGagakRebar(bStt, bLeft))
		{
			double dDist	= bLeft ? m_dDistLeftDirPlacing : m_dDistRightDirPlacing;
			tvExpRebar.m_v2	= tvExpRebar.m_v2 + dDist * tvExpRebar.GetXyDir(TRUE);

			//#0031514 가각부시 왼쪽, 오른쪽방향에서 tvExpRebar의 값이 잘못 계산되어져 철근이 생성이 안됨
			if(bLeft == FALSE) tvExpRebar.m_v2	= tvExpRebar.m_v1 - dDist * tvExpRebar.GetXyDir(TRUE);
		}

		double dCTC	= GetCtcRebarMain(TRUE)/2/GetAngleJijum(0).y;
		
		if(Compare(tvExpRebar.GetLength(), dCTC, "<=")) return;
			rb.GetXyDivideLine(xyArrRebarExp, tvExpRebar.m_v1, tvExpRebar.m_v2, dCTC, FALSE, 100, TRUE, FALSE);
		xyArrRebarExpOld	= xyArrRebarExp;
		xyArrRebarExpHunch	= xyArrRebarExp;

		// 선형방향배치일 때는 보강철근을 입력된 개수 만큼만 만든다
		if(m_bLineDirRebarOfExp[stt][left])
		{
			CDPointArray xyArrTmp;
			if(m_nCountSupportRebarOfExpAtLineDirRebar[stt][left] < 1)
				m_nCountSupportRebarOfExpAtLineDirRebar[stt][left]	= 1;

			long i = 0; for(i = 0; i < m_nCountSupportRebarOfExpAtLineDirRebar[stt][left]; i++)
			{
				if(xyArrRebarExp.GetSize() <= i) break;
				xyArrTmp.Add(xyArrRebarExp.GetAt(i));
			}
			xyArrRebarExp	= xyArrTmp;
		}

		// 헌치 철근은 헌치부에만 들어간다.
		double dLenL	= (m_dDH[0] + m_dCantilB[0]);
		double dLenR	= (m_dDH[1] + m_dCantilB[1]);
		long nCountEraseLeft	= (long)(dLenL > 0 ? dLenL / (m_dCTC_MainRebar/2) : 0);
		long nCountEraseRight	= (long)(dLenR > 0 ? dLenR / (m_dCTC_MainRebar/2) : 0);
		if(xyArrRebarExpHunch.GetSize() > nCountEraseLeft)
		{
			xyArrRebarExpHunch.RemoveAt(0, nCountEraseLeft);
		}
		if(xyArrRebarExpHunch.GetSize() > nCountEraseRight)
		{
			xyArrRebarExpHunch.RemoveAt(xyArrRebarExpHunch.GetSize()-nCountEraseRight, nCountEraseRight);
		}
	}

	if(xyArrRebarExp.GetSize() == 0)
		return;

	// 배치되어야 되는 철근의 각도(첫번째 철근이 됨)
	CTwinVectorArray tvArrPlaneSide, tvArrPlane;
	GetTvRebarOut_Plane_UpperSlabStd(tvArrPlane, 0, FALSE);
	CString sInfo	= bLeft ? "좌측" : "우측";
	CTwinVector tv;
	long i = 0; for(i = 0; i < tvArrPlane.GetSize(); i++)
	{
		tv	= tvArrPlane.GetAt(i);
		if(tv.m_sInfo == sInfo)
			tvArrPlaneSide.Add(tv);
	}

	// 철근 배치시 뻗어 나가는 기준 ////
	CTwinVectorArray tvArrOrg;
	GetTvMainRebarOrgOfExp(tvArrOrg, bStt, bLeft);
	// 철근 배치시 뻗어 나가는 기준 ////

	double dLenExt		= m_dLenMainRebarOfExp[stt][left];
	CDPoint xyDirRebar	= GetXyDirExpForRebar(bStt, bLeft);
	CDPoint xyStt		= xyArrRebarExp.GetAt(0);
	CDPoint xyEnd		= xyStt;
	CDPointArray xyArrMatch;
		
	tv.m_v1.z = tv.m_v2.z = 0;

	// 헌치 철근도 같이 구한다.
	CRebarInfoCycle *pRCHunch1	= NULL;
	CRebarInfoCycle *pRCHunch2	= NULL;
	if((bUpper != bUpperSlab) && !bJongGirder)
	{
		long nJ	= bStt ? 0 : m_nQtyJigan;
		long cycle = 0; for(cycle = 0; cycle < 2; cycle++)
		{
			long nConut = bUpperSlab? m_pArrRCMainUpperSlabHunch[cycle].GetSize() : m_pArrRCMainLowerSlabHunch[cycle].GetSize();
			for(long rc = 0; rc < nConut; rc++)
			{
				CRebarInfoCycle *pRC	= bUpperSlab? m_pArrRCMainUpperSlabHunch[cycle].GetAt(rc) : m_pArrRCMainLowerSlabHunch[cycle].GetAt(rc);
				
				if(pRC->m_nPosHunch == nJ)
				{
					if(cycle == 0) pRCHunch1	= pRC;
					else if(cycle == 1) pRCHunch2	= pRC;
				}
			}
		}
	}

	
	// 헌치철근 방향과 기준선 ///////////
	CTwinVectorArray tvArrRebarHunch, tvArrRebarHunchL, tvArrRebarHunchR;
	double dStaHunch	= pRCHunch1 ? pRCHunch1->m_tvArrRebar.GetXyLeft().x+pRCHunch1->m_tvArrRebar.GetHorLength()/2 : 
						(pRCHunch2 ? (pRCHunch2->m_tvArrRebar.GetXyLeft().x+pRCHunch2->m_tvArrRebar.GetHorLength()/2) : m_dStationBridgeStt);
	GetTvRebarMain_Plane_SlabHunch(tvArrRebarHunch, tvArrRebarHunchL, tvArrRebarHunchR, pRCHunch1 ? 0 : 1, dStaHunch, 0, 0, bUpperSlab);
	CTwinVector tvRebarHunch;
	if(tvArrRebarHunch.GetSize() > 0) tvRebarHunch	= tvArrRebarHunch.GetAt(0);
	else if(tvArrRebarHunchL.GetSize() > 0) tvRebarHunch	= tvArrRebarHunchL.GetAt(0);
	else if(tvArrRebarHunchR.GetSize() > 0) tvRebarHunch	= tvArrRebarHunchR.GetAt(0);
	CDPoint xyOrgHunch	= bStt ? tvRebarHunch.m_v2 : tvRebarHunch.m_v1;
	CDPoint vAngOrgHunch	= GetAngleAzimuthJijum(bStt ? 0 : m_nQtyJigan);
	/////////////////////////////////////

	// 첫번재 철근과의 교차점에서 시종점 방향으로 뻗어서 교차점을 구하면서 확장길이만큼 뻗는다.
	CDPoint xyDirSttEnd	= tvStt.GetXyDir();
	CDPoint xyOrg	= xyEnd;
	CDPoint xyMatch(0, 0);
	
	CTwinVectorArray tvArrRebarExpEndCut;
	GetTvRebarOut_Plane_UpperSlabStd(tvArrPlane, 0, TRUE, bLeft ? iLEFT : iRIGHT, FALSE, TRUE);
	if(m_nTypeRebarMainRebarOfExp[stt][left] == 1 || m_bLineDirRebarOfExp[stt][left])
	{
		CString sInfo	= bLeft ? "좌측" : "우측";
		CString sSttOther	= !bStt ? "시점" : "종점";
		long i = 0; for(i = 0; i < tvArrPlane.GetSize(); i++)
		{
			tv	= tvArrPlane.GetAt(i);
			if(tv.m_sInfo.Find(sInfo, 0) != -1 && tv.m_sInfo.Find(sSttOther, 0) == -1)
				tvArrRebarExpEndCut.Add(tv);
		}
		rb.RemoveMinLengthLine(tvArrRebarExpEndCut, 0.0);
		rb.RemoveMeanlessTwinVector(tvArrRebarExpEndCut);
		tvArrRebarExpEndCut.Sort();
		if((!bStt && bLeft) || (bStt && !bLeft))
			rb.ReverseRebar(tvArrRebarExpEndCut);
	}

	CTwinVectorArray tvArrRebarExp;
	GetTvRebarOut_Plane_UpperSlabStd(tvArrPlane, 0, TRUE, bLeft ? iLEFT : iRIGHT, FALSE, FALSE);
	if(m_nTypeRebarMainRebarOfExp[stt][left] == 1 || m_bLineDirRebarOfExp[stt][left])
	{
		CString sInfo	= bLeft ? "좌측" : "우측";
		CString sSttOther	= !bStt ? "시점" : "종점";
		long i = 0; for(i = 0; i < tvArrPlane.GetSize(); i++)
		{
			tv	= tvArrPlane.GetAt(i);
			if(tv.m_sInfo.Find(sInfo, 0) != -1 && tv.m_sInfo.Find(sSttOther, 0) == -1)
				tvArrRebarExp.Add(tv);
		}
		rb.RemoveMinLengthLine(tvArrRebarExp, 0.0);
		rb.RemoveMeanlessTwinVector(tvArrRebarExp);
		tvArrRebarExp.Sort();
		if((!bStt && bLeft) || (bStt && !bLeft))
			rb.ReverseRebar(tvArrRebarExp);
	}


	CDPoint xy(0, 0);
	
	BOOL bFirst	= TRUE;
	tv.m_v1.z	= 0;
	tv.m_v2.z	= 0;
	if(tvArrRebarExp.GetSize() > 0)
	{
		tv	= tvArrRebarExp.GetAt(0);
	}
	
	for(i = xyArrRebarExp.GetSize()-1; i >= 0; i--)
	{
		xy	= xyArrRebarExp.GetAt(i);
		CTwinVectorArray tvArrRebarExpTmp;
		
		if(m_nTypeRebarMainRebarOfExp[stt][left] == 0)
		{
			rb.GetXyMatchTvArrAndLine(tvArrOrg, xy, xyDirRebar, xyArrMatch);
			if(xyArrMatch.GetSize() == 0) continue;

			if(xyArrMatch.GetSize() == 1)
				xyMatch	= xyArrMatch.GetAt(0);
			else
				xyMatch	= ~(xyArrMatch.GetAt(0) - tv.m_v1) < ~(xyArrMatch.GetAt(1) - tv.m_v2) ? xyArrMatch.GetAt(0) : xyArrMatch.GetAt(1);
			tv.m_v1	= xy;
			tv.m_v2	= xyMatch + (xyDirRebar * dLenExt);
			tv.m_sInfo.Format("%d", i+1);

			tvArrRebarExpTmp.Add(tv);
		}
		else if(m_nTypeRebarMainRebarOfExp[stt][left] == 1)
		{
			
			tvArrRebarExpTmp	= tvArrRebarExp;
			CDPoint xyMove	= xy - tvArrRebarExp.GetAt(0).m_v1;

			rb.MoveRebar(tvArrRebarExpTmp, xyMove);
			if(m_nTypeOrgMainRebarOfExp[stt][left] == 0)
			{
				rb.TrimAndStretchByTvAndLength(tvArrRebarExpTmp, tvArrOrg, 0);

				// 주철근 기준이라면 첫번째 철근 만들때 뻗어나가는 방향을 정해준다.
				if(tvArrRebarExpTmp.GetSize() > 0)
				{
					CTwinVector tvLast	= tvArrRebarExpTmp.GetAt(tvArrRebarExpTmp.GetSize()-1);
					if(bFirst)
					{
						xyDirRebar	= tvLast.GetXyDir();
						bFirst	= FALSE;
					}

					tvLast.m_v1	= tvLast.m_v2;
					tvLast.m_v2	= tvLast.m_v1 + (xyDirRebar * dLenExt);
					tvLast.m_v1.z	= 0;
					tvLast.m_v2.z	= 0;
					tvArrRebarExpTmp.Add(tvLast);
				}
			}
			else
			{
				rb.TrimAndStretchByTvAndLength(tvArrRebarExpTmp, tvArrOrg, dLenExt);
			}

//			CTwinVector *pTv	= NULL;
			long s = 0; for(s = 0; s < tvArrRebarExpTmp.GetSize(); s++)
			{
				CTwinVector *pTv	= &tvArrRebarExpTmp.GetAt(s);
				pTv->m_sInfo.Format("%d", i+1);
			}
		}

		// 선형방향 배치가 되면 무조건 1cycle
		if(i % 2 == 0 || bJongGirder || m_bLineDirRebarOfExp[stt][left])
		{
			CTwinVectorArray *pTvArr	= new CTwinVectorArray;
			*pTvArr	= tvArrRebarExpTmp;

			pTvArrCycle1->InsertAt(0, pTvArr);
		}
		else
		{
			CTwinVectorArray *pTvArr	= new CTwinVectorArray;
			*pTvArr	= tvArrRebarExpTmp;

			pTvArrCycle2->InsertAt(0, pTvArr);
		}
	}

	// 헌치부 철근
	long nIdxHunch1(0), nIdxHunch2(0);
	for(i = xyArrRebarExpHunch.GetSize()-1; i >= 0; i--)
	{
		xy	= xyArrRebarExpHunch.GetAt(i);
		if(i % 2 == 0 || bJongGirder)
		{
			if(pRCHunch1)
			{
				tv.m_v1	= xy;
				// 헌치 철근은 직선으로만 배근된다.(가각부 철근 옵션 적용 안됨) //
				tv.m_v1.z	= 0;
				tv.m_v2.z	= 0;
				/////////////////////////////////////
				GetXyMatchLineAndLine(tv.m_v1, xyDirRebar, xyOrgHunch, vAngOrgHunch, tv.m_v2);
				tv.m_sInfo.Format("%d", nIdxHunch1);
				tvArrCycleHunch1.Add(tv);
				nIdxHunch1++;
			}
		}
		else
		{
			if(pRCHunch2)
			{
				tv.m_v1	= xy;
				// 헌치 철근은 직선으로만 배근된다.(가각부 철근 옵션 적용 안됨) //
				tv.m_v1.z	= 0;
				tv.m_v2.z	= 0;
				/////////////////////////////////////
				GetXyMatchLineAndLine(tv.m_v1, xyDirRebar, xyOrgHunch, vAngOrgHunch, tv.m_v2);
				tv.m_sInfo.Format("%d", nIdxHunch2);
				tvArrCycleHunch2.Add(tv);
				nIdxHunch2++;
			}
		}
	}




	// 선형방향으로 배치되는 철근은 2Cycle에 임시로 넣음
	if(m_bLineDirRebarOfExp[stt][left])
	{
		// dLenRound보다 작은 철근은 배치 불가.
		double dDia	= 0;
		CString sMark(""), sDescription("");
		if(bUpperSlab)
			GetInfoMainRebarExp_UpperSlab(bStt, bLeft, bUpper, 1, nDan, 0, sMark, dDia, sDescription);
		else
			GetInfoMainRebarExp_LowerSlab(bStt, bLeft, bUpper, 1, nDan, 0, sMark, dDia, sDescription);
		double dLenRound	= GetLenRebarAtEdge(dDia, FALSE);

		CLineInfo *pLine	= GetLineBase();
		CDPoint xyMatch(0, 0);
//		double dDist	= 0;
		double dSta		= 0;
		double dStaMatch	= 0;
		CTwinVectorArray tvArrRebarExpStt;
		for(i = 0; i < tvArrRebarExpEndCut.GetSize(); i++)
		{
			tv	= tvArrRebarExpEndCut.GetAt(i);
			if(bStt && tv.m_sInfo.Find("종점", 0) != -1) continue;
			if(!bStt && tv.m_sInfo.Find("시점", 0) != -1) continue;
			tvArrRebarExpStt.Add(tv);
		}

		for(i = xyArrRebarExpOld.GetSize()-1; i >= 0; i--)
		{
			xy	= xyArrRebarExpOld.GetAt(i);
			CTwinVectorArray tvArrRebarExpTmp;

			double dDist	= 0;
			dDist	= pLine->GetDisMatchVerticalByXy(xy);
			if(!pLine->GetStationMatchVerticalByXy(xy, dSta)) continue;

			BOOL bMatch	= FALSE;
			long j = 0; for(j = 0; j < tvArrRebarExpStt.GetSize(); j++)
			{
				tv	= tvArrRebarExpStt.GetAt(j);
				if(tv.m_v1.z == 0)
				{
					if(pLine->GetStationMatchSegment(tv.m_v1, tv.m_v2, dStaMatch, dDist))
					{
						bMatch	= TRUE;
						break;
					}
				}
				else
				{
					CDPoint xyCen	= tv.GetXyCircleCenter();
					CDPoint vAngStt	= (tv.m_v1 - xyCen).Unit();
					CDPoint vAngEnd	= (tv.m_v2 - xyCen).Unit();
					if(tv.m_v2.z < 0)
						GetSwap(vAngStt, vAngEnd);
					if(pLine->GetStationMatchArc(tv.GetXyCircleCenter(), fabs(tv.m_v2.z), vAngStt, vAngEnd, dStaMatch, dDist))
					{
						bMatch	= TRUE;
						break;
					}
				}
			}

			if(bMatch)
			{
				// 선형에서 거리 체크를 매번 하면 속도 저하(어짜피 철근은 점점 커지는  형태이므로)
				if(pLine->GetLengthByDis(dSta, dStaMatch, dDist) > dLenRound)
				{
					xyMatch	= pLine->GetXyLineDis(dStaMatch, dDist);
					tvArrRebarExpTmp.AddFromLineInfo(static_cast<CLineInfoApp*>(pLine), xy, xyMatch, dDist < 0);

					CTwinVectorArray *pTvArr	= new CTwinVectorArray;
					*pTvArr	= tvArrRebarExpTmp;
					pTvArrCycle2->InsertAt(0, pTvArr);
				}
			}
		}
	}


	// 상면이고 종거더가 아니면 내측에 수직으로 내려가는 점철근들이 존재한다
	// 하부슬래브는 하면
	if((bUpper==bUpperSlab) && !bJongGirder && nDan==0 && IsOutWall(bStt))
	{
		double dCover	= m_dCoverWallIn[0];
		double dSta	= GetStationByTarget(bStt ? BRIDGE_OFF_STT_STT : BRIDGE_OFF_END_END, 0, TRUE);
		dSta += bStt ? -dCover : dCover;
		
		CLineInfo *pLine	= GetLineBase();
		CDPoint xy	= pLine->GetXyLine(dSta);
		CDPoint vAng	= GetAngleAzimuthJijum(bStt ? 0 : m_nQtyJigan);
		//vAng	= pLine->GetAngleByOffsetWidth(dSta, bStt ? -dCover : dCover, vAng);

		CTwinVectorArray *pTvArrLine;
		CTwinVectorArrayArray *pTvArr;
		
		long cycle = 0; for(cycle = 0; cycle < 2; cycle++)
		{
			CDPointArray *pXyArr;
			pTvArr	= cycle == 0 ? pTvArrCycle1 : pTvArrCycle2;
			pXyArr	= cycle == 0 ? &xyArrCycle1 : &xyArrCycle2;

			// 선형방향 배치일때는 선형방향으로 내려가는 철근에만 점철근을 배치하면 됨
			if(m_bLineDirRebarOfExp[stt][left] && cycle == 0) continue;

			long i = 0; for(i = 0; i < pTvArr->GetSize(); i++)
			{
				pTvArrLine	= pTvArr->GetAt(i);
				rb.GetXyMatchTvArrAndLine(*pTvArrLine, xy, vAng, xyArrMatch);

				if(xyArrMatch.GetSize() > 0)
				{
					xyMatch	= xyArrMatch.GetAt(0);

					// 점철근은 가각에 포함 된 경우에만 사용가능하다.
					pLine->GetStationMatchVerticalByXy(xyMatch, dSta);
					double dDist	= pLine->GetDisMatchVerticalByXy(xyMatch);
					if(bLeft)
					{
						if(dDist < -GetWidthSlabAct(dSta, CDPoint(0, 1), -1, FALSE))
						{
							pXyArr->Add(xyMatch);
						}
					}
					else
					{
						if(dDist > GetWidthSlabAct(dSta, CDPoint(0, 1), 1, FALSE))
						{
							pXyArr->Add(xyMatch);
						}
					}
				}
			}
		}

		// 선형방향 배치이면 cycle==0을 넣지 않았으므로 xyArrCycle2에 있는 점들을 xyArrCycle1과 나눈다.
		if(m_bLineDirRebarOfExp[stt][left])
		{
			CDPointArray xyArrTmp;
			xyArrTmp	= xyArrCycle2;
			xyArrCycle2.RemoveAll();
			long i = 0; for(i = 0; i < xyArrTmp.GetSize(); i++)
			{
				if(i % 2 == 0)
					xyArrCycle1.Add(xyArrTmp.GetAt(i));
				else
					xyArrCycle2.Add(xyArrTmp.GetAt(i));
			}
		}
	}

	// 치수기입을 위해서 치수가 기입될 위치를 따로 보관함. ////
	long nSize1	= pTvArrCycle1->GetSize();
	long nSize2	= pTvArrCycle2->GetSize();
//	CTwinVectorArray *pTvArrTmp1	= NULL;
	CTwinVectorArray *pTvArrTmp2	= NULL;
	for(i = 0; i < nSize1; i++)
	{	
		CTwinVectorArray *pTvArrTmp1	= NULL;
		pTvArrTmp1	= pTvArrCycle1->GetAt(i);
		if(pTvArrTmp1->GetSize() == 0) continue;
		
		xyArrDimPoint.Add(pTvArrTmp1->GetAt(0).m_v1);
		if(nSize2 > i && !m_bLineDirRebarOfExp[stt][left])
		{
			pTvArrTmp2	= pTvArrCycle2->GetAt(i);
			if(pTvArrTmp2->GetSize() > 0)
				xyArrDimPoint.Add(pTvArrTmp2->GetAt(0).m_v1);
		}
	}
	/////////////////////////////////////////////////////////////////

	// 끝단 자르기 옵션에 의해서 잘려 나가거나 사라지는 철근이 있을 수 있다. //////////
	if(IsCutEndOfExp(bStt, bLeft))
	{
		CTwinVectorArray tvArrPlaneCut;
		GetTvRebarOut_Plane_UpperSlab(tvArrPlaneCut, 9, TRUE, 2, TRUE, TRUE);

		// 컷트라인을 기준으로 트림 /////////////
		//m_Util.TrimCutEndOfGagak(pTvArrCycle1, tvArrPlaneCut, bStt, bLeft, TRUE);
		//m_Util.TrimCutEndOfGagak(pTvArrCycle2, tvArrPlaneCut, bStt, bLeft, TRUE);
		//m_Util.TrimCutEndOfGagak(tvArrCycleHunch1, tvArrPlaneCut, bStt, bLeft, TRUE, TRUE);
		//m_Util.TrimCutEndOfGagak(tvArrCycleHunch2, tvArrPlaneCut, bStt, bLeft, TRUE, TRUE);

		// (ARCBRIDGE-3375) 곡선철근의 경우는 영역에 딱맞지 않고 잘려나가는 경우가 발생한다. 곡선철근은 무시해주자.
		for(i = 0; i < pTvArrCycle1->GetSize(); i++)
			rb.GetTvArrayByCrossTvArrayArea(*pTvArrCycle1->GetAt(i), tvArrPlaneCut, TRUE, FALSE, FALSE, TRUE);
		for(i = 0; i < pTvArrCycle2->GetSize(); i++)
			rb.GetTvArrayByCrossTvArrayArea(*pTvArrCycle2->GetAt(i), tvArrPlaneCut, TRUE);
		rb.GetTvArrayByCrossTvArrayArea(tvArrCycleHunch1, tvArrPlaneCut, TRUE);
		rb.GetTvArrayByCrossTvArrayArea(tvArrCycleHunch2, tvArrPlaneCut, TRUE);
		///////////////////////////////////////



		CVectorArray vecArr;
		tvArrPlaneCut.GetToVectorArray(vecArr);
		rb.GetXyByVectorArrayArea(xyArrCycle1, vecArr, TRUE);
		rb.GetXyByVectorArrayArea(xyArrCycle2, vecArr, TRUE);

		// 구해전 주철근을 시점끝단에 붙는 원래꺼와 끝단 자르기에 의해서 잘려나간 철근으로 구분해줘야 함
		CString str	= bStt ? "시점" : "종점";
		for(i = 0; i < tvArrPlaneCut.GetSize(); i++)
		{
			tvStt	= tvArrPlaneCut.GetAt(i);
			if(tvStt.m_sInfo == str) break;
		}
		
		CDPoint vAng	= tvStt.GetXyDir();
		CDPoint vAngPer	= vAng.Rotate90();
		for(i = 0; i < pTvArrCycle1->GetSize(); i++)
		{
			CTwinVectorArray *pTvArr	= pTvArrCycle1->GetAt(i);
			if(pTvArr->GetSize() > 0)
			{
				CDPoint xy	= pTvArr->GetAt(0).m_v1;
				// (ARCBRIDGE-3569) 철근이 잘리는지 확인하는데 왜 지점의 90도 방향으로 위치를 체크하는지... 철근방향으로 변경.
				vAngPer = pTvArr->GetAt(0).GetXyDir();

				GetXyMatchLineAndLine(tvStt.m_v1, vAng, xy, vAngPer, xy);
				if(!Compare(tvStt.GetLength(), ~(tvStt.m_v1-xy)+~(tvStt.m_v2-xy), "=") || ComparePt(tvStt.m_v1, xy, "=") || ComparePt(tvStt.m_v2, xy, "="))
				{
					pTvArrCycle12->Add(pTvArr);
					pTvArrCycle1->RemoveAt(i);
					i--;
				}
			}
		}

		for(i = 0; i < pTvArrCycle2->GetSize(); i++)
		{
			CTwinVectorArray *pTvArr	= pTvArrCycle2->GetAt(i);
			if(pTvArr->GetSize() > 0)
			{
				CDPoint xy	= pTvArr->GetAt(0).m_v1;
				vAngPer = pTvArr->GetAt(0).GetXyDir();

				GetXyMatchLineAndLine(tvStt.m_v1, vAng, xy, vAngPer, xy);
				if(!Compare(tvStt.GetLength(), ~(tvStt.m_v1-xy)+~(tvStt.m_v2-xy), "=") || ComparePt(tvStt.m_v1, xy, "=") || ComparePt(tvStt.m_v2, xy, "="))
				{
					pTvArrCycle22->Add(pTvArr);
					pTvArrCycle2->RemoveAt(i);
					i--;
				}
			}
		}
	}
	//////////////////////////////////////////////////////////////////////////////////////

	// 2단이상일 경우 헌치 철근은 제거
	if(nDan > 0)
	{
		tvArrCycleHunch1.RemoveAll();
		tvArrCycleHunch2.RemoveAll();
	}

	// 가각 끝단 자른 부분 철근만 있다면
	// 이 넘을 기본 철근으로 바꿔 치기 해줌
	if(pTvArrCycle1->GetSize() == 0)
	{
		AhTPACopy(pTvArrCycle1, pTvArrCycle12, (CTwinVectorArray *)0);
		AhTPADelete(pTvArrCycle12, (CTwinVectorArray*)0);
	}

	if(pTvArrCycle2->GetSize() == 0)
	{
		AhTPACopy(pTvArrCycle2, pTvArrCycle22, (CTwinVectorArray *)0);
		AhTPADelete(pTvArrCycle22, (CTwinVectorArray*)0);
	}

	// 개수가 없는 것은 완전 해 제거
	m_Util.RemoveMeanLessTvArr(pTvArrCycle1);
	m_Util.RemoveMeanLessTvArr(pTvArrCycle12);
	m_Util.RemoveMeanLessTvArr(pTvArrCycle2);
	m_Util.RemoveMeanLessTvArr(pTvArrCycle22);
}

// 사보강시 좌우측 철근 각도(방위각임)
CDPoint CRcBridgeRebar::GetXyDirRebarMainPlaneForSabogang(long nLeft)
{
	BOOL bVertDir				= IsVertDir();
	CLineInfoApp *pLineBase		= static_cast<CLineInfoApp*>(GetLineBase(bVertDir));
	double dStaOrg				= GetStationBridgeStt(bVertDir);
	// 사보강 배치일 경우 사방향 철근 구간을 정확히 판단하기 위해서 시점벽체를 기준으로 배근한다.
	if(bVertDir)
	{
		if(IsOutWall(TRUE))
			dStaOrg	-= m_dWS;
	}
	CDPoint xyDirOrg	= pLineBase->GetAngleAzimuth(dStaOrg);


	CTwinVector tvJijumStt	= GetTvJijum(0, 0);
	CTwinVector tvJijumEnd	= GetTvJijum(m_nQtyJigan, 0);
	CDPoint xyDir	= xyDirOrg;
	if(nLeft == -1) xyDir = (tvJijumEnd.m_v1 - tvJijumStt.m_v1).Unit();
	else if(nLeft == 1) xyDir = (tvJijumEnd.m_v2 - tvJijumStt.m_v2).Unit();

	return xyDir;
}

// OffsetInfo에 각도적용함.
// 입력은 직거리로 받고 그릴땐 사거리로 그린다거나 할때 이용하면 좋음.
void CRcBridgeRebar::ApplyAngleToOffsetInfo(CDPointArray &xyArrOffset, double dCurAngle, double dApplyAngle)
{
	long nSize	= xyArrOffset.GetSize();
	
	CDPoint vAngCur		= ToDPointFrDegree(dCurAngle);
	CDPoint vAngApply	= ToDPointFrDegree(dApplyAngle);

	CDPoint xyR(0, 0);
	long i = 0; for(i = 0; i < nSize; i++)
	{
		xyR	= xyArrOffset.GetAt(i);
		xyR.y *= vAngCur.y;
		xyR.y /= vAngApply.y;
		xyArrOffset.SetAt(i, xyR);
	}
}

void CRcBridgeRebar::SetConcDataWingWall()
{
	CHgBaseConcStd HgConcStd; 
	CARcBridgeDataStd *pStd = m_pARcBridgeDataStd;
	AhTPADelete(&m_pArrConcWingSttLeft,   (CConcBasic*)0);
	AhTPADelete(&m_pArrConcWingSttRight,   (CConcBasic*)0);
	AhTPADelete(&m_pArrConcWingEndLeft,   (CConcBasic*)0);
	AhTPADelete(&m_pArrConcWingEndRight,   (CConcBasic*)0);

	CWingWall *pWing;
	CString szTitle = _T("");
	BOOL bStt = TRUE;
	BOOL bLeft = TRUE;

	long i=0; for(i=0; i<4; i++)
	{
		switch(i) 
		{
		case 0:									// 시점 좌측
			pWing = m_pWingWallStt[0]; 
			szTitle = "시점좌측";
			bStt = TRUE;
			bLeft = TRUE;
			break;		
		case 1:									// 시점 우측
			pWing = m_pWingWallStt[1];
			szTitle = "시점우측";
			bStt = TRUE;
			bLeft = FALSE;
			break;
		case 2:									// 종점 좌측
			pWing = m_pWingWallEnd[0];
			szTitle = "종점좌측";
			bStt = FALSE;
			bLeft = TRUE;
			break;
		case 3:									// 종점 우측
			pWing = m_pWingWallEnd[1];
			szTitle = "종점우측";
			bStt = FALSE;
			bLeft = FALSE;
			break;
		}

		for(long j=0; j<5; j++)
		{
			CConcBasic *pData= new CConcBasic;
			double dB = 0, dBC = 0;

			switch(j) {
			case 0:
				{
					pData->m_sTitle = szTitle+_T(" A");
					pData->m_Ho		= (pWing->m_nDirHunch == 2)? pWing->m_dT2 : pWing->m_dT1;

					for(long nDan=0; nDan<pWing->m_nCountLayerA[iOUTTER]; nDan++)
					{
						dB = frM(UNIT_METER)/(GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTA, FALSE, TRUE, nDan));
						dBC = frM(UNIT_METER)/(GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTA, TRUE, TRUE, nDan));

						// 주철근
						pData->m_RbT1C_dc[nDan] = m_dCoverWingIn[0] + 100 * nDan;
						pData->m_RbT1C_B [nDan] = dB;  // 철근의 개수 (1000/CTC)
						pData->m_RbT1C_DIA[nDan] = pWing->m_dDiaMainA[0][nDan];

						pData->m_RbC1C_dc[nDan] = m_dCoverWingOut[0] + 100 * nDan;
						pData->m_RbC1C_B [nDan] = dBC;  // 철근의 개수 (1000/CTC)
						pData->m_RbC1C_DIA[nDan] = pWing->m_dDiaMainA[iINNER][nDan];

						// 배력철근
						pData->m_TSupportBarDia[nDan] = pWing->m_dDiaSupportA[0][nDan];
						pData->m_CSupportBarDia[nDan] = pWing->m_dDiaSupportA[1][nDan];
						pData->m_TSupportBarCTC[nDan] = GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTA, FALSE, FALSE, nDan);
						pData->m_CSupportBarCTC[nDan] = GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTA, TRUE, FALSE, nDan);
					}
					
					// 전단철근
					if(pWing->m_RebarShearDetailA.m_nType==TYPE_SHEAR_SPACER)
					{
						pData->m_SvDia	= 0;
						pData->m_SvCtc	= 0;
						pData->m_SvEa	= 0;
					}
					else
					{
						pData->m_SvDia = pWing->m_RebarShearDetailA.m_dDia;
						pData->m_SvCtc = pWing->m_dSpaceShearA;
						double dSvEa  = frM(UNIT_METER)/(pWing->m_nCountShearBind * GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTA, FALSE, TRUE, 0));
						pData->m_SvEa  = (pWing->m_RebarShearDetailA.m_nType == TYPE_SHEAR_DIGUT || pWing->m_RebarShearDetailA.m_nType == TYPE_SHEAR_SINGLE_HOOK) ? dSvEa/2 : dSvEa;
					}
					break;
				}
			case 1:
				{
					pData->m_sTitle = szTitle+_T(" B");
					pData->m_Ho		= pWing->m_dT2;

					for(long nDan=0; nDan<pWing->m_nCountLayerB[iOUTTER]; nDan++)
					{
						dB = frM(UNIT_METER)/(GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTB, FALSE, TRUE, nDan));
						dBC = frM(UNIT_METER)/(GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTB, TRUE, TRUE, nDan));

						// 주철근
						pData->m_RbT1C_dc[nDan] = m_dCoverWingIn[0] + 100 * nDan;
						pData->m_RbT1C_B [nDan] = dB;  // 철근의 개수 (1000/CTC)
						pData->m_RbT1C_DIA[nDan] = pWing->m_dDiaMainB[0][nDan];

						pData->m_RbC1C_dc[nDan] = m_dCoverWingOut[0] + 100 * nDan;
						pData->m_RbC1C_B [nDan] = dBC;  // 철근의 개수 (1000/CTC)
						pData->m_RbC1C_DIA[nDan] = pWing->m_dDiaMainB[iINNER][nDan];

						// 배력철근
						pData->m_TSupportBarDia[nDan] = pWing->m_dDiaSupportB[0][nDan];
						pData->m_CSupportBarDia[nDan] = pWing->m_dDiaSupportB[1][nDan];
						pData->m_TSupportBarCTC[nDan] = GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTB, FALSE, FALSE, nDan);
						pData->m_CSupportBarCTC[nDan] = GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTB, TRUE, FALSE, nDan);
					}
					
					// 전단철근
					if((pWing->m_nTypeShearBC==1 && pWing->m_RebarShearDetailC.m_nType==TYPE_SHEAR_SPACER) || pWing->m_RebarShearDetailB.m_nType==TYPE_SHEAR_SPACER)
					{
						pData->m_SvDia	= 0;
						pData->m_SvCtc	= 0;
						pData->m_SvEa	= 0;
					}
					else
					{
						pData->m_SvDia = (pWing->m_nTypeShearBC==1)? pWing->m_RebarShearDetailC.m_dDia : pWing->m_RebarShearDetailB.m_dDia;
						pData->m_SvCtc = (pWing->m_nTypeShearBC==1)? (pWing->m_nCountShearBind * GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTB, FALSE, TRUE, 0)): pWing->m_dSpaceShearB;
						double dSvEa   = (pWing->m_nTypeShearBC==1)? frM(UNIT_METER)/pWing->m_dSpaceShearC : frM(UNIT_METER)/(pWing->m_nCountShearBind * GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTB, FALSE, TRUE, 0));
						if(pWing->m_nTypeShearBC==1) (pWing->m_RebarShearDetailC.m_nType == TYPE_SHEAR_DIGUT || pWing->m_RebarShearDetailC.m_nType == TYPE_SHEAR_SINGLE_HOOK) ? dSvEa/2 : dSvEa;
						else pData->m_SvEa  = (pWing->m_RebarShearDetailB.m_nType == TYPE_SHEAR_DIGUT || pWing->m_RebarShearDetailB.m_nType == TYPE_SHEAR_SINGLE_HOOK) ? dSvEa/2 : dSvEa;
					}
					break;
				}
			case 2:
				{
					pData->m_sTitle = szTitle+_T(" C");
					pData->m_Ho		= pWing->m_dT2;

					for(long nDan=0; nDan<pWing->m_nCountLayerC[iOUTTER]; nDan++)
					{
						dB = frM(UNIT_METER)/(GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTC, FALSE, TRUE, nDan));
						dBC = frM(UNIT_METER)/(GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTC, TRUE, TRUE, nDan));

						// 주철근
						pData->m_RbT1C_dc[nDan] = m_dCoverWingIn[0] + 100 * nDan;
						pData->m_RbT1C_B [nDan] = dB;  // 철근의 개수 (1000/CTC)
						pData->m_RbT1C_DIA[nDan] = pWing->m_dDiaMainC[0][nDan];

						pData->m_RbC1C_dc[nDan] = m_dCoverWingOut[0] + 100 * nDan;
						pData->m_RbC1C_B [nDan] = dBC;  // 철근의 개수 (1000/CTC)
						pData->m_RbC1C_DIA[nDan] = pWing->m_dDiaMainC[iINNER][nDan];

						// 배력철근
						pData->m_TSupportBarDia[nDan] = pWing->m_dDiaSupportC[0][nDan];
						pData->m_CSupportBarDia[nDan] = pWing->m_dDiaSupportC[1][nDan];
						pData->m_TSupportBarCTC[nDan] = GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTC, FALSE, FALSE, nDan);
						pData->m_CSupportBarCTC[nDan] = GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTC, TRUE, FALSE, nDan);
					}
					
					// 전단철근
					if((pWing->m_nTypeShearBC==0 && pWing->m_RebarShearDetailB.m_nType==TYPE_SHEAR_SPACER) || pWing->m_RebarShearDetailC.m_nType==TYPE_SHEAR_SPACER)
					{
						pData->m_SvDia	= 0;
						pData->m_SvCtc	= 0;
						pData->m_SvEa	= 0;
					}
					else
					{
						pData->m_SvDia = (pWing->m_nTypeShearBC==0)? pWing->m_RebarShearDetailB.m_dDia : pWing->m_RebarShearDetailC.m_dDia;
						pData->m_SvCtc = (pWing->m_nTypeShearBC==0)? (pWing->m_nCountShearBind * GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTC, FALSE, TRUE, 0)) : pWing->m_dSpaceShearC;
						double dSvEa   = (pWing->m_nTypeShearBC==0)? frM(UNIT_METER)/pWing->m_dSpaceShearB : frM(UNIT_METER)/(pWing->m_nCountShearBind * GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTC, FALSE, TRUE, 0));					
						if(pWing->m_nTypeShearBC==0) pData->m_SvEa  = (pWing->m_RebarShearDetailB.m_nType == TYPE_SHEAR_DIGUT || pWing->m_RebarShearDetailB.m_nType == TYPE_SHEAR_SINGLE_HOOK) ? dSvEa/2 : dSvEa;
						else pData->m_SvEa  = (pWing->m_RebarShearDetailC.m_nType == TYPE_SHEAR_DIGUT || pWing->m_RebarShearDetailC.m_nType == TYPE_SHEAR_SINGLE_HOOK) ? dSvEa/2 : dSvEa;
					}
					break;
				}
			case 3:
				{
					pData->m_sTitle = szTitle+_T(" D");
					// (ARCBRIDGE-3391) 방향에 관계없이 옵션을 적용한다. AAbutPier와 동일하게
// 					pData->m_Ho	= (pWing->m_dL2 > 0) ? pWing->m_dT1 : (pWing->m_nDirHunch == 2)? pWing->m_dT2 : pWing->m_dT1;
// 					if(m_bApplyT1CalcWingWall)
// 					{
// 						pData->m_Ho = pWing->m_dT1;
// 					}
					pData->m_Ho	= pWing->m_dT1;
					if(pWing->m_nDirHunch != 0 && !m_bApplyT1CalcWingWall)
					{
						pData->m_Ho = pWing->m_dT2;
					}


					for(long nDan=0; nDan<pWing->m_nCountLayerD[iOUTTER]; nDan++)
					{
						dB = frM(UNIT_METER)/(GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTD, FALSE, TRUE, nDan));
						dBC = frM(UNIT_METER)/(GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTD, TRUE, TRUE, nDan));
						// 주철근
						pData->m_RbT1C_dc[nDan] = m_dCoverWingIn[0] + 100 * nDan;
						pData->m_RbT1C_B [nDan] = dB;  // 철근의 개수 (1000/CTC)
						pData->m_RbT1C_DIA[nDan] = pWing->m_dDiaMainD[0][nDan];

						pData->m_RbC1C_dc[nDan] = m_dCoverWingOut[0] + 100 * nDan;
						pData->m_RbC1C_B [nDan] = dBC;  // 철근의 개수 (1000/CTC)
						pData->m_RbC1C_DIA[nDan] = pWing->m_dDiaMainD[iINNER][nDan];

						// 배력철근
						pData->m_TSupportBarDia[nDan] = pWing->m_dDiaSupportD[0][nDan];
						pData->m_CSupportBarDia[nDan] = pWing->m_dDiaSupportD[1][nDan];
						pData->m_TSupportBarCTC[nDan] = GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTD, FALSE, FALSE, nDan);
						pData->m_CSupportBarCTC[nDan] = GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTD, TRUE, FALSE, nDan);
					}
					
					// 전단철근
					if(pWing->m_RebarShearDetailD.m_nType==TYPE_SHEAR_SPACER)
					{
						pData->m_SvDia	= 0;
						pData->m_SvCtc	= 0;
						pData->m_SvEa	= 0;
					}
					else
					{
						pData->m_SvDia = pWing->m_RebarShearDetailD.m_dDia;
						pData->m_SvCtc = pWing->m_dSpaceShearD;
						double dSvEa   = frM(UNIT_METER)/(pWing->m_nCountShearBind * GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTD, FALSE, TRUE, 0));
						pData->m_SvEa  = (pWing->m_RebarShearDetailD.m_nType == TYPE_SHEAR_DIGUT || pWing->m_RebarShearDetailD.m_nType == TYPE_SHEAR_SINGLE_HOOK)? dSvEa/2 : dSvEa;
					}
					break;
				}
			case 4:
				{
					pData->m_sTitle = szTitle+_T(" A'");
					pData->m_Ho		= pWing->m_dT2;
					

					for(long nDan=0; nDan<pWing->m_nCountLayerA[iOUTTER]; nDan++)
					{
						dB = frM(UNIT_METER)/(GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTA, FALSE, TRUE, nDan));
						dBC = frM(UNIT_METER)/(GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTA, TRUE, TRUE, nDan));

						// 주철근
						pData->m_RbT1C_dc[nDan] = m_dCoverWingIn[0] + 100 * nDan;
						pData->m_RbT1C_B [nDan] = dB;  // 철근의 개수 (1000/CTC)
						pData->m_RbT1C_DIA[nDan] = pWing->m_dDiaMainA[0][nDan];

						pData->m_RbC1C_dc[nDan] = m_dCoverWingOut[0] + 100 * nDan;
						pData->m_RbC1C_B [nDan] = dBC;  // 철근의 개수 (1000/CTC)
						pData->m_RbC1C_DIA[nDan] = pWing->m_dDiaMainA[iINNER][nDan];

						// 배력철근
						pData->m_TSupportBarDia[nDan] = pWing->m_dDiaSupportA[0][nDan];
						pData->m_CSupportBarDia[nDan] = pWing->m_dDiaSupportA[1][nDan];
						pData->m_TSupportBarCTC[nDan] = GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTA, FALSE, FALSE, nDan);
						pData->m_CSupportBarCTC[nDan] = GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTA, TRUE, FALSE, nDan);
					}
					
					// 전단철근
					if(pWing->m_RebarShearDetailA.m_nType==TYPE_SHEAR_SPACER)
					{
						pData->m_SvDia	= 0;
						pData->m_SvCtc	= 0;
						pData->m_SvEa	= 0;
					}
					else
					{
						pData->m_SvDia = pWing->m_RebarShearDetailA.m_dDia;
						pData->m_SvCtc = pWing->m_dSpaceShearA;
						double dSvEa   = frM(UNIT_METER)/(pWing->m_nCountShearBind * GetRebarCtcWingwall(bStt, bLeft, WINGWALL_SECTA, FALSE, TRUE, 0));
						pData->m_SvEa  = (pWing->m_RebarShearDetailA.m_nType == TYPE_SHEAR_DIGUT || pWing->m_RebarShearDetailA.m_nType == TYPE_SHEAR_SINGLE_HOOK) ? dSvEa/2 : dSvEa;
					}
					break;
				}
			}

			pData->m_nTypeUnit		= pStd->m_nTypeUnit; //0-CGS,1-SI
			pData->m_nTypeKciCode	= pStd->m_nTypeKciCode;
			pData->m_nTypeSection	= SECTION_SINGLE; // 단면의 타입,SECTION_SINGLE

			SetConcDataBasic(pData, bStt? ePartWingWallStt : ePartWingWallEnd, FALSE, eLSD_COMBINATION_LIMIT);
			pData->m_Bo		= frM(UNIT_METER);
			pData->m_nEnvTypeCrack = m_nTypeCrackDesignWing;
			pData->m_bMinAvCheck   = m_bApplyMinAvWing;
			pData->m_bCheckMinCtcShear = m_bCheckMinCtcShearWing;
			// 단면력은 Calculate에서 
			
			switch(i) 
			{
			case 0: m_pArrConcWingSttLeft.Add(pData); break;		// 시점 좌측
			case 1: m_pArrConcWingSttRight.Add(pData); break;		// 시점 우측
			case 2: m_pArrConcWingEndLeft.Add(pData); break;		// 종점 좌측
			case 3: m_pArrConcWingEndRight.Add(pData); break;		// 종점 우측
			}
		}
	}
}

// nIndex =  0: A구간, 1: B구간, 2: C구간, 3: D구간, 4: A'구간
CConcBasic* CRcBridgeRebar::GetConcDataWingWall(BOOL bStt, BOOL bLeft, long nIndex)
{
	CConcBasic *pConc = NULL;

	CSafetyTypedPtrArray <CObArray, CConcBasic*> *pArr;
 
	if(bStt && bLeft) pArr = &m_pArrConcWingSttLeft;
	else if(bStt && !bLeft) pArr = &m_pArrConcWingSttRight;
	else if(!bStt && bLeft) pArr = &m_pArrConcWingEndLeft;
	else if(!bStt && !bLeft) pArr = &m_pArrConcWingEndRight;

	if(pArr->GetSize() > nIndex)
		pConc	= pArr->GetAt(nIndex);

	return pConc;
}

BOOL CRcBridgeRebar::IsBracketRebar(BOOL bStt, long nCycle)
{
	long stt	= bStt ? iSTT : iEND;
	double dDia	= nCycle == 0 ? m_dDiaRebarMain_Bracket_Cycle1[stt] : m_dDiaRebarMain_Bracket_Cycle2[stt];
	return IsBracket(bStt) && m_bIsBracketRebar[nCycle][stt] && dDia > 0;
}

void CRcBridgeRebar::SetDataDefaultRebarBracket()
{
	long stt = 0; for(stt = 0; stt < 2; stt++)
	{
		long cycle = 0; for(cycle = 0; cycle < 2; cycle++)
			m_bIsBracketRebar[cycle][stt]	= TRUE;
		// 브라켓 철근 지름 권고안 해줌
		m_dDiaRebarMain_Bracket_Cycle1[stt]	= 19;
		m_dDiaRebarMain_Bracket_Cycle2[stt]	= 19;
	}
}

void CRcBridgeRebar::SetDataDefaultRebarBFooting()
{
	// 주철근
	m_bPRF_SameCTC_Main = TRUE;
	m_dPRF_CTC_Main = m_dCTC_MainRebar;
	m_dPRF_Dia_Main = 19.;
	// 수평철근
	m_dPRF_CTC_Support = m_dCTC_SupportRebar[iLOWER] / 2.;
	m_dPRF_Dia_Support = 16.;
	m_dPRF_CTC_SupportVert = m_dCTC_SupportRebar[iLOWER];
	// 전단철근
	m_dPRF_CTC_Shear = m_dCTC_ShearRebar[iLOWER] / 2.;
	m_dPRF_Dia_Shear = m_RebarShearDetail_OutWall[iSTT].m_dDia;
	m_nPRF_Type_Shear = m_RebarShearDetail_OutWall[iSTT].m_nType;
	m_nPRF_Count_Shear = 4;
}

// 평면도 주철근(모든 dan, cycle)
// 평범한 형태 사보강(확폭아님) - 확폭은 나중에 지원예정.
// long nDrawLeft : -1 : 진행방향 좌측 라인좌표만 구함, 0 : 진행방향 좌우측 라인 모두 구함, 1 : 진행방향 우측 라인만 구함.
// BOOL bHunch : 헌치주철근인지? (헌치 주철근인 경우, ctc등의 정보는 하부정보를 이용한다)
// BOOL bSttBracket, BOOL bEndBracket : 시점이나 종점 브라켓 주철근인지?(브라켓 주철근은 ctc등의 정보를 하부의 정보를 이용한다)
// BOOL bGirder : 거더 스터럽 철근 배근방식이 주철근과 동일하므로 여기서 처리함. (nIdx는 거더의 지점으로 이용함)
// bHunch, bStt나 bEndBracket은 중복될 수 없고, 중복될경우 우선순위는 hunch, stt, end가 된다.
// tvArrJoint : 이음 좌표
// tvArrHidden은 시종점벽체에 R로 꺽이는 철근에 대해서 점선으로 그리기 위한 좌표임
// bForDrawing : tvArrHidden을 구하면 tvArr과 tvArrAngLeft, tvArrAngRight에 대해서 tvArrHidden만큼 짧게 만드렁야 됨
// void CRcBridgeRebar::GetTvRebarMain_Plane_UpperSlab_Vertical(CTwinVectorArray &tvArr, CTwinVectorArray &tvArrAngLeft, CTwinVectorArray &tvArrAngRight, BOOL bUpper, long nCycle, long nDan, long nDrawLeft, long nIdx, BOOL bHunch, BOOL bSttBracket, BOOL bEndBracket, CTwinVectorArray &tvArrJoint, CTwinVectorArray &tvArrHidden, CTwinVectorArray &tvArrHiddenLeft, CTwinVectorArray &tvArrHiddenRight, BOOL bForDrawing)
// {
// 	tvArr.RemoveAll();
// 	tvArrAngLeft.RemoveAll();
// 	tvArrAngRight.RemoveAll();
// 	tvArrHidden.RemoveAll();
// 	tvArrHiddenLeft.RemoveAll();
// 	tvArrHiddenRight.RemoveAll();
// 
// 	// 사보강...
// 	CTwinVectorArray tvArrRebarPlane;	// 사보강배치용 외곽선(라운드를 직선으로 변경한다)
// 	CTwinVector tvCen;					// 중심선(어짜피 직선이니 어레이 안씀)
// 
// 
// 
// 
// }

// 사보강시 기존중심의 시작점과 사보강중심의 시작점의 거리차이
double CRcBridgeRebar::GetDistDiffOfMidInVert()
{
	if(!IsVertDir()) return 0;

	//CDPoint vAngStt		= GetAngleJijum(0);
	double dStaTmp		= GetStationByTarget(BRIDGE_OFF_STT_SLAB, 0, TRUE);//IsOutWall(TRUE) ? m_dStationBridgeStt - m_dWS/vAngStt.y : m_dStationBridgeStt;

	// 사보강일경우 기준sta에서의 직방향중심과 선형방향 중심의 차이를 알아야 된다.
	CLineInfo *pLine	= GetLineBase();
	CTwinVectorArray tvArrCen;
	GetTvCenterPlane_UpperSlab(tvArrCen, TRUE, FALSE, 0, TRUE);
	CTwinVector tvCen	= tvArrCen.GetAt(0);
	CDPoint xyStt		= pLine->GetXyLine(dStaTmp);
	double dDistDiff	= ~(xyStt-tvCen.m_v1);

	// 새로생긴 직방향 중심이 좌측으로 실제 중심보다 좌측끝에 가까우면 dDistDiff는 양수
	// 그렇지 않으면 음수가 된다.
	//if(IsRightFromRoadCenter())
	//	dDistDiff *= -1;
	//CDPoint xyLeft		= pLine->GetXyLineByLengthAndAngle(dStaTmp, -GetWidthSlabAct(dStaTmp, GetAngleJijum(0), -1, FALSE, FALSE), GetAngleJijum(0));
	//if(~(xyStt-xyLeft) < ~(tvCen.m_v1-xyLeft))
	//	dDistDiff	*= -1;

	// 2차수정(2006.10.8)
	// 직방향 중심시작점의 dist를 구해서 양수이면 dDistDiff가 음수가 된다.
	double dDist	= pLine->GetDisMatchVerticalByXy(tvCen.m_v1);
	if(dDist > 0)
		dDistDiff *= -1;

	return dDistDiff;
}

// 주철근 사보강 배치시 전단철근 배치
void CRcBridgeRebar::GetTvRebarShear_Plane_UpperSlab_Vert(CTwinVectorArray &tvArr, BOOL bForBM, BOOL bNormal, BOOL bHunch, BOOL bRib)
{
	tvArr.RemoveAll();

	BOOL bVertDir	= IsVertDir();
	if(!bVertDir) 
	{
		GetTvRebarShear_Plane_UpperSlab(tvArr, bForBM, bNormal, bHunch);
		return;
	}

	CLineInfo *pLine	= GetLineBase(bVertDir);
	
	double dDiffSta		= m_dStationBridgeStt;

	// 전단철근 배치된 스테이션 찾는다.
	CTwinVectorArray tvArrShear, tvArrShear2, tvArrShearHunch, tvArrRib, tvArrTot;
	CDoubleArray dArrSta;
	GetTvRebarShear_VertSection_UpperSlab(tvArrShear, tvArrShearHunch, tvArrRib, -1);
	if(bNormal)
		tvArrTot.AddFromTvArray(tvArrShear);
	if(bHunch)
		tvArrTot.AddFromTvArray(tvArrShearHunch);
	if(bRib)
		tvArrTot.AddFromTvArray(tvArrRib);

	long i = 0; for(i = 0; i < tvArrTot.GetSize(); i++)
		dArrSta.Add(tvArrTot.GetAt(i).m_v1.x - dDiffSta);
	dArrSta.Sort();

	// 기준으로 삼을 각 전단철근의 dDist를 구한다.(직거리 중심선형 기준)
	CDoubleArray dArrDist;
	CTwinVectorArray tvArrCross;
	GetTvCrossSection(tvArrCross, m_dStationBridgeStt, CDPoint(0, 1), FALSE, FALSE, FALSE, 0, FALSE, FALSE);
	CDRect rect	= tvArrCross.GetRect();
	CDPoint xyMid	= CDPoint(rect.left+rect.Width()/2, rect.top);

	CDPoint vAng	= CDPoint(0, 1);
	GetTvRebarShear_CrossSection_UpperSlab(tvArrShear, tvArrShear2, m_dStationBridgeStt, 0, FALSE);

	// GetTvRebarShear_CrossSection_UpperSlab는 횡단면도 그리는 용도로 mirror된 상태이다.
	// 이걸 정상으로 하기 위해 기호를 뒤집는다.
	for(i = 0; i < tvArrShear.GetSize(); i++)
		dArrDist.Add((tvArrShear.GetAt(i).m_v1.x-xyMid.x)/vAng.y*-1);

	// 스테이션 별로 돌아가면서 전단철근 구함.
	CTwinVector tv;
//	double dSta			= 0;
	double dDist		= 0;
	double dLenShear	= GetLenShearUpperSlab();
	BOOL bAddAtFirst	= TRUE;
	double dDiff		= GetDistDiffOfMidInVert();
	vAng				= GetAngleJijum(0);
	
	double dWS				= IsOutWall(TRUE) ? m_dWS : 0;
	double dDistLeftMax		= -GetWidthSlabAct(m_dStationBridgeStt-dWS, CDPoint(0, 1), -1, FALSE, TRUE) + dDiff;
	double dDistRightMax	= GetWidthSlabAct(m_dStationBridgeStt-dWS, CDPoint(0, 1), -1, FALSE, TRUE) + dDiff;
	BOOL bVertLeft			= TRUE;
	BOOL bVertRight			= TRUE;

// 	vAng					= GetAngleJijum(0);
	double dStaOrg			= -dWS;
	CTwinVector tvStt		= GetTvJijum(0, -dWS/vAng.y);
	long nCountSta	= dArrSta.GetSize();
	for(long sta = 0; sta < nCountSta; sta++)
	{
		double dSta			= 0;
		dSta	= dArrSta.GetAt(sta);

		long nIdxStt	= bAddAtFirst ? 0 : 1;
		for(long dist = nIdxStt; dist < dArrDist.GetSize()-(nIdxStt+1); dist+=2)
		{
			dDist	= dArrDist.GetAt(dist)/vAng.y;
			dDist	+= dDiff;

			bVertLeft	= FALSE;
			bVertRight	= FALSE;

			if(dDistLeftMax + m_dDistLeftDirPlacing > dDist)
				bVertLeft	= TRUE;
			else if(dDistRightMax - m_dDistRightDirPlacing < dDist)
				bVertRight	= TRUE;

			if(bVertLeft || bVertRight)
			{
				CDPoint xyDir	= GetXyDirRebarMainPlaneForSabogang(bVertLeft ? -1 : 1);
				tv.m_v1	= pLine->GetXyLineDis(dStaOrg, dDist);
				tv.m_v1	= tv.m_v1 + xyDir * (dSta - dStaOrg)/vAng.y;
				tv.m_v2	= tv.m_v1 + vAng * dLenShear;
			}
			else
			{
				tv.m_v1	= pLine->GetXyLineDis(dSta, dDist);
				tv.m_v2	= pLine->GetXyLineDis(dSta, dDist-dLenShear);
			}

			if(sta == 0)
				tv.m_sInfo	= "시작1";
			else if(sta == 1)
				tv.m_sInfo	= "시작2";
			else if(sta == nCountSta-2)
				tv.m_sInfo	= "끝1";
			else if(sta == nCountSta-1)
				tv.m_sInfo	= "끝2";
			else
				tv.m_sInfo	= "";
				 
			tvArr.Add(tv);
		}

		bAddAtFirst	= !bAddAtFirst;
	}
}

// RC 생성시 앞뒤 지름과 위치 참조해서 이음 길이 알아내기.
// BOOL bReverse : 철근 시작지점 이음 길이 산정
double CRcBridgeRebar::GetValueJoint(CRebarInfoCycle *pRCCur, double dDiaNext, CRebarInfoCycle *pRCNext, long nVertDir, BOOL bReverse)
{	
	if(!pRCCur) return 0;
	if(Compare(pRCCur->m_Dia, 0.0, "<=") && Compare(dDiaNext, 0.0, "<=")) return 0;

	double dCover	= 0;
	double dSpace	= m_dCTC_MainRebar/2;
	BOOL bTensionUpper		= FALSE;
	SRebarEnvOption LsdRebarOpt;
	
	// 철근이 시점벽체에서 종점벽체까지 한번에 이어지면 슬래브 이음 없다.
	if(((!bReverse && pRCCur->m_nPosStt == REBARINFO_POS_STTWALL_OUTTER) || (bReverse && pRCCur->m_nPosEnd == REBARINFO_POS_ENDWALL_OUTTER))
		&& (pRCCur->m_nPosStt == REBARINFO_POS_UPPERSLAB_UPPER || pRCCur->m_nPosEnd == REBARINFO_POS_UPPERSLAB_UPPER || pRCCur->m_nPosStt == REBARINFO_POS_LOWERSLAB_LOWER || pRCCur->m_nPosEnd == REBARINFO_POS_LOWERSLAB_LOWER) )
	{
		BOOL bUpperSlabe(TRUE);
		dCover	= m_dCoverWallOut[0];
		bTensionUpper	= FALSE;
		if(pRCCur->m_nPosStt == REBARINFO_POS_UPPERSLAB_UPPER || pRCCur->m_nPosEnd == REBARINFO_POS_UPPERSLAB_UPPER)
		{
			dCover	= m_dCoverUpper_UpperSlab[0];
			bTensionUpper	= TRUE;
			bUpperSlabe		= TRUE;
		}
		if(pRCCur->m_nPosStt == REBARINFO_POS_LOWERSLAB_LOWER || pRCCur->m_nPosEnd == REBARINFO_POS_LOWERSLAB_LOWER)
		{
			dCover	= m_dCoverLower_LowerSlab[0];
			bTensionUpper	= FALSE;
			bUpperSlabe		= FALSE;
		}

		SetRebarLsdOptionSlab(&LsdRebarOpt, bUpperSlabe, bUpperSlabe, TRUE, 0, 0);
	}
	else if(pRCCur->m_nPosStt == REBARINFO_POS_UPPERSLAB_LOWER || pRCCur->m_nPosEnd == REBARINFO_POS_UPPERSLAB_LOWER) 
	{
		dCover	= m_dCoverLower_UpperSlab[0];
		bTensionUpper	= FALSE;

		BOOL bUpperSlabe = (pRCCur->m_nPosStt == REBARINFO_POS_UPPERSLAB_LOWER || pRCCur->m_nPosEnd ==REBARINFO_POS_UPPERSLAB_LOWER)? TRUE : FALSE;
		SetRebarLsdOptionSlab(&LsdRebarOpt, TRUE, !bUpperSlabe, TRUE, 0, 0);
	}
	else if(pRCCur->m_nPosStt == REBARINFO_POS_STTWALL_OUTTER || pRCCur->m_nPosEnd == REBARINFO_POS_STTWALL_OUTTER || pRCCur->m_nPosEnd == REBARINFO_POS_ENDWALL_OUTTER) 
	{
		// pRCCur->m_nPosStt == REBARINFO_POS_STTWALL_OUTTER 인경우는 Box타입 인경우 Stt가 시점벽체 End가 하부 슬래브
		dCover	= m_dCoverWallOut[0];
		bTensionUpper	= FALSE;

		BOOL bSttWall = (pRCCur->m_nPosEnd == REBARINFO_POS_STTWALL_OUTTER)? TRUE : FALSE;
		SetRebarLsdOptionOutWall(&LsdRebarOpt, bSttWall, FALSE, TRUE, 0, 0);
	}
	else if(pRCCur->m_nPosStt == REBARINFO_POS_UPPERSLAB_UPPER || pRCCur->m_nPosStt == REBARINFO_POS_UPPERSLAB_SIDE) 
	{
		dCover	= m_dCoverUpper_UpperSlab[0];
		bTensionUpper	= TRUE;

		SetRebarLsdOptionSlab(&LsdRebarOpt, TRUE, TRUE, TRUE, 0, 0);
	}
	else if(pRCCur->m_nPosEnd == REBARINFO_POS_STTWALL_INNER || pRCCur->m_nPosEnd == REBARINFO_POS_ENDWALL_INNER) 
	{
		dCover	= m_dCoverWallIn[0];
		bTensionUpper	= FALSE;

		BOOL bSttWall = (pRCCur->m_nPosEnd == REBARINFO_POS_STTWALL_INNER)? TRUE : FALSE;
		SetRebarLsdOptionOutWall(&LsdRebarOpt, bSttWall, TRUE, TRUE, 0, 0);
	}
	else if(pRCCur->m_nPosStt == REBARINFO_POS_ARCHRIB_UPPER || pRCCur->m_nPosEnd == REBARINFO_POS_ARCHRIB_UPPER)
	{
		dCover	= m_dCoverRib[iUPPER][0];
		bTensionUpper	= TRUE;
	}
	else if(pRCCur->m_nPosStt == REBARINFO_POS_ARCHRIB_LOWER || pRCCur->m_nPosEnd == REBARINFO_POS_ARCHRIB_LOWER)
	{
		dCover	= m_dCoverRib[iLOWER][0];
		bTensionUpper	= TRUE;
	}
	else if(pRCCur->m_nPosStt == REBARINFO_POS_LOWERSLAB_LOWER || pRCCur->m_nPosEnd == REBARINFO_POS_LOWERSLAB_LOWER) 
	{
		dCover	= m_dCoverLower_LowerSlab[0];
		// bTensionUpper는 이음타입을 결정하는 것이기 하부슬래브라고 해서 대칭이 되는건 아니고 무조건 상면이 TRUE.
		bTensionUpper	= FALSE;

		SetRebarLsdOptionSlab(&LsdRebarOpt, FALSE, FALSE, TRUE, 0, 0);
	}
	else if(pRCCur->m_nPosStt == REBARINFO_POS_LOWERSLAB_UPPER || pRCCur->m_nPosEnd == REBARINFO_POS_LOWERSLAB_UPPER) 
	{
		dCover	= m_dCoverUpper_LowerSlab[0];
		bTensionUpper	= TRUE;

		SetRebarLsdOptionSlab(&LsdRebarOpt, FALSE, TRUE, TRUE, 0, 0);
	}

	double dLenJoint(0);
	if(m_pARcBridgeDataStd->IsLsdDesign())
	{
		if(pRCCur->m_nPosEnd == REBARINFO_POS_INWALL_LEFT || pRCCur->m_nPosEnd == REBARINFO_POS_INWALL_RIGHT)
		{
			CWallApp *pWall	= GetInWall(0);
			if(pWall)
			{
				pWall->SetRebarLsdOption(&LsdRebarOpt, TRUE, TRUE, 0, 0);
			}
			dLenJoint	= pWall->GetValueJoint(pRCCur, dDiaNext);
		}

		dLenJoint = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueJoint(max(pRCCur->m_Dia, dDiaNext), &LsdRebarOpt);
	}
	else
	{
		if(pRCNext)
		{
			if(pRCNext->m_nPosStt == REBARINFO_POS_UPPERSLAB_UPPER)
				bTensionUpper	= TRUE;
		}

		if(m_nSelectJointUpperRange == 2) bTensionUpper = FALSE;

		long nType			= bTensionUpper ? JOINT_TENS_UPPER_B : JOINT_TENS_NORMAL_B;
		dLenJoint	= m_pARcBridgeDataStd->GetValueJoint(max(pRCCur->m_Dia, dDiaNext), nType, dCover/10, dSpace/10);

		// 내측벽체인지 여기서 판단함.(치수 기입시 필요해서 따로 여기다 둠)
		CWallApp *pWall	= GetInWall(0);
		if(pWall)
		{
			if(pRCCur->m_nPosEnd == REBARINFO_POS_INWALL_LEFT || pRCCur->m_nPosEnd == REBARINFO_POS_INWALL_RIGHT)
			{
				dLenJoint	= pWall->GetValueJoint(pRCCur, dDiaNext);
			}
		}
	}

	// 주철근 이음 위치는 직거리 사거리 두가지 방법으로 입력받는다.
	// 사거리인 경우 직거리로 구해야 될 때도 있고, 직거리인데 사거리로 구해야 될때도 있다.
	// 일단 사각은 시점각도만을 고려한다.
	dLenJoint	= GetLengthBynVertDir(dLenJoint, nVertDir);

	return dLenJoint;
}



double CRcBridgeRebar::GetCTCRebarSupport_Slab(BOOL bUpperSlab, BOOL bUpper, long nDan, BOOL bStd)
{
	long upper	= bUpper ? iUPPER : iLOWER;
	CPlaceRebarByBlock *pPlace	= bUpperSlab? &m_placeByBlock_SupportRebar_UpperSlab[upper][nDan] : &m_placeByBlock_SupportRebar_LowerSlab[upper][nDan];

	if(pPlace->m_xyArr.GetSize() == 0 || bStd)
		return m_dCTC_SupportRebar[bUpperSlab ? iUPPER : iLOWER];
	else
		return pPlace->GetCTC();
}

// 외측벽체 외측 철근을 상부슬래브와 연결이 가능한지 판단.
BOOL CRcBridgeRebar::IsEnableJointMainRebar_OutWallOutterAndUpperSlabUpper(BOOL bStt, BOOL bCycle13)
{
	long stt	= bStt ? iSTT : iEND;

	long nCountJointUpperSlab	= 0;
	long i = 0; for(i = 0; i < m_nQtyJigan; i++)
		nCountJointUpperSlab += bCycle13 ? m_nCountJointMainRebar_UpperSlab_Cycle1[i][iUPPER][0] : m_nCountJointMainRebar_UpperSlab_Cycle2[i][iUPPER][0];

	// 일단 상부슬래브 이음이 없으면 리턴
	if(nCountJointUpperSlab == 0) return FALSE;
	if(bCycle13 && m_nCountJointMainRebar_OutWall_Cycle1[stt][iOUTTER][0] != 0) return FALSE;
	else if(!bCycle13 && m_nCountJointMainRebar_OutWall_Cycle2[stt][iOUTTER][0] != 0) return FALSE;

	return TRUE;
}

// 상부슬래브와 외측벽체가 연결된 형태의 철근인지 판단한다.
BOOL CRcBridgeRebar::IsMainRebarJointUpperSlabAndOutWall(CRebarInfoCycle *pRC, BOOL &bStt)
{
	if(!pRC) return FALSE;

	BOOL bOK	= FALSE;
	if((pRC->m_nPosStt == REBARINFO_POS_FOOTING_LOWER && pRC->m_nPosEnd == REBARINFO_POS_UPPERSLAB_UPPER))
	{
		bOK		= TRUE;
		bStt	= TRUE;
	}
	else if(pRC->m_nPosStt == REBARINFO_POS_UPPERSLAB_UPPER && pRC->m_nPosEnd == REBARINFO_POS_FOOTING_LOWER)
	{
		bOK		= TRUE;
		bStt	= FALSE;
	}

	return bOK;
}

// 상부슬래브가 철근이 일체로 된 형태인지?
BOOL CRcBridgeRebar::IsMainRebarJointUpperSlabAndUpperSlab(CRebarInfoCycle *pRC)
{
	if(!pRC) return FALSE;

	BOOL bOK	= FALSE;
	if(pRC->m_nPosStt == REBARINFO_POS_STTWALL_OUTTER && pRC->m_nPosEnd == REBARINFO_POS_ENDWALL_OUTTER)
		bOK	= TRUE;

	return bOK;
}

// 가각부 주철근 지름 리턴
double CRcBridgeRebar::GetDiaMainRebarGagak(BOOL bStt, BOOL bLeft)
{
	double dDia	= 22;	// 현재 고정(입력을 안 받아서)
	return dDia;
}

// 가각부 주철근 간격
// 좌측이든 우측이든 외측부터 안쪽으로 들어가는 거리임(슬래브 끝에서 구함)
void CRcBridgeRebar::GetDistRebarMain_CrossSection_OutWallExp(CDoubleArray &dArrCycle1, CDoubleArray &dArrCycle2, CDoubleArray &dArrCycle12, CDoubleArray &dArrCycle22, CDoubleArray &dArrCycle1Inner, CDoubleArray &dArrCycle2Inner, BOOL bStt, BOOL bLeft, long nDan, BOOL bUpper)
{
	dArrCycle1.RemoveAll();
	dArrCycle2.RemoveAll();
	dArrCycle12.RemoveAll();
	dArrCycle22.RemoveAll();
	dArrCycle1Inner.RemoveAll();
	dArrCycle2Inner.RemoveAll();
	if(!IsGagakForLine(bStt, bLeft)) return;

	long stt	= bStt ? iSTT : iEND;
	long left	= bLeft ? iLEFT : iRIGHT;

	CTwinVectorArrayArray pTvArrCycle1[2];
	CTwinVectorArrayArray pTvArrCycle2[2];
	CTwinVectorArray tvArrCycle1Hunch, tvArrCycle2Hunch;
	CDPointArray xyArrCycle1, xyArrCycle2;
	long type = 0;

	GetTvRebarMain_Plane_Slab_Exp(TRUE, &pTvArrCycle1[0], &pTvArrCycle2[0], &pTvArrCycle1[1], &pTvArrCycle2[1], bStt, bLeft, nDan, bUpper, tvArrCycle1Hunch, tvArrCycle2Hunch, FALSE, xyArrCycle1, xyArrCycle2);


	if((!m_bLineDirRebarOfExp[stt][left] && pTvArrCycle1[0].GetSize() == 0) ||
		(m_bLineDirRebarOfExp[stt][left] && pTvArrCycle2[0].GetSize() == 0)) 
	{
		for(type = 0; type < 2; type++)
		{
			AhTPADelete(&pTvArrCycle1[type], (CTwinVectorArray*)0);
			AhTPADelete(&pTvArrCycle2[type], (CTwinVectorArray*)0);
		}
		return;
	}

	CTwinVector tvStt, tvEnd;
	GetTvSttEndOfSlab(tvStt, tvEnd);

	CTwinVector tvSttOffset, tvEndOffset;
	BOOL bCutEnd = (bStt)? m_bExpCutStt[bLeft? 0:1] : m_bExpCutEnd[bLeft? 0:1];
	CTwinVectorArray tvArrPlaneOffset;
	GetTvRebarOut_Plane_UpperSlabStd(tvArrPlaneOffset, 0, TRUE,2,TRUE, bCutEnd);
	if(!tvArrPlaneOffset.GetTvByInfo("시점", tvSttOffset)) return;
	if(!tvArrPlaneOffset.GetTvByInfo("종점", tvEndOffset)) return;


	// 슬래브 끝점(시작점)
	CDPoint xyStt	= bStt ? (bLeft ? tvStt.m_v2 : tvStt.m_v1) : (bLeft ? tvEnd.m_v2 : tvEnd.m_v1);
	CDPoint xyDir	= bStt ? tvStt.GetXyDir() : tvEnd.GetXyDir();
	CTwinVectorArray tvArrPlaneExp;
	GetTvPlaneOfExp(tvArrPlaneExp, bStt, bLeft, -1);
	CDPointArray xyArrMatch;
	CRebarPlacing rb;
	CTwinVectorArray *pTvArrTmp	= NULL;
	if(m_bLineDirRebarOfExp[stt][left] && pTvArrCycle2[0].GetSize() > 0)
	{
		pTvArrTmp	= pTvArrCycle2[0].GetAt(0);
	}
	else
	{
		pTvArrTmp	= pTvArrCycle1[0].GetAt(0);
	}
	if(pTvArrTmp->GetSize() == 0) 
	{
		for(type = 0; type < 2; type++)
		{
			AhTPADelete(&pTvArrCycle1[type], (CTwinVectorArray*)0);
			AhTPADelete(&pTvArrCycle2[type], (CTwinVectorArray*)0);
		}
		return;
	}
	CDPoint xySttRebar	= pTvArrTmp->GetAt(0).m_v1;
	CDPoint xyEndRebar	= pTvArrTmp->GetAt(pTvArrTmp->GetSize()-1).m_v2;
	if(~(xyStt - xySttRebar) > ~(xyStt - xyEndRebar))
		GetSwap(xySttRebar, xyEndRebar);
	rb.GetXyMatchTvArrAndLine(tvArrPlaneExp, xySttRebar, xyDir, xyArrMatch);
	if(xyArrMatch.GetSize() == 0)
	{
		for(type = 0; type < 2; type++)
		{
			AhTPADelete(&pTvArrCycle1[type], (CTwinVectorArray*)0);
			AhTPADelete(&pTvArrCycle2[type], (CTwinVectorArray*)0);
		}
		return;
	}
	xyStt	= xyArrMatch.GetAt(0);

	//#0029484 xyStt의 위치값이 잘못되어 있다. pTvArr의 철근이 구조물선까지 배치가 되지 않고 중간에 끊기게 되면 이격거리를 잘못가져오게 된다. 외측벽체에서 부터 철근의 이격거리를 가져올수 있도록 수정
	{
		CDPoint xy = bStt ? (bLeft ? tvStt.m_v2 : tvStt.m_v1) : (bLeft ? tvEnd.m_v2 : tvEnd.m_v1);
		CDPoint xyAng =  GetAngleCutGagakEnd(bStt, bLeft);
		GetXyMatchLineAndLine(xy, xyAng, xyStt, GetAngleAzimuthJijum(bStt ? 0 : m_nQtyJigan), xyStt);
	}

	if(xyArrCycle1.GetSize() > 0)
	{
		CDPoint xySttInner	= xyStt;
		rb.GetXyMatchTvArrAndLine(tvArrPlaneExp, xyArrCycle1.GetAt(0), GetAngleAzimuthJijum(bStt ? 0 : m_nQtyJigan), xyArrMatch);
		if(xyArrMatch.GetSize() > 0)
			xySttInner	= xyArrMatch.GetAt(0);


		pTvArrTmp	= NULL;
		CDPoint xyMatch(0, 0);
		CTwinVectorArrayArray *pTvArr	= NULL;
		CDoubleArray *pDArr	= NULL;
		long nSize	= 0;
		CTwinVector tvSttEndForMatch	= bStt ? tvSttOffset : tvEndOffset;
		long cycle = 0; for(cycle = 0; cycle < 2; cycle++)
		{
			for(type = 0; type < 2; type++)
			{
				pTvArr	= cycle == 0 ? &pTvArrCycle1[type] : &pTvArrCycle2[type];
				pDArr	= cycle == 0 ? (type == 0 ? &dArrCycle1 : &dArrCycle12) 
														: (type == 0 ? &dArrCycle2 : &dArrCycle22);

				// type2 철근은 치수표시 하지 말자.
				if(type == 1) continue;

				nSize	= pTvArr->GetSize();
				if(nSize == 0) continue;

				long i = 0; for(i = 0; i < nSize; i++)
				{
					pTvArrTmp	= pTvArr->GetAt(i);
					if(pTvArrTmp->GetSize() == 0) continue;

					rb.GetXyMatchTvArrAndLine(*pTvArrTmp, tvSttEndForMatch.m_v1, tvSttEndForMatch.GetXyDir(), xyArrMatch);
					if(xyArrMatch.GetSize() > 0)
						xyMatch	= xyArrMatch.GetAt(0);
					else
						continue;
					//xyMatch	= pTvArrTmp->GetAt(0).m_v1;

					
					if(bStt && m_bExpCutStt[left] || !bStt && m_bExpCutEnd[left])
					{
						CDPoint xyDirCut	=  GetAngleCutGagakEnd(bStt, bLeft);
						GetXyMatchLineAndLine(xyMatch, xyDirCut, xyStt, GetAngleAzimuthJijum(bStt ? 0 : m_nQtyJigan), xyMatch);
					}
				

					double dDist	= ~(xyMatch-xyStt);

					pDArr->Add(dDist);
				}

				// 피복을 넣어주자.
				// 가각부 철근만으로 피복철근을 표시할 수는 없다.
				pDArr->Add(GetCoverSide_UpperSlab(0));

				pDArr->RemoveSameValue(1);
				pDArr->Sort();
			}
		}

		// 내측
		CDPointArray *pXyArr;
		for(cycle = 0; cycle < 2; cycle++)
		{
			pXyArr	= cycle == 0 ? &xyArrCycle1: &xyArrCycle2;
			pDArr	= cycle == 0 ? &dArrCycle1Inner : &dArrCycle2Inner;
			nSize	= pXyArr->GetSize();
			if(nSize == 0) continue;


			long i = 0; for(i = 0; i < nSize; i++)
			{		
				xyMatch	= pXyArr->GetAt(i);
				pDArr->Add(~(xyMatch-xySttInner));
			}

			// 피복을 넣어주자.
			// 가각부 철근만으로 피복철근을 표시할 수는 없다.
			pDArr->Add(GetCoverSide_UpperSlab(0));

			pDArr->RemoveSameValue(1);
			pDArr->Sort();
		}
	}


	for(type = 0; type < 2; type++)
	{
		AhTPADelete(&pTvArrCycle1[type], (CTwinVectorArray*)0);
		AhTPADelete(&pTvArrCycle2[type], (CTwinVectorArray*)0);
	}

	// 선형방향 배치일 경우 중복되는게 잇을 수 있다. 중복된거 없애고, 1Cycle 2Cycle을 골고루 다시 분배한다
	if(m_bLineDirRebarOfExp[stt][left])
	{
		CDoubleArray dArr;
		long i = 0; for(i = 0; i < dArrCycle1.GetSize(); i++)
			dArr.Add(dArrCycle1.GetAt(i));
		for(i = 0; i < dArrCycle2.GetSize(); i++)
			dArr.Add(dArrCycle2.GetAt(i));

		dArrCycle1.RemoveAll();
		dArrCycle2.RemoveAll();
		dArr.Sort();
		for(i = 0; i < dArr.GetSize()-1; i++)
		{
			if(dArr.GetAt(i) == dArr.GetAt(i+1))
			{
				dArr.RemoveAt(i);
				i--;
			}
		}

		for(i = 0; i < dArr.GetSize(); i++)
		{
// 			if(i % 2 == 0)
// 				dArrCycle1.Add(dArr.GetAt(i));
// 			else
// 				dArrCycle2.Add(dArr.GetAt(i));
			// 가각부 철근은 1,2Cycle 구분이 없다.
			dArrCycle1.Add(dArr.GetAt(i));
		}
	}
}

// 외측벽체 가각부 철근
// 무조건 바깥쪽에서 안쪽으로 간격만큼 들어오면서 배근(상면만 해당됨)
// CTwinVectorArray &tvArrCycle12, CTwinVectorArray &tvArrCycle22 : 상부슬래브와 연결된 철근에서만 발생 가능함(가각 끝단 꺽기 했을때)
void CRcBridgeRebar::GetTvRebarMain_CrossSection_OutWallExp(CTwinVectorArray &tvArrCycle1, CTwinVectorArray &tvArrCycle2, CTwinVectorArray &tvArrCycle12, CTwinVectorArray &tvArrCycle22, CTwinVectorArray &tvArrJoint, BOOL bStt, BOOL bLeftWall, BOOL bInner, long nDan, long nIdx, BOOL bLeft)
{
	tvArrCycle1.RemoveAll();
	tvArrCycle2.RemoveAll();
	tvArrCycle12.RemoveAll();
	tvArrCycle22.RemoveAll();
	tvArrJoint.RemoveAll();
	if(!IsGagakForLine(bStt, bLeftWall)) return;

	CDoubleArray dArrCycle1[2], dArrCycle2[2];
	CDoubleArray dArrCycle1Inner, dArrCycle2Inner;
	GetDistRebarMain_CrossSection_OutWallExp(dArrCycle1[0], dArrCycle2[0], dArrCycle1[1], dArrCycle2[1], dArrCycle1Inner, dArrCycle2Inner, bStt, bLeftWall, nDan, TRUE);

	CTwinVectorArray tvArrWall;
	GetTvCrossSection_OutWall_Exp(tvArrWall, bStt, bLeftWall, bInner, bLeft);

	CTwinVector tvOut	= tvArrWall.GetTvByInfo(bLeft == bLeftWall ? "벽체좌측" : "벽체우측");
	double sw			= bLeft == bLeftWall ? 1 : -1;
	BOOL bToUpperSlab	= FALSE;
	CRebarPlacing rb;

	CTwinVectorArray tvArrUpper;
	double dSta	= GetStationByTarget(bStt ? BRIDGE_OFF_STT_SLAB : BRIDGE_OFF_END_SLAB, 0, FALSE);
	CDPoint vAng	= GetAngleByTarget(bStt ? BRIDGE_OFF_STT_SLAB : BRIDGE_OFF_END_SLAB, 0);
	if(m_nTypeWallForRebarGen == 0)
	{
		dSta	= GetStationByTarget(bStt ? BRIDGE_OFF_STT_SLAB : BRIDGE_OFF_END_SLAB, 0, TRUE);
		vAng	= GetAngleByTarget(bStt ? BRIDGE_OFF_STT_SLAB : BRIDGE_OFF_END_SLAB, 0);
	}
	else if(m_nTypeWallForRebarGen == 1)
	{
		dSta	= GetStationByTarget(bStt ? BRIDGE_OFF_STT_STT : BRIDGE_OFF_END_END, 0, TRUE);
		vAng	= GetAngleByTarget(bStt ? BRIDGE_OFF_STT_STT : BRIDGE_OFF_END_END, 0);
	}
	GetTvCrossSection(tvArrUpper, dSta, vAng, FALSE, FALSE, FALSE, 0, FALSE, FALSE, FALSE, TRUE);
	if(!bLeft)
		rb.Mirror(tvArrUpper, CDPoint(GetMidCrossSection(FALSE), 0), TRUE);
	if(!bStt)
	{
		double dELDiff	= GetDiffELSttAndJijumForVertSection(m_nQtyJigan, FALSE);
		if(dELDiff != 0)
			rb.MoveRebar(tvArrUpper, CDPoint(0, -dELDiff));
	}

	CWallApp wall;
	MakeWallByOutWall(wall, bStt, TRUE);

	// 벽체 끝에서 들어감.
	BOOL bLeftSide = (bInner != bStt)? TRUE : FALSE;
	CDoubleArray *pDArr;
	CTwinVectorArray *pTvArr;
	CTwinVectorArray *pTvArrJoint;
	long cycle = 0; for(cycle = 0; cycle < 2; cycle++)
	{
		bToUpperSlab	= FALSE;

		long nSizeRC = wall.m_pArrRCMain[cycle][bLeftSide? iLEFT:iRIGHT][nDan].GetSize();
		if(nIdx >= nSizeRC) continue;

		// rc의 정보와 nIdx에 따라서 철근의 길이가 바뀜. ///////////////
		CRebarInfoCycle *pRC	= wall.GetRebarInfoCycle(cycle, nDan, bLeftSide, nIdx);
		if(!pRC) continue;
		if(!pRC->m_bExist) continue;
		if(bInner)
		{
			if(nIdx == nSizeRC-1)
			{
				bToUpperSlab	= TRUE;
			}
		}
		else
		{
			if(nIdx == nSizeRC-1 && pRC->GetLengthEnd())
			{
				bToUpperSlab = TRUE;
			}
		}

		double dYLower	= pRC->m_xyStt.y;
		double dYUpper	= pRC->m_xyEnd.y;
		if(pRC->m_bUseEndExt) dYUpper	= pRC->m_xyEndExt.y;

		// 이음
		CRebarInfoCycle *pRCNext	= wall.GetRebarInfoCycle(cycle, nDan, bLeftSide, nIdx+1);

		BOOL bJoint	= FALSE;
		double dYLowerJoint	= 0;
		double dYUpperJoint	= 0;

		if(pRCNext)
		{
			if(pRCNext->m_bExist)
			{
				dYLowerJoint	= pRCNext->m_xyStt.y;
				dYUpperJoint	= pRCNext->m_xyEnd.y;
				if(pRCNext->m_bUseEndExt) dYUpperJoint	= pRCNext->m_xyEndExt.y;
				if(dYLowerJoint > dYUpperJoint) GetSwap(dYLowerJoint, dYUpperJoint);

				if(dYLowerJoint < dYUpper)
				{
//					dYLowerJoint	= dYLowerJoint;
					dYUpperJoint	= dYUpper;
					bJoint	= TRUE;
				}
			}
		}
		else if(Compare(dYUpper, dYLower, _T("="), 0.1) && nSizeRC == 2) //pRCNext == NULL
		{
			double dMin_Y = 0, dMax_Y =0;
			dMin_Y = min(min(pRC->m_xyEnd.y , pRC->m_xyEndExt.y), pRC->m_xyStt.y);
			dMax_Y = max(max(pRC->m_xyEnd.y , pRC->m_xyEndExt.y), pRC->m_xyStt.y);

			double dLenRound	= nIdx == 0 ? (pRC->m_xyMid2.y - pRC->m_xyMid1.y) : 
				(pRC->m_bUseEndExt ? (pRC->m_xyMidExt.y - pRC->m_xyEnd.y) : (pRC->m_xyMid2.y - pRC->m_xyMid1.y));
			dLenRound = fabs(dLenRound);

			if(Compare(dMin_Y, dYLower, _T("="),0.1) == FALSE)
				dYLower = dMin_Y ;
			if(Compare(dMax_Y, dYUpper, _T("="),0.1) == FALSE)
				dYUpper = dMax_Y;				
		}
		/////////////////////////////////////////////////////////////////
	

		long type = 0; for(type = 0; type < 2; type++)
		{
			if(bInner && type == 1) continue;

			pDArr	= cycle == 0 ? (bInner ? &dArrCycle1Inner : &dArrCycle1[type]) : (bInner ? &dArrCycle2Inner : &dArrCycle2[type]);
			pTvArr	= cycle == 0 ? (type == 0 ? &tvArrCycle1 : &tvArrCycle12) 
								: (type == 0 ? &tvArrCycle2 : &tvArrCycle22);
			pTvArrJoint	= &tvArrJoint;

			if(!bToUpperSlab && !bInner)
			{
				if(type == 0)
				{
					CDoubleArray *pDArrOther	= cycle == 0 ? &dArrCycle1[1] : &dArrCycle2[1];
					long i = 0; for(i = 0; i < pDArrOther->GetSize(); i++)
						pDArr->Add(pDArrOther->GetAt(i));
					pDArr->Sort();
				}
				else
					pDArr->RemoveAll();
			}

			CDPointArray xyArrMatch;
			CTwinVector tv;
//			double dDist	= 0;
			long nSize		= pDArr->GetSize();
			long i = 0; for(i = 0; i < nSize; i++)
			{
				double dDist	= 0;
				dDist	= pDArr->GetAt(i) * sw;
				tv.m_v1	= CVector(tvOut.m_v1.x + dDist, dYLower, 0);
				tv.m_v2	= CVector(tvOut.m_v2.x + dDist, dYUpper, 0);

				if(bToUpperSlab)
				{
					rb.GetXyMatchTvArrAndLine(tvArrUpper, tv.m_v1, tv.GetXyDir(), xyArrMatch);
					if(xyArrMatch.GetSize() > 0)
					{
						tv.m_v2	= xyArrMatch.GetAt(0);
						tv.m_v2.y -= m_dCoverUpper_UpperSlab[0];
					}
				}

				pTvArr->Add(tv);

				// 이음도 함께 해요.
				if(bJoint)
				{
					tv.m_v1	= CVector(tvOut.m_v1.x + dDist + -m_dGapJoint, dYLowerJoint, 0);
					tv.m_v2	= CVector(tvOut.m_v2.x + dDist + -m_dGapJoint, dYUpperJoint, 0);
					pTvArrJoint->Add(tv);
				}
			}
		}
	}

	// 상부슬래브까지 뻗는것이 아니라면 무조건 한 변수에 몰아 넣는다.(철근 구분해서 집계할 필요가 없기 때문임)
	if(!bToUpperSlab)
	{
		tvArrCycle1.AddFromTvArray(tvArrCycle12);
		tvArrCycle2.AddFromTvArray(tvArrCycle22);

		tvArrCycle12.RemoveAll();
		tvArrCycle22.RemoveAll();
	}
}

// 가각부 주철근 배치의 기준 선 리턴
// 가각부 주철근 배치의 기준선 리턴시 R이 있는 부분이고, 접선방식이 아니고, 끝단 절단이면
// R이 있는  상태로 구한뒤 R의 시작점에서의 접선방향으로 뻗어서 가각부 주철근의 기준선 위치를 구한다.
void CRcBridgeRebar::GetTvMainRebarOrgOfExp(CTwinVectorArray &tvArr, BOOL bStt, BOOL bLeft)
{
	tvArr.RemoveAll();

	long stt	= bStt ? iSTT : iEND;
	long left	= bLeft ? iLEFT : iRIGHT;
	CRebarPlacing rb;

	CTwinVectorArray tvArrPlane;

	if(m_nTypeOrgMainRebarOfExp[stt][left] == 0)	// 좌우측 기준
	{
		GetTvRebarOut_Plane_UpperSlabStd(tvArrPlane, 0, FALSE, 2, TRUE, FALSE);
		CString str	= bLeft ? "좌측" : "우측";
		CTwinVector tv;
		long i = 0; for(i = 0; i < tvArrPlane.GetSize(); i++)
		{
			tv	= tvArrPlane.GetAt(i);
			if(tv.m_sInfo == str)
				tvArr.Add(tv);
		}
	}
	else
	{
		CString str	= _T("");

		CTwinVectorArray tvArrLeft;
		CString strLeft	= bLeft ? "좌측" : "우측";
		CTwinVectorArray tvArrPlaneNormal;
		GetTvRebarOut_Plane_UpperSlabStd(tvArrPlaneNormal, 0, FALSE, 2, TRUE, FALSE);

		// R이 없는 형태의 가각부에서 기준점을 찾는다. ////////////
		double dExpSttR[2]	= {m_dExpSttR[0], m_dExpSttR[1]};
		double dExpEndR[2]	= {m_dExpEndR[0], m_dExpEndR[1]};
				
		m_dExpSttR[0]	= 0;
		m_dExpSttR[1]	= 0;
		m_dExpEndR[0]	= 0;
		m_dExpEndR[1]	= 0;

		str.Format("(%s%s가각부)", bStt ? "시점" : "종점", bLeft ? "좌측" : "우측");
		GetTvRebarOut_Plane_UpperSlabStd(tvArrPlane, 0, TRUE, 2, TRUE, FALSE);

		m_dExpSttR[0]	= dExpSttR[0];
		m_dExpSttR[1]	= dExpSttR[1];
		m_dExpEndR[0]	= dExpEndR[0];
		m_dExpEndR[1]	= dExpEndR[1];
		
		///////////////////////////////////////////////////////////

		CTwinVector tv;
		long i = 0; for(i = 0; i < tvArrPlane.GetSize(); i++)
		{
			tv	= tvArrPlane.GetAt(i);
			if(tv.m_sInfo.Find(str, 0) != -1)
				tvArr.Add(tv);

		}

		for(i = 0; i < tvArrPlaneNormal.GetSize(); i++)
		{
			tv	= tvArrPlaneNormal.GetAt(i);
			if(tv.m_sInfo == strLeft)
				tvArrLeft.Add(tv);
		}


		long nSize	= tvArr.GetSize();
		if(nSize > 0)
		{
			CTwinVector tv	= tvArr.GetAt(0);

			CDPointArray xyArrMatch;
			CDPoint xyOrg	= bStt == bLeft ? tvArr.GetAt(tvArr.GetSize()-1).m_v2 : tvArr.GetAt(0).m_v1;
			rb.GetXyMatchTvArrAndLine(tvArrLeft, tv.m_v1, tv.GetXyDir(), xyArrMatch);
			if(xyArrMatch.GetSize() > 0)
			{
				if(xyArrMatch.GetSize() == 1)
				{
					xyOrg	= xyArrMatch.GetAt(0);
				}
				else
				{
					xyOrg	= ~(xyOrg - xyArrMatch.GetAt(0)) < ~(xyOrg - xyArrMatch.GetAt(1)) ? 
						xyArrMatch.GetAt(0) : xyArrMatch.GetAt(1);
				}
			}
			
			double dSta	= 0;
			CLineInfo *pLine	= GetLineBase();
			pLine->GetStationMatchByXyAndAngle(xyOrg, GetAngleAzimuthJijum(bStt ? 0 : m_nQtyJigan), dSta, 0);

			CDPoint vAng	= bStt ? GetAngleJijum(0) : GetAngleJijum(m_nQtyJigan);
			double dWL	= GetWidthSlabActByGagak(dSta, vAng, -1);
			double dWR	= GetWidthSlabActByGagak(dSta, vAng, 1);

			tv.m_v1	= pLine->GetXyLineByLengthAndAngle(dSta, -dWL, vAng);
			tv.m_v2	= pLine->GetXyLineByLengthAndAngle(dSta, dWR, vAng);
			tv.m_v1.z	= 0;
			tv.m_v2.z	= 0;
			tvArr.RemoveAll();
			tvArr.Add(tv);

			if(bStt)
				rb.ReverseRebar(tvArr);
		}
	}
}

// 상부슬래브 주철근 정보 리턴(마크정보) - 가각부
void CRcBridgeRebar::GetInfoMainRebarExp_UpperSlab(BOOL bStt, BOOL bLeft, BOOL bUpper, long nCycle, long nDan, long nType, CString &sMark, double &dDia, CString &sDescription)
{
	long stt	= bStt ? iSTT : iEND;
	long left	= bLeft ? iLEFT : iRIGHT;
	
	CString sStt	= bStt ? "시점" : "종점";
	CString sLeft	= bLeft ? "좌측" : "우측";
	CString sUpper	= bUpper ? "상면" : "하면";
	CString sCycle	= m_bLineDirRebarOfExp[stt][left] ? (nCycle==0 ? "1" : "2") : (nCycle==0 ? "①" : "②");
	CString sType	= nType==0 ? "1" : "2";

	if(nDan == 0)
		sDescription.Format("상부SLAB %s %s%s 가각부 %s_%s", sUpper, sStt, sLeft, sCycle, sType);
	else
		sDescription.Format("상부SLAB %s %s%s 가각부 %s_%s_%d", sUpper, sStt, sLeft, sCycle, sType, nDan+1);
	long nNum	= 1;
	long upper = 0; for(upper = 0; upper < 2; upper++)
	{
		long stt = 0; for(stt = 0; stt < 2; stt++)
		{
			long left = 0; for(left = 0; left < 2; left++)
			{
				long cycle = 0; for(cycle = 0; cycle < 2; cycle++)
				{
					if(!IsExistMainRebarUpperSlabExp(stt == iSTT, left == iLEFT, upper == iUPPER, cycle)) continue;

					long type = 0; for(type = 0; type < 2; type++)
					{
						if((bStt == (stt==iSTT)) && (bUpper == (upper==iUPPER)) && 
							(bLeft == (left==iLEFT)) && (nCycle == cycle) && 
							(type == nType))
						{
							if(nDan == 0)
								sMark.Format("ET%d", nNum);
							else
								sMark.Format("ET%d_%d", nNum, nDan+1);
							break;
						}
						nNum++;
					}
				}
			}
		}
	}


	// (41631) 철근 구분을 위해 1,2Cycle이 나눠져 있지만 철근 직경은 다 1Cycle 철근을 적용하자.
	CRebarInfoCycle *pRC	= GetRebarInfoCycleUpperSlabCheckExist(nCycle, 0, bUpper, bStt ? 0 : -1);
	if(pRC)
		dDia	= pRC->m_Dia;
}

// 상부슬래브 헌치부 주철근 정보 리턴(마크정보) - 가각부
void CRcBridgeRebar::GetInfoMainRebarExp_UpperSlabHunch(BOOL bStt, BOOL bLeft, long nCycle, CString &sMark, double &dDia, CString &sDescription)
{
	CString sStt	= bStt ? "시점" : "종점";
	CString sLeft	= bLeft ? "좌측" : "우측";
	CString sCycle	= nCycle==0 ? "①" : "②";

	sDescription.Format("상부SLAB 헌치부 %s%s 가각부 %s", sStt, sLeft, sCycle);
	long nNum	= 1;
	long cycle = 0; for(cycle = 0; cycle < 2; cycle++)
	{
		long stt = 0; for(stt = 0; stt < 2; stt++)
		{
			long left = 0; for(left = 0; left < 2; left++)
			{
				if((bStt == (stt==iSTT)) && (bLeft == (left==iLEFT)) && (nCycle == cycle))
				{
					sMark.Format("EH%d", nNum);
					break;
				}
				nNum++;
			}
		}
	}

	long nJ	= bStt ? 0 : m_nQtyJigan;
	CRebarInfoCycle *pRC	= NULL;
	for(long rc = 0; rc < m_pArrRCMainUpperSlabHunch[nCycle].GetSize(); rc++)
	{
		CRebarInfoCycle *pTmp	= m_pArrRCMainUpperSlabHunch[nCycle].GetAt(rc);
		if(pTmp->m_nPosHunch == nJ)
		{
			pRC	= pTmp;
			break;
		}
	}

	if(pRC)
		dDia	= pRC->m_Dia;
}


// 외측벽체 정보리턴
void CRcBridgeRebar::GetInfoMainRebarExp_OutWall(BOOL bStt, BOOL bLeft, BOOL bInner, long nCycle, long nIdx, CString &sMark, double &dDia, CString &sDescription, BOOL bIndexWall)
{
	CString sStt	= bStt ? "시점" : "종점";
	CString sLeft	= bLeft ? "좌측" : "우측";
	CString sInner	= bInner ? "내측" : "외측";
	CString sCycle	= nCycle==0 ? "①" : "②";

	sDescription.Format("%s측벽체 %s %s가각부 %s %d", sStt, sLeft, sInner, sCycle, nIdx+1);
	long nNum	= 1;

	// (40374) 벽체 일때와 상하부 슬래브 철근일때...
	if(bInner == FALSE && !bIndexWall)
	{
		CWallApp wall;
		MakeWallByOutWall(wall, bStt, TRUE);

		long nSide = (bStt != bInner)? iLEFT : iRIGHT;
		long nCountMakeWall = wall.m_pArrRCMain[nCycle][nSide][0].GetSize();
		long nCountOutWall = m_pArrRCMainOutWall[nCycle][bStt? iSTT:iEND][bInner? iINNER:iOUTTER][0].GetSize();

		
		if(nCountMakeWall != nCountOutWall && nCountMakeWall > 0)
		{
			CRebarInfoCycle *pRcMakeWall = wall.m_pArrRCMain[nCycle][nSide][0].GetAt(0);
			CRebarInfoCycle *pRcOutWall = NULL;
			if(nCountOutWall > 0)
				pRcOutWall = m_pArrRCMainOutWall[nCycle][bStt? iSTT:iEND][bInner? iINNER:iOUTTER][0].GetAt(0);

			// 첫번째 철근의 시작위치가 같지 않다면 하부슬래브 철근이 포함되는거겠지~
			// 벽체 철근의 갯수가 0개라면 Box형에 하부슬래브 철근이 포함된 경우 뿐이다. 무조건 하부슬래브 있는거지..
			if(pRcOutWall == NULL || pRcMakeWall->m_xyStt != pRcOutWall->m_xyStt)
			{
				if(nIdx == 0)
				{
					GetInfoMainRebarExp_LowerSlab(bStt, bLeft, FALSE, nCycle, 0, 0, sMark, dDia, sDescription);
					return;
				}

				// 인덱스에서 하부슬래브 철근을 뺀 인덱스로 바꿔주자.
				nIdx--;
			}

			if(nIdx >= nCountOutWall)
			{
				GetInfoMainRebarExp_UpperSlab(bStt, bLeft, TRUE, nCycle, 0, 0, sMark, dDia, sDescription);
				return;
			}
		}
	}
	
	// 상/하부 슬래브 철근이 아니라면 벽체 철근에서 인덱스로 찾는다.
	long stt = 0; for(stt = 0; stt < 2; stt++)
	{
		long left = 0; for(left = 0; left < 2; left++)
		{
			for(long inner = 0; inner < 2; inner++)
			{
				long cycle = 0; for(cycle = 0; cycle < 2; cycle++)
				{
					if(!IsGagakForLine(stt == iSTT, left == iLEFT)) continue;
					long nSize	= m_pArrRCMainOutWall[cycle][stt][inner][0].GetSize();
					for(long rc = 0; rc < nSize; rc++)
					{
						CRebarInfoCycle *pRC	= m_pArrRCMainOutWall[cycle][stt][inner][0].GetAt(rc);
						if(!pRC->m_bExist) continue;
						if(cycle == nCycle && (bStt == (stt==iSTT)) && (bLeft==(left==iLEFT)) &&
							(bInner == (inner==iINNER)) && rc == nIdx)
						{
							sMark.Format("EW%d", nNum);
							break;
						}

						nNum++;
					}
				}
			}
		}
	}

	CRebarInfoCycle *pRC	= GetRebarInfoCycleOutWall(nCycle, 0, bStt, bInner, nIdx);
	if(pRC)
		dDia	= pRC->m_Dia;
}

// 가각부 주철근 횡단면
void CRcBridgeRebar::GetXyRebarMain_CrossSection_SlabExp(CDPointArray &xyArrCycle1, CDPointArray &xyArrCycle2, BOOL bUpperSlab, BOOL bStt, BOOL bLeft, BOOL bUpper, long nDan)
{
	xyArrCycle1.RemoveAll();
	xyArrCycle2.RemoveAll();
	if(!IsGagakForLine(bStt, bLeft)) return;
	BOOL bVertDir	= FALSE;
	
	CLineInfo *pLine	= GetLineBase(bVertDir, FALSE);
	CRebarPlacing rb;
	
	// 1. 평면상의 주철근 위치를 구한다.
	CTwinVectorArrayArray pTvArrCycle1[2];
	CTwinVectorArrayArray pTvArrCycle2[2];
	GetTvRebarMain_Plane_Slab_Exp(bUpperSlab, &pTvArrCycle1[0], &pTvArrCycle2[0], &pTvArrCycle1[1], &pTvArrCycle2[1], bStt, bLeft, nDan, bUpper);
	CTwinVector tvStt, tvEnd;
	GetTvSttEndOfSlab(tvStt, tvEnd);
	double dStaOrg	= GetStationByTarget(bStt ? BRIDGE_OFF_STT_SLAB : BRIDGE_OFF_END_SLAB, 0, FALSE);
	CDPoint xyStt	= pLine->GetXyLineDis(dStaOrg, 0);

	// 횡단면 좌표
	CTwinVectorArray tvArrSup, tvArrSupLeft, tvArrSupRight;
	if(bUpperSlab)
		GetTvRebarSupport_CrossSection_UpperSlab(tvArrSup, tvArrSupLeft, tvArrSupRight, dStaOrg, bUpper, nDan, 0, TRUE, FALSE, TRUE);
	else
		GetTvRebarSupport_CrossSection_LowerSlab(tvArrSup, tvArrSupLeft, tvArrSupRight, dStaOrg, bUpper, nDan, 0, TRUE, FALSE, TRUE);

	long type = 0; for(type = 0; type < 2; type ++)
	{
		// 2. 주철근을 시점이 90도가 되도록 회전한다.
		double dAngJijum	= GetAngleJijum(0).GetAngleDegree();
		double dAngAzJijum	= GetAngleAzimuthJijum(0).GetAngleDegree();
		double dAng		= (180+dAngJijum)-dAngAzJijum;
		CDPoint xyOrg	= CDPoint(0, 0);
		CTwinVectorArray *pTvArrTmp	= NULL;
		long i = 0; for(i = 0; i < pTvArrCycle1[type].GetSize(); i++)
		{
			pTvArrTmp	= pTvArrCycle1[type].GetAt(i);
			CTwinVectorArray tvArr;
			tvArr	= *pTvArrTmp;
			rb.RotateTvArr(tvArr, xyOrg, dAng);
			*pTvArrTmp	= tvArr;
		}
		for(i = 0; i < pTvArrCycle2[type].GetSize(); i++)
		{
			pTvArrTmp	= pTvArrCycle2[type].GetAt(i);
			CTwinVectorArray tvArr;
			tvArr	= *pTvArrTmp;
			rb.RotateTvArr(tvArr, xyOrg, dAng);
			*pTvArrTmp	= tvArr;
		}
		rb.RotateXy(xyStt, xyOrg, dAng);
		rb.RotateTv(tvStt, xyOrg, dAng);
		rb.RotateTv(tvEnd, xyOrg, dAng);

		// 3. 주철근 시작점의 y좌표를 모두 보관한다.
		CDoubleArray dArrMainCycle1Y, dArrMainCycle2Y;
		CDPoint xyMatch(0, 0);
		CTwinVector tv;
		CDPoint vAng	= GetAngleJijum(0);
		// 중심선에서 시점과 교차되는 부분을 찾는다.(어쨋든 시점을 기준으로 회전했으므로 
		// 시점을 기준으로 배근을 하자!!)
		// 사보강일 때만 찾으면 됨. 아닐땐 그냥 실제 y좌표 사용하자.!!!!
		for(i = 0; i < pTvArrCycle1[type].GetSize(); i++)
		{
			pTvArrTmp	= pTvArrCycle1[type].GetAt(i);
			if(pTvArrTmp->GetSize() == 0) continue;

			tv	= pTvArrTmp->GetAt(0);
			if(GetXyMatchLineAndLine(tv.m_v1, CDPoint(-1, 0), tvStt.m_v1, tvStt.GetXyDir(), xyMatch))
				dArrMainCycle1Y.Add(xyMatch.y);
		}

		for(i = 0; i < pTvArrCycle2[type].GetSize(); i++)
		{
			pTvArrTmp	= pTvArrCycle2[type].GetAt(i);
			if(pTvArrTmp->GetSize() == 0) continue;

			tv	= pTvArrTmp->GetAt(0);
			if(GetXyMatchLineAndLine(tv.m_v1, CDPoint(-1, 0), tvStt.m_v1, tvStt.GetXyDir(), xyMatch))
				dArrMainCycle2Y.Add(xyMatch.y);
		}
		

		// 시점에서의 좌우측 점도 추가해줌
		// 폭이 가장 작은 부분을 기준으로 삼아야 됨. ///////
		double dW	= GetWidthSlabActByGagak(dStaOrg, CDPoint(0, 1), 0);

		GetXyMatchLineAndLine(tvStt.m_v1, tvStt.GetXyDir(), CDPoint(0, tvStt.GetXyMid().y+dW/2), CDPoint(1, 0), xyMatch);
		tvStt.m_v2	= xyMatch;
		GetXyMatchLineAndLine(tvStt.m_v1, tvStt.GetXyDir(), CDPoint(0, tvStt.GetXyMid().y-dW/2), CDPoint(1, 0), xyMatch);
		tvStt.m_v1	= xyMatch;
		////////////////////////////////////////////////////

		dArrMainCycle1Y.Add(tvStt.m_v1.y);
		dArrMainCycle1Y.Add(tvStt.m_v2.y);
		if(!bUpper)
		{
			dArrMainCycle2Y.Add(tvStt.m_v1.y);
			dArrMainCycle2Y.Add(tvStt.m_v2.y);
		}
		

		// y좌표 정렬 위에서 아래로
		dArrMainCycle1Y.Sort(FALSE);
		dArrMainCycle2Y.Sort(FALSE);

		// 중복좌표 제거
		for(i = 0; i < dArrMainCycle1Y.GetSize()-1; i++)
		{
			if(Compare(dArrMainCycle1Y.GetAt(i), dArrMainCycle1Y.GetAt(i+1), "="))
			{
				dArrMainCycle1Y.RemoveAt(i+1);
				i--;
			}
		}
		for(i = 0; i < dArrMainCycle2Y.GetSize()-1; i++)
		{
			if(Compare(dArrMainCycle2Y.GetAt(i), dArrMainCycle2Y.GetAt(i+1), "="))
			{
				dArrMainCycle2Y.RemoveAt(i+1);
				i--;
			}
		}

		// 4. 보관된 y좌표로 횡단면에 그려질 간격을 구한다.
		// 중심선시작점에서의 떨어진 거리임.
		CDoubleArray dArrMainCycle1Dist, dArrMainCycle2Dist;
		for(i = 0; i < dArrMainCycle1Y.GetSize(); i++)
			dArrMainCycle1Dist.Add(tvStt.m_v1.y-dArrMainCycle1Y.GetAt(i));
		for(i = 0; i < dArrMainCycle2Y.GetSize(); i++)
			dArrMainCycle2Dist.Add(tvStt.m_v1.y-dArrMainCycle2Y.GetAt(i));

		// 떨어진 거리를 이용해 실제 위치로 옮김
		CTwinVectorArray tvArrCross;
		GetTvCrossSection(tvArrCross, dStaOrg, CDPoint(0, 1), FALSE, FALSE, FALSE, 0, TRUE, FALSE, FALSE, TRUE);
		CDRect rect	= tvArrCross.GetRect();
		for(i = 0; i < dArrMainCycle1Dist.GetSize(); i++)
			dArrMainCycle1Dist.SetAt(i, rect.left-dArrMainCycle1Dist.GetAt(i));
		for(i = 0; i < dArrMainCycle2Dist.GetSize(); i++)
			dArrMainCycle2Dist.SetAt(i, rect.left-dArrMainCycle2Dist.GetAt(i));

		// 5. 횡단면에 그려지는 좌표를 구하자.
		// 실제 횡단면 배력근에 수직으로 뻗어서 붙이면 끝.

		if(tvArrSup.GetSize() > 0)
		{
			CDPointArray xyArrMatch;
			for(i = 0; i < dArrMainCycle1Dist.GetSize(); i++)
			{
				rb.GetXyMatchTvArrAndLine(tvArrSup, CDPoint(dArrMainCycle1Dist.GetAt(i), 0), CDPoint(0, 1), xyArrMatch);
				if(xyArrMatch.GetSize() > 0)
					xyArrCycle1.Add(xyArrMatch.GetAt(0));
			}

			for(i = 0; i < dArrMainCycle2Dist.GetSize(); i++)
			{
				rb.GetXyMatchTvArrAndLine(tvArrSup, CDPoint(dArrMainCycle2Dist.GetAt(i), 0), CDPoint(0, 1), xyArrMatch);
				if(xyArrMatch.GetSize() > 0)
					xyArrCycle2.Add(xyArrMatch.GetAt(0));
			}
		}


	}

	// 철근반지름만큼 상하로 이동
	if(bUpper)
	{
		rb.MoveRebar(xyArrCycle1, CDPoint(0, 1) * REBAR_RADIUS);
		rb.MoveRebar(xyArrCycle2, CDPoint(0, 1) * REBAR_RADIUS);
	}
	else
	{
		rb.MoveRebar(xyArrCycle1, CDPoint(0, -1) * REBAR_RADIUS);
		rb.MoveRebar(xyArrCycle2, CDPoint(0, -1) * REBAR_RADIUS);
	}

	for(type = 0; type < 2; type++)
	{
		AhTPADelete(&pTvArrCycle1[type], (CTwinVectorArray*)0);
		AhTPADelete(&pTvArrCycle2[type], (CTwinVectorArray*)0);
	}
}



// 철근이 존재 하는지 체크하기 위한 스테이션을 사보강과 선형방향 스테이션에 맞게 보정해서 리턴함.
// 그리고 시종점일 경우에 벽체 두께에 대한 보정도 한다.
// 상부슬래브 주철근과 헌치부 주철근 체크용으로 사용함.
// 여기 들어오는 dSta는 사보강일땐 직거리용 sta 선형방향일땐 사거리용 sta
double CRcBridgeRebar::GetStationModifyForRebarCheck(double dSta)
{
	// 시종점 Sta를 벽체 외측면 피복위치로 바꾸면 2단 부터는 철근 을 찾지 못한다.(전기주. 21511)
	// return dSta;

	// (ARCBRIDGE-3454) 주철근이 시점각도의 직각방향이라면 Station으로 찾으면 안된다. 위치를 보정해준다.
	if(m_nTypePlacingMainRebar_UpperSlab != 0)
	{
		double dLen1 = GetLengthBridge(FALSE);
		double dLen2 = GetLengthBridge(TRUE);
		dSta = m_dStationBridgeStt + (dSta - m_dStationBridgeStt) * (dLen2 / dLen1);
	}

	return dSta;

// 	BOOL bVertDir	= IsVertDir();
// 
// 	CDPoint vAngStt	= GetAngleJijum(0, bVertDir);
// 	CDPoint vAngEnd	= GetAngleJijum(m_nQtyJigan, bVertDir);
// 	double dSttUgan	= m_bExpJoint[0] ? GetJijum(0)->m_dLengthUgan[1]/vAngStt.y : 0;
// 	double dEndUgan	= m_bExpJoint[m_nQtyJigan] ? GetJijum(m_nQtyJigan)->m_dLengthUgan[0]/vAngEnd.y : 0;
// 	double dLenBri	= GetLengthBridge(bVertDir);
// 	double dStaSttApplyAngle	= m_dStationBridgeStt;
// 	if(!IsOutWall(TRUE))
// 	{
// 		dStaSttApplyAngle	= GetStationByTarget(BRIDGE_OFF_STT_SLAB, 0, FALSE);
// 	}
// 
// 	if(!IsOutWall(FALSE))
// 	{
// 		dLenBri -= (dSttUgan + dEndUgan);
// 		if(IsBlockOut(TRUE))
// 		{
// 			dStaSttApplyAngle += m_fxJointStt.m_dWidth;
// 			dLenBri -= m_fxJointStt.m_dWidth;
// 		}
// 		if(IsBlockOut(FALSE))
// 		{
// 			dLenBri -= m_fxJointEnd.m_dWidth;
// 		}
// 	}
// 
// 	// 들어오는 dSta가 시점보다 작거나, 종점보다 크다면  //////////
// 	// 철근이 있는지 검사하기 위해 조정을 좀 해줘야 된다.
// 	double dStaStt	= GetXyVertSectionByDirVert(CDPoint(dStaSttApplyAngle, 0), 0).x;
// 	double dWStt	= IsOutWall(TRUE) ? m_dWS/vAngStt.y : 0;
// 	double dWEnd	= IsOutWall(FALSE) ? m_dWE/vAngEnd.y : 0;
// 
// 	
// 	if(Compare(dSta, dStaStt, "<="))
// 	{
// 		dSta = dStaStt - dWStt + m_dCoverWallOut[0]/vAngStt.y + dSttUgan;
// 		if(IsBlockOut(TRUE))
// 			dSta += m_fxJointStt.m_dWidth/vAngStt.y;
// 	}
// 	else if(Compare(dSta, dStaStt + dLenBri, ">="))
// 	{
// 		dSta	= dStaStt + dLenBri + dWEnd - m_dCoverWallOut[0]/vAngEnd.y - dEndUgan;
// 		if(IsBlockOut(FALSE))
// 			dSta -= m_fxJointEnd.m_dWidth/vAngEnd.y;
// 	}
// 
// 	return dSta;
}

// 기초 주철근 권고안
// BOOL bMatchWithWall : 벽체 주철근과 간격을 맞출지?
void CRcBridgeRebar::SetDataDefaultRebarMain_Front_Footing(long nJ, BOOL bMatchWithWall)
{
	CFootingApp *pFooting	= GetFootingByJijumNumber(nJ);
	if(!pFooting) return;
	if(!pFooting->m_bIs) return;
	pFooting->m_bAutoMainRebar	= TRUE;

	pFooting->SetDataDefaultRebarMain_Side(TRUE, 0);
	pFooting->SetDataDefaultRebarMain_Side(FALSE, 0);

	// 벽체와 맞춰야 된다면 적당한 위치에 넣어주면 된다.
	if(bMatchWithWall)
	{
		CTwinVectorArray tvArrCrossWall, tvArrCrossFooting, tvArrHidden, tvArrCrossFootingVert, tvArrHiddenVert;
		CTwinVectorArray tvArrMainWall, tvArrJoint;
		pFooting->GetTvLeftSide(tvArrCrossFootingVert, tvArrHiddenVert, FALSE,0);	// 직거리로 구한 기초 위치

		if(nJ == 0 || nJ == m_nQtyJigan)
		{
			if(IsOutWall(nJ == 0))
			{
				CWallApp wall;
				MakeWallByOutWall(wall, nJ==0, TRUE);
				wall.GetTvRebarMain_Side(tvArrMainWall, 0, 0, 0, 0, tvArrJoint);
				wall.GetTvLeftSide(tvArrCrossWall, FALSE, FALSE, FALSE, TRUE, 0, FALSE, FALSE);
			}
		}
		else
		{
			CWallApp *pWall	= GetInWall(nJ-1);
			if(pWall)
			{
				if(pWall->m_bIs)
				{
					SyncWall(nJ, pWall, TRUE);
					pWall->GetTvRebarMain_Side(tvArrMainWall, -1, 0, 0, 0, tvArrJoint);
					pWall->GetTvLeftSide(tvArrCrossWall, FALSE, FALSE, FALSE, TRUE, 0, FALSE, FALSE);
				}
			}
		}

		SyncBridge_CrossSection_SttEndFooting(TRUE);
		pFooting->GetTvLeftSide(tvArrCrossFooting, tvArrHidden, FALSE,0);	// 사거리로 구한 기초위치

		CRebarPlacing rb;
		// (ARCBRIDGE-2419) 기초주철근이 (기초좌측면 기준 배치) 일때는 이격거리가 없다.
		double dXDiff	= (m_nTypePlacingMainRebar_Footing == 3)? 0 : pFooting->GetDiffLengthNormalOrInput(TRUE);//tvArrCrossFooting.GetRect().left - tvArrCrossWall.GetRect().left;
		double dXDiffVAndA	= (m_nTypePlacingMainRebar_Footing== 3)? 0 : (tvArrCrossFooting.GetRect().left - tvArrCrossFootingVert.GetRect().left);
		dXDiff -= dXDiffVAndA;
		rb.MoveRebar(tvArrMainWall, CDPoint(dXDiff, 0));
		if(tvArrMainWall.GetSize() > 1)
		{
			long upper = 0; for(upper = 0; upper < 2; upper++)
			{
				CDPointArray xyArrTot;
				pFooting->GetXyRebarMain_Side(xyArrTot, 0, upper==iUPPER, 0);
				
				// 직거리와 사거리 기초의ㅏ 시작위치 차이를 더 빼줘야 된다.
				rb.MoveRebar(xyArrTot, CDPoint(-dXDiffVAndA, 0));

				long nSize	= xyArrTot.GetSize();
				double dLeftFooting		= xyArrTot.GetAt(0).x;
				double dRightFooting	= xyArrTot.GetAt(nSize-1).x;
				if(dLeftFooting > dRightFooting) GetSwap(dLeftFooting, dRightFooting);

				// 벽체 안쪽에 있는 기초철근은 제거 ///////////////////
				// 단 처음과 끝은 제거 하지 않음 
				// 벽체 철근으로 위치를 대체 하기 위함.
				CDPoint xy(0, 0);
				nSize				= tvArrMainWall.GetSize();
				double dLeftWall	= tvArrMainWall.GetAt(0).m_v1.x;
				double dRightWall	= tvArrMainWall.GetAt(nSize-1).m_v1.x;
				if(dLeftWall > dRightWall) GetSwap(dLeftWall, dRightWall);
				nSize	= xyArrTot.GetSize();
				long i = 0; for(i = 1; i < xyArrTot.GetSize()-1; i++)
				{
					xy	= xyArrTot.GetAt(i);
					if(Compare(xy.x, dLeftWall, ">=") && Compare(xy.x, dRightWall, "<="))
					{
						xyArrTot.RemoveAt(i);
						i--;
					}
				}
				/////////////////////////////////////////////////////////////

				// 기초 사이에 벽체 철근 위치 넣음 ///////////////////////
				nSize	= tvArrMainWall.GetSize();
				for(i = 0; i < nSize; i++)
				{
					xy	= tvArrMainWall.GetAt(i).m_v1;
					if(Compare(xy.x, dLeftFooting, ">=") && Compare(xy.x, dRightFooting, "<="))
					{
						xyArrTot.Add(xy);
					}
				}
				//////////////////////////////////////////////////////////

				xyArrTot.Sort();

				nSize	= xyArrTot.GetSize();
				for(i = 0; i < nSize; i++)
				{
					xy	= xyArrTot.GetAt(i);
					xyArrTot.SetAt(i, CDPoint(xy.x, 0));
				}

				rb.RemoveContinueSamePoint(xyArrTot);

				CPlaceRebarByBlock *pPlace	= &pFooting->m_placeByBlock_Main_Side[upper][0];
				rb.ConvertPointArrayToOffsetInfo(xyArrTot, pPlace->m_xyArr, 0);
				pPlace->m_nCountBlock	= pPlace->m_xyArr.GetSize();
				pPlace->ModifyPlaceRebarByMinLimits(pFooting->m_dCTC_MainRebar/2);
				pPlace->m_nCountBlock	= pPlace->m_xyArr.GetSize();

				long dan = 0; for(dan = 1; dan < MAX_REBAR_DAN; dan++)
				{
					pFooting->m_placeByBlock_Main_Side[upper][dan]	= pFooting->m_placeByBlock_Main_Side[upper][0];
				}
			}
		}
	}
}


// 배근시 속도 개선을 위해 자주 쓰이는 좌표나 간격은 미리 구해 놓고 가져다 쓴다. ///////////////////////
void CRcBridgeRebar::SettingValueRebarForSlab()		// 상부슬래브 배근도를 위한 값 셋팅
{

	CTwinVectorArray tvArrTmp;
	// 횡단면 배력근 상하(가장폭이작은곳)
	double dSta	= GetStationSmallestWidthOfUpperSlab(IsVertDir(), 0, !IsVertDir());

	if(IsVertDir())
	{
		if(!IsExtLine() && !IsExp(dSta))
		{
			long nJ	= GetJijumNumberByStation(dSta);
			dSta	= GetXyVertSectionByDirVert(CDPoint(dSta, 0), nJ).x;
		}		
	}

	GetTvRebarSupport_CrossSection_UpperSlab(m_tvArrSupRebarCross[iUPPER], tvArrTmp, tvArrTmp, dSta, TRUE, 0, 0, FALSE, FALSE, FALSE);
	GetTvRebarSupport_CrossSection_UpperSlab(m_tvArrSupRebarCross[iLOWER], tvArrTmp, tvArrTmp, dSta, FALSE, 0, 0, FALSE, FALSE, FALSE);

	// 주철근 배치를 위한 횡단면 주철근 간격 구함(사방향 직방향 두가지) ///////
	long upper = 0; for(upper = 0; upper < 2; upper++)
	{
		BOOL bUpper	= upper == iUPPER;
		long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
		{
			// 기본 철근 간격(배근 방식에 따라 직이나 사가 됨)
			GetDistRebarMain_CrossSection_Slab(TRUE, m_dArrDist_RebarMain_Plane[0][dan][upper][0], m_dArrDist_RebarMain_PlaneHunch[0][0], 
				m_dArrDist_RebarMain_Plane[1][dan][upper][0], m_dArrDist_RebarMain_PlaneHunch[1][0], 
				m_dArrDist_RebarMain_Plane[2][dan][upper][0], m_dArrDist_RebarMain_PlaneHunch[2][0], 
				m_dArrDist_RebarMain_Plane[3][dan][upper][0], m_dArrDist_RebarMain_PlaneHunch[3][0], 
				dSta, bUpper, dan, TRUE, TRUE, TRUE);

			// 사철근용 간격 (피복을 맞춰줌, 사보강일경우 적용됨)
			if(IsVertDir() || IsExtLine())
			{
				GetDistRebarMain_CrossSection_Slab(TRUE, m_dArrDist_RebarMain_Plane[0][dan][upper][1], m_dArrDist_RebarMain_PlaneHunch[0][1], 
					m_dArrDist_RebarMain_Plane[1][dan][upper][1], m_dArrDist_RebarMain_PlaneHunch[1][1], 
					m_dArrDist_RebarMain_Plane[2][dan][upper][1], m_dArrDist_RebarMain_PlaneHunch[2][1], 
					m_dArrDist_RebarMain_Plane[3][dan][upper][1], m_dArrDist_RebarMain_PlaneHunch[3][1], 
					dSta, bUpper, dan, FALSE, TRUE, TRUE);
			}
		}
	}

	if(IsBoxType())
	{
		GetTvRebarSupport_CrossSection_LowerSlab(m_tvArrSupRebarCrossLowerSlab[iUPPER], tvArrTmp, tvArrTmp, dSta, TRUE, 0, 0, FALSE, FALSE, FALSE);
		GetTvRebarSupport_CrossSection_LowerSlab(m_tvArrSupRebarCrossLowerSlab[iLOWER], tvArrTmp, tvArrTmp, dSta, FALSE, 0, 0, FALSE, FALSE, FALSE);

		long upper = 0; for(upper = 0; upper < 2; upper++)
		{
			BOOL bUpper	= upper == iUPPER;
			long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
			{
				// 기본 철근 간격(배근 방식에 따라 직이나 사가 됨)
				GetDistRebarMain_CrossSection_Slab(FALSE, m_dArrDist_RebarMain_LowerPlane[0][dan][upper][0], m_dArrDist_RebarMain_LowerPlaneHunch[0][0], 
					m_dArrDist_RebarMain_LowerPlane[1][dan][upper][0], m_dArrDist_RebarMain_LowerPlaneHunch[1][0], 
					m_dArrDist_RebarMain_LowerPlane[2][dan][upper][0], m_dArrDist_RebarMain_LowerPlaneHunch[2][0], 
					m_dArrDist_RebarMain_LowerPlane[3][dan][upper][0], m_dArrDist_RebarMain_LowerPlaneHunch[3][0], 
					dSta, bUpper, dan, TRUE);

				// 사철근용 간격 (피복을 맞춰줌, 사보강일경우 적용됨)
				if(IsVertDir()|| IsExtLine())
				{
					GetDistRebarMain_CrossSection_Slab(FALSE, m_dArrDist_RebarMain_LowerPlane[0][dan][upper][1], m_dArrDist_RebarMain_LowerPlaneHunch[0][1], 
						m_dArrDist_RebarMain_LowerPlane[1][dan][upper][1], m_dArrDist_RebarMain_LowerPlaneHunch[1][1], 
						m_dArrDist_RebarMain_LowerPlane[2][dan][upper][1], m_dArrDist_RebarMain_LowerPlaneHunch[2][1], 
						m_dArrDist_RebarMain_LowerPlane[3][dan][upper][1], m_dArrDist_RebarMain_LowerPlaneHunch[3][1], 
						dSta, bUpper, dan, FALSE);
				}
			}
		}
	}
	/////////////////////////////////////////////////////////////////////////////
}

void CRcBridgeRebar::InitValueRebarForUpperSlab(BOOL bLowerSlab)		// 상부슬래브 배근도를 위한 값 초기화
{
	if(bLowerSlab)
	{
		// 횡단면 배력근 상하(가각 아님, 시점)
		m_tvArrSupRebarCrossLowerSlab[iUPPER].RemoveAll();
		m_tvArrSupRebarCrossLowerSlab[iLOWER].RemoveAll();

		// 배력근 스테이션
		// 상하면 1cycle에 대해서만 구함
		m_dArrStaSupRebarLowerSlab[iUPPER].RemoveAll();
		m_dArrStaSupRebarLowerSlab[iLOWER].RemoveAll();
	}
	else
	{
		// 횡단면 배력근 상하(가각 아님, 시점)
		m_tvArrSupRebarCross[iUPPER].RemoveAll();
		m_tvArrSupRebarCross[iLOWER].RemoveAll();

		// 배력근 스테이션
		// 상하면 1cycle에 대해서만 구함
		m_dArrStaSupRebar[iUPPER].RemoveAll();
		m_dArrStaSupRebar[iLOWER].RemoveAll();
	}
}

void CRcBridgeRebar::SettingValueRebarForCrossSection(double dStaLeft, double dStaRight)	// 횡단면도 배근도를 위한 값 셋팅
{
	m_dStaLeftCross		= dStaLeft;
	m_dStaRightCross	= dStaRight;
	long cycle(0), upper(0), dan(0), left(0);
	BOOL bUpper(TRUE), bLeft(TRUE);

	CVectorArray xyArrHunch;

	// 확폭이 아니면 있는 그대로 그림.
	// 확폭일때는 꽁수를 씀
	BOOL bUseMatchSta	= TRUE;
	//if(!IsExtLine())
		//bUseMatchSta	= FALSE;
	for(left = 0; left < 2; left++)
	{
		//if(left == 1 && Compare(dStaLeft, dStaRight, "=")) continue;
		bLeft	= left == iLEFT;

		for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
		{
			for(upper = 0; upper < 2; upper++)
			{
				bUpper	= upper == iUPPER;
				for(dan = 0; dan < MAX_REBAR_DAN; dan++)
				{
					double dSta	= bLeft ? dStaLeft : dStaRight;
					GetXyRebarMain_CrossSection_UpperSlab(m_xyArrMainRebarCross[cycle][upper][dan][left], !bUpper && dan == 0 ? m_xyArrMainRebarCrossHunch[cycle][left] : xyArrHunch, dSta, bUpper, dan, cycle, TRUE, bUseMatchSta);

					if(IsBoxType())
					{
						GetXyRebarMain_CrossSection_LowerSlab(m_xyArrMainRebarCrossLowerSlab[cycle][upper][dan][left], bUpper && dan == 0 ? m_xyArrMainRebarCrossHunchLowerSlab[cycle][left] : xyArrHunch, dSta, bUpper, dan, cycle, TRUE, bUseMatchSta);
					}
				}
			}
		}
	}
}

void CRcBridgeRebar::InitValueRebarForCrossSection()	// 횡단면도 배근도를 위한 값 초기화
{
	long cycle(0), upper(0), dan(0), left(0);

	for(left = 0; left < 2; left++)
	{
		for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
		{
			for(upper = 0; upper < 2; upper++)
			{
				for(dan = 0; dan < MAX_REBAR_CYCLE; dan++)
				{
					m_xyArrMainRebarCross[cycle][upper][dan][left].RemoveAll();
					m_xyArrMainRebarCrossLowerSlab[cycle][upper][dan][left].RemoveAll();
				}
			}

			m_xyArrMainRebarCrossHunch[cycle][left].RemoveAll();	// 횡단면 배력근
			m_xyArrMainRebarCrossHunchLowerSlab[cycle][left].RemoveAll();
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////

// 단부 스터럽 철근 지름 리턴
double CRcBridgeRebar::GetDiaRebarStirrupDanbu(BOOL bStt, long nIdx, BOOL bUpper)
{
	return m_dDiaStirrupAtDanBuRebar[bUpper ? iUPPER : iLOWER][bStt ? iSTT : iEND];
}

BOOL CRcBridgeRebar::SetDiaMainRebarUpperSlab(long nCycle, long nDan, BOOL bUpper, long nJigan, long nIdx, double dDia, BOOL bMax)
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return FALSE;
	if(nJigan == -1) nJigan = nDan > 0 ? m_nQtyJigan : m_nQtyJigan-1;
	if(nJigan < 0 || nJigan > (nDan > 0 ? m_nQtyJigan : m_nQtyJigan-1)) return FALSE;
	long nSize	= 0;
	long upper	= bUpper ? iUPPER : iLOWER;
	if(nDan == 0)
	{
		nSize	= m_pArrDiaUpperSlab[nCycle][upper][0].GetSize();
		if(nJigan < nSize)
		{
			nSize	= m_pArrDiaUpperSlab[nCycle][upper][0][nJigan]->GetSize();
			if(nIdx == -1) nIdx = nSize-1;
			if(nIdx < 0 || nIdx > nSize-1) return FALSE;

			if(nIdx < nSize)
			{
				if(bMax == FALSE || m_pArrDiaUpperSlab[nCycle][upper][0][nJigan]->GetAt(nIdx) < dDia)
					m_pArrDiaUpperSlab[nCycle][upper][0][nJigan]->SetAt(nIdx, dDia);
				else
					return FALSE;
			}
			else
				return FALSE;
		}
	}
	// 2단부터는 다른 변수에 저장되어 있다
	// 2단이상은 그냥 내측 외측으로 지름이 구분되어 있음.
	// 2단이 index 0이고 3단이 1이다.
	else if(nDan > 0)
	{
		if(nDan == -1) nDan = MAX_REBAR_DAN-1;
		if(nDan < 0) return FALSE;
		if(nDan > MAX_REBAR_DAN-1) return FALSE;
		if(nCycle == -1) nCycle = MAX_REBAR_CYCLE-1;
		if(nCycle < 0) return FALSE;
		if(nCycle > MAX_REBAR_CYCLE-1) return FALSE;
		
		nSize	=  m_pArrSetRebarDanUpperSlab[upper].GetSize();
		if(nJigan == -1) nJigan	= nSize-1;
		if(nJigan < 0 || nJigan > nSize-1) return FALSE;

		CSetRebarDan *pRD	= m_pArrSetRebarDanUpperSlab[upper].GetAt(nJigan);
		if(dDia > 0 && GetCountCycleMainRebar() > nCycle)
		{
			if(bMax == FALSE || pRD->m_dDia[nCycle][nDan] < dDia)
			{
				pRD->m_dDia[nCycle][nDan]	= dDia;
				if(pRD->m_nCountDan < nDan+1)
					pRD->m_nCountDan	= nDan+1;
			}
		}
		else 
			return FALSE;
	}

	return TRUE;
}

BOOL CRcBridgeRebar::SetDiaMainRebarLowerSlab(long nCycle, long nDan, BOOL bUpper, long nJigan, long nIdx, double dDia, BOOL bMax)
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return FALSE;
	if(nJigan == -1) nJigan = nDan > 0 ? m_nQtyJigan : m_nQtyJigan-1;
	if(nJigan < 0 || nJigan > (nDan > 0 ? m_nQtyJigan : m_nQtyJigan-1)) return FALSE;
	long nSize	= 0;
	long upper	= bUpper ? iUPPER : iLOWER;

	if(nDan == 0 || m_bDetailInput23DanMainRebar)
	{
		nSize	= m_pArrDiaLowerSlab[nCycle][upper][nDan].GetSize();
		if(nJigan < nSize)
		{
			nSize	= m_pArrDiaLowerSlab[nCycle][upper][nDan][nJigan]->GetSize();
			if(nIdx == -1) nIdx = nSize-1;

			if(nIdx < nSize && nIdx > -1)
			{
				if(bMax == FALSE || m_pArrDiaLowerSlab[nCycle][upper][nDan][nJigan]->GetAt(nIdx) < dDia)
					m_pArrDiaLowerSlab[nCycle][upper][nDan][nJigan]->SetAt(nIdx, dDia);
				else
					return FALSE;
			}
			else 
			{
				// 개수가 없는 경우 상부슬래브 철근에 이음이 한개도 없어서 마지막 지간에만 직경이 하나 들어 가 있을 수 있다.
				nSize	= m_pArrDiaLowerSlab[nCycle][upper][nDan][m_nQtyJigan-1]->GetSize();
				if(nIdx == -1)
					nIdx = nSize - 1;

				if(nIdx < nSize && nIdx > -1)
				{
					if(bMax == FALSE || m_pArrDiaLowerSlab[nCycle][upper][nDan][m_nQtyJigan-1]->GetAt(nIdx) < dDia)
						m_pArrDiaLowerSlab[nCycle][upper][nDan][m_nQtyJigan-1]->SetAt(nIdx, dDia);
					else
						return FALSE;
				}
				return FALSE;
			}
		}
	}
	// 2단부터는 다른 변수에 저장되어 있다
	// 2단이상은 그냥 내측 외측으로 지름이 구분되어 있음.
	// 2단이 index 0이고 3단이 1이다.
	else if(nDan > 0)
	{
		if(nDan == -1) nDan = MAX_REBAR_DAN-1;
		if(nDan < 0) return FALSE;
		if(nDan > MAX_REBAR_DAN-1) return FALSE;
		if(nCycle == -1) nCycle = MAX_REBAR_CYCLE-1;
		if(nCycle < 0) return FALSE;
		if(nCycle > MAX_REBAR_CYCLE-1) return FALSE;

		nSize	=  m_pArrSetRebarDanLowerSlab[upper].GetSize();
		if(nSize == 1 && !bUpper)
			nIdx	= 0;

		if(nIdx == -1) nIdx	= nSize-1;
		if(nIdx < 0 || nIdx > nSize-1) return FALSE;

		CSetRebarDan *pRD	= m_pArrSetRebarDanLowerSlab[upper].GetAt(nIdx);
		if(pRD->m_nCountDan > nDan && GetCountCycleMainRebar() > nCycle)
		{
			if(bMax == FALSE || pRD->m_dDia[nCycle][nDan] < dDia)
			{
				pRD->m_dDia[nCycle][nDan] = dDia;
				if(pRD->m_nCountDan < nDan+1)
					pRD->m_nCountDan	= nDan+1;
				else return FALSE;
			}
		}
	}

	return TRUE;
}

BOOL CRcBridgeRebar::SetDiaMainRebarArchRib(long nCycle, long nDan, long nIdx, double dDia)
{
	long nJijumConnect = GetJijumConnectRibAndSlab();
	long nIdxCrown = (nJijumConnect * 2) + 1;
	long nSize = m_pArrConcArchRib.GetSize();
	long nPos = 0;
	long nSpan = 0;

	if(nIdx==0 || nIdx==nSize-1)							// 시종점 SPRINGING
	{
		nSpan = (nIdx==0)? 0 : (nIdx-1)/2;
		nPos = (nIdx==0)? CHECK_POS_LEFT : CHECK_POS_RIGHT;
	}
	else if(nIdx==nIdxCrown-1 || nIdx==nIdxCrown+1)		// 리브,슬래브 접합부
	{
		nSpan = (nIdx==nIdxCrown-1)? nJijumConnect-1 : nJijumConnect;
		nPos = CHECK_POS_RIGHT;
	}
	else if(nIdx == nIdxCrown)			// CROWN
	{
		nSpan = nJijumConnect;
		nPos = CHECK_POS_CENTER;
	}
	else if(nIdx%2 == 1)					// 중간부
	{
		nSpan = (nIdx < nIdxCrown)? (nIdx-1)/2 : (nIdx-1)/2;
		nPos = CHECK_POS_CENTER;
	}
	else if(nIdx%2 == 0)					// 연직재 교차점
	{
		nSpan = (nIdx < nIdxCrown)? (nIdx-1)/2 : (nIdx-1)/2;
		nPos = CHECK_POS_RIGHT;
	}

	long nIdxArr = -1;

	double dSta = GetStationRibBySpan(nSpan, nPos);

	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC	= &m_pArrRCMainRib[nCycle][iUPPER][nDan];
	long nCntRb =pArrRC->GetSize();
	for(long rc = 0; rc < nCntRb; rc++)
	{
		CRebarInfoCycle *pRC	= pArrRC->GetAt(rc);
		double dXLeft	= pRC->m_xyStt.x;
		double dXRight	= pRC->m_nPosStt == pRC->m_nPosEnd ? pRC->m_xyMid1.x : pRC->m_xyEnd.x;
		if(pRC->m_bUseEndExt)
			dXRight	= pRC->m_xyEndExt.x;
		if(dXRight < dXLeft)
			GetSwap(dXRight, dXLeft);
		
		if(dXLeft <= dSta && dXRight >= dSta && pRC->m_bExist)
		{
			nIdxArr = rc;
			break;
		}
	}

	if(nIdxArr > -1)
	{
		m_dArrDiaRib[nCycle][iUPPER][nDan].SetAt(nIdxArr, dDia);
		m_dArrDiaRib[nCycle][iLOWER][nDan].SetAt(nIdxArr, dDia);
		return TRUE;
	}
	return FALSE;
}

BOOL CRcBridgeRebar::SetDiaMainRebarOutWall(long nCycle, long nDan, BOOL bStt, BOOL bInner, long nIdx, double dDia, BOOL bMax)
{
	long stt	= bStt ? iSTT : iEND;
	long inner	= bInner ? iINNER : iOUTTER;

	if(nDan == 0)
	{
		long nSize	= 0;
		nSize	= m_pArrDiaOutWall[nCycle][stt][inner][0].GetSize();
		if(nIdx == -1) nIdx = nSize-1;
		if(nIdx < 0 || nIdx > nSize-1) return 0;

		if(nIdx < nSize)
		{
			if(bMax == FALSE || m_pArrDiaOutWall[nCycle][stt][inner][0].GetAt(nIdx) < dDia)
				m_pArrDiaOutWall[nCycle][stt][inner][0].SetAt(nIdx, dDia);
			else
				return FALSE;
		}
		else 
			return FALSE;
	}
	// 2단부터는 다른 변수에 저장되어 있다
	// 2단이상은 그냥 내측 외측으로 지름이 구분되어 있음.
	// 2단이 index 0이고 3단이 1이다.
	else if(nDan > 0)
	{
		if(nDan == -1) nDan = MAX_REBAR_DAN-1;
		if(nDan < 0) return 0;
		if(nDan > MAX_REBAR_DAN-1) return 0;
		if(nCycle == -1) nCycle = MAX_REBAR_CYCLE-1;
		if(nCycle < 0) return 0;
		if(nCycle > MAX_REBAR_CYCLE-1) return 0;

		CSetRebarDan *pRD	= &m_pArrSetRebarDanOutWall[stt][inner];
		if(dDia > 0 && GetCountCycleMainRebar() > nCycle)
		{
			if(bMax == FALSE || pRD->m_dDia[nCycle][nDan] < dDia)
			{
				pRD->m_dDia[nCycle][nDan]	= dDia;
				if(pRD->m_nCountDan < nDan+1)
					pRD->m_nCountDan	= nDan+1;
			}
		}
		else 
			return FALSE;
	}

	return TRUE;
}

// 브라켓 전단 철근 권고안
// 주철근이 있는 경우에만 권고안 가능하면 철근 생성도 가능하다
void CRcBridgeRebar::SetDataDefaultRebarShear_VertSection_Bracket()
{
	long stt = 0; for(stt = 0; stt < 2; stt++)
	{
		CPlaceRebarByBlock *pPlace	= NULL;
		BOOL bStt	= stt == iSTT;
		pPlace	= &m_placeByBlock_ShearRebar_Bracket[stt];
		if(!IsBracketRebar(bStt, 0) || m_pArrRCMainOutWallBracket_Cycle1[stt].GetSize() == 0) 
		{
			pPlace->m_nCountBlock	= 0;
			pPlace->m_xyArr.RemoveAll();
			continue;
		}

		CRebarInfoCycle *pRC	= m_pArrRCMainOutWallBracket_Cycle1[stt].GetAt(0);
		CTwinVector tvHunch	= pRC->m_tvArrRebar.GetTvByInfo(bStt ? "시점브라켓헌치" : "종점브라켓헌치");

		pPlace->m_nCountBlock	= 2;
		pPlace->m_xyArr.RemoveAll();
		pPlace->m_xyArr.Add(CDPoint(1, tvHunch.GetVerLength() - m_dCTC_ShearRebarBracket));
		pPlace->m_xyArr.Add(CDPoint(1, m_dCTC_ShearRebarBracket));
	}
}



void CRcBridgeRebar::SetDataDefaultCountJoint(long nCycle)
{
	BOOL bCycle13	= nCycle == -1 || nCycle == 0 || nCycle == 2;
	BOOL bCycle24	= nCycle == -1 || nCycle == 1 || nCycle == 3;

	for(long jijum = 0; jijum <= m_nQtyJigan; jijum++)
	{
		CWallApp *pWall	= GetInWall(jijum);
		long upper(0), stt(0), left(0), inner(0), dan(0);

		for(dan = 0; dan < MAX_REBAR_DAN; dan++)
		{
			// 이음 개수
			if(bCycle13)
			{
				for(upper = 0; upper < 2; upper++)
				{
					m_nCountJointMainRebar_UpperSlab_Cycle1[jijum][upper][dan] = 2;	// 상부슬래브 상,하면 각 지간별 이음 개수
					m_nCountJointMainRebar_LowerSlab_Cycle1[jijum][upper][dan] = 2;	// 상부슬래브 상,하면 각 지간별 이음 개수
				}
				for(stt = 0; stt < 2; stt++)
				{
					for(inner = 0; inner < 2; inner++)
						m_nCountJointMainRebar_OutWall_Cycle1[stt][inner][dan] = 2;	// 외측벽체 시종점,좌우측 이음 개수
				}
				if(pWall)
				{
					for(left = 0; left < 2; left++)
						pWall->m_nCountJointMainRebar_Cycle1[left][dan] = 2;
				}
			}

			if(bCycle24)
			{
				for(upper = 0; upper < 2; upper++)
				{
					BOOL bUpper	= upper == iUPPER;
					if(m_nTypeBridge == BRIDGE_TYPE_ARCH && bUpper)
					{
						if(jijum == GetJijumConnectRibAndSlab()-1 || jijum == GetJijumConnectRibAndSlab())
							m_nCountJointMainRebar_UpperSlab_Cycle2[jijum][upper][dan] = 3;
						else
							m_nCountJointMainRebar_UpperSlab_Cycle2[jijum][upper][dan] = 2;
					}
					else
					{
						m_nCountJointMainRebar_UpperSlab_Cycle2[jijum][upper][dan] = 2;	// 상부슬래브 상,하면 각 지간별 이음 개수
					}
				}
				for(stt = 0; stt < 2; stt++)
				{
					for(inner = 0; inner < 2; inner++)
						m_nCountJointMainRebar_OutWall_Cycle2[stt][inner][dan] = 2;	// 외측벽체 시종점,좌우측 이음 개수
				}
				if(pWall)
				{
					for(left = 0; left < 2; left++)
						pWall->m_nCountJointMainRebar_Cycle2[left][dan] = 2;
				}
			}
		}
	}
}

// 상부슬래브 2,3단 철근에 대해서 확장길이 적용
// 상부슬래브는 2,3단에 대해서 이음이 생길 수 없으므로 무조건 좌우로 늘려줌늘려줌
void CRcBridgeRebar::ApplyExtLength23DanMainRebar_UpperSlab(CRebarInfoCycle* pRC, double dLengthExt23DanRebar)
{
	if(!pRC) return;
	if(!pRC->m_bExist) return;

	if(pRC->m_nPosStt != pRC->m_nPosEnd)
	{
		CDPoint xyDir	= CDPoint(0, 1);
			
		if(pRC->m_nPosStt != REBARINFO_POS_STTWALL_OUTTER || IsOutWall(TRUE))
		{
			xyDir	= (pRC->m_xyMid1 - pRC->m_xyStt).Unit();
			pRC->m_xyStt	= pRC->m_xyStt + (xyDir * -	dLengthExt23DanRebar);
		}
		

		if(pRC->m_nPosEnd != REBARINFO_POS_ENDWALL_OUTTER || IsOutWall(FALSE))
		{
			xyDir	= (pRC->m_xyEnd - pRC->m_xyMid2).Unit();
			pRC->m_xyEnd	= pRC->m_xyEnd + (xyDir * dLengthExt23DanRebar);
		}
	}
	else
	{
		CDPoint xyDir	= (pRC->m_xyMid1 - pRC->m_xyStt).Unit();
		pRC->m_xyStt	= pRC->m_xyStt + (xyDir * -dLengthExt23DanRebar);
		pRC->m_xyMid1	= pRC->m_xyMid1 + (xyDir * dLengthExt23DanRebar);
		pRC->m_xyMid2	= pRC->m_xyMid1;
		pRC->m_xyEnd	= pRC->m_xyMid1;
	}
}

// 외측벽체 2,3단 철근에 대해서 확장길이 적용
// 일단 필요한 경우 모두 늘려놓고, 마지막 철근은 상부슬래브 피복철근을 넘어가는지 검사해 준다.
void CRcBridgeRebar::ApplyExtLength23DanMainRebar_OutWall(CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC, double dLengthExt23DanRebar)
{
	CWallApp wall;
	CTwinVector tvRebar	= GetTvOffset_UpperSlab(0, TRUE, -1, -1, IsVertDir());
	wall.ApplyExtLength23DanMainRebar(pArrRC, dLengthExt23DanRebar, tvRebar);
}

// 긴급 권고안
// 2cycle이음 입력이 가능해 지면서 예전 파일에 대해서 2cycle 철근 권고안이 필요 하게 돼었다.
// 정확하게 맞춰 줘야 됨. 
// long nType : 0 상부슬래브 1 외측벽체 2 중간벽체 3 하부슬래브 -1 전체
void CRcBridgeRebar::SyncRebar2CycleMainRebarOldAndNew(long nType, BOOL bDefaultUpper, BOOL bDefaultLower)
{
	long upper(0), i(0), stt(0);
	BOOL bStt(TRUE), bInner(TRUE);
	BOOL bVertDir	= IsVertDir();
	double dDist(0);

	CSafetyTypedPtrArray <CObArray, CDoubleArray*> *pArrDist	= NULL;
	CSafetyTypedPtrArray <CObArray, CDoubleArray*> *pArrDia		= NULL;
	CSafetyTypedPtrArray <CObArray, CDoubleArray*> *pArrExist;
	CSafetyTypedPtrArray <CObArray, CDoubleArray*> pArrDistTmp;
	CSafetyTypedPtrArray <CObArray, CDoubleArray*> pArrDiaTmp;

	// 이게 하나도 없는 경우는 배근 입력자체가 안 된경우이므로 
	// 권고안을 해서 넘겨준다.
	if(m_pArrDistUpperSlab[1][iUPPER][0].GetSize() == 0)
	{
		SetDataDefaultRebarInfoCycle_Std(-1, 1);
		SetDataDefaultRebarInfoCycle_Std(-1, 3);
	}

	// ***** 상부 슬래브 상면 *****
	if(nType == 0 || nType == -1)
	{
		if(bDefaultUpper)
		{
			// 1. 지간별 이음을 2개로 함
			// 2. 두번째 철근은 없는걸로 만듬
			// 3. 철근 길이 맞춰줌
			pArrDist	= &m_pArrDistUpperSlab[1][iUPPER][0];
			pArrDia		= &m_pArrDiaUpperSlab[1][iUPPER][0];
			pArrExist	= &m_pArrExistUpperSlab[1][iUPPER][0];
			AhTPADelete(pArrExist, (CDoubleArray*)0);

			for(i = 0; i < m_nQtyJigan; i++)
			{
				if(IsJointMainRebarUpperSlab_Upper_Cycle2(i))
				{
					m_nCountJointMainRebar_UpperSlab_Cycle2[i][iUPPER][0]	= 0;
				}
				else
				{
					m_nCountJointMainRebar_UpperSlab_Cycle2[i][iUPPER][0]	= 2;
				}
				// 기존 직경 설정
				CDoubleArray *pDArr	= pArrDia->GetAt(i);
				CDoubleArray *pDArrTmp	= new CDoubleArray;
				CDoubleArray *pDArrExistTmp	= new CDoubleArray;
				pDArrTmp->Add(pDArr->GetAt(0));
				pDArrExistTmp->Add((double)TRUE);
				pDArrTmp->Add(pDArr->GetAt(0));
				pDArrExistTmp->Add((double)FALSE);
				if(i == m_nQtyJigan-1)
				{
					pDArrTmp->Add(pDArr->GetAt(1));
					pDArrExistTmp->Add((double)TRUE);
				}
				pArrDiaTmp.Add(pDArrTmp);
				pArrExist->Add(pDArrExistTmp);

				// 기존 거리 설정
				CRebarInfoCycle rc;
				rc.m_Dia		= pDArr->GetAt(0);
				rc.m_nPosStt	= i == 0 ? REBARINFO_POS_STTWALL_OUTTER : REBARINFO_POS_UPPERSLAB_UPPER;
				rc.m_nPosEnd	= i == 0 ? REBARINFO_POS_UPPERSLAB_UPPER : (i == m_nQtyHDan-1 ? REBARINFO_POS_ENDWALL_OUTTER : REBARINFO_POS_UPPERSLAB_UPPER);
				//double dLenJigan	= GetLengthJigan(i, 0, bVertDir, TRUE);
				double dDiaNext		= pDArrTmp->GetAt(0);
				double dLenJoint1	= GetValueJoint(&rc, dDiaNext);
				dDiaNext			= i < m_nQtyJigan-1 ? pArrDia->GetAt(i+1)->GetAt(0) : pDArrTmp->GetAt(1);
				double dLenJoint2	= GetValueJoint(&rc, dDiaNext);
				//double dCoverStt	= m_dCoverWallOut[0] / GetAngleJijum(0, bVertDir).y;
				//double dCoverEnd	= m_dCoverWallOut[0] / GetAngleJijum(m_nQtyJigan, bVertDir).y;

				dDist	= pArrDist->GetAt(i)->GetAt(0) - dLenJoint1/2;
				CDoubleArray *pDArrDistTmp	= new CDoubleArray;
				pDArrDistTmp->Add(Round(dDist, 0));
				
				CDoubleArray *pDArrJigan	= pArrDist->GetAt(i);
				dDist	= pDArrJigan->GetAt(1) + dLenJoint1/2 + dLenJoint2/2;//dLenJigan - dDist - pDArrJigan->GetAt(1) + dLenJoint2/2;
				/*
				if(i == 0)
				{
					dDist -= dCoverStt;
					dDist -= GetLenRebarAtEdge(pDArrTmp->GetAt(0));
				}
				if(i == m_nQtyJigan-1)
				{
					dDist -= dCoverEnd;
					dDist -= GetLenRebarAtEdge(pDArrTmp->GetAt(2));
				}
				*/
				pDArrDistTmp->Add(Round(dDist, 0));

				pArrDistTmp.Add(pDArrDistTmp);
			}

			AhTPACopy(pArrDist, &pArrDistTmp, (CDoubleArray*)0);
			AhTPACopy(pArrDia, &pArrDiaTmp, (CDoubleArray*)0);
		}

		if(bDefaultLower)
		{
			// ***** 상부 슬래브 하면 *****
			// 1. 지간별 이음 2개씩
			AhTPADelete(&pArrDistTmp, (CDoubleArray*)0);
			AhTPADelete(&pArrDiaTmp, (CDoubleArray*)0);
			pArrDist	= &m_pArrDistUpperSlab[1][iLOWER][0];
			pArrDia		= &m_pArrDiaUpperSlab[1][iLOWER][0];
			pArrExist	= &m_pArrExistUpperSlab[1][iLOWER][0];
			AhTPADelete(pArrExist, (CDoubleArray*)0);

			for(i = 0; i < m_nQtyJigan; i++)
			{
				if(IsJointMainRebarUpperSlab_Lower_Cycle2((long)i))
				{
					m_nCountJointMainRebar_UpperSlab_Cycle2[i][iLOWER][0]	= 1;
				}
				else
				{
					if(i == m_nQtyJigan-1 && IsJointMainRebarUpperSlab_Lower_Cycle2((long)m_nQtyJigan))
						m_nCountJointMainRebar_UpperSlab_Cycle2[i][iLOWER][0]	= 1;
					else
						m_nCountJointMainRebar_UpperSlab_Cycle2[i][iLOWER][0]	= 2;
				}

				// 기존 직경 설정
				CDoubleArray *pDArr	= pArrDia->GetAt(i);
				CDoubleArray *pDArrTmp	= new CDoubleArray;
				CDoubleArray *pDArrExistTmp	= new CDoubleArray;
				if(i == 0 && m_nCountJointMainRebar_UpperSlab_Cycle2[i][iLOWER][0] == 1)
				{
					pDArrTmp->Add(pDArr->GetAt(0));
					pDArrExistTmp->Add((double)TRUE);
					pDArrTmp->Add(pDArr->GetAt(0));
					pDArrExistTmp->Add((double)FALSE);
				}
				else
				{
					pDArrTmp->Add(pDArr->GetAt(0));
					pDArrExistTmp->Add((double)FALSE);
					pDArrTmp->Add(pDArr->GetAt(0));
					pDArrExistTmp->Add((double)TRUE);
					if(i == m_nQtyJigan-1)
					{
						pDArrTmp->Add(pDArr->GetAt(0));
						pDArrExistTmp->Add((double)FALSE);
					}
				}
				pArrDiaTmp.Add(pDArrTmp);
				pArrExist->Add(pDArrExistTmp);

				// 기존 거리 설정
				CRebarInfoCycle rc;
				rc.m_Dia		= pDArr->GetAt(0);
				rc.m_nPosStt	= REBARINFO_POS_UPPERSLAB_LOWER;
				rc.m_nPosEnd	= REBARINFO_POS_UPPERSLAB_LOWER;
				double dLenJigan	= GetLengthJigan(i, 0, bVertDir);
				if(i == 0 && IsOutWall(TRUE))
					dLenJigan += m_dWS / GetAngleJijum(0, bVertDir).y;
				if(i == m_nQtyJigan-1 && IsOutWall(FALSE))
					dLenJigan += m_dWE / GetAngleJijum(m_nQtyJigan, bVertDir).y;
				double dDiaNext		= pDArrTmp->GetAt(0);
				double dLenJoint1	= GetValueJoint(&rc, dDiaNext);
				dDiaNext			= i < m_nQtyJigan-1 ? pArrDia->GetAt(i+1)->GetAt(0) : pDArrTmp->GetAt(1);
				double dLenJoint2	= GetValueJoint(&rc, dDiaNext);
				double dCoverStt	= m_dCoverWallOut[0] / GetAngleJijum(0, bVertDir).y;
				double dCoverEnd	= m_dCoverWallOut[0] / GetAngleJijum(m_nQtyJigan, bVertDir).y;

				// 유간 있을 땐 유간 고려..  2008/05/19 //
				if(i == 0 && m_bExpJoint[0])
				{
					dCoverStt	+= GetJijum(0)->m_dLengthUgan[1];
				}
				if(i == m_nQtyJigan-1 && m_bExpJoint[m_nQtyJigan])
				{
					dCoverEnd += GetJijum(m_nQtyJigan)->m_dLengthUgan[0];
				}
				// 유간 있을 땐 유간 고려..  2008/05/19 //
				
				CDoubleArray *pDArrDistTmp	= new CDoubleArray;
				if(i == 0 && m_nCountJointMainRebar_UpperSlab_Cycle2[i][iLOWER][0] == 1)
				{
					dDist	= dLenJigan	- pArrDist->GetAt(i)->GetAt(0) - pArrDist->GetAt(i)->GetAt(1) - dLenJoint1/2;
					if(i == 0)
					{
						dDist -= dCoverStt;
					}
					pDArrDistTmp->Add(Round(dDist, 0));
				}
				else
				{
					dDist	= pArrDist->GetAt(i)->GetAt(0) + dLenJoint1/2;
					pDArrDistTmp->Add(Round(dDist, 0));
					
					dDist	= dLenJigan - dDist - pArrDist->GetAt(i)->GetAt(1) - dLenJoint2/2;
					if(i == 0)
					{
						dDist -= dCoverStt;
					}
					if(i == m_nQtyJigan-1)
					{
						dDist -= dCoverEnd;
					}
					pDArrDistTmp->Add(Round(dDist, 0));
				}
				pArrDistTmp.Add(pDArrDistTmp);			
			}

			AhTPACopy(pArrDist, &pArrDistTmp, (CDoubleArray*)0);
			AhTPACopy(pArrDia, &pArrDiaTmp, (CDoubleArray*)0);
		}
		// 메모리 릭 때문에 추가 - 김도헌
		AhTPADelete(&pArrDistTmp, (CDoubleArray*)0);
		AhTPADelete(&pArrDiaTmp, (CDoubleArray*)0);
	}

	// ***** 시종점벽체 외측면 *****
	if(nType == 1 || nType == -1)
	{
		for(stt = 0; stt < 2; stt++)
		{
			bStt	= stt == iSTT ? TRUE : FALSE;
			
			if(IsOutWall(bStt))
			{
				for(long inner = 0; inner < 2; inner++)
				{
					bInner	= inner == iINNER;

					// 1. 이음 2개
					if(!bInner)
					{
						if(IsEnableJointMainRebar_OutWallOutterAndUpperSlabUpper(bStt, FALSE))
							m_nCountJointMainRebar_OutWall_Cycle2[stt][inner][0]	= 0;
						else
							m_nCountJointMainRebar_OutWall_Cycle2[stt][inner][0]	= 2;
					}
					else
					{
						if(IsJointMainRebarOutWall_Cycle2_Old(bStt, TRUE) && IsJointMainRebarOutWall_Cycle2_Old(bStt, FALSE))
							m_nCountJointMainRebar_OutWall_Cycle2[stt][inner][0]	= 0;
						else if(IsJointMainRebarOutWall_Cycle2_Old(bStt, TRUE) || IsJointMainRebarOutWall_Cycle2_Old(bStt, FALSE))
							m_nCountJointMainRebar_OutWall_Cycle2[stt][inner][0]	= 1;
						else
							m_nCountJointMainRebar_OutWall_Cycle2[stt][inner][0]	= 2;

					}

					AhTPADelete(&pArrDistTmp, (CDoubleArray*)0);
					AhTPADelete(&pArrDiaTmp, (CDoubleArray*)0);

					CDoubleArray *pDArrDist		= &m_pArrDistOutWall[1][stt][inner][0];
					CDoubleArray *pDArrDia		= &m_pArrDiaOutWall[1][stt][inner][0];
					CDoubleArray *pDArrExist	= &m_pArrExistOutWall[1][stt][inner][0];
					CDoubleArray pDArrDistTmp;
					CDoubleArray pDArrDiaTmp;

					pDArrExist->RemoveAll();

					// 기존 직경 설정
					pDArrDiaTmp.Add(pDArrDia->GetAt(0));
					pDArrExist->Add((double)(bInner ? FALSE : TRUE));
					pDArrDiaTmp.Add(pDArrDia->GetAt(0));
					pDArrExist->Add((double)(bInner ? TRUE : FALSE));
					if(bInner && IsBoxType())
					{
						pDArrDiaTmp.Add(pDArrDia->GetAt(0));
						pDArrExist->Add((double)FALSE);
					}

					// 기존 거리 설정
					CRebarInfoCycle rc;
					
					rc.m_Dia		= pDArrDia->GetAt(0);
					rc.m_nPosEnd	= bInner ? REBARINFO_POS_STTWALL_INNER : REBARINFO_POS_STTWALL_OUTTER;
					rc.m_nPosStt	= IsBoxType()? rc.m_nPosEnd : REBARINFO_POS_FOOTING_LOWER;
					double dHeightWall	= GetTvOffset_OutWall(0, bStt, FALSE, bVertDir).GetVerLength();
					double dDiaNext		= pDArrDiaTmp.GetAt(1);
					double dLenJoint1	= GetValueJoint(&rc, dDiaNext);
					dDiaNext			= bInner ? pDArrDiaTmp.GetAt(1) : GetDiaMainRebarUpperSlab(1, 0, TRUE, bStt ? 0 : -1, bStt ? 0 : -1);
					double dLenJoint2	= GetValueJoint(&rc, dDiaNext);
					dDist	= pDArrDist->GetAt(0) - (bInner ? -dLenJoint1/2 : dLenJoint1/2);
					if(bInner && !IsBoxType())
					{
						// 박스형은 기초가없어서 하단 라운드가 없다.
						dDist -= GetLenRebarAtEdge(rc.m_Dia);
					}

					// 아래쪽이 연결 되었다면
					if(bInner && IsJointMainRebarOutWall_Cycle2_Old(bStt, FALSE) )
					{
						if(pDArrDist->GetSize() > 1)
						{
							dDist	= dHeightWall - pDArrDist->GetAt(1) - dLenJoint2/2;
							dDist	-= GetLenRebarAtEdge(rc.m_Dia);
						}
						
						if(pDArrExist->GetSize() > 0)	pDArrExist->SetAt(0, (double)TRUE);
						if(pDArrExist->GetSize() > 1)	pDArrExist->SetAt(1, (double)FALSE);
					}

					pDArrDistTmp.Add(Round(dDist, 0));
					
					// 위쪽이 연결된 경우라면 
					if(!bInner || !IsJointMainRebarOutWall_Cycle2_Old(bStt, TRUE))
					{
						if(pDArrDist->GetSize() > 1)
							dDist	= dHeightWall - dDist - pDArrDist->GetAt(1) + (bInner ? -dLenJoint2/2 : dLenJoint2/2);
						// BOX타입인 경우는 철근 하단에 라운드부분이 없으니까 빼줄게 없다.
						if(!IsBoxType())
							dDist	-= GetLenRebarAtEdge(pDArrDiaTmp.GetAt(0));
						if(!bInner)
							dDist -= GetLenRebarAtEdge(dDiaNext);

						// dDist가 0이 나오는 경우는 기존에 2사이클 외측벽체 외측면을 서로 겹치게 한 경우이다.
						if(dDist < 0)
							dDist = 0;
						pDArrDistTmp.Add(Round(dDist, 0));
					}

					*pDArrDist	= pDArrDistTmp;
					*pDArrDia	= pDArrDiaTmp;
				}
			}
		}
	}

	// 내측벽체(좌우측)
	if(nType == 2 || nType == -1)
	{
		long nCountInWall	= GetCountInWall();
		for(long wall = 0; wall < nCountInWall; wall++)
		{
			CWallApp *pWall	= GetInWall(wall);
			if(!pWall) continue;
			if(!pWall->m_bIs) continue;
			
			CFootingApp *pFooting	= &pWall->m_footing;

			for(long left = 0; left < 2; left++)
			{
				// 1. 이음 2개
				CDoubleArray *pDArrExist	= &pWall->m_dArrExistRC[1][left][0];
				pDArrExist->RemoveAll();

				long j = 0; for(j = 0; j < pWall->m_nCountJointMainRebar_Cycle2[left][0]+1; j++)
				{
					// 기존 직경 설정
					pDArrExist->Add(m_bPlacingInWallRebarOfCycle24 ? (double)TRUE : (double)FALSE);
				}
			}
		}
	}

	// ***** 하부 슬래브 하면 *****
	if(nType == 3 || (nType == -1 && m_nTypeBridge == BRIDGE_TYPE_BOX))
	{
		if(bDefaultLower)
		{
			// 1. 지간별 이음을 2개로 함
			// 2. 두번째 철근은 없는걸로 만듬
			// 3. 철근 길이 맞춰줌
			pArrDist	= &m_pArrDistLowerSlab[1][iLOWER][0];
			pArrDia		= &m_pArrDiaLowerSlab[1][iLOWER][0];
			pArrExist	= &m_pArrExistLowerSlab[1][iLOWER][0];
			AhTPADelete(pArrExist, (CDoubleArray*)0);

			for(i = 0; i < m_nQtyJigan; i++)
			{
				if(IsJointMainRebarLowerSlab_Lower_Cycle2(i))
				{
					m_nCountJointMainRebar_LowerSlab_Cycle2[i][iLOWER][0]	= 0;
				}
				else
				{
					m_nCountJointMainRebar_LowerSlab_Cycle2[i][iLOWER][0]	= 2;
				}
				// 기존 직경 설정
				CDoubleArray *pDArr	= pArrDia->GetAt(i);
				CDoubleArray *pDArrTmp	= new CDoubleArray;
				CDoubleArray *pDArrExistTmp	= new CDoubleArray;
				pDArrTmp->Add(pDArr->GetAt(0));
				pDArrExistTmp->Add((double)TRUE);
				pDArrTmp->Add(pDArr->GetAt(0));
				pDArrExistTmp->Add((double)FALSE);
				if(i == m_nQtyJigan-1)
				{
					pDArrTmp->Add(pDArr->GetAt(1));
					pDArrExistTmp->Add((double)TRUE);
				}
				pArrDiaTmp.Add(pDArrTmp);
				pArrExist->Add(pDArrExistTmp);

				// 기존 거리 설정
				CRebarInfoCycle rc;
				rc.m_Dia		= pDArr->GetAt(0);
				rc.m_nPosStt	= i == 0 ? REBARINFO_POS_STTWALL_OUTTER : REBARINFO_POS_LOWERSLAB_LOWER;
				rc.m_nPosEnd	= i == 0 ? REBARINFO_POS_LOWERSLAB_LOWER : (i == m_nQtyHDan-1 ? REBARINFO_POS_ENDWALL_OUTTER : REBARINFO_POS_LOWERSLAB_LOWER);
				//double dLenJigan	= GetLengthJigan(i, 0, bVertDir, TRUE);
				double dDiaNext		= pDArrTmp->GetAt(0);
				double dLenJoint1	= GetValueJoint(&rc, dDiaNext);
				dDiaNext			= i < m_nQtyJigan-1 ? pArrDia->GetAt(i+1)->GetAt(0) : pDArrTmp->GetAt(1);
				double dLenJoint2	= GetValueJoint(&rc, dDiaNext);
				//double dCoverStt	= m_dCoverWallOut[0] / GetAngleJijum(0, bVertDir).y;
				//double dCoverEnd	= m_dCoverWallOut[0] / GetAngleJijum(m_nQtyJigan, bVertDir).y;

				dDist	= pArrDist->GetAt(i)->GetAt(0) - dLenJoint1/2;
				CDoubleArray *pDArrDistTmp	= new CDoubleArray;
				pDArrDistTmp->Add(Round(dDist, 0));
				
				CDoubleArray *pDArrJigan	= pArrDist->GetAt(i);
				dDist	= pDArrJigan->GetAt(1) + dLenJoint1/2 + dLenJoint2/2;//dLenJigan - dDist - pDArrJigan->GetAt(1) + dLenJoint2/2;
				/*
				if(i == 0)
				{
					dDist -= dCoverStt;
					dDist -= GetLenRebarAtEdge(pDArrTmp->GetAt(0));
				}
				if(i == m_nQtyJigan-1)
				{
					dDist -= dCoverEnd;
					dDist -= GetLenRebarAtEdge(pDArrTmp->GetAt(2));
				}
				*/
				pDArrDistTmp->Add(Round(dDist, 0));

				pArrDistTmp.Add(pDArrDistTmp);
			}

			AhTPACopy(pArrDist, &pArrDistTmp, (CDoubleArray*)0);
			AhTPACopy(pArrDia, &pArrDiaTmp, (CDoubleArray*)0);
		}

		if(bDefaultUpper)
		{
			// ***** 하부 슬래브 상면 *****
			// 1. 지간별 이음 2개씩
			AhTPADelete(&pArrDistTmp, (CDoubleArray*)0);
			AhTPADelete(&pArrDiaTmp, (CDoubleArray*)0);
			pArrDist	= &m_pArrDistLowerSlab[1][iUPPER][0];
			pArrDia		= &m_pArrDiaLowerSlab[1][iUPPER][0];
			pArrExist	= &m_pArrExistLowerSlab[1][iUPPER][0];
			AhTPADelete(pArrExist, (CDoubleArray*)0);

			for(i = 0; i < m_nQtyJigan; i++)
			{
				if(IsJointMainRebarLowerSlab_Upper_Cycle2((long)i))
				{
					m_nCountJointMainRebar_LowerSlab_Cycle2[i][iUPPER][0]	= 1;
				}
				else
				{
					if(i == m_nQtyJigan-1 && IsJointMainRebarLowerSlab_Upper_Cycle2((long)m_nQtyJigan))
						m_nCountJointMainRebar_LowerSlab_Cycle2[i][iUPPER][0]	= 1;
					else
						m_nCountJointMainRebar_LowerSlab_Cycle2[i][iUPPER][0]	= 2;
				}

				// 기존 직경 설정
				CDoubleArray *pDArr	= pArrDia->GetAt(i);
				CDoubleArray *pDArrTmp	= new CDoubleArray;
				CDoubleArray *pDArrExistTmp	= new CDoubleArray;
				if(i == 0 && m_nCountJointMainRebar_LowerSlab_Cycle2[i][iUPPER][0] == 1)
				{
					pDArrTmp->Add(pDArr->GetAt(0));
					pDArrExistTmp->Add((double)TRUE);
					pDArrTmp->Add(pDArr->GetAt(0));
					pDArrExistTmp->Add((double)FALSE);
				}
				else
				{
					pDArrTmp->Add(pDArr->GetAt(0));
					pDArrExistTmp->Add((double)FALSE);
					pDArrTmp->Add(pDArr->GetAt(0));
					pDArrExistTmp->Add((double)TRUE);
					if(i == m_nQtyJigan-1)
					{
						pDArrTmp->Add(pDArr->GetAt(0));
						pDArrExistTmp->Add((double)FALSE);
					}
				}
				pArrDiaTmp.Add(pDArrTmp);
				pArrExist->Add(pDArrExistTmp);

				// 기존 거리 설정
				CRebarInfoCycle rc;
				rc.m_Dia		= pDArr->GetAt(0);
				rc.m_nPosStt	= REBARINFO_POS_LOWERSLAB_UPPER;
				rc.m_nPosEnd	= REBARINFO_POS_LOWERSLAB_UPPER;
				double dLenJigan	= GetLengthJigan(i, 0, bVertDir);
				if(i == 0 && IsOutWall(TRUE))
					dLenJigan += m_dWS / GetAngleJijum(0, bVertDir).y;
				if(i == m_nQtyJigan-1 && IsOutWall(FALSE))
					dLenJigan += m_dWE / GetAngleJijum(m_nQtyJigan, bVertDir).y;
				double dDiaNext		= pDArrTmp->GetAt(0);
				double dLenJoint1	= GetValueJoint(&rc, dDiaNext);
				dDiaNext			= i < m_nQtyJigan-1 ? pArrDia->GetAt(i+1)->GetAt(0) : pDArrTmp->GetAt(1);
				double dLenJoint2	= GetValueJoint(&rc, dDiaNext);
				double dCoverStt	= m_dCoverWallOut[0] / GetAngleJijum(0, bVertDir).y;
				double dCoverEnd	= m_dCoverWallOut[0] / GetAngleJijum(m_nQtyJigan, bVertDir).y;

				// 유간 있을 땐 유간 고려..  2008/05/19 //
				if(i == 0 && m_bExpJoint[0])
				{
					dCoverStt	+= GetJijum(0)->m_dLengthUgan[1];
				}
				if(i == m_nQtyJigan-1 && m_bExpJoint[m_nQtyJigan])
				{
					dCoverEnd += GetJijum(m_nQtyJigan)->m_dLengthUgan[0];
				}
				// 유간 있을 땐 유간 고려..  2008/05/19 //
				
				CDoubleArray *pDArrDistTmp	= new CDoubleArray;
				if(i == 0 && m_nCountJointMainRebar_LowerSlab_Cycle2[i][iUPPER][0] == 1)
				{
					dDist	= dLenJigan	- pArrDist->GetAt(i)->GetAt(0) - pArrDist->GetAt(i)->GetAt(1) - dLenJoint1/2;
					if(i == 0)
					{
						dDist -= dCoverStt;
					}
					pDArrDistTmp->Add(Round(dDist, 0));
				}
				else
				{
					dDist	= pArrDist->GetAt(i)->GetAt(0) + dLenJoint1/2;
					pDArrDistTmp->Add(Round(dDist, 0));
					
					dDist	= dLenJigan - dDist - pArrDist->GetAt(i)->GetAt(1) - dLenJoint2/2;
					if(i == 0)
					{
						dDist -= dCoverStt;
					}
					if(i == m_nQtyJigan-1)
					{
						dDist -= dCoverEnd;
					}
					pDArrDistTmp->Add(Round(dDist, 0));
				}
				pArrDistTmp.Add(pDArrDistTmp);			
			}

			AhTPACopy(pArrDist, &pArrDistTmp, (CDoubleArray*)0);
			AhTPACopy(pArrDia, &pArrDiaTmp, (CDoubleArray*)0);
		}
		// 메모리 릭 때문에 추가 - 김도헌
		AhTPADelete(&pArrDistTmp, (CDoubleArray*)0);
		AhTPADelete(&pArrDiaTmp, (CDoubleArray*)0);
	}

	for(upper = 0; upper < 2; upper++)
	{
		for(i = 0; i < m_pArrSetRebarJointUpperSlab[upper].GetSize(); i++)
		{
			CSetRebarJoint *pRJ	= m_pArrSetRebarJointUpperSlab[upper].GetAt(i);
			pRJ->m_bJoint	= FALSE;
		}
	}

	for(stt = 0; stt < 2; stt++)
	{
		for(upper = 0; upper < 2; upper++)
		{
			CSetRebarJoint *pSetRebarJoint = &m_pArrSetRebarJointOutWall_Inner[stt][upper];
			pSetRebarJoint->m_bJoint	= FALSE;
		}
	}

	if(m_nTypeBridge == BRIDGE_TYPE_BOX)
	{
		for(upper = 0; upper < 2; upper++)
		{
			for(i = 0; i < m_pArrSetRebarJointLowerSlab[upper].GetSize(); i++)
			{
				CSetRebarJoint *pRJ	= m_pArrSetRebarJointLowerSlab[upper].GetAt(i);
				pRJ->m_bJoint	= FALSE;
			}
		}
	}
}

double CRcBridgeRebar::GetLengthExt23DanRebarUpperSlab(BOOL bUpper, long nIdx)
{
	long upper	= bUpper ? iUPPER : iLOWER;
	long nSize = m_pArrSetRebarDanUpperSlab[upper].GetSize();
	if(nIdx == -1) nIdx = nSize-1;
	if(nIdx < 0 || nIdx >= nSize) return 1;

	CSetRebarDan *pRD	= m_pArrSetRebarDanUpperSlab[upper].GetAt(nIdx);
	return pRD->m_dLengthExt23DanRebar;
}

double CRcBridgeRebar::GetLengthExt23DanRebarOutWall(BOOL bStt, BOOL bInner)
{
	long stt	= bStt ? iSTT : iEND;
	long inner	= bInner ? iINNER : iOUTTER;

	CSetRebarDan *pRD	= &m_pArrSetRebarDanOutWall[stt][inner];
	return pRD->m_dLengthExt23DanRebar;
}

// 상부슬래브 철근에 사각 정보 설정
void CRcBridgeRebar::SettingAngleInfoAtRebarInfoCycle_UpperSlab(CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC, long nJ, long nIdxStt, long nIdxEnd, BOOL bVertDir)
{
	if(!pArrRC) return;
	long nSize	= pArrRC->GetSize();
	if(nSize < 1) return;
	if(nIdxStt == -1) nIdxStt	= 0;
	if(nIdxEnd == -1) nIdxEnd	= nSize - 1;

	if(nIdxStt < 0) nIdxStt	= 0;
	if(nIdxEnd >= nSize) nIdxEnd	= nSize - 1;

	long i = 0; for(i = nIdxStt; i <= nIdxEnd; i++)
	{
		CRebarInfoCycle *pRC	= pArrRC->GetAt(i);
		pRC->m_bApplyAngle	= !bVertDir;
		pRC->m_dAngle		= GetAngleJijum(0).GetAngleDegree();
		pRC->m_bCalLengthByAngle	= m_nTypePlacingMainRebar_UpperSlab == 0 ? TRUE : FALSE;
	}
}

double CRcBridgeRebar::GetLengthBynVertDir(double dLen, long nVertDir)
{
	// 주철근 이음 위치는 직거리 사거리 두가지 방법으로 입력받는다.
	// 사거리인 경우 직거리로 구해야 될 때도 있고, 직거리인데 사거리로 구해야 될때도 있다.
	// 일단 사각은 시점각도만을 고려한다.
	BOOL bVertDir	= IsVertDir();
	if(nVertDir != 0)
	{
		double dAngCur		= bVertDir ? 90 : GetAngleJijum(0).GetAngleDegree();
		double dAngApply	= nVertDir == -1 ? 90 : GetAngleJijum(0).GetAngleDegree();

		if(dAngCur != dAngApply)
		{
			if(dAngCur == 90)
			{
				dLen	= dLen / sin(ToRadian(dAngApply));
			}
			else
			{
				dLen	= dLen * sin(ToRadian(dAngCur));
			}
		}
	}

	return dLen;
}

void CRcBridgeRebar::GetXyRebarWingWallReinforce(CDPoint *xy, BOOL bStt, BOOL bLeft)
{
	CWingWall* pWing = GetWingWall(bStt, bLeft);
	
	if(!pWing->m_bExist) return;
	
	CTwinVectorArray tvArrGen;
	CTwinVector tvOut, tvEnd, tvHuPrev, tvHuNext, tvHunch, tvSlab, tvFoot;
	
	GetTvWingWallPlane(bStt, TRUE, TRUE, TRUE);
	tvArrGen = m_tvArrPlaneWingWall;
	
	CString strDir = bLeft ? _T("좌측") : _T("우측");

	CDPoint xyRf1(0, 0), xyRf2(0, 0), xyRf3(0, 0);
	double lr = bLeft ? -1.0 : 1.0;
	double dCoverWallOut = m_dCoverWallOut[0];
	double dCoverSlab = m_dCoverWallIn[0];
	double dTickWall = (bStt)? m_dWS : m_dWE;
	double dDistOffset = dTickWall - dCoverSlab - dCoverWallOut;
	
	tvArrGen.GetTvByInfo(strDir+_T("날개벽외측"), tvOut);
	tvArrGen.GetTvByInfo(_T("슬래브끝단외측"), tvSlab);
	
	Offset(tvOut.m_v1, tvOut.m_v2, -(m_dCoverWingOut[0])*lr);
	Offset(tvSlab.m_v1, tvSlab.m_v2, -dDistOffset);
	CDPoint vOut = tvOut.GetXyDir();
	CDPoint vSlab = tvSlab.GetXyDir();
	
	GetXyMatchLineAndLine(tvOut.m_v1, vOut, tvSlab.m_v1, vSlab, xyRf2);
	xyRf1 = xyRf2 - vSlab*3000*lr;
	xyRf3 = xyRf2 + vOut*1000;
	
	xy[0] = xyRf1;
	xy[1] = xyRf2;
	xy[2] = xyRf3;
}

void CRcBridgeRebar::SettingVertSection()
{
	m_bSettingVertSection	= FALSE;

	long nTypeJongDan	= m_nTypeJongdanForRebar;
	CTwinVectorArray tvArrVertSection;
	tvArrVertSection	= m_tvArrVertSection;
	for(long jong = 0; jong < 3; jong++)
	{
		m_nTypeJongdanForRebar	= jong;
		for(long wing = 0; wing < 2; wing++)
		{
			BOOL bWingFront	= wing == 0 ? FALSE : TRUE;
			if(bWingFront && !IsOutsideWall()) continue;
			
			GetTvVertSection(-1, TRUE, bWingFront, -1, TRUE);
			m_tvArrVertSection_Ang_Left[jong][wing]		= m_tvArrVertSection;

			GetTvVertSection(0, TRUE, bWingFront);
			m_tvArrVertSection_Ang_Center[jong][wing]	= m_tvArrVertSection;

			GetTvVertSection(1, TRUE, bWingFront, -1, TRUE);
			m_tvArrVertSection_Ang_Right[jong][wing]	= m_tvArrVertSection;
		}

		//GetTvVertSection(-1, FALSE, FALSE);
		//m_tvArrVertSection_Vert_Left[jong]		= m_tvArrVertSection;

		GetTvVertSection(0, FALSE, FALSE);
		m_tvArrVertSection_Vert_Center[jong]	= m_tvArrVertSection;

		//GetTvVertSection(1, FALSE, FALSE);
		//m_tvArrVertSection_Vert_Right[jong]		= m_tvArrVertSection;
	}

	m_nTypeJongdanForRebar	= nTypeJongDan;
	m_tvArrVertSection		= tvArrVertSection;

	m_bSettingVertSection	= TRUE;
	m_bNeedSettingVertSection	= FALSE;
}

// 외측벽체 철근이 연결되어 있는지 판단.
BOOL CRcBridgeRebar::IsJointMainRebar_OutWall_Cycle2(BOOL bStt, BOOL bInner)
{
	BOOL bJoint	= FALSE;

	if(bInner)
	{
		CRebarInfoCycle *pRC	= GetRebarInfoCycleOutWall(1, 0, bStt, bInner, 0);
		if(pRC)
		{
			bJoint	= pRC->m_bExist;
		}
	}
	else
	{
		bJoint	= TRUE;
		long stt	= bStt ? iSTT : iEND;
		long inner	= bInner ? iINNER : iOUTTER;
		for(long rc = 0; rc < m_pArrRCMainOutWall[1][stt][inner][0].GetSize(); rc++)
		{
			CRebarInfoCycle *pRC	= m_pArrRCMainOutWall[1][stt][inner][0].GetAt(rc);
			if(!pRC->m_bExist)
			{
				bJoint	= FALSE;
				break;
			}
		}
	}

	return bJoint;
}

void CRcBridgeRebar::SetDataDefaultRangeSupportRebarForSameUpperSlab(long nJ)
{
	if(nJ == 0)
	{
		m_dRangeSupportRebarForSameUpperSlab[iSTT]	= 0;
		m_placeByBlock_SupportRebarAddSameUpperSlab[iSTT].m_xyArr.RemoveAll();
		m_placeByBlock_SupportRebarAddSameUpperSlab[iSTT].m_xyArr.Add(CDPoint(0, 0));
		m_placeByBlock_SupportRebarAddSameUpperSlab[iSTT].m_nCountBlock	= 1;
		m_dDistAddSupportRebarForSameUpperSlab[iSTT][iLEFT]		= 0;
		m_dDistAddSupportRebarForSameUpperSlab[iSTT][iRIGHT]	= 0;
	}
	else if(nJ == m_nQtyJigan)
	{
		m_dRangeSupportRebarForSameUpperSlab[iEND]	= 0;
		m_placeByBlock_SupportRebarAddSameUpperSlab[iEND].m_xyArr.RemoveAll();
		m_placeByBlock_SupportRebarAddSameUpperSlab[iEND].m_xyArr.Add(CDPoint(0, 0));
		m_placeByBlock_SupportRebarAddSameUpperSlab[iEND].m_nCountBlock	= 1;
		m_dDistAddSupportRebarForSameUpperSlab[iEND][iLEFT]		= 0;
		m_dDistAddSupportRebarForSameUpperSlab[iEND][iRIGHT]	= 0;
	}
	else
	{
		CWallApp *pWall	= GetInWall(nJ-1);
		if(pWall)
		{
			pWall->m_dRangeSupportRebarForSameUpperSlab	= 0;
		}
	}
}

// 주철근 평면 좌표 미리 구해둠.
void CRcBridgeRebar::SettingTvArrRebarMainPlane()
{
	// 가각을 일단 없앤 뒤에 배근하고 가각은 따로 배근함////
	m_tvArrPlane1DanOrg.RemoveAll();
	GetTvRebarOut_Plane_UpperSlabStd(m_tvArrPlane1DanOrg, 0, TRUE, 2, TRUE, FALSE);

	BOOL bIsExpOld	= m_bIsExp;
	double dExpEndW[2]	= {m_dExpEndW[0], m_dExpEndW[1]};
	double dExpEndR[2]	= {m_dExpEndR[0], m_dExpEndR[1]};
	double dExpEndH[2]	= {m_dExpEndH[0], m_dExpEndH[1]};
	double dExpSttW[2]	= {m_dExpSttW[0], m_dExpSttW[1]};
	double dExpSttR[2]	= {m_dExpSttR[0], m_dExpSttR[1]};
	double dExpSttH[2]	= {m_dExpSttH[0], m_dExpSttH[1]};
	m_bIsExp	= FALSE;
	long left = 0;
	for(left = 0; left < 2; left++)
	{
		m_dExpEndW[left]	= 0;
		m_dExpEndR[left]	= 0;
		m_dExpEndH[left]	= 0;
		m_dExpSttW[left]	= 0;
		m_dExpSttR[left]	= 0;
		m_dExpSttH[left]	= 0;
	}
	SettingPlane();
	// 가각을 일단 없앤 뒤에 배근하고 가각은 따로 배근함////

	long cycle(0), dan(0), rc(0), upper(0);
	BOOL bUpper(TRUE);
	CTwinVectorArray tvArr, tvArrAngLeft, tvArrAngRight, tvArrJoint, tvArrHidden, tvArrHiddenLeft, tvArrHiddenRight, tvArrAngLeftHalf, tvArrAngRightHalf;

	SettingValueRebarForSlab();
	

	for(upper = 0; upper < 2; upper++)
	{
		for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
		{
			for(dan = 0; dan < MAX_REBAR_DAN; dan++)
			{
				bUpper	= upper == iUPPER;

				// 상부슬래브 주철근
				AhTPADelete(&m_tvArr_RebarMain_Plane[cycle][dan][upper], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrAngLeft_RebarMain_Plane[cycle][dan][upper], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrAngRight_RebarMain_Plane[cycle][dan][upper], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrJoint_RebarMain_Plane[cycle][dan][upper], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrHidden_RebarMain_Plane[cycle][dan][upper], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrHiddenLeft_RebarMain_Plane[cycle][dan][upper], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrHiddenRight_RebarMain_Plane[cycle][dan][upper], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrAngLeftHalf_RebarMain_Plane[cycle][dan][upper], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrAngRightHalf_RebarMain_Plane[cycle][dan][upper], (CTwinVectorArray*)0);

				CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC	= &m_pArrRCMainUpperSlab[cycle][upper][dan];
				long nSize	= pArrRC->GetSize();
				for(rc = 0; rc < nSize; rc++)
				{
					GetTvRebarMain_Plane_UpperSlab_TypeNormal(tvArr, tvArrAngLeft, tvArrAngRight, bUpper, cycle, 
						dan, 0, rc, FALSE, FALSE, FALSE, tvArrJoint, tvArrHidden, tvArrHiddenLeft, 
						tvArrHiddenRight, TRUE, tvArrAngLeftHalf, tvArrAngRightHalf, TRUE);
				}

				// 상부슬래브 주철근만 2,3단 있음
				if(dan > 0) continue;
				if(bUpper) continue;

				// 상부슬래브 헌치부 주철근
				AhTPADelete(&m_tvArr_RebarMain_PlaneHunch[cycle], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrAngLeft_RebarMain_PlaneHunch[cycle], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrAngRight_RebarMain_PlaneHunch[cycle], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrJoint_RebarMain_PlaneHunch[cycle], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrHidden_RebarMain_PlaneHunch[cycle], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrHiddenLeft_RebarMain_PlaneHunch[cycle], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrHiddenRight_RebarMain_PlaneHunch[cycle], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrAngLeftHalf_RebarMain_PlaneHunch[cycle], (CTwinVectorArray*)0);
				AhTPADelete(&m_tvArrAngRightHalf_RebarMain_PlaneHunch[cycle], (CTwinVectorArray*)0);

				pArrRC	= &m_pArrRCMainUpperSlabHunch[cycle];
				nSize	= pArrRC->GetSize();
				for(rc = 0; rc < nSize; rc++)
				{
					GetTvRebarMain_Plane_UpperSlab_TypeNormal(tvArr, tvArrAngLeft, tvArrAngRight, bUpper, cycle, 
						dan, 0, rc, TRUE, FALSE, FALSE, tvArrJoint, tvArrHidden, tvArrHiddenLeft, 
						tvArrHiddenRight, TRUE, tvArrAngLeftHalf, tvArrAngRightHalf, TRUE);
				}

				if(cycle < 2)
				{
					// 시점브라켓
					pArrRC	= cycle == 0 ? &m_pArrRCMainOutWallBracket_Cycle1[iSTT] : &m_pArrRCMainOutWallBracket_Cycle2[iSTT];
					upper	= iLOWER;
					nSize	= pArrRC->GetSize();
					for(rc = 0; rc < nSize; rc++)
					{
						GetTvRebarMain_Plane_UpperSlab_TypeNormal(tvArr, tvArrAngLeft, tvArrAngRight, bUpper, cycle, 
							dan, 0, rc, FALSE, TRUE, FALSE, tvArrJoint, tvArrHidden, tvArrHiddenLeft, 
							tvArrHiddenRight, TRUE, tvArrAngLeftHalf, tvArrAngRightHalf, TRUE);
					}

					// 종점브라켓
					pArrRC	= cycle == 0 ? &m_pArrRCMainOutWallBracket_Cycle1[iEND] : &m_pArrRCMainOutWallBracket_Cycle2[iEND];
					upper	= iLOWER;
					nSize	= pArrRC->GetSize();
					for(rc = 0; rc < nSize; rc++)
					{
						GetTvRebarMain_Plane_UpperSlab_TypeNormal(tvArr, tvArrAngLeft, tvArrAngRight, bUpper, cycle, 
							dan, 0, rc, FALSE, FALSE, TRUE, tvArrJoint, tvArrHidden, tvArrHiddenLeft, 
							tvArrHiddenRight, TRUE, tvArrAngLeftHalf, tvArrAngRightHalf, TRUE);
					}
				}
			}
		}
	}

	if(IsBoxType())
	{
		for(upper = 0; upper < 2; upper++)
		{
			for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
			{
				for(dan = 0; dan < MAX_REBAR_DAN; dan++)
				{
					bUpper	= upper == iUPPER;

					// 하부슬래브 주철근
					AhTPADelete(&m_tvArr_RebarMain_LowerPlane[cycle][dan][upper], (CTwinVectorArray*)0);
					AhTPADelete(&m_tvArrAngLeft_RebarMain_LowerPlane[cycle][dan][upper], (CTwinVectorArray*)0);
					AhTPADelete(&m_tvArrAngRight_RebarMain_LowerPlane[cycle][dan][upper], (CTwinVectorArray*)0);
					AhTPADelete(&m_tvArrJoint_RebarMain_LowerPlane[cycle][dan][upper], (CTwinVectorArray*)0);
					AhTPADelete(&m_tvArrHidden_RebarMain_LowerPlane[cycle][dan][upper], (CTwinVectorArray*)0);
					AhTPADelete(&m_tvArrHiddenLeft_RebarMain_LowerPlane[cycle][dan][upper], (CTwinVectorArray*)0);
					AhTPADelete(&m_tvArrHiddenRight_RebarMain_LowerPlane[cycle][dan][upper], (CTwinVectorArray*)0);
					AhTPADelete(&m_tvArrAngLeftHalf_RebarMain_LowerPlane[cycle][dan][upper], (CTwinVectorArray*)0);
					AhTPADelete(&m_tvArrAngRightHalf_RebarMain_LowerPlane[cycle][dan][upper], (CTwinVectorArray*)0);

					CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC	= &m_pArrRCMainLowerSlab[cycle][upper][dan];
					long nSize	= pArrRC->GetSize();
					for(rc = 0; rc < nSize; rc++)
					{
						GetTvRebarMain_Plane_LowerSlab_TypeNormal(tvArr, tvArrAngLeft, tvArrAngRight, bUpper, cycle, 
							dan, 0, rc, FALSE, FALSE, FALSE, tvArrJoint, tvArrHidden, tvArrHiddenLeft, 
							tvArrHiddenRight, TRUE, tvArrAngLeftHalf, tvArrAngRightHalf, TRUE);
					}

					// 하부슬래브 주철근만 2,3단 있음
					if(dan > 0) continue;
					if(!bUpper) continue;

					// 하부슬래브 헌치부 주철근
					AhTPADelete(&m_tvArr_RebarMain_LowerPlaneHunch[cycle], (CTwinVectorArray*)0);
					AhTPADelete(&m_tvArrAngLeft_RebarMain_LowerPlaneHunch[cycle], (CTwinVectorArray*)0);
					AhTPADelete(&m_tvArrAngRight_RebarMain_LowerPlaneHunch[cycle], (CTwinVectorArray*)0);
					AhTPADelete(&m_tvArrJoint_RebarMain_LowerPlaneHunch[cycle], (CTwinVectorArray*)0);
					AhTPADelete(&m_tvArrHidden_RebarMain_LowerPlaneHunch[cycle], (CTwinVectorArray*)0);
					AhTPADelete(&m_tvArrHiddenLeft_RebarMain_LowerPlaneHunch[cycle], (CTwinVectorArray*)0);
					AhTPADelete(&m_tvArrHiddenRight_RebarMain_LowerPlaneHunch[cycle], (CTwinVectorArray*)0);
					AhTPADelete(&m_tvArrAngLeftHalf_RebarMain_LowerPlaneHunch[cycle], (CTwinVectorArray*)0);
					AhTPADelete(&m_tvArrAngRightHalf_RebarMain_LowerPlaneHunch[cycle], (CTwinVectorArray*)0);

					pArrRC	= &m_pArrRCMainLowerSlabHunch[cycle];
					nSize	= pArrRC->GetSize();
					for(rc = 0; rc < nSize; rc++)
					{
						GetTvRebarMain_Plane_LowerSlab_TypeNormal(tvArr, tvArrAngLeft, tvArrAngRight, bUpper, cycle, 
							dan, 0, rc, TRUE, FALSE, FALSE, tvArrJoint, tvArrHidden, tvArrHiddenLeft, 
							tvArrHiddenRight, TRUE, tvArrAngLeftHalf, tvArrAngRightHalf, TRUE);
					}

					if(cycle < 2)
					{
						// 시점 부상방지저판
						pArrRC	= cycle == 0 ? &m_pArrRCMainBoxLowerPRF_Cycle1[iSTT] : &m_pArrRCMainBoxLowerPRF_Cycle2[iSTT];
						// upper	= iLOWER;
						nSize	= pArrRC->GetSize();
						for(rc = 0; rc < nSize; rc++)
						{
							GetTvRebarMain_Plane_LowerSlab_TypeNormal(tvArr, tvArrAngLeft, tvArrAngRight, FALSE, cycle, 
								dan, 0, rc, FALSE, TRUE, FALSE, tvArrJoint, tvArrHidden, tvArrHiddenLeft, 
								tvArrHiddenRight, TRUE, tvArrAngLeftHalf, tvArrAngRightHalf, TRUE);
						}

						// 종점 부상방지저판
						pArrRC	= cycle == 0 ? &m_pArrRCMainBoxLowerPRF_Cycle1[iEND] : &m_pArrRCMainBoxLowerPRF_Cycle2[iEND];
						// upper	= iLOWER;
						nSize	= pArrRC->GetSize();
						for(rc = 0; rc < nSize; rc++)
						{
							GetTvRebarMain_Plane_LowerSlab_TypeNormal(tvArr, tvArrAngLeft, tvArrAngRight, FALSE, cycle, 
								dan, 0, rc, FALSE, FALSE, TRUE, tvArrJoint, tvArrHidden, tvArrHiddenLeft, 
								tvArrHiddenRight, TRUE, tvArrAngLeftHalf, tvArrAngRightHalf, TRUE);
						}
					}
				}
			}
		}
	}

	m_bCaledRebarMain_Plane	= TRUE;

	// 가각 복구 /////////////////////
	m_bIsExp	= bIsExpOld;
	for(left = 0; left < 2; left++)
	{
		m_dExpEndW[left]	= dExpEndW[left];
		m_dExpEndR[left]	= dExpEndR[left];
		m_dExpEndH[left]	= dExpEndH[left];
		m_dExpSttW[left]	= dExpSttW[left];
		m_dExpSttR[left]	= dExpSttR[left];
		m_dExpSttH[left]	= dExpSttH[left];
	}
	SettingPlane();
	// 가각 복구 /////////////////////
}

// 배력근 평면 좌표 미리 구해둠.
void CRcBridgeRebar::SettingTvArrRebarSupportPlane()
{
	long dan(0), upper(0);
	BOOL bUpper(TRUE);
	CTwinVectorArray tvArr, tvArrAngStt, tvArrAngEnd, tvArrRAngStt, tvArrRAngEnd;



	// 배력근 스테이션
	// 상하면 1dan에 대해서만 구함
	GetStaRebarSupport_VertSection_Slab(m_dArrStaSupRebar[iUPPER], TRUE, 0);
	GetStaRebarSupport_VertSection_Slab(m_dArrStaSupRebar[iLOWER], FALSE, 0);

	for(upper = 0; upper < 2; upper++)
	{
		bUpper	= upper == iUPPER;
		for(dan = 0; dan < MAX_REBAR_DAN; dan++)
		{
			m_tvArr_RebarSupport_Plane[dan][upper].RemoveAll();
			m_tvArrAngStt_RebarSupport_Plane[dan][upper].RemoveAll();
			m_tvArrAngEnd_RebarSupport_Plane[dan][upper].RemoveAll();
			m_tvArrRAngStt_RebarSupport_Plane[dan][upper].RemoveAll();
			m_tvArrRAngEnd_RebarSupport_Plane[dan][upper].RemoveAll();

			GetTvRebarSupport_Plane_Slab(TRUE, tvArr, tvArrAngStt, tvArrAngEnd, tvArrRAngStt, tvArrRAngEnd, bUpper, dan, 0);
		}
	}

	if(IsBoxType())
	{
		GetStaRebarSupport_VertSection_Slab(m_dArrStaSupRebarLowerSlab[iUPPER], TRUE, 0, FALSE);
		GetStaRebarSupport_VertSection_Slab(m_dArrStaSupRebarLowerSlab[iLOWER], FALSE, 0, FALSE);

		for(upper = 0; upper < 2; upper++)
		{
			bUpper	= upper == iUPPER;
			for(dan = 0; dan < MAX_REBAR_DAN; dan++)
			{
				m_tvArr_RebarSupport_LowerPlane[dan][upper].RemoveAll();
				m_tvArrAngStt_RebarSupport_LowerPlane[dan][upper].RemoveAll();
				m_tvArrAngEnd_RebarSupport_LowerPlane[dan][upper].RemoveAll();
				m_tvArrRAngStt_RebarSupport_LowerPlane[dan][upper].RemoveAll();
				m_tvArrRAngEnd_RebarSupport_LowerPlane[dan][upper].RemoveAll();

				GetTvRebarSupport_Plane_Slab(FALSE, tvArr, tvArrAngStt, tvArrAngEnd, tvArrRAngStt, tvArrRAngEnd, bUpper, dan, 0);
			}
		}
	}

	m_bCaledRebarSupport_Plane	= TRUE;
}



// 배력근
void CRcBridgeRebar::GetTvArrUpperSlabByDrawLeft_SupportRebar(CTwinVectorArray &tvArr, long nDrawLeft)
{
	if(nDrawLeft == 0) return;

	BOOL bVertDir	= IsVertDir();
	CTwinVectorArray tvArrCenter;
	GetTvCenterPlane_UpperSlab(tvArrCenter, TRUE, TRUE, 1000, bVertDir);
	
	CRebarPlacing rb;
	CTwinVector *pTv	= NULL;
	CDPointArray xyArrMatch;

	if(nDrawLeft == 1)
	{
		// 좌
		long i = 0; for(i = 0; i < tvArr.GetSize(); i++)
		{
			pTv	= &tvArr.GetAt(i);
			rb.GetXyMatchTvArrAndTv(tvArrCenter, *pTv, xyArrMatch, TRUE);
			if(xyArrMatch.GetSize() > 0)
			{
				pTv->m_v2	= xyArrMatch.GetAt(0);
			}
		}
	}
	else
	{
		// 좌
		long i = 0; for(i = 0; i < tvArr.GetSize(); i++)
		{
			pTv	= &tvArr.GetAt(i);
			rb.GetXyMatchTvArrAndTv(tvArrCenter, *pTv, xyArrMatch, TRUE);
			if(xyArrMatch.GetSize() > 0)
			{
				pTv->m_v1	= xyArrMatch.GetAt(0);
			}
		}
	}
}

// 평면선형용 정보를 좌표로 변경
void CRcBridgeRebar::ConvertPlaneLineToTv(CTwinVectorArray &tvArr)
{
	if(IsVertDir()) return;

	CLineInfo *pLine	= GetLineBase();
	long nSize	= tvArr.GetSize();
	CTwinVector *pTv	= NULL;
	long i = 0; for(i = 0; i < nSize; i++)
	{
		pTv	= &tvArr.GetAt(i);
		if(pTv->m_v1.z == 6)
		{
			double dStaStt	= pTv->m_v1.x;
			double dStaEnd	= pTv->m_v2.x;
			double dDist	= pTv->m_v1.y;
			pTv->m_v1	= pLine->GetXyLineDis(dStaStt, dDist);
			pTv->m_v2	= pLine->GetXyLineDis(dStaEnd, dDist);
			pTv->m_v1.z	= 4;
			pTv->m_v2.z	= dDist;
		}
	}
}

// 헌치 철근이 존재 하는지 검사
BOOL CRcBridgeRebar::IsHunchRebarPlane(double dSta, BOOL bLowerSlab)
{
	dSta	= GetStationModifyForRebarCheck(dSta);
	BOOL bFind	= FALSE;

	long nCount = bLowerSlab? m_pArrRCMainLowerSlabHunch[0].GetSize() : m_pArrRCMainUpperSlabHunch[0].GetSize();
	long i = 0; for(i = 0; i < nCount; i++)
	{
		CRebarInfoCycle *pRC	= bLowerSlab? m_pArrRCMainLowerSlabHunch[0].GetAt(i) : m_pArrRCMainUpperSlabHunch[0].GetAt(i);
		double dLeft	= pRC->m_tvArrRebar.GetXyLeft().x;
		double dRight	= pRC->m_tvArrRebar.GetXyRight().x;
		if((fabs(dSta-dLeft) <= 100 || Compare(dSta, dLeft, ">=")) && (fabs(dSta-dRight) <= 100 || Compare(dSta, dRight, "<=")))
		{
			bFind	= TRUE;
			break;
		}
	}

	return bFind;
}

void CRcBridgeRebar::MakeRebarInfoCycle_OutWall_Hunch(long nCycle, BOOL bInput, long nVertDir)
{
	// Box형 일때는 하부슬래브 헌치 따로 집계
	if(m_nTypeBridge == BRIDGE_TYPE_BOX) return;
	if(nCycle == -1) nCycle = GetCountCycleMainRebar() - 1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar() - 1) return;
	BOOL bVertDir	= IsVertDir();
	if(nVertDir != 0)
		bVertDir	= nVertDir == -1 ? TRUE : FALSE;

	CRebarPlacing rb;
	if(nCycle == 0)
		GetMarkRebarMain(MARK_OUTWALL_HUNCH, bInput, nCycle, TRUE, FALSE, "", 0);

	long stt = 0; for(stt = 0; stt < 2; stt++)
	{
		BOOL bStt	= stt == iSTT;
		CRebarInfoCycle *pRC	= &m_rebarInfoCycleOutWallHunch[nCycle][stt];
		pRC->InitInfoCycle();
		if(!IsOutWallHunch(bStt)) continue;

		CTwinVector tvHunch;
		CString str	= bStt ? "시점벽체하부헌치" : "종점벽체하부헌치";
		if(!m_tvArrVertSection.GetTvByInfo(str, tvHunch)) continue;
		
		double dCover		= m_dCoverWallOut[0];
		CFootingApp *pFooting	= bStt ? &m_footingStt : &m_footingEnd;
		CTwinVector tvWall, tvLower;
		tvWall	= GetTvOffset_OutWall(0, bStt, FALSE, bVertDir);
		tvLower	= pFooting->GetTvOffset_Front(0, FALSE, bVertDir);

		rb.Offset(tvHunch.m_v1, tvHunch.m_v2, dCover);
		GetXyMatchLineAndLine(tvHunch.m_v1, tvHunch.GetXyDir(), tvWall.m_v1, tvWall.GetXyDir(), pRC->m_xyMid1);
		GetXyMatchLineAndLine(tvHunch.m_v1, tvHunch.GetXyDir(), tvLower.m_v1, tvLower.GetXyDir(), pRC->m_xyMid2);

		CString sCycle	= m_pARcBridgeDataStd->GetStringCircleNum(nCycle+1);
		CString sStt	= bStt ? "시점" : "종점";

		// (39755) 양끝이 정착장 만큼 들어가야 하는데 100 만 넣어줬네.. 철근 그릴때 길이 표현하면 실제 수량과 다름
		double dRebarSpace	= GetCtcRebarMain(TRUE);
		double dDia		= GetDiaRebarMainOutWallHunch(nCycle, bStt);
		double dSettle(0);
		if(m_pARcBridgeDataStd->IsLsdDesign())
		{
			SRebarEnvOption LsdRebarOpt;
			SetRebarLsdOptionOutWall(&LsdRebarOpt, bStt, TRUE, TRUE, 0, 0);
			dSettle = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueSettle(dDia, &LsdRebarOpt);
		}else
		{
			dSettle = m_pARcBridgeDataStd->GetValueSettleByCalc((long)dDia, SETTLE_TENS_NORMAL, dCover, dRebarSpace, 2, 1);
		}

		pRC->m_szMark		= GetMarkRebarMain(MARK_OUTWALL_HUNCH, bInput, nCycle, FALSE, TRUE, "", 0);
		pRC->m_nTypeRebar	= REBAR_TYPE_MAIN;
		pRC->m_xyStt		= pRC->m_xyMid1 + (CDPoint(0, 1) * dSettle);
		pRC->m_xyEnd		= pRC->m_xyMid2 + (bStt ? CDPoint(1, 0) : CDPoint(-1, 0) * dSettle);
		pRC->m_nPosStt		= bStt ? REBARINFO_POS_STTWALL_OUTTER : REBARINFO_POS_ENDWALL_OUTTER;
		pRC->m_nPosEnd		= REBARINFO_POS_FOOTING_LOWER;
		pRC->m_Dia			= dDia;
		pRC->m_sDescription.Format("%s벽체 하면 헌치 %s", sStt, sCycle);
		pRC->m_bExist		= TRUE;
		pRC->m_nRebarDan	= 0;
	}
}

// 외측벽체 헌치부 철근
void CRcBridgeRebar::GetTvRebarMain_Side_OutWallHunch(CTwinVectorArray &tvArr, long nCycle, BOOL bStt)
{
	tvArr.RemoveAll();
	if(!IsOutWallHunch(bStt)) return;

	CTwinVectorArray tvArrJoint;
	GetTvRebarMain_Side_OutWall(tvArr, bStt, TRUE, nCycle, 0, 0, tvArrJoint);

	long stt	= bStt ? iSTT : iEND;
	CRebarInfoCycle *pRC	= &m_rebarInfoCycleOutWallHunch[nCycle][stt];
	double dTop	= pRC->m_xyStt.y;
	double dBottom	= pRC->m_xyEnd.y;
	
	long nSize	= tvArr.GetSize();
	long i = 0; for(i = 0; i < nSize; i++)
	{
		CTwinVector *pTv	= NULL;
		pTv	= &tvArr.GetAt(i);
		pTv->m_v1.y	= dBottom;
		pTv->m_v2.y	= dTop;
	}
}

// 외측벽체 헌치부 배력근
void CRcBridgeRebar::GetXyRebarSupport_VertSection_OutWallHunch(CDPointArray &xyArr, BOOL bStt, long nVertDir)
{
	xyArr.RemoveAll();
	if(!IsOutWallHunch(bStt)) return;

	long stt	= bStt ? iSTT : iEND;
	CRebarInfoCycle *pRC	= &m_rebarInfoCycleOutWallHunch[0][stt];

	CTwinVector tvHunch, tvHunchRebar;
	if(!m_tvArrVertSection.GetTvByInfo(bStt ? "시점벽체하부헌치" : "종점벽체하부헌치", tvHunch)) return;

	GetXyMatchLineAndLine(tvHunch.GetXyTop(), CDPoint(1, 0), pRC->m_xyMid1, (pRC->m_xyMid2-pRC->m_xyMid1).Unit(), tvHunchRebar.m_v1);
	GetXyMatchLineAndLine(tvHunch.GetXyBottom(), CDPoint(1, 0), pRC->m_xyMid1, (pRC->m_xyMid2-pRC->m_xyMid1).Unit(), tvHunchRebar.m_v2);
	
	double dCtc	= m_dCTC_SupportRebar[iUPPER];
	CRebarPlacing rb;
	double dRadRebar	= REBAR_RADIUS;
	rb.GetXyDivideLine(xyArr, tvHunchRebar.m_v1, tvHunchRebar.m_v2, dCtc, FALSE, 0, FALSE, FALSE);

	CDPoint xyDir	= !bStt ? tvHunchRebar.GetXyDir().Rotate90() : tvHunchRebar.GetXyDir().RotateInv90();
	CDPoint xy	= CDPoint(0, 0);
	long i = 0; for(i = 0; i < xyArr.GetSize(); i++)
	{
		xy	= xyArr.GetAt(i);
		xy	= xy + xyDir * dRadRebar;
		xyArr.SetAt(i, xy);
	}
}

// 외측벽체 헌치부 배력 철근 측면도
void CRcBridgeRebar::GetTvRebarSupport_CrossSection_OutWallHunch(CTwinVectorArray &tvArr, BOOL bStt)
{
	tvArr.RemoveAll();

	CDPointArray xyArr;
	GetXyRebarSupport_VertSection_OutWallHunch(xyArr, bStt, 0);

	BOOL bLeft	= bStt ? FALSE : TRUE;
	CTwinVectorArray tvArrCross;
	GetTvCrossSection_OutWall(tvArrCross, bStt, bLeft);
	double dCover	= bLeft ? (bStt ? m_dCoverWallOut[0] : m_dCoverWallIn[0]) : (bStt ? m_dCoverWallIn[0] : m_dCoverWallOut[0]);
	CTwinVector tvLeft	= tvArrCross.GetTvByInfo("벽체좌측");
	CTwinVector tvRight	= tvArrCross.GetTvByInfo("벽체우측");
	tvLeft.m_v1.x += dCover;
	tvLeft.m_v2.x += dCover;

	tvRight.m_v1.x -= dCover;
	tvRight.m_v2.x -= dCover;

	CDPoint xy(0, 0);
	CTwinVector tv;
	tv.m_v1.x	= tvLeft.m_v1.x;
	tv.m_v2.x	= tvRight.m_v1.x;

	long i = 0; for(i = 0; i < xyArr.GetSize(); i++)
	{
		xy	= xyArr.GetAt(i);
		tv.m_v1.y	= xy.y;
		tv.m_v2.y	= xy.y;
		tvArr.Add(tv);
	}
}

double CRcBridgeRebar::GetDiaRebarMainOutWallHunch(long nCycle, BOOL bStt)
{
	return GetDiaMainRebarOutWall(nCycle, 0, bStt, TRUE, 0);
}

double CRcBridgeRebar::GetDiaRebarSupportOutWallHunch(BOOL bStt)
{
	long stt	= bStt ? iSTT : iEND;
	return m_placeByBlock_SupportRebar_OutWall[stt][iINNER][0].m_dDia;
}

double CRcBridgeRebar::GetGirderWidth(long nJijum, BOOL bUpperSlabGirder)
{
	CTwinVector tvLower;
	CTwinVector tvUpper;
	double dW	= 0;

	CGirderSectionRebar *pGirder	= &m_SlabGirderRebar[bUpperSlabGirder ? iUPPER : iLOWER][nJijum];
	if(nJijum == 0 || nJijum == m_nQtyJigan)
	{
		dW += pGirder->m_dC1[iLOWER][0] + pGirder->m_dC[iLOWER][0] * pGirder->m_nB[iLOWER][0] + pGirder->m_dC2[iLOWER][0] + pGirder->m_dDist * 2;
	}
	else
	{
		if(!GetTvHunchLower(tvLower, nJijum, TRUE, bUpperSlabGirder))
		{
			dW += pGirder->m_dC1[iLOWER][0] + pGirder->m_dC[iLOWER][0] * pGirder->m_nB[iLOWER][0] + pGirder->m_dC2[iLOWER][0] + pGirder->m_dDist * 2;
		}
		else
		{
			dW	= tvLower.GetHorLength();
		}
	}
	

	return dW;
}

void CRcBridgeRebar::SetDataDefaultEnv()
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();

	long nTypeCon = m_pARcBridgeDataStd->m_nTypeConditionApply;		// 0: 콘크리트교 설계 기준, 1: 도로교 설계 기준

	m_bCheckMainSlabAndFootTemper	= FALSE;
	m_bSelectSupportBarWall		= (nTypeCon == DESIGN_CONDITION_CONCRETE)?  TRUE : FALSE;
	m_bCheckSuppoerBarSlabMain	= (nTypeCon == DESIGN_CONDITION_ROAD)?  TRUE : FALSE;
	m_bCheckSuppoerBarSlabMainOver20	= FALSE;
	m_bCheckSuppoerBarSlab300	= (nTypeCon == DESIGN_CONDITION_ROAD)?  TRUE : FALSE;
	m_bCheckSuppoerBarWall15hs	= (nTypeCon == DESIGN_CONDITION_ROAD)?  TRUE : FALSE;
	m_bCheckSuppoerBarWallMainOver20 = FALSE;
	m_bCheckSuppoerBarWall300	= (nTypeCon == DESIGN_CONDITION_ROAD)?  TRUE : FALSE;
	m_bCheckSuppoerBarWallArea	= (nTypeCon == DESIGN_CONDITION_CONCRETE)?  TRUE : FALSE;
	m_bCheckSuppoerBarFoot15hs	= (nTypeCon == DESIGN_CONDITION_ROAD)?  TRUE : FALSE;
	m_bCheckSuppoerBarFootMainOver20	= FALSE;
	m_bCheckSuppoerBarFoot300	= (nTypeCon == DESIGN_CONDITION_ROAD)?  TRUE : FALSE;
	m_bCheckSuppoerBarFootArea	= (nTypeCon == DESIGN_CONDITION_CONCRETE)?  TRUE : FALSE;
	m_bCheckSuppoerBarWing15hs	= (nTypeCon == DESIGN_CONDITION_ROAD)?  TRUE : FALSE;
	m_bCheckSuppoerBarWing300	= (nTypeCon == DESIGN_CONDITION_ROAD)?  TRUE : FALSE;
	m_bCheckSuppoerBarWingArea	= (nTypeCon == DESIGN_CONDITION_CONCRETE)?  TRUE : FALSE;

	m_dCheckSuppoerBarWallArea	= 0.0025;
	m_dCheckSuppoerBarWallAreaForOver400	= 0.0020;
	m_dCheckSuppoerBarFootArea	= 0.0020;
	m_dCheckSuppoerBarSlabArea	= 0.0020;
	m_dCheckSuppoerBarWingArea	= 0.0020;

	m_bApplyMinAvSlab			= FALSE;
	m_bApplyMinAvWall			=  TRUE;
	m_bApplyMinAvFoot			= FALSE;
	m_bApplyMinAvWing			=  TRUE;
	m_bApplyMinAvAps			= FALSE;
	m_bApplyMinAvHyunTa			= FALSE;
	m_bCheckMinCtcShearWing		= bLsd? FALSE : TRUE;
	m_bCheckMinCtcShearAps		= bLsd? FALSE : TRUE;
	m_bCheckRebarRateFooting = FALSE;
	m_nApplyCalcShearDistFront	= bLsd ? 2 : (nTypeCon == DESIGN_CONDITION_CONCRETE)?  0 : 1;
	m_nApplyCalcShearDistBack	= bLsd ? 2 : (nTypeCon == DESIGN_CONDITION_CONCRETE)?  0 : 1;
	m_nTypeCrackDesignSlab		= 1;
	m_nTypeCrackDesignWall		= 1;
	m_nTypeCrackDesignFoot		= 1;
	m_nTypeCrackDesignWing		= 1;
	m_nTypeCrackDesignAps		= 1;
	m_nSelectJointUpperRange	= 0;
	m_nIdxCountCycleMainRebar	= 0;
	m_nTypeStandardCTCRebarMain	= 0;
	m_nTypePlacingSupportRebar_UpperSlab = 2;
	m_bRemoveShearRebarAtSlabYundan	= FALSE;		// 슬래브 연단 전단철근 제거
	m_nTypeCouplerColumnMainRebar	= 0;				// 기둥 주철근 커플러? 겹이음. 
	m_dFactorToap				= 1.7;
	m_dFactorLive				= (m_pARcBridgeDataStd->IsRailDesign())? 1.7:2.15;
	m_nTypeJongdanForRebar		= 0;		// 종단면 타입 : 0 : 수평, 1 : 경사(배근시만 적용됨), 2 : 일반도를 위해서 종단선형으로 그림
	m_nTypeWallForRebarGen		= 0;		// 벽체 표현 방법(일반도 구조도), 0 : 슬래브 끝단, 1 : 시종점, 2 : 실제sta(전면배면에 해당하는)
	m_nSelSubsideType			= 0;
	m_nSelectForceCheckPos		= 0;
	m_nSelectDesignRoadWidth	= 0;
	m_nSelectModelingHeight		= 0;
	m_nSelCalcCornerFt = pStd->IsRailDesign2017() ? 1 : 0;
	m_nSelectDesignSpanLength	= 0;

	m_bCheckSuppoerBarArchRibMinDia1	= (m_nTypeBridge == BRIDGE_TYPE_ARCH)? TRUE : FALSE;
	m_bCheckSuppoerBarArchRibMinDia2	= (m_nTypeBridge == BRIDGE_TYPE_ARCH)? TRUE : FALSE;

	m_bApplyFootingMinThick		= FALSE;

	m_nSelectWallSectionDesign		= 0;
	m_nSelectInWallSectionDesign = 1;
	m_nSelectFootingReactionForce	= 2;
	m_nArchRibSectionMomentPos = 0;
	m_bCheckFrontFootTrap2 = FALSE;

	m_nSelectRigidModeling			= pStd->IsLsdDesign() ? 2 : 1;
	m_bSelectRigidCalcHunch		= TRUE;
	m_bSelectTempLoadAddWall		= TRUE;
	m_bSelectShrinkLoadAddWall		= FALSE;
	m_bSelectEnvToapOne			= FALSE;	
	m_bSelectEnvSubsid			= (m_nSelect2DFrameTool == SOLVE_MIDAS) ? TRUE : (m_nQtyJigan > 2 ? TRUE : FALSE);
	m_bSelectHunchModeling = TRUE;
	m_bSelectHunchDesignCheck = TRUE;
	m_nSelectExposureCoverCheck = 0;
	//m_nSelectApsAxleWeight		= pStd->IsLsdDesign() ? 0 : 1;

	m_nApplyCalcShearDistSlab = 1;			// 슬래브 전단검토시 위험단면 위치
	m_nApplyCalcShearDistWall = 1;			// 벽체 전단검토시 위험단면 위치

	m_nSelectApsDeadLoad = bLsd? 1 : 0;

	m_bApplyT1CalcWingWall = TRUE;
	m_nApplyWingWallHeightBasePos = 0;
}


BOOL CRcBridgeRebar::IsGirderRebarJong(BOOL bStt, BOOL bLeft, BOOL bGagak)
{
	return GetGirderRebarJong(bStt, bLeft, bGagak)->m_bIs;	
}

CGirderSectionRebar* CRcBridgeRebar::GetGirderRebarJong(BOOL bStt, BOOL bLeft, BOOL bGagak)
{
	long stt	= bStt ? iSTT : iEND;
	long left	= bLeft ? iLEFT : iRIGHT;

	return bGagak ? &m_girderRebarJongGagak[stt][left] : &m_girderRebarJong[left];
}

// 거더의 y 값 셋팅해줌(자동)
void CRcBridgeRebar::SetDataDefaultYPosOfGirder(long nJ, BOOL bStt, BOOL bLeft, BOOL bGagak, BOOL bJongGirder,  BOOL bUpperSlabGirder)
{
	if(bJongGirder)
	{
		if(!IsGirderRebarJong(bStt, bLeft, bGagak)) return;
	}
	else
	{
		if(!IsGirderRebar(nJ, bUpperSlabGirder)) return;
	}

	CGirderSectionRebar *pGirderRB	= bJongGirder ? GetGirderRebarJong(bStt, bLeft, bGagak) : &m_SlabGirderRebar[bUpperSlabGirder ? iUPPER : iLOWER][nJ];

	if(bJongGirder)
	{
		
		CTwinVectorArray tvArrCross;
		GetTvGirderLowerJong(tvArrCross, bStt, bLeft, bGagak);

		CDPoint xyOrg	= pGirderRB->m_xyOrg;
		xyOrg.x += bLeft ? pGirderRB->m_dDist : -pGirderRB->m_dDist;
		
		CRebarPlacing rb;
		CDPointArray xyArrMatch;
		rb.GetXyMatchTvArrAndLine(tvArrCross, xyOrg, CDPoint(0, 1), xyArrMatch);
		if(xyArrMatch.GetSize() > 0)
		{
			pGirderRB->m_xyOrg.y	= xyArrMatch.GetAt(0).y+pGirderRB->m_dCoverLower[0];
		}
	}
	else
	{}
}

// 종거더 평면 (보강철근)
// BOOL bConvertLineInfoToTvArr : 선형정보를 순수 tvarr로 변경
void CRcBridgeRebar::GetTvRebarSupport_Plane_UpperSlabGirderJong(CTwinVectorArray &tvArr, BOOL bStt, BOOL bLeft, BOOL bGagak, BOOL bUpper, BOOL bConvertLineInfoToTvArr)
{
	tvArr.RemoveAll();

	CLineInfo *pLineCR		= GetLineBase();
	CLineInfo *pLineSide	= GetLineLeftRight(bLeft);
	double dSta				= GetStationForInputJongGirder(bStt, bLeft, bGagak);

	if(bGagak)
	{
		CTwinVectorArrayArray pTvArrCycle1[2];
		CTwinVectorArrayArray pTvArrCycle2[2];
		CTwinVectorArray tvArrCycleHunch1, tvArrCycleHunch2;
		GetTvRebarMain_Plane_Slab_Exp(TRUE, &pTvArrCycle1[0], &pTvArrCycle2[0], &pTvArrCycle1[1], &pTvArrCycle2[1], bStt, bLeft, 0, bUpper, tvArrCycleHunch1, tvArrCycleHunch2, TRUE);

		long i = 0; for(i = 0; i < pTvArrCycle1[0].GetSize(); i++)
		{
			tvArr.AddFromTvArray(*pTvArrCycle1[0].GetAt(i));
		}
		long type = 0; for(type = 0; type < 2; type++)
		{
			AhTPADelete(&pTvArrCycle1[type], (CTwinVectorArray*)0);
			AhTPADelete(&pTvArrCycle2[type], (CTwinVectorArray*)0);
		}
	}
	else
	{
		// 여기들어온 x값은 dist값임
		CDPointArray xyArr, xyArrDirApplyScale;
		GetxyRebarSupport_SlabGirder(xyArr, xyArrDirApplyScale, 0, 0, bStt, bLeft, bGagak, TRUE);

		// 일단 슬래브 끝에서 끝까지 그리고 필요한 양을 남김
		long nSize	= xyArr.GetSize();
		CDPoint xy(0, 0);

		CDoubleArray dArrDist;	// 측면 선형에서의 거리
		double dDist	= 0;
		long i = 0; for(i = 0; i < nSize; i++)
		{
			xy	= xyArr.GetAt(i);
			xy	= pLineCR->GetXyLineDis(dSta, xy.x);
			dDist	= pLineSide->GetDisMatchVerticalByXy(xy);
			dArrDist.Add(dDist);
		}
		
		if(!bLeft)
		{
			CDoubleArray dArrDistTmp;
			nSize	= dArrDist.GetSize();
			for(i = 0; i < nSize; i++)
			{
				dArrDistTmp.Add(dArrDist.GetAt(nSize-i-1));
			}
			dArrDist.RemoveAll();
			dArrDist	= dArrDistTmp;
		}

		// 선형에서 좌표 가져옴
		long left	= bLeft ? iLEFT : iRIGHT;
		double dStaStt	= GetStationByTarget(BRIDGE_OFF_STT_SLAB, 0, FALSE) + m_dDistGirderRebarJong[left][iSTT];
		double dStaEnd	= GetStationByTarget(BRIDGE_OFF_END_SLAB, 0, FALSE) - m_dDistGirderRebarJong[left][iEND];
				
		CTwinVector tv;
		CDPoint xyStt(0, 0), xyEnd(0, 0);
		CDPoint vAngStt	= GetAngleJongGirder(bStt, bLeft, bGagak, TRUE);
		CDPoint vAngEnd	= GetAngleJongGirder(bStt, bLeft, bGagak, FALSE);

		CDPoint vAngSttJIjum	= GetAngleByTarget(BRIDGE_OFF_STT_SLAB, 0);
		CDPoint vAngEndJijum	= GetAngleByTarget(BRIDGE_OFF_END_SLAB, 0);
		double dWidth	= bLeft ? m_dWidthSlabLeft : m_dWidthSlabRight;
		double dCover	= bLeft ? m_dCoverSide_UpperSlab[0] : -m_dCoverSide_UpperSlab[0];
		xyStt	= pLineSide->GetXyLineByLengthAndAngle(dStaStt, dWidth, vAngSttJIjum);
		xyEnd	= pLineSide->GetXyLineByLengthAndAngle(dStaEnd, dWidth, vAngEndJijum);
		

		for(i = 0; i < nSize; i++)
		{
			dDist	= dArrDist.GetAt(i);
			if(i == 0)
			{
				pLineSide->GetStationMatchByXyAndAngle(xyStt, vAngStt, dStaStt, dWidth+dCover);
				pLineSide->GetStationMatchByXyAndAngle(xyEnd, vAngEnd, dStaEnd, dWidth+dCover);
			}
			else if(i > 0)
			{
				pLineSide->GetStationMatchByXyAndAngle(xyStt, vAngStt, dStaStt, dDist);
				pLineSide->GetStationMatchByXyAndAngle(xyEnd, vAngEnd, dStaEnd, dDist);
			}

			tv.m_v1	= pLineSide->GetXyLineDis(dStaStt, dDist);
			tv.m_v2	= pLineSide->GetXyLineDis(dStaEnd, dDist);
			tv.m_v1.z	= 4;
			tv.m_v2.z	= dDist;
			if(i == 0)
			{
				xyStt	= tv.m_v1;
				xyEnd	= tv.m_v2;
			} 

			if(bConvertLineInfoToTvArr)
				tvArr.AddFromLineInfo(static_cast<CLineInfoApp*>(pLineSide), tv.m_v1, tv.m_v2, dDist<0);
			else
				tvArr.Add(tv);
		}
	}
}

// 종거더 평면 스터럽 좌표
void CRcBridgeRebar::GetTvRebarStirrup_Plane_UpperSlabGirderJong(CTwinVectorArray &tvArr, BOOL bStt, BOOL bLeft, BOOL bGagak)
{
	tvArr.RemoveAll();
	if(!IsGirderRebarJong(bStt, bLeft, bGagak)) return;

	CTwinVectorArray tvArrMain;
	GetTvRebarSupport_Plane_UpperSlabGirderJong(tvArrMain, bStt, bLeft, bGagak, TRUE);
	if(tvArrMain.GetSize() == 0) return;
	CTwinVector tvMain	= tvArrMain.GetAt(0);
	CTwinVector tvMainFir	= tvArrMain.GetAt(0);
	CTwinVector tvMainLast	= tvArrMain.GetAt(tvArrMain.GetSize()-1);

	if(!bGagak && !bLeft)
	{
		tvMain	= tvArrMain.GetAt(tvArrMain.GetSize()-1);
		GetSwap(tvMainFir, tvMainLast);
	}


	CTwinVector tvUpper, tvLower;
	GetTvVirtualRebarGirder(0, tvUpper, tvLower, bStt, bLeft, bGagak, TRUE);
	
	CGirderSectionRebar *pGirderRB	= GetGirderRebarJong(bStt, bLeft, bGagak);
	if(!pGirderRB) return;

	if(bGagak)
	{
		CDPoint xyDir	= bLeft ? tvMain.GetXyDir().Rotate90() : tvMain.GetXyDir().RotateInv90();
		if(bStt)
			xyDir	= !bLeft ? tvMain.GetXyDir().Rotate90() : tvMain.GetXyDir().RotateInv90();
		CDPoint xyStt(0, 0), xyEnd(0, 0);
		if(GetXyMatchSegAndLine(tvMainLast.m_v1, tvMainLast.m_v2, tvMainFir.m_v1, xyDir, xyStt))
			xyStt	= tvMainFir.m_v1;
		else
			xyStt	= tvMainLast.m_v1;
		if(GetXyMatchSegAndLine(tvMainLast.m_v1, tvMainLast.m_v2, tvMainFir.m_v2, xyDir, xyEnd))
			xyEnd	= tvMainFir.m_v2;
		else
			xyEnd	= tvMainLast.m_v2;

		GetXyMatchLineAndLine(tvMainFir.m_v1, tvMainFir.GetXyDir(), xyStt, xyDir, xyStt);
		GetXyMatchLineAndLine(tvMainFir.m_v1, tvMainFir.GetXyDir(), xyEnd, xyDir, xyEnd);

		double dLenMain	= ~(xyEnd - xyStt);
		if(Compare(dLenMain, 0.0, "=")) return;
		
		double dCTC	= pGirderRB->m_dCTC;
		long nCount	= (long)(dLenMain / dCTC);
		double dRemain	= dLenMain - (dCTC * nCount);
		if(dRemain/2 < MIN_LEN_BLOCK)
		{
			dRemain += dCTC;
			nCount --;
		}

		
		double dWidth	= tvUpper.GetHorLength();
		CTwinVector tv;
		tv.m_v1	= xyStt;
		tv.m_v2	= tv.m_v1 + xyDir * dWidth;
		tvArr.Add(tv);

		if(dRemain/2 > 0)
		{
			xyStt += tvMain.GetXyDir() * dRemain/2;
			tv.m_v1	= xyStt;
			tv.m_v2	= tv.m_v1 + xyDir * dWidth;
			tvArr.Add(tv);
		}

		long i = 0; for(i = 0; i < nCount; i++)
		{
			xyStt += tvMain.GetXyDir() * dCTC;
			tv.m_v1	= xyStt;
			tv.m_v2	= tv.m_v1 + xyDir * dWidth;
			tvArr.Add(tv);
		}

		if(dRemain/2 > 0)
		{
			xyStt += tvMain.GetXyDir() * dRemain/2;
			tv.m_v1	= xyStt;
			tv.m_v2	= tv.m_v1 + xyDir * dWidth;
			tvArr.Add(tv);
		}

		tv.m_v1	= xyEnd;
		tv.m_v2	= tv.m_v1 + xyDir * dWidth;	
		tvArr.Add(tv);
	}
	else
	{
		CLineInfo *pLine	= GetLineLeftRight(bLeft);
		double dStaSttFir	= 0;
		double dStaEndFir	= 0;
		double dStaSttLast	= 0;
		double dStaEndLast	= 0;
		pLine->GetStationMatchVerticalByXy(tvMainFir.m_v1, dStaSttFir);
		pLine->GetStationMatchVerticalByXy(tvMainFir.m_v2, dStaEndFir);
		pLine->GetStationMatchVerticalByXy(tvMainLast.m_v1, dStaSttLast);
		pLine->GetStationMatchVerticalByXy(tvMainLast.m_v2, dStaEndLast);

		if(dStaSttFir < dStaSttLast)
		{
			double dDist	= pLine->GetDisMatchVerticalByXy(tvMain.m_v1);
			tvMain.m_v1		= pLine->GetXyLineDis(dStaSttLast, dDist);
		}
		if(dStaEndFir > dStaEndLast)
		{
			double dDist	= pLine->GetDisMatchVerticalByXy(tvMain.m_v2);
			tvMain.m_v2		= pLine->GetXyLineDis(dStaEndLast, dDist);
		}


		double dDist	= pLine->GetDisMatchVerticalByXy(tvMain.m_v1);
		double dWidth	= -tvUpper.GetHorLength();
		double dStaStt	= m_dStationBridgeStt;
		double dStaEnd	= m_dStationBridgeStt;
// 		double dLenMain	= dStaEnd - dStaStt;
		pLine->GetStationMatchVerticalByXy(tvMain.m_v1, dStaStt);
		pLine->GetStationMatchVerticalByXy(tvMain.m_v2, dStaEnd);
		double dLenMain	= dStaEnd - dStaStt;

		if(Compare(dLenMain, 0.0, "=")) return;
		
		double dCTC	= pGirderRB->m_dCTC;
		long nCount	= (long)(dLenMain / dCTC);
		double dRemain	= dLenMain - (dCTC * nCount);
		if(dRemain/2 < MIN_LEN_BLOCK)
		{
			dRemain += dCTC;
			nCount --;
		}

		
		// 스터럽 설치
		CDoubleArray dArrSta;
		CTwinVector tv;
		// 시작위치
		dArrSta.Add(dStaStt);
		if(dRemain/2 > 0)
		{
			dStaStt += dRemain/2;
			dArrSta.Add(dStaStt);
		}

		long i = 0; for(i = 0; i < nCount; i++)
		{
			dStaStt += dCTC;
			dArrSta.Add(dStaStt);
		}

		if(dRemain/2 > 0)
		{
			dStaStt += dRemain/2;
			dArrSta.Add(dStaStt);
		}

		// 마지막위치
		dArrSta.Add(dStaEnd);

		// 선으로 변경
		long nSize	= dArrSta.GetSize();
		for(i = 0; i < nSize; i++)
		{
			dStaStt	= dArrSta.GetAt(i);
			tv.m_v1	= pLine->GetXyLineDis(dStaStt, dDist);
			tv.m_v2	= pLine->GetXyLineDis(dStaStt, dDist - dWidth);
			tvArr.Add(tv);
		}
	}
}

void CRcBridgeRebar::SetDataDefaultRebarJewon_GirderJong_All()
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();

	double dCover		= 0;
	double dSpace		= GetCtcRebarMain();
	long nCountStirrup	= 1;	// 스터럽 철근 개수는 계산 따로 해야 됨.
	CTwinVectorArray tvArr;
	CTwinVectorArray tvArrShearPlane;
	CHgBaseConcStd baseConc;
	
	BOOL bStt	= TRUE;
	BOOL bLeft	= TRUE;
	BOOL bGagak	= TRUE;

	long left = 0; for(left = 0; left < 2; left++)
	{
		bLeft	= left == iLEFT;
		CLineInfo *pLineLR	= GetLineLeftRight(bLeft);

		for(long gagak = 0; gagak < 2; gagak++)
		{
			bGagak	= gagak == 1;
			long stt = 0; for(stt = 0; stt < 2; stt++)
			{
				bStt	= stt == iSTT;
				if(!bGagak)
				{
					if(stt == 1) continue;
				}

				if(!IsGirderRebarJong(bStt, bLeft, bGagak)) continue;

				CGirderSectionRebar *pGirder	= GetGirderRebarJong(bStt, bLeft, bGagak);
				dCover	= pGirder->m_dCoverUpper[0];
				
				// 스트럽 철근 좌표 구함.
				GetTvRebarStirrup_SlabGrider(tvArr, 0, bStt, bLeft, bGagak, TRUE);

				// 평면상의 전단철근 개수
				GetTvRebarStirrup_Plane_UpperSlabGirderJong(tvArrShearPlane, bStt, bLeft, bGagak);
				nCountStirrup	= tvArrShearPlane.GetSize();

				//  거더 스터럽 철근 /////////////////////////////////////////////
				// 가로 세로 최대 최소 길이를 구함.
				double dLenMaxHor(0), dLenMaxVer(0), dLenMinHor(0), dLenMinVer(0);

				long i = 0; for(i = 0; i < pGirder->m_nCountStirrup; i++)
				{
					CTwinVector tvVer, tvHor;
					tvVer	= tvArr.GetTvByInfo("좌"+COMMA(i+1));
					tvHor	= tvArr.GetTvByInfo("상"+COMMA(i+1));

					if(i==0)
					{
						dLenMaxHor	= tvHor.GetLength();
						dLenMaxVer	= tvVer.GetLength();
						dLenMinHor	= tvHor.GetLength();
						dLenMinVer	= tvVer.GetLength();
					}
					else
					{
						dLenMaxHor	= max(tvHor.GetLength(), dLenMaxHor);
						dLenMaxVer	= max(tvVer.GetLength(), dLenMaxVer);
						dLenMinHor	= min(tvHor.GetLength(), dLenMinHor);
						dLenMinVer	= min(tvVer.GetLength(), dLenMinVer);
					}
				}

				CRebar *pRB	= new CRebar;
				pRB->m_Fy			= bLsd? GetValueFy(ePartUpperSlab, TRUE) : m_pARcBridgeDataStd->m_Fy;
				CString sLeft	= bLeft ? "좌측" : "우측";
				CString sStt	= bGagak ? (bStt ? "시점 " : "종점 ") : "";
				CString sGagak	= bGagak ? "가각부 " : "";
				pRB->m_sDescription.Format("%s%s%s 종거더 수직전단철근", sGagak, sStt, sLeft);
				pRB->m_sMark	= GetMarkRebarEtc(G_REBAR_ST, FALSE, TRUE, FALSE, "", TRUE);
				pRB->m_dDia		= pGirder->m_dDiaStirrup;
				double disMaxB	= dLenMaxVer;
				double disMinB	= dLenMinVer;
				double disMaxC	= max(m_pARcBridgeDataStd->GetValueJoint(pRB->m_dDia, JOINT_TENS_NORMAL_B, dCover, dSpace), disMaxB);
				double disMinC	= min(disMaxC, disMinB);
				pRB->m_dLengthMax_A = dLenMaxHor;
				pRB->m_dLengthMin_A = dLenMinHor;
				pRB->m_dLengthMax_B = disMaxB;
				pRB->m_dLengthMin_B = disMinB;
				pRB->m_dLengthMax_C = disMaxC;
				pRB->m_dLengthMin_C = disMinC;
				pRB->m_nTypeRebar	= 18;
				pRB->m_bMainRebar	= FALSE;
				pRB->m_dRateAdd		= MAKE_RATE;
				pRB->m_nEa			= pGirder->m_nCountStirrup * nCountStirrup;
				baseConc.OptimizationRebar(pRB);
				AddOrDeleteRebarInList(&m_pArrRebarGirder, pRB);
				//  거더 스터럽 철근 /////////////////////////////////////////////

				CTwinVectorArray tvArrUpper, tvArrLower;
				GetTvRebarSupport_Plane_UpperSlabGirderJong(tvArrUpper, bStt, bLeft, bGagak, TRUE);
				GetTvRebarSupport_Plane_UpperSlabGirderJong(tvArrLower, bStt, bLeft, bGagak, FALSE);
				tvArrUpper.m_pLine	= pLineLR;
				tvArrLower.m_pLine	= pLineLR;

				// 거더 좌우측 수평전단철근 /////////////////////////////////////
				dSpace				= pGirder->m_dF;
				if(Compare(dSpace, 0.0, "=")) 
					dSpace	= pGirder->m_dF1;
				pRB					= new CRebar;
				pRB->m_Fy			= bLsd? GetValueFy(ePartUpperSlab, TRUE) : m_pARcBridgeDataStd->m_Fy;
				pRB->m_sDescription.Format("%s%s%s 종거더 수평전단철근", sGagak, sStt, sLeft);
				pRB->m_sMark		= GetMarkRebarEtc(G_REBAR_HORV, FALSE, TRUE, FALSE, "", TRUE);
				pRB->m_dDia			= pGirder->m_dDiaSide;
				pRB->m_nTypeRebar	= 22;

				// 수평전단철근 너비 
				CDRect rect	= tvArr.GetRect();
				disMaxB		= rect.Width();
				disMinB		= 0;
				pRB->m_dLengthMax_A		= tvArrUpper.GetLengthMax();
				pRB->m_dLengthMin_A		= 0;
				pRB->m_dLengthMax_B		= disMaxB;
				pRB->m_dLengthMin_B		= 0;
				
				// 철근지름에 의한 길이 보정 
				pRB->m_dLengthMax_A += 2*ConstPi*(pRB->m_dDia/2+pGirder->m_dDiaStirrup/2)/2;

				pRB->m_bMainRebar	= FALSE;
				pRB->m_dRateAdd		= MAKE_RATE;
				m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dSpace);
				if (pRB->m_nJoint%2!=0)
					pRB->m_nJoint += 1;	
				long nCountOneLine	= 0;	// 스트럽 한 라인당 수평철근 개수
				nCountOneLine	= pGirder->m_dF1 > 0 ? 1 : 0;
				nCountOneLine	+= pGirder->m_nE*pGirder->m_dF > 0 ? pGirder->m_nE : 0;
				pRB->m_nEa	= nCountOneLine;
				baseConc.OptimizationRebar(pRB);
				AddOrDeleteRebarInList(&m_pArrRebarGirder, pRB);
				// 거더 좌우측 수평전단철근 /////////////////////////////////////

				// 거더 내측 수평전단철근 ////////////////////////////////////////
				pRB					= new CRebar;
				pRB->m_Fy			= bLsd? GetValueFy(ePartUpperSlab, TRUE) : m_pARcBridgeDataStd->m_Fy;
				pRB->m_sDescription.Format("%s%s%s 종거더 내측 수평전단철근", sGagak, sStt, sLeft);
				pRB->m_sMark		= GetMarkRebarEtc(G_REBAR_HORV_I, FALSE, TRUE, FALSE, "", TRUE);
				pRB->m_dDia			= pGirder->m_dDiaSide_I;
				pRB->m_dLengthMax_A	= tvArrUpper.GetLengthMax();
				pRB->m_dLengthMin_B	= 0;
				/*
				pRB->m_dLengthMax_A = pRB->m_dLengthMax_A + pRB->m_dDia;
				if(!Compare(pRB->m_dLengthMin_A, 0.0, "="))
					pRB->m_dLengthMin_A	= pRB->m_dLengthMin_A + pRB->m_dDia;
					*/
				double D			= pRB->m_dDia;
				pRB->m_R			= RoundUp(3*D/10, 0) * 10;
				pRB->m_dLengthMax_B = 2*pRB->m_R*ConstPi*135/360;
				pRB->m_dLengthMin_B	= 0;
				pRB->m_dLengthMax_C = RoundUp(6*D/10, 0) * 10;
				pRB->m_dLengthMin_C	= 0;
				pRB->m_dLengthMax_D	= 0;
				pRB->m_dLengthMin_D	= 0;
				pRB->m_nTypeRebar	= 61;
				pRB->m_bMainRebar	= FALSE;
				pRB->m_dRateAdd		= MAKE_RATE;
				m_Util.SetLengthRebar(pRB,JOINT_TENS_NORMAL_B, dCover, dSpace);
				pRB->m_nEa			= (pGirder->m_nCountStirrup*2-2) * nCountOneLine;
				AddOrDeleteRebarInList(&m_pArrRebarGirder, pRB);
				// 거더 내측 수평전단철근 ////////////////////////////////////////

				// 거더 상하부 보강철근 ///////////////////////////////////////////
				CDPointArray xyArr, xyArrDirApplyScale;
				long upper = 0; for(upper = 0; upper < 2; upper++)
				{
					BOOL bUpper	= upper == iUPPER;
					CString sUpper	= bUpper ? "상면" : "하면";
					long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
					{
						long nTypeRebar	= bUpper ? G_REBAR_M_U1+dan : G_REBAR_M_L1+dan;
						if(dan == 0)
							GetxyRebarSupport_SlabGirder(xyArr, xyArrDirApplyScale, upper, 0,  bStt, bLeft, bGagak, TRUE);
						else
							GetXyRebarSupport_SlabGirderInner(xyArr, 0, upper, dan, bStt, bLeft, bGagak, TRUE);

						if(xyArr.GetSize() == 0) continue;
						
						pRB					= new CRebar;
						pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
						pRB->m_sDescription.Format("%s%s%s 종거더 %s 주철근 %d단", sGagak, sStt, sLeft, sUpper, dan+1);
						pRB->m_sMark		= GetMarkRebarEtc(nTypeRebar, FALSE, TRUE, FALSE, "", TRUE);
						pRB->m_dDia			= pGirder->m_dDiaUL[upper][dan];
						pRB->m_dLengthMax_A	= bUpper ? tvArrUpper.GetLengthMax() : tvArrLower.GetLengthMax();
						pRB->m_dLengthMin_A	= bUpper ? tvArrUpper.GetLengthMin() : tvArrLower.GetLengthMax();
						pRB->m_nTypeRebar	= 1;
						pRB->m_bMainRebar	= TRUE;
						pRB->m_dRateAdd		= MAKE_RATE;
						m_Util.SetLengthRebar(pRB,JOINT_TENS_NORMAL_B, dCover, dSpace);
						pRB->m_nEa			= xyArr.GetSize();
						AddOrDeleteRebarInList(&m_pArrRebarGirder, pRB);
					}
				}
				// 거더 상하부 보강철근 ///////////////////////////////////////////
			}
		}
	}
}

// void CRcBridgeRebar::SetDataDefaultGirderWidth(long nJ, BOOL bStt, BOOL bLeft, BOOL bGagak, BOOL bJongGirder,  BOOL bUpperSlabGirder)
// {
// 	if(bJongGirder)
// 	{
// 		if(!IsGirderRebarJong(bStt, bLeft, bGagak)) return;
// 	}
// 	else
// 	{
// 		if(IsGirderRebar(nJ, bUpperSlabGirder)) return;
// 	}
// 
// 	CGirderSectionRebar *pGirderRB		= bJongGirder ? GetGirderRebarJong(bStt, bLeft, bGagak) : &m_SlabGirderRebar[bUpperSlabGirder ? iUPPER : iLOWER][nJ];
// 
// 	CTwinVectorArray tvArr;
// 	GetTvRebarStirrup_SlabGrider(tvArr, nJ, bStt, bLeft, bGagak, bJongGirder);
// 	if(tvArr.GetSize() == 0) return;
// 
// 	CDRect rect	= tvArr.GetRect();
// 	if(pGirderRB->m_nType == 0 || pGirderRB->m_nType == 1)
// 	{
// 		pGirderRB->m_dWidthL	= rect.Width();
// 		pGirderRB->m_dWidthR	= 0;
// 	}
// }

// 거더 넓이 설정
// stirrup에 따라서 적절하게 결정해줌
void CRcBridgeRebar::SetDataDefaultWidthGirder(long nJ, BOOL bStt, BOOL bLeft, BOOL bGagak, BOOL bJongGirder,  BOOL bUpperSlabGirder)
{
	if(bJongGirder)
	{
		if(!IsGirderRebarJong(bStt, bLeft, bGagak)) return;
	}
	else
	{
		if(!IsGirderRebar(nJ, bUpperSlabGirder)) return;
	}

	CGirderSectionRebar *pGirderRB	= bJongGirder ? GetGirderRebarJong(bStt, bLeft, bGagak) : &m_SlabGirderRebar[bUpperSlabGirder ? iUPPER : iLOWER][nJ];
	if(!pGirderRB) return;

	long nCountStirrup	= pGirderRB->m_nCountStirrup;
	double dXMin	= 0;
	double dXMax	= 0;
	long i = 0; for(i = 0; i < nCountStirrup; i++)
	{
		CDPoint xyR	= pGirderRB->m_xyDistStirrup[i];
		if(i == 0)
		{
			dXMin	= xyR.x;
			dXMax	= xyR.x + xyR.y;
		}
		else
		{
			double dXMinTmp	= xyR.x;
			double dXMaxTmp	= xyR.x + xyR.y;
			if(dXMinTmp < dXMin)
				dXMin	= dXMinTmp;
			if(dXMaxTmp > dXMax)
				dXMax	= dXMaxTmp;
		}
	}
	if(pGirderRB->m_nType == 0 || pGirderRB->m_nType == 1)
	{
		pGirderRB->m_dWidthL	= dXMax - dXMin;
		pGirderRB->m_dWidthR	= 0;
	}
	else
	{
		//CTwinVector tvLower;
		//GetTvHunchLower(tvLower, nJ, TRUE, bUpperSlabGirder);
		//pGirderRB->m_dWidthL	= tvLower.GetLength(FALSE)/2;
		//pGirderRB->m_dWidthR	= pGirderRB->m_dWidthL;
		
		long nIndexInWall = nJ - 1;
		long nIdxHunch = GetIdxHunchInWall(nIndexInWall, TRUE);
		pGirderRB->m_dWidthL = m_dWL[nIdxHunch][bUpperSlabGirder?0:1];
		pGirderRB->m_dWidthR = m_dWR[nIdxHunch][bUpperSlabGirder?0:1];
	}
}
// 둔각부 보강 철근 권고안
void CRcBridgeRebar::SetDataDefaultRebarObtuseAngle()
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	if(!pStd) return;

	BOOL bBox			= IsBoxType();
	double dDiaDefault = 19;
	double dCoverDefault = 200;

	double dCTCDefault	=0, dB =0, dLenObtuse =0, dSettle =0;
	dCTCDefault				= 200;																	// 도로교 설계기준(2005)
	dB							= GetWidthSlabAct(m_dStationBridgeStt, CDPoint(0, 1), 0);
	dLenObtuse				= 0.3 * dB;															// ㄷ누각부 길이는 슬래브 전폭 * 0.3
	
	long nCntStrct = IsBoxType()? 2 : 1;
	for (long nStrct = 0; nStrct < nCntStrct; nStrct++)
	{
		BOOL bUpperSlab = nStrct ==0;

		long stt = 0; for(stt = 0; stt < 2; stt++)
		{
			BOOL bStt	= stt == iSTT;
			long left = 0; for(left = 0; left < 2; left++)
			{
				//m_bIsObtuseAngle_UpperSlab[stt][left]	= FALSE;	// 시종점, 좌우측
				
				bUpperSlab? m_dCoverObtuseAngle_UpperSlab_Plane[stt][left][0] = dCoverDefault : m_dCoverObtuseAngle_LowerSlab_Plane[stt][left][0]	= dCoverDefault;		// 시종점, 좌우측, 0:종방향,1:횡방향
				bUpperSlab? m_dCoverObtuseAngle_UpperSlab_Plane[stt][left][1] = dCoverDefault : m_dCoverObtuseAngle_LowerSlab_Plane[stt][left][1]	= dCoverDefault;		// 시종점, 좌우측, 0:종방향,1:횡방향

				double dLen	= dLenObtuse;//100 * 2 + 10 * GetCtcRebarMain(TRUE);
				double dWallLen = 0;
				CTwinVectorArray tvArrUpper, tvArrLower;

				CString sSlab(_T("")),  sWall(_T(""));

				sSlab = _T("슬래브상면");
				if(bBox)
				{
					sWall = _T("하부슬래브하면");
				}
				else
				{
					sWall = bStt?_T("시점벽체좌측면") : _T("종점벽체우측면");
				}

				m_tvArrVertSection.GetTvArrByInfo(sSlab, tvArrUpper, FALSE, FALSE);
				m_tvArrVertSection.GetTvArrByInfo(sWall, tvArrLower, FALSE, FALSE);

				CDPoint xyTop, xyBot;
				xyTop = bStt ? tvArrUpper.GetXyLeft() : tvArrUpper.GetXyRight();
				if(bBox)
					xyBot = bStt ? tvArrLower.GetXyLeft() : tvArrLower.GetXyRight();
				else
					xyBot = tvArrLower.GetXyBottom();

				double dLenHeight = fabs(xyTop.y - xyBot.y);
				dSettle				= pStd->GetValueJoint(dDiaDefault, JOINT_TENS_NORMAL_B, dCoverDefault, dCTCDefault);
				if(dLenHeight > 0)
				{
					dWallLen = (0.25* dLenHeight)+dSettle;
					dWallLen = Round(dWallLen, 0);
				}
				else
				{
					dWallLen = dLenObtuse;
				}


				long upper = 0; for(upper = 0; upper < 2; upper++)
				{
					bUpperSlab? m_dCoverObtuseAngle_UpperSlab[stt][left][upper]	= 200		: m_dCoverObtuseAngle_LowerSlab[stt][left][upper]	= 200;		// 시종점, 좌우측, 상하면피복
					bUpperSlab? m_dLenObtuseAngle_UpperSlab[stt][left][upper]	= dLen	: m_dLenObtuseAngle_LowerSlab[stt][left][upper]		= dLen;	// 시종점, 좌우측, 상하면 철근 길이
				}

				bUpperSlab? m_dLenObtuseAngle_OutWall[stt][left] = IsOutWall(bStt) ? dWallLen : m_dTS - 400 : m_dLenObtuseAngle_LowerOutWall[stt][left] = IsOutWall(bStt) ? dWallLen : m_dTS - 400;	// 시종점, 좌우측 상면 철근 벽체방향 길이
				

				long nCount	= (long)(dLenObtuse / dCTCDefault);
				double dRemain	= dLenObtuse - (nCount * dCTCDefault);
				if(dRemain < 200)
				{
					nCount --;
					dRemain += dCTCDefault;
				}


				for(upper = 0; upper < 2; upper++)
				{
					CPlaceRebarByBlock *pPlace	= bUpperSlab? &m_placeByBlock_ObtuseAngle_Support_UpperSlab[stt][left][upper] : &m_placeByBlock_ObtuseAngle_Support_LowerSlab[stt][left][upper];	// 시종점 좌우측 선형방향 간격
					pPlace->m_xyArr.RemoveAll();
					pPlace->m_dDia	= 19;
					pPlace->m_xyArr.Add(CDPoint(1, dRemain/2));
					pPlace->m_xyArr.Add(CDPoint(nCount, dCTCDefault));
					pPlace->m_xyArr.Add(CDPoint(1, dRemain/2));
					pPlace->m_nCountBlock	= pPlace->m_xyArr.GetSize();


					pPlace	=  bUpperSlab?  &m_placeByBlock_ObtuseAngle_Main_UpperSlab[stt][left][upper] : &m_placeByBlock_ObtuseAngle_Main_LowerSlab[stt][left][upper];	// 시종점 좌우측 횡방향 간격
					pPlace->m_xyArr.RemoveAll();
					pPlace->m_dDia	= 19;
					pPlace->m_xyArr.Add(CDPoint(1, dRemain/2));
					pPlace->m_xyArr.Add(CDPoint(nCount, dCTCDefault));
					pPlace->m_xyArr.Add(CDPoint(1, dRemain/2));
					pPlace->m_nCountBlock	= pPlace->m_xyArr.GetSize();
				}



				CPlaceRebarByBlock *pPlace	= bUpperSlab? &m_placeByBlock_ObtuseAngle_Support_OutWall[stt][left] : &m_placeByBlock_ObtuseAngle_Support_LowerOutWall[stt][left];	// 시종점 좌우측 횡방향 간격
				pPlace->m_xyArr.RemoveAll();
				pPlace->m_dDia	= 19;

				if(IsOutWall(bStt))
				{
					if(bUpperSlab)
						dWallLen	= dWallLen;// - (m_dTS - m_dCoverObtuseAngle_UpperSlab[stt][left][iUPPER] - m_dCoverObtuseAngle_UpperSlab[stt][left][iLOWER]);
					else
						dWallLen	= dWallLen;// - (m_dTS - m_dCoverObtuseAngle_LowerSlab[stt][left][iUPPER] - m_dCoverObtuseAngle_LowerSlab[stt][left][iLOWER]);

					nCount	= (long)(dWallLen / dCTCDefault);
					dRemain	= dWallLen - (nCount * dCTCDefault);
					if(dRemain < 200)
					{
						nCount --;
						dRemain += dCTCDefault;
					}

					pPlace->m_xyArr.Add(CDPoint(1, dRemain/2));
					pPlace->m_xyArr.Add(CDPoint(nCount, dCTCDefault));
					pPlace->m_xyArr.Add(CDPoint(1, dRemain/2));
				}
				pPlace->m_nCountBlock	= pPlace->m_xyArr.GetSize();

				m_dDiaObtuseAngle_UpperSlabLower[stt][left]	= 19;
			}
		}
	}
}

// 둔각부 보강 rebarinfocycle만들기
void CRcBridgeRebar::MakeRebarInfoCycle_ObtuseAngle_Slab(BOOL bInput, long nVertDir, BOOL bUpperSlab)
{
	BOOL bVertDir	= IsVertDir();
	if(nVertDir!=0)
		bVertDir	= nVertDir == -1 ? TRUE : FALSE;
	m_bMakedRebarInfoCycleByVert	= bVertDir;

	// 사용할 변수들.. 
	long stt(0), left(0), upper(0);
	CRebarInfoCycle *pRC = NULL;
	for(stt = 0; stt < 2; stt++)
	{
		for(left = 0; left < 2; left++)
		{
			for(upper = 0; upper < 2; upper++)
			{
				CRebarInfoCycle *pRC	= bUpperSlab? &m_rebarInfoCycle_ObtuseAngle_Upperslab[stt][left][upper] : &m_rebarInfoCycle_ObtuseAngle_Lowerslab[stt][left][upper];
				pRC->InitInfoCycle();
			}
		}
	}
	
	CRebarPlacing rbPlacing;
	CTwinVector tv;
	CTwinVectorArray tvArr, tvArrTmp;

	// 공통사용 변수
	CTwinVector tvRebar;		// 상부슬래브 좌표
	double dOffset		= 0;	// 상단슬래브 상면에서 철근까지의 거리
	double dLenRound	= 0;	// 가장자리 철근의 모따리나 라운드 크기
	double dDia			= 0;	// 철근 지름
	CDPoint vAng		= CDPoint(0, 1);

	GetMarkRebarMain(MARK_OBTUSE_UPPER, bInput, 0, TRUE, FALSE, "", 0);

	// description 정보 /////
	CString sCycle	= m_pARcBridgeDataStd->GetStringCircleNum(1);
	CString sUpper	= "상";
	///////////////////////////

	
	for(stt = 0; stt < 2; stt++)
	{
		BOOL bStt	= stt == iSTT;
		CString sStt	= bStt ? "시점" : "종점";

		for(left = 0; left < 2; left++)
		{
			BOOL bLeft	= left == iLEFT;
			CString sLeft	= bLeft ? "좌측" : "우측";
			double dCoverU	= bUpperSlab? m_dCoverObtuseAngle_UpperSlab[stt][left][iUPPER] : m_dCoverObtuseAngle_LowerSlab[stt][left][iUPPER];
			double dCoverL	= bUpperSlab? m_dCoverObtuseAngle_UpperSlab[stt][left][iLOWER] : m_dCoverObtuseAngle_LowerSlab[stt][left][iLOWER];

			if(!bUpperSlab)
			{
				if(IsBoxType() && !m_bIsObtuseAngle_LowerSlab[stt][left])
					continue;
			}
			else if(!m_bIsObtuseAngle_UpperSlab[stt][left]) 
				continue;

			// 상면 ////////////////////////////////////////////////////////////////////////////
			tvRebar		= GetTvOffset_ObtuseAngle_Slab(bStt, bLeft, TRUE, bVertDir, bUpperSlab);
			dOffset		= bUpperSlab? m_dCoverObtuseAngle_UpperSlab[stt][left][iUPPER] : m_dCoverObtuseAngle_LowerSlab[stt][left][iLOWER];
		
			vAng		= bVertDir ? CDPoint(0, 1) : GetAngleJijum(bStt ? 0 : m_nQtyJigan);
		
			double dist		= bUpperSlab? m_dLenObtuseAngle_UpperSlab[stt][left][iUPPER] : m_dLenObtuseAngle_LowerSlab[stt][left][iLOWER];
			double distVer	= bUpperSlab? m_dLenObtuseAngle_OutWall[stt][left] : m_dLenObtuseAngle_LowerOutWall[stt][left];

			// 철근 지름과 가장자리철근 모따기밑 라운드 크기 ////////////
			dDia		= bUpperSlab? m_placeByBlock_ObtuseAngle_Support_UpperSlab[stt][left][iUPPER].m_dDia : m_placeByBlock_ObtuseAngle_Support_LowerSlab[stt][left][iLOWER].m_dDia;
			dLenRound	= GetLenRebarAtEdge(dDia, FALSE, nVertDir, bUpperSlab);
			if(!IsOutWall(bStt)) dLenRound	= 0;
			/////////////////////////////////////////////////////////////////
					

			pRC		= bUpperSlab? &m_rebarInfoCycle_ObtuseAngle_Upperslab[stt][left][iUPPER] : &m_rebarInfoCycle_ObtuseAngle_Lowerslab[stt][left][iLOWER];

			// 공통속성
			pRC->m_nTypeRebar	= REBAR_TYPE_MAIN;
 			pRC->m_nRebarDan	= 0;
			pRC->m_Dia			= dDia;
			pRC->m_bExist		= TRUE;
			// 마크 번호를 증가시키지 않기 위해서 1단으로 함.			
			CString sSlab = _T("");
			if(IsBoxType())
				sSlab.Format(bUpperSlab? _T("상부슬래브") : _T("하부슬래브"));
			
			if(bUpperSlab)
			{
				pRC->m_szMark		= GetMarkRebarMain(MARK_OBTUSE_UPPER, bInput, 0, FALSE, TRUE, "", 1);
				if(IsBoxType())
					pRC->m_sDescription.Format("%s 둔각부(%s%s) 주철근(상면)",sSlab, sStt, sLeft);
				else
					pRC->m_sDescription.Format("둔각부(%s%s) 주철근(상면)", sStt, sLeft);
			}
			else
			{
				pRC->m_szMark		= GetMarkRebarMain(MARK_OBTUSE_LOWER_LOWSLAB, bInput, 0, FALSE, TRUE, "", 1);
				pRC->m_sDescription.Format("%s 둔각부(%s%s) 주철근(하면)", sSlab, sStt, sLeft);
			}


			double dDirY = bUpperSlab ? +1.0 : -1.0;
			CDPoint vAngRound = bUpperSlab? CDPoint(0,-1) : CDPoint(0,1);
			// 첫번째 지간에 첫번째 이음까지의 철근 
			if(bStt)
			{
				pRC->m_nPosStt	= REBARINFO_POS_STTWALL_OUTTER;
				pRC->m_nPosEnd	= bUpperSlab? REBARINFO_POS_UPPERSLAB_UPPER : REBARINFO_POS_LOWERSLAB_LOWER;				
				if(!IsOutWall(TRUE))
					pRC->m_xyStt	= CDPoint(tvRebar.m_v1.x, tvRebar.m_v1.y - (m_dTS - dCoverU - dCoverL));
				else
					pRC->m_xyStt	= CDPoint(tvRebar.m_v1.x, tvRebar.m_v1.y - (dLenRound+distVer)* dDirY);
				GetXyTanOfArc(tvRebar.m_v1, tvRebar.GetXyDir(), vAngRound, dLenRound, pRC->m_xyCen, pRC->m_xyMid2, pRC->m_xyMid1);
				pRC->m_xyEnd	= bUpperSlab? GetXyToDistFromSlabUpper(pRC->m_xyMid2.x, dist, 0, dOffset, bVertDir) : GetXyToDistFromSlabLower(pRC->m_xyMid2.x, dist, 0, dOffset, bVertDir);
				pRC->m_R_Mid	= dLenRound;
				pRC->m_bRevArc	= TRUE ;
			}
			else
			{
				pRC->m_nPosStt		= bUpperSlab? REBARINFO_POS_UPPERSLAB_UPPER : REBARINFO_POS_LOWERSLAB_LOWER;
				pRC->m_nPosEnd	= REBARINFO_POS_ENDWALL_OUTTER;
				pRC->m_xyStt	= bUpperSlab? GetXyToDistFromSlabUpper(tvRebar.m_v2.x, -dist-dLenRound, 0, dOffset, bVertDir) : GetXyToDistFromSlabLower(tvRebar.m_v2.x, -dist-dLenRound, 0, dOffset, bVertDir);
				GetXyTanOfArc(tvRebar.m_v2, vAngRound, tvRebar.GetXyDir(TRUE), dLenRound, pRC->m_xyCen, pRC->m_xyMid2, pRC->m_xyMid1);
				if(IsOutWall(FALSE))
					pRC->m_xyEnd	= pRC->m_xyMid2 + CDPoint(0, -distVer * dDirY);
				else
					pRC->m_xyEnd	= pRC->m_xyMid2 + CDPoint(0, -(m_dTS - dCoverU - dCoverL));
				pRC->m_R_Mid	= dLenRound;
				pRC->m_bRevArc	=  TRUE ;
			}


			// 하면 ////////////////////////////////////////////////////////////////////////////
			tvRebar	= GetTvOffset_ObtuseAngle_Slab(bStt, bLeft, FALSE, bVertDir, bUpperSlab);
			dDia		= bUpperSlab? m_placeByBlock_ObtuseAngle_Support_UpperSlab[stt][left][iLOWER].m_dDia : m_placeByBlock_ObtuseAngle_Support_LowerSlab[stt][left][iUPPER].m_dDia;

			// 철근 하나 추가
			dist	= bUpperSlab? m_dLenObtuseAngle_UpperSlab[stt][left][iLOWER] : m_dLenObtuseAngle_LowerSlab[stt][left][iUPPER];
			pRC	= bUpperSlab? &m_rebarInfoCycle_ObtuseAngle_Upperslab[stt][left][iLOWER] : &m_rebarInfoCycle_ObtuseAngle_Lowerslab[stt][left][iUPPER];
			
			// 공통속성
			pRC->m_nTypeRebar	= REBAR_TYPE_MAIN;
			pRC->m_nRebarDan	= 0;
			pRC->m_nPosStt			= bUpperSlab? REBARINFO_POS_UPPERSLAB_LOWER : REBARINFO_POS_LOWERSLAB_UPPER;
			pRC->m_nPosEnd		= bUpperSlab? REBARINFO_POS_UPPERSLAB_LOWER : REBARINFO_POS_LOWERSLAB_UPPER;
			pRC->m_Dia				= dDia;
			pRC->m_bExist			= TRUE;
			// 마크 번호를 증가시키지 않기 위해서 1단으로 함.
			if(bUpperSlab)
			{
				pRC->m_szMark		= GetMarkRebarMain(MARK_OBTUSE_LOWER, bInput, 0, FALSE, TRUE, "", 1);
				if(IsBoxType())
					pRC->m_sDescription.Format("%s 둔각부(%s%s) 보강철근(하면)",sSlab, sStt, sLeft);
				else
					pRC->m_sDescription.Format("둔각부(%s%s) 보강철근(하면)",sStt, sLeft);
			}
			else
			{
				pRC->m_szMark		= GetMarkRebarMain(MARK_OBTUSE_UPPER_LOWSLAB, bInput, 0, FALSE, TRUE, "", 1);
				pRC->m_sDescription.Format("%s 둔각부(%s%s) 보강철근(상면)", sSlab , sStt, sLeft);
			}
			

			if(bStt)
			{
				pRC->m_xyStt	= tvRebar.m_v1;
				GetXyMatchLineAndLine(pRC->m_xyStt, tvRebar.GetXyDir(), CDPoint(pRC->m_xyStt.x+dist,0), CDPoint(0, 1), pRC->m_xyMid1);
			}
			else
			{
				pRC->m_xyStt	= tvRebar.m_v2;
				GetXyMatchLineAndLine(pRC->m_xyStt, tvRebar.GetXyDir(), CDPoint(pRC->m_xyStt.x-dist,0), CDPoint(0, 1), pRC->m_xyMid1);
			}
			pRC->m_xyMid2	= pRC->m_xyMid1;
			pRC->m_xyEnd	= pRC->m_xyMid1;

			// 하면 만들고 횡방향 철근 기호를 바로 연결하기 위해 한칸 띄움
			GetMarkRebarMain(MARK_OBTUSE_CROSS, bInput, 0, FALSE, TRUE, "", 1);
		}
	}



	/*
	// szMark 설정
	SetStringMarkToRebarInfoCycle(pArrRCLower, MARK_UPPERSLAB_LOWER, nCycleReal, bInput, bInput, nDan);
	// sDescription 설정
	SetStringDescriptionRebarInfoCycle_UpperSlab(pArrRCLower, nCycleReal, FALSE, nDan);

	SettingAngleInfoAtRebarInfoCycle_UpperSlab(pArrRCLower, 0, -1, -1, bVertDir);
	*/
}

// 둔각부 보강을 위한 상부 슬래브 선 
CTwinVector CRcBridgeRebar::GetTvOffset_ObtuseAngle_Slab(BOOL bStt, BOOL bLeft, BOOL bUpper, BOOL bVertDir, BOOL bUpperSlab)
{
	CTwinVector tv;
	CDPoint vAngStt	= bVertDir ? CDPoint(0, 1) : GetAngleJijum(0);
	CDPoint vAngEnd	= bVertDir ? CDPoint(0, 1) : GetAngleJijum(m_nQtyJigan);
	
	long stt	= bStt ? iSTT : iEND;
	long left	= bLeft ? iLEFT : iRIGHT;

	// dSttSta와 dEndSta가 모두 -1이면 벽체 시작부터 끝까지로 인식...
	double dCoverSideStt	= bUpperSlab ? m_dCoverObtuseAngle_UpperSlab_Plane[stt][left][0] : m_dCoverObtuseAngle_LowerSlab_Plane[stt][left][0];//IsOutWall(TRUE) ? m_dCoverWallOut[nDan] : GetCoverSide_UpperSlab(nDan);
	double dCoverSideEnd	= bUpperSlab? m_dCoverObtuseAngle_UpperSlab_Plane[stt][left][0] : m_dCoverObtuseAngle_LowerSlab_Plane[stt][left][0];//IsOutWall(FALSE) ? m_dCoverWallOut[nDan] : GetCoverSide_UpperSlab(nDan);

	double dSttSta	= 0;
	double dEndSta	= 0;
	CTwinVector tvUpper;
	CTwinVector tvStt, tvEnd;
	CString str	= IsOutWall(TRUE) ? "시점브라켓상부측면" : "시점슬래브측면";
	if(bUpperSlab == FALSE)	str = "하부슬래브하면(시점벽체아래)";

	m_tvArrVertSection.GetTvByInfo(str, tvStt);

	if(bUpperSlab == FALSE)
		swap(tvStt.m_v1, tvStt.m_v2);

	dSttSta = tvStt.m_v2.x;


	str	= IsOutWall(FALSE) ? "종점브라켓상부측면" : "종점슬래브측면";
	if(bUpperSlab == FALSE)	str = "하부슬래브하면(종점벽체아래)";

	m_tvArrVertSection.GetTvByInfo(str, tvEnd);

	if(bUpperSlab == FALSE)
		swap(tvEnd.m_v1, tvEnd.m_v2);

	dEndSta = tvEnd.m_v1.x;
	
	dSttSta += dCoverSideStt / vAngStt.y;
	dEndSta -= dCoverSideEnd / vAngEnd.y;

	tv.m_v1	= tvStt.m_v2;
	tv.m_v2	= tvEnd.m_v1;

	// 상부슬래브에서 구하고자하는 tv까지의 거리
	double dOffset = 0;
	if(bUpperSlab)
		dOffset = bUpper ? m_dCoverObtuseAngle_UpperSlab[stt][left][iUPPER] : m_dTS - m_dCoverObtuseAngle_UpperSlab[stt][left][iLOWER];
	else
		dOffset = bUpper ? -m_dCoverObtuseAngle_LowerSlab[stt][left][iUPPER] : -(m_dTS - m_dCoverObtuseAngle_LowerSlab[stt][left][iLOWER]);

	GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), CDPoint(dSttSta, 0), CDPoint(0, 1), tv.m_v1);
	GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), CDPoint(dEndSta, 0), CDPoint(0, 1), tv.m_v2);
	tv.m_v1.y -= dOffset;
	tv.m_v2.y -= dOffset;

	return tv;
}

// 둔각부 보강 철근 
void CRcBridgeRebar::GetTvRebarMain_Plane_Slab_Obtuse(CTwinVectorArrayArray *pTvArrMainRebar, CTwinVectorArray &tvArrSupportRebar, BOOL bStt, BOOL bLeft, BOOL bUpper,BOOL bLowerSlab)
{
	AhTPADelete(pTvArrMainRebar, (CTwinVectorArray*)0);
	tvArrSupportRebar.RemoveAll();
	long stt	= bStt ? iSTT : iEND;
	long left	= bLeft ? iLEFT : iRIGHT;
	long upper	= bUpper ? iUPPER : iLOWER;

	if(!m_bIsObtuseAngle_UpperSlab[stt][left]) return;

	CRebarPlacing rb;

	CTwinVectorArray tvArrLeftRightTmp;
	CTwinVectorArray tvArrLeftRight, tvArrSttEnd;
	CTwinVector tv;
	GetTvArrPlane_UpperSlab_Obtuse(tvArrLeftRight, tvArrSttEnd, bStt, bLeft, 0, bLowerSlab);
	if(tvArrLeftRight.GetSize() == 0 || tvArrSttEnd.GetSize() == 0) return;
	tvArrLeftRightTmp	= tvArrLeftRight;

	// 선형방향 철근 하나 길이에 맞게 만듬.
	double dLenLineDir	= m_dLenObtuseAngle_UpperSlab[stt][left][upper];
	rb.StretchTvArr(tvArrLeftRight, 0, -(tvArrLeftRight.GetLength()-dLenLineDir));
	if(tvArrLeftRight.GetSize() == 0) return;

	CPlaceRebarByBlock *pPlace	= &m_placeByBlock_ObtuseAngle_Main_UpperSlab[stt][left][upper];
	CTwinVector tvSttLeft;
	tvSttLeft.m_v1	= tvArrSttEnd.GetAt(0).m_v1;
	tvSttLeft.m_v2	= tvArrSttEnd.GetAt(tvArrSttEnd.GetSize()-1).m_v2;
	CDPointArray xyArr;
	rb.GetXyDivideLine(xyArr, tvSttLeft.m_v1, tvSttLeft.m_v2, pPlace->m_xyArr, TRUE, FALSE, FALSE);

	long i = 0; for(i = 0; i < xyArr.GetSize(); i++)
	{
		CDPoint xy	= xyArr.GetAt(i);
		rb.MoveRebar(tvArrLeftRight, xy - tvArrLeftRight.GetAt(0).m_v1);

		CTwinVectorArray *pTvArrLeftRight	= new CTwinVectorArray;
		*pTvArrLeftRight	= tvArrLeftRight;
		pTvArrMainRebar->Add(pTvArrLeftRight);
	}

	// 횡방향 철근 하나 길이에 맞게 만듬
	double dLenSupportRebar	= ~(xyArr.GetAt(0) - xyArr.GetAt(xyArr.GetSize()-1));
	tvSttLeft.m_v2	= tvSttLeft.m_v1 + tvSttLeft.GetXyDir() * dLenSupportRebar;
	pPlace	= &m_placeByBlock_ObtuseAngle_Support_UpperSlab[stt][left][upper];
	CDPoint xyR(0, 0), xyMove(0, 0), xyOld(0, 0);

	tvArrSupportRebar.Add(tvSttLeft);
	for(i = 0; i < pPlace->m_xyArr.GetSize(); i++)
	{
		xyR	= pPlace->m_xyArr.GetAt(i);
		long j = 0; for(j = 0; j < xyR.x; j++)
		{
			xyOld	= tvArrLeftRightTmp.GetAt(0).m_v1;
			rb.StretchTvArr(tvArrLeftRightTmp, -xyR.y, 0);
			xyMove	= (tvArrLeftRightTmp.GetAt(0).m_v1 - xyOld);
			tvSttLeft.m_v1	= tvSttLeft.m_v1 + xyMove;
			tvSttLeft.m_v2	= tvSttLeft.m_v2 + xyMove;
			tvArrSupportRebar.Add(tvSttLeft);
		}
	}
	
}

void CRcBridgeRebar::GetTvArrPlane_UpperSlab_Obtuse(CTwinVectorArray &tvArrMainRebar, CTwinVectorArray &tvArrSupportRebar, BOOL bStt, BOOL bLeft, long nDan, BOOL bLowerSlab)
{
	CRebarPlacing rb;
	CTwinVectorArray tvArrPlane;

	long stt	= bStt ? iSTT : iEND;
	long left	= bLeft ? iLEFT : iRIGHT;
	double dCoverWallOutOld		= m_dCoverWallOut[0];
	double dCoverUpperSlabOld	= m_dCoverSide_UpperSlab[0];
	m_dCoverWallOut[0]			= bLowerSlab? m_dCoverObtuseAngle_LowerSlab_Plane[stt][left][0] : m_dCoverObtuseAngle_UpperSlab_Plane[stt][left][0];
	m_dCoverSide_UpperSlab[0]	= bLowerSlab? m_dCoverObtuseAngle_LowerSlab_Plane[stt][left][1] : m_dCoverObtuseAngle_UpperSlab_Plane[stt][left][1];

	GetTvRebarOut_Plane_UpperSlabStd(tvArrPlane, nDan, 0);

	m_dCoverWallOut[0]			= dCoverWallOutOld;
	m_dCoverSide_UpperSlab[0]	= dCoverUpperSlabOld;

	CTwinVector tv;
	CString sStt	= bStt ? "시점" : "종점";
	CString sLeft	= bLeft ? "좌측" : "우측";
	long i = 0; for(i = 0; i < tvArrPlane.GetSize(); i++)
	{
		tv	= tvArrPlane.GetAt(i);
		if(tv.m_sInfo.Find(sStt, 0) != -1) tvArrSupportRebar.Add(tv);
		else if(tv.m_sInfo.Find(sLeft, 0) != -1) tvArrMainRebar.Add(tv);
	}

	if(!bStt)
		rb.ReverseRebar(tvArrMainRebar);
	if(nDan > -1)
	{
		if(bStt && !bLeft || !bStt && !bLeft)
			rb.ReverseRebar(tvArrMainRebar);
	}

	if((bStt && bLeft) || (!bStt && !bLeft))
		rb.ReverseRebar(tvArrSupportRebar);
}

void CRcBridgeRebar::SetDataDefaultRebarJewon_Slab_Obtuse(BOOL bUpperSlab)
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();
	BOOL bBoxType = IsBoxType();
	BOOL bLowSlabType = bBoxType && !bUpperSlab? TRUE : FALSE;
	long stt(0), left(0);
	long upper(0);
	double dCover(0), dRebarSpace(0);

	CHgBaseConcStd baseConc;
	GetMarkRebarMain(MARK_OBTUSE_CROSS, FALSE, 0, TRUE, TRUE, "", 1);

	for(stt = 0; stt < 2; stt++)
	{
		BOOL bStt		= stt == iSTT;
		CString sStt	= bStt ? "시점" : "종점";

		for(left = 0; left < 2; left++)
		{
			BOOL bLeft	= left == iLEFT;
			CString sLeft	= bLeft ? "좌측" : "우측";

			if(bLowSlabType && !m_bIsObtuseAngle_LowerSlab[stt][left]) continue;
			else if(!m_bIsObtuseAngle_UpperSlab[stt][left]) continue;

			CTwinVectorArray tvArrSupportRebar;
			CTwinVectorArrayArray pTvArrMainRebar;

			CDPointArray xyArrUpperSlabUpper, xyArrUpperSlabLower, xyArrUpperSide;
			GetXyRebarMain_VertSection_SlabObtuse(xyArrUpperSlabUpper, xyArrUpperSide, xyArrUpperSlabLower, bStt, bLeft, bLowSlabType);

			// 선형방향
			for(upper = 0; upper < 2; upper++)
			{
				BOOL bUpper	= upper == iUPPER;

				GetTvRebarMain_Plane_Slab_Obtuse(&pTvArrMainRebar, tvArrSupportRebar, bStt, bLeft, bUpper, bLowSlabType);
				
				CPlaceRebarByBlock *pPlace	= bLowSlabType? &m_placeByBlock_ObtuseAngle_Main_LowerSlab[stt][left][upper] : &m_placeByBlock_ObtuseAngle_Main_UpperSlab[stt][left][upper];
				if(!pPlace) continue;

				CRebarInfoCycle *pRC	= bLowSlabType? &m_rebarInfoCycle_ObtuseAngle_Lowerslab[stt][left][upper] : &m_rebarInfoCycle_ObtuseAngle_Upperslab[stt][left][upper];
				if(!pRC) continue;

				CRebarInfoCycle *pRCOwner	= GetOwnerRebarInfoCycleObtuseAngle(bStt, bLeft, bUpper, bLowSlabType);

				dRebarSpace	= pPlace->GetCTC();
				dCover		= bLowSlabType? m_dCoverObtuseAngle_LowerSlab[stt][left][upper] : m_dCoverObtuseAngle_UpperSlab[stt][left][upper];

				if(pRCOwner && pRC != pRCOwner)
				{
					long i = 0; for(i = 0; i < m_pArrRebarMain.GetSize(); i++)
					{
						CRebar *pRB	= m_pArrRebarMain.GetAt(i);
						if(pRB->m_sDescription == pRCOwner->m_sDescription)
						{
							pRB->m_nEa += pTvArrMainRebar.GetSize();
						}
					}
				}
				else
				{
					CRebar *pRB				= new CRebar;
					pRB->m_Fy				= bLeft?  GetValueFy(bLowSlabType? ePartLowerSlab : ePartUpperSlab) : m_pARcBridgeDataStd->m_Fy;
					pRB->m_sDescription	= pRC->m_sDescription;
					pRB->m_sMark			= pRC->m_szMark;
					GetMarkRebarMain(bUpper ? MARK_OBTUSE_UPPER : MARK_OBTUSE_LOWER, FALSE, 0, FALSE, TRUE, "", 1);
					pRB->m_dDia			= pRC->m_Dia;
					pRB->m_dLengthMax_A	= bStt ? pRC->GetLengthStt() : pRC->GetLengthEnd();
					pRB->m_dLengthMin_A	= 0;
					pRB->m_dLengthMax_B	= pRC->GetLengthMid(TRUE);
					pRB->m_dLengthMin_B	= 0;
					pRB->m_dLengthMax_C	= bStt ? pRC->GetLengthEnd() : pRC->GetLengthStt();
					pRB->m_dLengthMin_C	= 0;
					
					if(bUpper)
					{
						if(pRC->m_R_Mid > 0)
						{
							pRB->m_dLengthMax_R1	= pRC->m_R_Mid;
							pRB->m_dLengthMin_R1	= 0;
							pRB->m_nTypeRebar		= 5;
						}				
						else
						{
							pRB->m_nTypeRebar		= 78;
							if(pRB->m_dLengthMax_B == 0)
							{
								pRB->m_nTypeRebar	= 2;
								pRB->m_dLengthMax_A	= pRB->m_dLengthMax_C;
								pRB->m_dLengthMax_B	= pRB->m_dLengthMax_A;
								pRB->m_dLengthMax_C	= 0;
							}
						}
					}
					else
					{
						pRB->m_nTypeRebar	= 1;
						if(!bStt)
						{
							pRB->m_dLengthMax_A	= pRB->m_dLengthMax_C;
							pRB->m_dLengthMax_C	= 0;
						}
					}
					pRB->m_bMainRebar		= TRUE;
					pRB->m_nEa				= pTvArrMainRebar.GetSize();
					m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
					pRB->m_dRateAdd	= MAKE_RATE;
					AddOrDeleteRebarInList(&m_pArrRebarMain, pRB);
				}
			}

			AhTPADelete(&pTvArrMainRebar, (CTwinVectorArray*)0);
		}
	}
}

// 둔각부 보강철근 점 철근 가져옴
void CRcBridgeRebar::GetXyRebarMain_VertSection_SlabObtuse(CDPointArray &xyArrUpperSlabUpper, CDPointArray &xyArrUpperSlabSide, CDPointArray &xyArrUpperSlabLower, BOOL bStt, BOOL bLeft, BOOL bLowerSlab)
{
	xyArrUpperSlabUpper.RemoveAll();
	xyArrUpperSlabSide.RemoveAll();
	xyArrUpperSlabLower.RemoveAll();

	BOOL bBox	= IsBoxType();
	long stt		= bStt ? iSTT : iEND;
	long left		= bLeft ? iLEFT : iRIGHT;
	
	CRebarPlacing rb;
	CTwinVectorArray tvArr;
	CDPointArray xyArrMatch;
	CDPoint xy(0, 0);

	// 상면(함형은 하면)
	CRebarInfoCycle *pRC	= !bLowerSlab? &m_rebarInfoCycle_ObtuseAngle_Upperslab[stt][left][iUPPER] : &m_rebarInfoCycle_ObtuseAngle_Lowerslab[stt][left][iLOWER];
	if(!pRC) return;

	// 상부슬래브 상면 (함형: 하부슬래브 하면)
	CPlaceRebarByBlock *pPlace	= !bLowerSlab?  &m_placeByBlock_ObtuseAngle_Support_UpperSlab[stt][left][iUPPER] : &m_placeByBlock_ObtuseAngle_Support_LowerSlab[stt][left][iLOWER];
	if(!pPlace) return;

	CTwinVector tv;
	tv.m_v1	= pRC->m_xyStt;
	tv.m_v2	= pRC->m_xyEnd;
	tv.m_v1.y	= tv.m_v2.y;
	if(!bStt)
		GetSwap(tv.m_v1, tv.m_v2);
	rb.GetXyDivideLine(xyArrUpperSlabUpper, tv.m_v1, tv.m_v2, pPlace->m_xyArr, TRUE, FALSE, FALSE);

	if(bStt)
	{
		tv.m_v1	= pRC->m_xyEnd;
		tv.m_v2	= pRC->m_xyMid2;
		tv.m_v1.z	= 0;
		tv.m_v2.z	= 0;
		tvArr.Add(tv);

		tv.m_v1	= bLowerSlab? pRC->m_xyMid1 : pRC->m_xyMid2;
		tv.m_v2	= bLowerSlab? pRC->m_xyMid2 : pRC->m_xyMid1;
		tv.m_v1.z	= -1;
		tv.m_v2.z	= pRC->m_R_Mid;
		tvArr.Add(tv);
	}
	else
	{
		if(bBox && bLowerSlab)
		{
			tv.m_v1	= pRC->m_xyMid1;
			tv.m_v2	= pRC->m_xyMid2;
			tv.m_v1.z	= -1;
			tv.m_v2.z	= pRC->m_R_Mid;
			tvArr.Add(tv);

			tv.m_v1	= pRC->m_xyMid1;
			tv.m_v2	= pRC->m_xyStt;
			tv.m_v1.z	= 0;
			tv.m_v2.z	= 0;
			tvArr.Add(tv);
		}
		else
		{
			tv.m_v1	= pRC->m_xyMid2;
			tv.m_v2	= pRC->m_xyMid1;
			tv.m_v1.z	= -1;
			tv.m_v2.z	= pRC->m_R_Mid;
			tvArr.Add(tv);

			tv.m_v1	= pRC->m_xyMid1;
			tv.m_v2	= pRC->m_xyStt;
			tv.m_v1.z	= 0;
			tv.m_v2.z	= 0;
			tvArr.Add(tv);
		}	
	}

	long i = 0; for(i = 0; i < xyArrUpperSlabUpper.GetSize(); i++)
	{
		xy	= xyArrUpperSlabUpper.GetAt(i);
		rb.GetXyMatchTvArrAndLine(tvArr, xy, CDPoint(0, 1), xyArrMatch);
		if(xyArrMatch.GetSize() > 0)
		{
			xy	= xyArrMatch.GetAt(0);
			if(bLowerSlab)	xy.y += REBAR_RADIUS;
			else				xy.y -= REBAR_RADIUS;
			xyArrUpperSlabUpper.SetAt(i, xy);
		}
	}

	long nSize	= xyArrUpperSlabUpper.GetSize();
	if(nSize > 0)
	{
		if(bStt)
		{
			xy	= xyArrUpperSlabUpper.GetAt(0);
			xy.x += REBAR_RADIUS;
			xyArrUpperSlabUpper.SetAt(0, xy);
		}
		else
		{
			long nIdx = bBox? 0 : nSize -1;
			xy	= xyArrUpperSlabUpper.GetAt(nIdx);
			bBox? xy.x -= REBAR_RADIUS : xy.x += REBAR_RADIUS;
			xyArrUpperSlabUpper.SetAt(nIdx, xy);
		}
	}

	// 상면 외측벽체 
	pPlace	= !bLowerSlab? &m_placeByBlock_ObtuseAngle_Support_OutWall[stt][left] : &m_placeByBlock_ObtuseAngle_Support_LowerOutWall[stt][left];
	if(!pPlace) return;

	tvArr.RemoveAll();

	if(bBox)
	{
		tv.m_v1	= bStt? pRC->m_xyStt : pRC->m_xyEnd;
		tv.m_v2	= bStt? pRC->m_xyMid1 : pRC->m_xyMid2;	

		if(bLowerSlab)
		{
			if(tv.m_v1.y > tv.m_v2.y)	
			{
				GetSwap(tv.m_v1, tv.m_v2);
			}
		}
		else
		{
			if(tv.m_v2.y > tv.m_v1.y)		
			{
				GetSwap(tv.m_v1, tv.m_v2);
			}
		}
	}
	else
	{
		tv.m_v1	= Compare(pRC->m_xyMid1.y, pRC->m_xyMid2.y , _T("<"), 0.1)? pRC->m_xyMid1 : pRC->m_xyMid2; //pRC->m_xyStt;
		tv.m_v2	= Compare(pRC->m_xyStt.y, pRC->m_xyEnd.y , _T("<"), 0.1)? pRC->m_xyStt :  pRC->m_xyEnd; //pRC->m_xyEnd;

		if(tv.m_v1.y < tv.m_v2.y)
			GetSwap(tv.m_v1, tv.m_v2);
	}	
	
	tv.m_v1.x	= tv.m_v2.x;

	rb.GetXyDivideLine(xyArrUpperSlabSide, tv.m_v1, tv.m_v2, pPlace->m_xyArr, TRUE, FALSE, FALSE);

	if(bStt)
	{
		tv.m_v1	= pRC->m_xyMid2;
		tv.m_v2	= pRC->m_xyMid1;
		tv.m_v1.z	= -1;
		tv.m_v2.z	= pRC->m_R_Mid;
		tvArr.Add(tv);

		tv.m_v1	= pRC->m_xyMid1;
		tv.m_v2	= pRC->m_xyStt;
		tv.m_v1.z	= 0;
		tv.m_v2.z	= 0;
		tvArr.Add(tv);
	}
	else
	{
		tv.m_v1	= pRC->m_xyEnd;
		tv.m_v2	= pRC->m_xyMid2;
		tv.m_v1.z	= 0;
		tv.m_v2.z	= 0;
		tvArr.Add(tv);

		tv.m_v1	= pRC->m_xyMid2;
		tv.m_v2	= pRC->m_xyMid1;
		tv.m_v1.z	= -1;
		tv.m_v2.z	= pRC->m_R_Mid;
		tvArr.Add(tv);
	}

	CDPoint xySide	= bStt ? tvArr.GetXyLeft() : tvArr.GetXyRight();
	for(i = 0; i < xyArrUpperSlabSide.GetSize(); i++)
	{
		xy	= xyArrUpperSlabSide.GetAt(i);
		GetXyMatchLineAndLine(xySide, CDPoint(0, 1), xy, CDPoint(1, 0), xy);
		xy.x += (bStt ? REBAR_RADIUS : -REBAR_RADIUS);
		xyArrUpperSlabSide.SetAt(i, xy);
	}

	// 첫번째꺼는 위로 살짝 올림
	if(xyArrUpperSlabSide.GetSize() > 0)
	{
		xy	= xyArrUpperSlabSide.GetAt(0);
		xy.y += REBAR_RADIUS;
		xyArrUpperSlabSide.SetAt(0, xy);
	}

	// 상부슬래브 하면 철근
	pRC	= !bLowerSlab? &m_rebarInfoCycle_ObtuseAngle_Upperslab[stt][left][iLOWER] : &m_rebarInfoCycle_ObtuseAngle_Lowerslab[stt][left][iUPPER];
	pPlace	= !bLowerSlab? &m_placeByBlock_ObtuseAngle_Support_UpperSlab[stt][left][iLOWER] : &m_placeByBlock_ObtuseAngle_Support_LowerSlab[stt][left][iUPPER];
	rb.GetXyDivideLine(xyArrUpperSlabLower, pRC->m_xyStt, pRC->m_xyMid1, pPlace->m_xyArr, TRUE, FALSE, FALSE);

	for(i = 0; i < xyArrUpperSlabLower.GetSize(); i++)
	{
		xy	= xyArrUpperSlabLower.GetAt(i);
		if(bLowerSlab)	xy.y -= REBAR_RADIUS;
		else				xy.y += REBAR_RADIUS;
		xyArrUpperSlabLower.SetAt(i, xy);
	}

	nSize	= xyArrUpperSlabLower.GetSize();
	if(nSize > 0)
	{
		if(bStt)
		{
			xy	= xyArrUpperSlabLower.GetAt(0);
			xy.x += REBAR_RADIUS;
			xyArrUpperSlabLower.SetAt(0, xy);
		}
		else
		{
			long nIdx = bBox? 0 : nSize -1;
			xy	= xyArrUpperSlabLower.GetAt(nIdx);
			xy.x -= REBAR_RADIUS ;
			xyArrUpperSlabLower.SetAt(nIdx, xy);
		}
	}

	if(bLowerSlab)
	{
		CDPointArray xyArrTmp;
		for (long ix =0; ix < xyArrUpperSlabUpper.GetSize(); ix++)
			xyArrTmp.Add(xyArrUpperSlabUpper.GetAt(ix));	
		
		xyArrUpperSlabUpper.RemoveAll();
		for (long ix =0; ix < xyArrUpperSlabLower.GetSize(); ix++)
			xyArrUpperSlabUpper.Add(xyArrUpperSlabLower.GetAt(ix));	

		xyArrUpperSlabLower.RemoveAll();
		for (long ix =0; ix < xyArrTmp.GetSize(); ix++)
			xyArrUpperSlabLower.Add(xyArrTmp.GetAt(ix));	
	}
}

// 벽체 예각부 권고안
void CRcBridgeRebar::setDataDefaultRebarAcuteAngle()
{
	long stt = 0; for(stt = 0; stt < 2; stt++)
	{
		BOOL bStt	= stt == iSTT;
		CFootingApp *pFooting	= bStt ? &m_footingStt : &m_footingEnd;

		long left = 0; for(left = 0; left < 2; left++)
		{
			//m_bIsAcuteAngle_OutWall[stt][left]	= FALSE;	// 시종점 좌우측 벽체 예각부 설치 여부
			long upper = 0; for(upper = 0; upper < 2; upper++)
			{
				m_dCoverAcuteAngle_OutWall[stt][left][upper]	= 200;	// 벽체 예각부 피복(시종점,좌우측,상하면)
			}
			m_dLenAcuteangle_OutWall[stt][left]			= 3000;	// 벽체 예각부 철근길이(시종점,좌우측)
			pFooting->m_dLenObtuseUpper[left]			= pFooting->GetWidth()/2;
			if(bStt)
				pFooting->m_dLenObtuseUpper[left]	= pFooting->m_dFWL + m_dWS - pFooting->m_dCoverUpper[0];
			else
				pFooting->m_dLenObtuseUpper[left]	= pFooting->m_dFWR + m_dWE - pFooting->m_dCoverUpper[0];
			m_dRange_AcuteAngle_OutWall[stt][left]		= 3000;
			pFooting->m_dRange_Obtuse_MainRebar[left]	= pFooting->m_dLenObtuseUpper[left];
			CPlaceRebarByBlock *pPlace	= &m_placeByBlock_AcuteAngle_MainRebar_OutWall[stt][left];	// 벽체 예각부 철근 배치 간격
			pPlace->m_dDia	= 22;

			pPlace	= &m_placeByBlock_AcuteAngle_SupportRebar_OutWall[stt][left];	// 벽체 예각부 철근 배치 간격
			pPlace->m_dDia	= 22;
		
			pPlace	= &pFooting->m_placeByBlock_Obtuse_MainRebar[left];
			pPlace->m_dDia	= 22;

			pPlace	= &pFooting->m_placeByBlock_Obtuse_SupportRebar[left];
			pPlace->m_dDia	= 22;
		}
	}
}

void CRcBridgeRebar::MakeRebarInfoCycle_ACuteAngle_OutWall(BOOL bInput, long nVertDir)
{
	BOOL bVertDir	= IsVertDir();
	if(nVertDir != 0)
		bVertDir	= nVertDir == -1 ? TRUE : FALSE;

	CRebarPlacing rbPlacing;
	CTwinVector tv;
	CTwinVectorArray tvArr, tvArrTmp;

	const double dSettleOfFooting	= 500;

	long stt	= 0;
	long left	= 0;
	for(stt = 0; stt < 2; stt++)
	{
		BOOL bStt	= stt == iSTT;
		CString sStt	= bStt ? "시점" : "종점";
		CFootingApp *pFooting	= bStt ? &m_footingStt : &m_footingEnd;
		
		for(left = 0; left < 2; left++)
		{
			BOOL bLeft	= left == iLEFT;
			CString sLeft	= bLeft ? "좌측" : "우측";

			long nFront	= bLeft ? (bStt ? iFRONT : iBACK) : (bStt ? iBACK : iFRONT);
			pFooting->m_bIsObtuse[nFront]	= m_bIsAcuteAngle_OutWall[stt][left];

			CRebarInfoCycle *pRC	= &m_rebarInfoCycle_AcuteAngle_OutWall[stt][left];
			pRC->InitInfoCycle();
			if(!m_bIsAcuteAngle_OutWall[stt][left]) continue;
			if(!IsOutWall(bStt)) continue;

			CDPoint vAng	= bVertDir ? CDPoint(0, 1) : GetAngleJijum(bStt ? 0 : m_nQtyJigan);
			CTwinVector tv;
			CFootingApp *pFooting = (bStt) ? &m_footingStt : &m_footingEnd;
			pFooting->m_tvArrFront.GetTvByInfo("기초하면", tv);

			CTwinVector tvRebar	= GetTvOffset_OutWall_AcuteAngle(bStt, bLeft, bVertDir);
			CDPoint xyStt		= CDPoint(tvRebar.m_v1.x, tv.m_v1.y + m_dCoverAcuteAngle_OutWall[stt][left][iLOWER]);	// 시작위치

			CPlaceRebarByBlock *pPlace	= &m_placeByBlock_AcuteAngle_MainRebar_OutWall[stt][left];
			double dLen	= m_dLenAcuteangle_OutWall[stt][left];
			double dDia		= pPlace->m_dDia;

			double dLenRound	= GetLenRebarAtEdge(dDia, TRUE, nVertDir, FALSE);

			// 공통속성
			pRC->m_nTypeRebar	= REBAR_TYPE_MAIN;
			pRC->m_nPosStt		= bStt ? REBARINFO_POS_STTWALL_OUTTER : REBARINFO_POS_STTWALL_OUTTER;
			pRC->m_nPosEnd		= pRC->m_nPosStt;
			pRC->m_Dia			= dDia;
			pRC->m_bExist		= TRUE;
			pRC->m_nRebarDan	= 0;
			

			// 시작위치는 항상 기초에서 시작한다.
			double sw		= bStt ? -1 : 1;
			pRC->m_nPosStt	= REBARINFO_POS_FOOTING_LOWER;
			pRC->m_xyStt	= CDPoint(xyStt.x + (dLenRound+dSettleOfFooting)*sw, xyStt.y);
			pRC->m_xyMid1	= CDPoint(pRC->m_xyStt.x + (dSettleOfFooting*sw*-1), pRC->m_xyStt.y);
			pRC->m_xyMid2	= CDPoint(pRC->m_xyMid1.x + (dLenRound*sw*-1), pRC->m_xyMid1.y + dLenRound);
			pRC->m_xyEnd	= CDPoint(pRC->m_xyMid2.x, pRC->m_xyMid2.y + dLen);
			pRC->m_xyCen	= CDPoint(pRC->m_xyMid1.x, pRC->m_xyMid2.y);
			pRC->m_R_Mid	= dLenRound;
			pRC->m_bRevArc	= bStt ? FALSE : TRUE;


			// szMark 설정
			pRC->m_szMark	= GetMarkRebarMain(MARK_ACUTE_OUTWALL, bInput, 0, FALSE, TRUE);

			// sDescription 설정
			pRC->m_sDescription.Format("%s벽체 %s예각부 주철근", sStt, sLeft);
		}
	}
}

CTwinVector CRcBridgeRebar::GetTvOffset_OutWall_AcuteAngle(BOOL bStt, BOOL bLeft, BOOL bVertDir)
{
	long stt	= bStt ? iSTT : iEND;
	long left	= bLeft ? iLEFT : iRIGHT;
	CFootingApp *pFooting	= bStt ? &m_footingStt : &m_footingEnd;

	double dCoverOld1	= m_dCoverWallOut[0];
	double dCoverOld2	= pFooting->m_dCoverLower[0];

	m_dCoverWallOut[0]	= m_dCoverAcuteAngle_OutWall[stt][left][iUPPER];
	pFooting->m_dCoverLower[0]	= m_dCoverAcuteAngle_OutWall[stt][left][iLOWER];

	CTwinVector tv	= GetTvOffset_OutWall(0, bStt, FALSE, bVertDir);
	m_dCoverWallOut[0]	= dCoverOld1;
	pFooting->m_dCoverLower[0]	= dCoverOld2;

	return tv;
}

void CRcBridgeRebar::GetXyRebarSupport_VertSection_OutWallAcuteAngle(CDPointArray &xyArr, BOOL bStt, BOOL bLeft, long nVertDir)
{
	xyArr.RemoveAll();

	long stt	= bStt ? iSTT : iEND;
	long left	= bLeft ? iLEFT : iRIGHT;

	if(!IsOutWall(bStt)) return;
	if(!m_bIsAcuteAngle_OutWall[stt][left]) return;

	m_placeByBlock_AcuteAngle_SupportRebar_OutWall[stt][left].m_xyArr	= m_placeByBlock_SupportRebar_OutWall[stt][iOUTTER][0].m_xyArr;
	m_placeByBlock_AcuteAngle_SupportRebar_OutWall[stt][left].m_nCountBlock	= m_placeByBlock_SupportRebar_OutWall[stt][iOUTTER][0].m_nCountBlock;

	GetXyRebarSupport_VertSection_OutWall(xyArr, bStt, FALSE, 0, nVertDir, TRUE, bLeft);

	// 철근 있는 부분에꺼만 골라냄
	CRebarInfoCycle *pRC	= &m_rebarInfoCycle_AcuteAngle_OutWall[stt][left];
	double dYTop	= pRC->m_xyEnd.y;
	double dYBottom	= pRC->m_xyMid2.y;
	CDPoint xy(0, 0);
	long i = 0; for(i = 0; i < xyArr.GetSize(); i++)
	{
		xy	= xyArr.GetAt(i);
		if(xy.y > dYTop || xy.y < dYBottom)
		{
			xyArr.RemoveAt(i);
			i--;
		}
	}
}

// 둔각부 주철근
void CRcBridgeRebar::GetTvRebarMain_Side_OutWall_Acute(CTwinVectorArray &tvArr, BOOL bStt, BOOL bLeft)
{
	long stt	= bStt ? iSTT : iEND;
	long left	= bLeft ? iLEFT : iRIGHT;
	tvArr.RemoveAll();
	if(!IsOutWall(bStt)) return;
	if(!m_bIsAcuteAngle_OutWall[left]) return;

	// convert : 외측벽체를 CWallApp에 맞게 제원을 설정해서 벽체를 만들어 냄.
	CWallApp wall;
	MakeWallByOutWall(wall, bStt, TRUE, FALSE, TRUE, bLeft);
	CTwinVectorArray tvArrJoint;
	wall.GetTvRebarMain_Side(tvArr, bStt ? TRUE : FALSE, 0, 0, 0, tvArrJoint, TRUE, !bStt);

	// 주철근에서 필요한 부분만 빼옴.
	CTwinVectorArray tvArrSide;
	wall.GetTvLeftSide(tvArrSide, TRUE, FALSE, FALSE, TRUE, 0, TRUE, FALSE, FALSE);
	CTwinVector tvLeft	= tvArrSide.GetTvByInfo("벽체좌측");
	CTwinVector tvRight	= tvArrSide.GetTvByInfo("벽체우측");
	double dXLeft	= tvLeft.m_v1.x;
	double dXRight	= tvRight.m_v1.x;
	double dRange	= m_dRange_AcuteAngle_OutWall[stt][left];

	CTwinVector tv;
	if(bStt)
	{
		if(bLeft)
		{
			dXRight -= dRange;
			long i = 0; for(i = 0; i < tvArr.GetSize(); i++)
			{
				tv	= tvArr.GetAt(i);
				if(dXRight > tv.m_v1.x)
				{
					tvArr.RemoveAt(i);
					i--;
				}
			}
		}
		else
		{
			dXLeft += dRange;
			long i = 0; for(i = 0; i < tvArr.GetSize(); i++)
			{
				tv	= tvArr.GetAt(i);
				if(dXLeft < tv.m_v1.x)
				{
					tvArr.RemoveAt(i);
					i--;
				}
			}
		}
	}
	else
	{
		if(bLeft)
		{
			dXLeft += dRange;
			long i = 0; for(i = 0; i < tvArr.GetSize(); i++)
			{
				tv	= tvArr.GetAt(i);
				if(dXLeft < tv.m_v1.x)
				{
					tvArr.RemoveAt(i);
					i--;
				}
			}
		}
		else
		{
			dXRight -= dRange;
			long i = 0; for(i = 0; i < tvArr.GetSize(); i++)
			{
				tv	= tvArr.GetAt(i);
				if(dXRight > tv.m_v1.x)
				{
					tvArr.RemoveAt(i);
					i--;
				}
			}
		}
	}
	

	AhTPADelete(&wall.m_pArrRCMain, (CRebarInfoCycle*)0);	
}

// 벽체 예각부 
void CRcBridgeRebar::GetTvRebarSupport_CrossSection_OutWall_Acute(CTwinVectorArray &tvArr, CTwinVectorArray &tvArrAngle, BOOL bStt, BOOL bLeft)
{
	long stt	= bStt ? iSTT : iEND;
	long left	= bLeft ? iLEFT : iRIGHT;
	tvArr.RemoveAll();
	if(!IsOutWall(bStt)) return;
	if(!m_bIsAcuteAngle_OutWall[left]) return;

	// convert : 외측벽체를 CWallApp에 맞게 제원을 설정해서 벽체를 만들어 냄.
	CWallApp wall;
	MakeWallByOutWall(wall, bStt, TRUE, FALSE, TRUE, bLeft);
	CTwinVectorArray tvArrAngleAdd;
	wall.GetTvRebarSupport_Side(tvArr, tvArrAngle, tvArrAngleAdd, bStt ? TRUE : FALSE, 0, !bStt);

	// 예각부 철근 구할땐 추가 된 철근에 대해서는 역활을 그냥 꺽이는 철근으로 이임한다.
	tvArrAngle.AddFromTvArray(tvArrAngleAdd);
	tvArrAngleAdd.RemoveAll();
	///////////////////////////////////////////////////////////////////////////////////

	// 배력근중 필요한 부분만 빼옴.
	CTwinVectorArray tvArrSide;
	wall.GetTvLeftSide(tvArrSide, TRUE, FALSE, FALSE, TRUE, 0, TRUE, FALSE, FALSE);
	CTwinVector tvLeft	= tvArrSide.GetTvByInfo("벽체좌측");
	CTwinVector tvRight	= tvArrSide.GetTvByInfo("벽체우측");
	double dXLeft	= tvLeft.m_v1.x;
	double dXRight	= tvRight.m_v1.x;
	double dRange	= m_dRange_AcuteAngle_OutWall[stt][left];

	CTwinVector *pTv	= NULL;
	CDPoint xyMatch(0, 0);
	if(bStt)
	{
		if(bLeft)
		{
			dXRight -= dRange;
			long i = 0; for(i = 0; i < tvArr.GetSize(); i++)
			{
				pTv	= &tvArr.GetAt(i);
				pTv->m_v1.x	= dXRight;
			}

			
			for(i = 0; i < tvArrAngle.GetSize(); i++)
			{
				pTv	= &tvArrAngle.GetAt(i);
				GetXyMatchLineAndLine(pTv->m_v1, pTv->GetXyDir(), CDPoint(dXRight, 0), CDPoint(0, 1), xyMatch);
				pTv->m_v1	= xyMatch;
			}
		}
		else
		{
			dXLeft += dRange;
			long i = 0; for(i = 0; i < tvArr.GetSize(); i++)
			{
				pTv	= &tvArr.GetAt(i);
				pTv->m_v2.x	= dXLeft;
			}

			
			for(i = 0; i < tvArrAngle.GetSize(); i++)
			{
				pTv	= &tvArrAngle.GetAt(i);
				GetXyMatchLineAndLine(pTv->m_v1, pTv->GetXyDir(), CDPoint(dXLeft, 0), CDPoint(0, 1), xyMatch);
				pTv->m_v2	= xyMatch;
			}
		}
	}
	else
	{
		if(bLeft)
		{
			dXLeft += dRange;
			long i = 0; for(i = 0; i < tvArr.GetSize(); i++)
			{
				pTv	= &tvArr.GetAt(i);
				pTv->m_v2.x	= dXLeft;
			}

			for(i = 0; i < tvArrAngle.GetSize(); i++)
			{
				pTv	= &tvArrAngle.GetAt(i);
				GetXyMatchLineAndLine(pTv->m_v1, pTv->GetXyDir(), CDPoint(dXLeft, 0), CDPoint(0, 1), xyMatch);
				pTv->m_v2	= xyMatch;
			}
		}
		else
		{
			dXRight -= dRange;
			long i = 0; for(i = 0; i < tvArr.GetSize(); i++)
			{
				pTv	= &tvArr.GetAt(i);
				pTv->m_v1.x	= dXRight;
			}

			for(i = 0; i < tvArrAngle.GetSize(); i++)
			{
				pTv	= &tvArrAngle.GetAt(i);
				GetXyMatchLineAndLine(pTv->m_v1, pTv->GetXyDir(), CDPoint(dXRight, 0), CDPoint(0, 1), xyMatch);
				pTv->m_v1	= xyMatch;
			}
		}
	}

	AhTPADelete(&wall.m_pArrRCMain, (CRebarInfoCycle*)0);


	// 주철근에 포함되는 것들만 남김
	double dMid	= wall.GetCrossSectionCenterOfRoad(TRUE);
	CRebarInfoCycle *pRC	= &m_rebarInfoCycle_AcuteAngle_OutWall[stt][left];
	long i = 0; for(i = 0; i < tvArr.GetSize(); i++)
	{
		pTv	= &tvArr.GetAt(i);
		GetXyMatchLineAndLine(pTv->m_v1, pTv->GetXyDir(), CDPoint(dMid, 0), CDPoint(0, 1), xyMatch);
		if(xyMatch.y > pRC->m_xyEnd.y)
		{
			tvArr.RemoveAt(i);
			i--;
		}
	}

	// 당분간 꺽이는 철근은 무조건 없음
	tvArrAngle.RemoveAll();
}

// 벽체 예각부 주철근/배력철근
void CRcBridgeRebar::SetDataDefaultRebarJewonOutWall_AcuteAngle()
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();

	long stt	= 0;
	long left	= 0;
	CHgBaseConcStd baseConc;

	// 주철근
	for(stt = 0; stt < 2; stt++)
	{
		BOOL bStt	= stt == iSTT;
		CString sStt	= bStt ? "시점" : "종점";

		for(left = 0; left < 2; left++)
		{
			BOOL bLeft	= left == iLEFT;
			CString sLeft	= bLeft ? "좌측" : "우측";

			if(!m_bIsAcuteAngle_OutWall[stt][left]) continue;

			double dCover		= m_dCoverAcuteAngle_OutWall[stt][left][iUPPER];
			double dRebarSpace	= GetCtcRebarMain(FALSE)/2;

			// 주철근
			CRebarInfoCycle *pRC	= &m_rebarInfoCycle_AcuteAngle_OutWall[stt][left];
			CTwinVectorArray tvArrRebarMain;
			GetTvRebarMain_Side_OutWall_Acute(tvArrRebarMain, bStt, bLeft);
			
			long nSize	= tvArrRebarMain.GetSize();

			CRebar *pRB	= new CRebar;
			pRB->m_Fy			= bLsd? GetValueFy(bStt? ePartOutWallStt : ePartOutWallEnd) : m_pARcBridgeDataStd->m_Fy;
			pRB->m_sDescription	= pRC->m_sDescription;
			pRB->m_sMark		= pRC->m_szMark;
			pRB->m_dDia			= pRC->m_Dia;
			pRB->m_dLengthMax_A	= pRC->GetLengthEnd();
			pRB->m_dLengthMin_A	= pRB->m_dLengthMin_A;
			pRB->m_dLengthMax_B	= pRC->GetLengthMid();
			pRB->m_dLengthMax_C	= fabs(pRC->m_xyStt.x-pRC->m_xyMid1.x);
			pRB->m_dLengthMin_C	= pRB->m_dLengthMax_C;
			pRB->m_nTypeRebar	= 5;
			pRB->m_R			= pRC->m_R_Mid;
			pRB->m_bMainRebar	= FALSE;
			pRB->m_nEa			= nSize;
			baseConc.OptimizationRebar(pRB);	// 철근 최적화
			m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
			pRB->m_dRateAdd	= MAKE_RATE;
			AddOrDeleteRebarInList(&m_pArrRebarMain, pRB);
		}
	}
}

void CRcBridgeRebar::SetDataDefaultRebarJewon_Slab_ObtuseSupportRebar(BOOL bUpperSlab)
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();

	BOOL bBox = IsBoxType();
	BOOL bLowSlabType = bBox && !bUpperSlab? TRUE : FALSE;
	long stt(0), left(0);
	long upper(0);
	double dCover(0), dRebarSpace(0);

	GetMarkRebarMain(MARK_OBTUSE_CROSS, FALSE, 0, TRUE, TRUE, "", 1);

	for(stt = 0; stt < 2; stt++)
	{
		BOOL bStt		= stt == iSTT;
		CString sStt	= bStt ? "시점" : "종점";

		for(left = 0; left < 2; left++)
		{
			BOOL bLeft	= left == iLEFT;
			CString sLeft	= bLeft ? "좌측" : "우측";

			if(bBox && !bUpperSlab && !m_bIsObtuseAngle_LowerSlab[stt][left])
				continue;
			else if(!m_bIsObtuseAngle_UpperSlab[stt][left]) 
				continue;

			CTwinVectorArray tvArrSupportRebar;
			CTwinVectorArrayArray pTvArrMainRebar;

			CDPointArray xyArrUpperSlabUpper, xyArrUpperSlabLower, xyArrUpperSide;
			GetXyRebarMain_VertSection_SlabObtuse(xyArrUpperSlabUpper, xyArrUpperSide, xyArrUpperSlabLower, bStt, bLeft, bLowSlabType);

			BOOL bSttOwner	= bStt;
			BOOL bLeftOwner	= bLeft;
			if(m_pARcBridgeDataStd->m_nTypeProcess != TYPE_PROCESS_NORMAL)
			{
				GetOwnerRebarSupportObtuseAngle(bStt, bLeft, bSttOwner, bLeftOwner); 
			}

			// 선형방향
			for(upper = 0; upper < 2; upper++)
			{
				BOOL bUpper	= upper == iUPPER;

				CString sDescription	= _T(""), sSlab = _T("");
				
				if(IsBoxType())
				{
					sSlab.Format(bUpperSlab? _T("상부슬래브") : _T("하부슬래브"));
					sDescription.Format("%s 둔각부(%s%s) 배력철근(%s)", sSlab, sStt, sLeft, bUpper ? "상면" : "하면");
				}
				else
				{
					sDescription.Format("둔각부(%s%s) 배력철근(%s)", sStt, sLeft, bUpper ? "상면" : "하면");
				}

				// 주인철근이 있는 경우 주인철근에 개수만 더함
				if(bStt != bSttOwner || bLeft != bLeftOwner)
				{
					sStt	= bSttOwner ? "시점" : "종점";
					sLeft	= bLeftOwner ? "좌측" : "우측";
					sDescription.Format("둔각부(%s%s) 배력철근(%s)", sStt, sLeft, bUpper ? "상면" : "하면");

					long i = 0; for(i = 0; i < m_pArrRebarSupport.GetSize(); i++)
					{
						CRebar *pRB	= m_pArrRebarSupport.GetAt(i);
						if(pRB->m_sDescription == sDescription)
						{
							long nEa	= bUpper ? xyArrUpperSide.GetSize() + xyArrUpperSlabUpper.GetSize() : xyArrUpperSlabLower.GetSize();
							pRB->m_nEa += nEa;
						}
					}

					continue;
				}


				GetTvRebarMain_Plane_Slab_Obtuse(&pTvArrMainRebar, tvArrSupportRebar, bStt, bLeft, bUpper, bLowSlabType);
				CPlaceRebarByBlock *pPlace	= bLowSlabType? &m_placeByBlock_ObtuseAngle_Support_LowerSlab[stt][left][upper] : &m_placeByBlock_ObtuseAngle_Support_UpperSlab[stt][left][upper];
				if(!pPlace) continue;
// 				dRebarSpace	= pPlace->GetCTC();
// 				dCover		= m_dCoverObtuseAngle_UpperSlab[stt][left][upper];

				// 횡방향(배력근)
				// 횡방향으로 뻗는 철근은 외측벽에에 있는 점철근 개수도 포함 시켜 준다.
				
				dCover		= m_dCoverObtuseAngle_UpperSlab[stt][left][upper];
				dRebarSpace	= pPlace->GetCTC();
				
				long nTypeRebar	= US_REBAR_OB_SL;
				if(bUpper)
				{
					nTypeRebar = bStt ? (bLeft ? US_REBAR_OB_SL : US_REBAR_OB_SR) 
										: (bLeft ? US_REBAR_OB_EL : US_REBAR_OB_ER);
				}
				else
				{
					nTypeRebar = bStt ? (bLeft ? US_REBAR_OB_SLL : US_REBAR_OB_SRL) 
										: (bLeft ? US_REBAR_OB_ELL : US_REBAR_OB_ERL);
				}
				CRebar *pRB	= new CRebar;
				pRB->m_Fy	= bLsd? GetValueFy(bStt? ePartOutWallStt : ePartOutWallEnd) : m_pARcBridgeDataStd->m_Fy;
				if(IsBoxType())
					pRB->m_sDescription.Format("%s 둔각부(%s%s) 배력철근(%s)", sSlab, sStt, sLeft, bUpper ? "상면" : "하면");
				else
					pRB->m_sDescription.Format("둔각부(%s%s) 배력철근(%s)", sStt, sLeft, bUpper ? "상면" : "하면");
				pRB->m_sMark		= GetMarkRebarSupport(nTypeRebar, FALSE, TRUE, FALSE, "");
				pRB->m_dDia			= pPlace->m_dDia;
				pRB->m_dLengthMax_A	= tvArrSupportRebar.GetLengthMax();
				pRB->m_dLengthMin_A	= 0;
				pRB->m_nTypeRebar	= 1;
				pRB->m_bMainRebar	= FALSE;
				pRB->m_nEa			= bUpper ? xyArrUpperSide.GetSize() + xyArrUpperSlabUpper.GetSize() : xyArrUpperSlabLower.GetSize();
				m_Util.SetLengthRebar(pRB, (m_nSelectJointUpperRange == 0)? JOINT_TENS_UPPER_B:JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
				pRB->m_dRateAdd	= MAKE_RATE;
				AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
			}

			AhTPADelete(&pTvArrMainRebar, (CTwinVectorArray*)0);
		}
	}
}

void CRcBridgeRebar::SetDataDefaultRebarJewonOutWall_AcuteAngleSupportRebar()
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();
	const double dMulti = bLsd? 10 : 1;

	long stt	= 0;
	long left	= 0;
	CHgBaseConcStd baseConc;

	// 배력근
	for(stt = 0; stt < 2; stt++)
	{
		BOOL bStt	= stt == iSTT;
		CString sStt	= bStt ? "시점" : "종점";

		for(left = 0; left < 2; left++)
		{
			BOOL bLeft	= left == iLEFT;
			CString sLeft	= bLeft ? "좌측" : "우측";

			if(!m_bIsAcuteAngle_OutWall[stt][left]) continue;

			double dCover	= m_dCoverAcuteAngle_OutWall[stt][left][iUPPER];
// 			double dRebarSpace	= GetCtcRebarMain(FALSE)/2;

			// 배력근
			double dRebarSpace	= GetCTCRebarSupport_OutWall(bStt, FALSE, 0, TRUE);
			CPlaceRebarByBlock *pPlace	= &m_placeByBlock_AcuteAngle_SupportRebar_OutWall[stt][left];
			CTwinVectorArray tvArrRebarSupport, tvArrRebarSupportAngle;
			GetTvRebarSupport_CrossSection_OutWall_Acute(tvArrRebarSupport, tvArrRebarSupportAngle, bStt, bLeft);

			
			long nTypeRebar	= bStt ? (bLeft ? SW_REBAR_AC_L : SW_REBAR_AC_R) 
									: (bLeft ? EW_REBAR_AC_L : EW_REBAR_AC_R);
			long nSize	= tvArrRebarSupport.GetSize();
			if(nSize > 0)
			{
				CRebar *pRB	= new CRebar;
				pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
				pRB->m_sDescription.Format("%s벽체 %s예각부 배력철근1", sStt, sLeft);
				pRB->m_sMark		= GetMarkRebarSupport(nTypeRebar, FALSE, TRUE, FALSE, "");
				pRB->m_dDia			= pPlace->m_dDia;
				pRB->m_dLengthMax_A	= tvArrRebarSupport.GetLengthMax();
				pRB->m_dLengthMin_A	= pRB->m_dLengthMin_A;
				pRB->m_nTypeRebar	= 1;
				pRB->m_bMainRebar	= TRUE;
				pRB->m_nEa			= nSize;
				baseConc.OptimizationRebar(pRB);	// 철근 최적화
				SetRebarLsdOptionOutWall(pRB->m_pOptionLsd, bStt, TRUE, FALSE, 0, 0);
				if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
				m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
				pRB->m_dRateAdd	= MAKE_RATE;
				AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
			}

			// 배력근2
			nSize	= tvArrRebarSupportAngle.GetSize();
			if(nSize > 0)
			{
				CRebar *pRB	= new CRebar;
				pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
				pRB->m_sDescription.Format("%s벽체 %s예각부 배력근2", sStt, sLeft);
				pRB->m_sMark		= GetMarkRebarSupport(nTypeRebar, FALSE, TRUE, FALSE, "") + "-1";
				pRB->m_dDia			= pPlace->m_dDia;
				pRB->m_dLengthMax_A	= tvArrRebarSupportAngle.GetLengthMax();
				pRB->m_dLengthMin_A	= pRB->m_dLengthMin_A;
				pRB->m_nTypeRebar	= 1;
				pRB->m_bMainRebar	= TRUE;
				pRB->m_nEa			= nSize;
				baseConc.OptimizationRebar(pRB);	// 철근 최적화
				SetRebarLsdOptionOutWall(pRB->m_pOptionLsd, bStt, TRUE, FALSE, 0, 0);
				if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
				m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
				pRB->m_dRateAdd	= MAKE_RATE;
				AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
			}
		}
	}
}

// 철근 지름이나 이음의 길이를 직접 가져와도 되지만, 만해하나라도 배열이 원하는 만큼 덜 생성 됐을 경우나
// 이상한 값이 들어간 경우를 대비해서 이 함수를 통해서 직접 이음길이를 가져 오도록 한다.
// bAccumulation : index까지의 이음길이를 축적해서 가져옴.
double CRcBridgeRebar::GetDistMainRebarRib(long nCycle, long nDan, BOOL bUpper, long nIdx, BOOL bAccumulation)
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return 0;

	double dDist	= 0;
	long nSize		= 0;
	long upper		= bUpper ? iUPPER : iLOWER;
	
	if(m_nTypeBridge != BRIDGE_TYPE_ARCH) return 0;

	CDoubleArray *pDArr	= &m_dArrDistRib[nCycle][upper][nDan];
	nSize	= pDArr->GetSize();
	if(nIdx == -1) nIdx = nSize-1;
	if(nIdx < 0) return dDist;

	if(bAccumulation)
	{
		long i = 0; for(i = 0; i <= nIdx; i++)
		{
			if(i >= nSize) break;
			dDist	+= pDArr->GetAt(i);
		}
	}
	else
	{
		if(nIdx < nSize)
			dDist	= pDArr->GetAt(nIdx);
		else
			dDist	= 0;
	}

	return dDist;
}

double CRcBridgeRebar::GetDiaMainRebarRib(long nCycle, long nDan, BOOL bUpper, long nIdx)
{
	double dDia	= 0;
	long nSize	= 0;
	long upper	= bUpper ? iUPPER : iLOWER;
	if(nDan >= m_nCountDanMainRebarRib[nCycle][upper]) return dDia;	

//	nSize	= m_dArrDiaRib[nCycle][upper][nDan].GetSize();
	if(nCycle == 0) 
		nSize	= m_nCountJointMainRebar_ArchRib_Cycle1[upper][nDan] + 1;
	else if(nCycle == 1) 
		nSize	= m_nCountJointMainRebar_ArchRib_Cycle2[upper][nDan] + 1;

	if(nIdx == -1) nIdx = nSize-1;
	if(nIdx < 0 || nIdx > nSize-1) return 0;

	nSize = MIN(m_dArrExistRib[nCycle][upper][nDan].GetSize(), m_dArrDiaRib[nCycle][upper][nDan].GetSize());

	if(nIdx < nSize)
	{	
		double dExist = m_dArrExistRib[nCycle][upper][nDan].GetAt(nIdx);
		dDia = (dExist>0) ? m_dArrDiaRib[nCycle][upper][nDan].GetAt(nIdx) : 0;
	}
	else 
	{
		dDia	= 0;
	}

	return dDia;
}

long CRcBridgeRebar::GetDanMainRebarRib(long nCycle, BOOL bUpper)
{
	long upper	= bUpper ? iUPPER : iLOWER;
	
	long nDan	= m_nCountDanMainRebarRib[nCycle][upper];
	if(nDan < 1 || nDan > MAX_REBAR_DAN)
		nDan	= 1;

	return nDan;
}

BOOL CRcBridgeRebar::IsExistMainRebarRib(long nCycle, long nDan, BOOL bUpper, long nIdx)
{
	if((nCycle == 0 || nCycle == 2) && nDan == 0) return TRUE;
	BOOL bExist	= FALSE;
	long nSize	= 0;
	long upper	= bUpper ? iUPPER : iLOWER;

	// 다른거는 2단은 2사이클을 참고해서 만들지만, 리브는 모두 각각입력을 받으므로
	// 실제 자신의 변수를 사용해서 존재유무를 가려낸다.
	
	// 4cycle은 입력받지 않으므로 2cycle껄로 사용
	if(nCycle == 3) 
		nCycle = 1;

	nSize	= m_dArrExistRib[nCycle][upper][nDan].GetSize();
	if(nIdx == -1) nIdx = nSize-1;
	if(nIdx < 0 || nIdx > nSize-1) return FALSE;

	if(nIdx < nSize)
		bExist	= BOOL(m_dArrExistRib[nCycle][upper][nDan].GetAt(nIdx));
	else 
		bExist	= FALSE;

	return bExist;
}


// 입력된 정보로 리브 주철근 생성
// 아치굔는 사교가 없으나, 함수 일관성을 위해 nVertDir 인수 만들어 놈
// CRebarInfoCycle m_pArrRCMainRib[MAX_REBAR_CYCLE][2][MAX_REBAR_DAN];	// 리브 1~4cycle, 상하면
void CRcBridgeRebar::MakeRebarInfoCycle_ArchRib(long nCycle, long nDan, BOOL bUpper, BOOL bInput, long nVertDir)
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return;
	if(nDan == -1) nDan = MAX_REBAR_DAN-1;
	if(nDan < 0 || nDan > MAX_REBAR_DAN-1) return;
	long upper	= bUpper ? iUPPER : iLOWER;

	BOOL bVertDir	= FALSE;

	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC	= &m_pArrRCMainRib[nCycle][upper][nDan];
	AhTPADelete(pArrRC, (CRebarInfoCycle*)0);
	if(m_nTypeBridge != BRIDGE_TYPE_ARCH) return;
	
	double dSettleOfFooting	 = 500;

	long nCountDan	= GetDanMainRebarRib(nCycle, bUpper);
	if(nCountDan <= nDan) return;

	// 마크 초기화
	if(bInput || (nDan==0 && bUpper && nCycle==0))
	{
		GetMarkRebarMain(bUpper ? MARK_ARCHRIB_UPPER : MARK_ARCHRIB_LOWER, bInput, nCycle, TRUE, TRUE, _T(""), nDan);
	}

	// 철근 시점 기초 하면철근에서 종점기초 하면 철근까지..
	CParabola pbRebar;
	double dCover	= bUpper ? -m_dCoverRib[upper][nDan] : m_dCoverRib[upper][nDan];
	m_pbRib[upper].GetOffsetParabola(pbRebar, dCover);
	CTwinVector tvLowerStt	= m_footingStt.GetTvOffset_Front(0, FALSE, bVertDir);
	CTwinVector tvLowerEnd	= m_footingEnd.GetTvOffset_Front(0, FALSE, bVertDir);
	CDPoint xyMatchStt	= pbRebar.GetXyMatchXyAndAngle(tvLowerStt.m_v1, CDPoint(1, 0));
	CDPoint xyMatchEnd	= pbRebar.GetXyMatchXyAndAngle(tvLowerEnd.m_v1, CDPoint(1, 0));
	pbRebar.m_dDistStt	= pbRebar.GetDistByXPos(xyMatchStt.x);
	pbRebar.m_dDistEnd	= pbRebar.GetDistByXPos(xyMatchEnd.x);

	CBasicConcInfo concInfo;
	CHgBaseConcStd baseConc;

	double dDistStt		= pbRebar.m_dDistStt;
	double dDistNext	= dDistStt;
	
	double dLenJoint	= 0;
	
	long nCountJoint	= nCycle == 0 || nCycle == 2 ? m_nCountJointMainRebar_ArchRib_Cycle1[upper][nDan] : m_nCountJointMainRebar_ArchRib_Cycle2[upper][nDan];

	for(long joint = 0; joint < nCountJoint+1; joint++)
	{
		double dist = GetDistMainRebarRib(nCycle, nDan, bUpper, joint, FALSE);
		double dLenJointLast	= 0;
		dLenJointLast	= dLenJoint;
		if(Compare(dist, 0.0, "=") && joint<nCountJoint) continue;

		// 철근 지름과 가장자리철근 모따기밑 라운드 크기 ////////////
		double dDia		= GetDiaMainRebarRib(nCycle, nDan, bUpper, joint);
		BOOL bExist		= IsExistMainRebarRib(nCycle, nDan, bUpper, joint);
		double dDiaNext	= GetDiaMainRebarRib(nCycle, nDan, bUpper, joint+1);
		double dLenRound	= (joint == 0) ? GetLenRebarAtEdge(dDia, TRUE) : GetLenRebarAtEdge(dDia, FALSE);
		/////////////////////////////////////////////////////////////////

		pArrRC->Add(new CRebarInfoCycle);
		CRebarInfoCycle *pRC	= pArrRC->GetAt(pArrRC->GetSize()-1);

		// 공통속성
		pRC->m_szMark		= bExist ? GetMarkRebarMain(bUpper ? MARK_ARCHRIB_UPPER : MARK_ARCHRIB_LOWER, bInput, nCycle, FALSE, TRUE, _T(""), nDan) : "";
		pRC->m_nTypeRebar	= REBAR_TYPE_MAIN;
		pRC->m_nPosEnd		= bUpper ? REBARINFO_POS_ARCHRIB_UPPER : REBARINFO_POS_ARCHRIB_LOWER;
		pRC->m_Dia			= dDia;
		pRC->m_bExist		= bExist;
		pRC->m_nRebarDan	= 0;
		
		// 시작위치는 항상 기초에서 시작한다.
		if(joint == 0)
		{
			pRC->m_nPosStt	= REBARINFO_POS_FOOTING_LOWER;
			dLenJoint		= GetValueJoint(pRC, dDiaNext);
			pRC->m_Dia		= dDia;
			
			CDPoint xyStt	= pbRebar.GetXyByDist(dDistStt);
			CDPoint xyDir	= pbRebar.GetXyDirTanByDist(dDistStt);
			GetXyTanOfArc(xyStt, CDPoint(1, 0), xyDir, dLenRound, pRC->m_xyCen, pRC->m_xyMid1, pRC->m_xyMid2);
			CDPoint xyMatch	= pbRebar.GetXyMatchXyAndAngle(pRC->m_xyMid2, CDPoint(1, 0));
			CDPoint xyMove	= xyMatch - pRC->m_xyMid2;
			pRC->m_xyMid1 += xyMove;
			pRC->m_xyMid2 += xyMove;
			pRC->m_xyCen += xyMove;
			pRC->m_xyStt	= pRC->m_xyMid1 + CDPoint(dSettleOfFooting, 0);
			pRC->m_R_Mid	= dLenRound;
			pRC->m_bRevArc	= TRUE;
			dDistNext		= pbRebar.GetDistByXPos(pRC->m_xyMid2.x);
			if(joint < nCountJoint)
			{
				dDistNext		= pbRebar.GetDistByDistToLen(dDistNext, dist + dLenJoint/2);
				pRC->m_xyEnd	= pbRebar.GetXyByDist(dDistNext);

				dDistNext		= pbRebar.GetDistByDistToLen(dDistNext, -dLenJoint);
			}
			else
			{
				CDPoint xyDir		= ToDPointFrDegree(pbRebar.GetXyDirTanByDist(pbRebar.m_dDistEnd).GetAngleDegree()+180);
				CDPoint xyEnd		= pbRebar.GetXyByDist(pbRebar.m_dDistEnd);
				GetXyTanOfArc(xyEnd, xyDir, CDPoint(-1, 0), dLenRound, pRC->m_xyCenExt, pRC->m_xyEnd, pRC->m_xyMidExt);
				CDPoint xyMatch		= pbRebar.GetXyMatchXyAndAngle(pRC->m_xyEnd, CDPoint(1, 0));
				CDPoint xyMove		= xyMatch - pRC->m_xyEnd;
				pRC->m_xyEnd		= pRC->m_xyEnd + xyMove;
				pRC->m_xyMidExt		= pRC->m_xyMidExt + xyMove;
				pRC->m_R_MidExt		= dLenRound;
				pRC->m_bRevArcExt	= TRUE;
				pRC->m_xyEndExt		= pRC->m_xyMidExt+ CDPoint(-dSettleOfFooting, 0);
				pRC->m_bUseMidExt	= TRUE;
				pRC->m_bUseEndExt	= TRUE;

				break;
			}
		}
		else
		{
			if(joint < nCountJoint)
			{
				pRC->m_nPosStt	= pRC->m_nPosEnd;
				dLenJoint		= GetValueJoint(pRC, dDiaNext);
				pRC->m_Dia		= dDia;

				pRC->m_xyStt	= pbRebar.GetXyByDist(dDistNext);
				dDistNext		= pbRebar.GetDistByDistToLen(dDistNext, dist + dLenJointLast/2 + dLenJoint/2);
				pRC->m_xyMid1	= pbRebar.GetXyByDist(dDistNext);
				pRC->m_xyMid2	= pRC->m_xyMid1;
				pRC->m_xyEnd	= pRC->m_xyMid1;
				pRC->m_xyCen	= pRC->m_xyMid1;
				pRC->m_R_Mid	= 0;

				
				dDistNext		= pbRebar.GetDistByDistToLen(dDistNext, -dLenJoint);
			}
			else
			{
				pRC->m_xyStt		= pbRebar.GetXyByDist(dDistNext);
				CDPoint xyDir		= ToDPointFrDegree(pbRebar.GetXyDirTanByDist(pbRebar.m_dDistEnd).GetAngleDegree()+180);
				CDPoint xyEnd		= pbRebar.GetXyByDist(pbRebar.m_dDistEnd);
				GetXyTanOfArc(xyEnd, xyDir, CDPoint(-1, 0), dLenRound, pRC->m_xyCen, pRC->m_xyMid1, pRC->m_xyMid2);
				CDPoint xyMatch		= pbRebar.GetXyMatchXyAndAngle(pRC->m_xyMid1, CDPoint(1, 0));
				CDPoint xyMove		= xyMatch - pRC->m_xyMid1;
				pRC->m_xyMid1		= pRC->m_xyMid1 + xyMove;
				pRC->m_xyMid2		= pRC->m_xyMid2 + xyMove;
				pRC->m_xyCen		= pRC->m_xyCen + xyMove;
				pRC->m_R_Mid		= dLenRound;
				pRC->m_bRevArcExt	= TRUE;
				pRC->m_xyEnd		= pRC->m_xyMid2 + CDPoint(-dSettleOfFooting, 0);
			}
		}
	}


	// Not Exist인 rc 제거
	/*
	if(!bInput)
		RemoveNotExistRebarInfoCycle(pArrRC);
		*/

	// sDescription 설정
	SetStringDescriptionRebarInfoCycle_ArchRib(pArrRC, nCycle, bUpper, nDan);
}

void CRcBridgeRebar::GetXyRebarSupport_VertSection_ArchRib(CDPointArray &xyArrL, CDPointArray &xyArrDirL, CDPointArray &xyArrR, CDPointArray &xyArrDirR, BOOL bUpper, long nDan, long nVertDir, BOOL bApplyDir)
{
	xyArrL.RemoveAll();
	xyArrDirL.RemoveAll();
	xyArrR.RemoveAll();
	xyArrDirR.RemoveAll();
	if(m_nTypeBridge != BRIDGE_TYPE_ARCH) return;

	if(nDan == -1) nDan = MAX_REBAR_DAN-1;
	if(nDan < 0 || nDan > MAX_REBAR_DAN-1) return;

	long upper	= bUpper ? iUPPER : iLOWER;
	CRebarPlacing rb;

	CParabola pbRebar, pbRebarL;
	GetRebarRib(pbRebar, TRUE, 0);
	GetRebarRib(pbRebarL, FALSE, 0);
	
	double dCoverDiff	= m_dCoverRib[upper][nDan] - m_dCoverRib[upper][0];
	dCoverDiff = -dCoverDiff;
	
	long left = 0; for(left = 0; left < 2; left++)
	{
		BOOL bLeft	= left == iLEFT;
		double sw	= bLeft ? -1 : 1;
		CDPointArray *pXyArr	= bLeft ? &xyArrL : &xyArrR;
		CDPointArray *pXyArrDir	= bLeft ? &xyArrDirL : &xyArrDirR;

		// 2단, 3단은 입력을 받지 않고 1단의 3개까지 같고 다음부터는 1단 2개에 하나씩 2,3단에 들어간다.
		CPlaceRebarByBlock *pPlace	= &m_placeByBlock_SupportRebar_ArchRib[iUPPER][0][left];
		CDPointArray xyArrOffsetInfo;
		xyArrOffsetInfo	= pPlace->m_xyArr;

		// 주철근에 따라 직거리 사거리로 배근하는데, 실제 그려야 되는게 입력된거랑 다르면 데이타를 수정해줌 //////
		/* 아치교는  사거리 없으므로 이 코드 일단 무시
		BOOL bVertDirMainRebar	= IsVertDir();
		BOOL bVertDir	= nVertDir == -1 ? TRUE : (nVertDir == 0 ? bVertDirMainRebar : FALSE);
		if(bVertDirMainRebar != bVertDir && nVertDir != 0)
		{
			double dAngCur		= GetAngleJijum(0, bVertDirMainRebar).GetAngleDegree();
			double dAngApply	= bVertDir ? 90 : GetAngleJijum(0).GetAngleDegree();
			ApplyAngleToOffsetInfo(xyArrOffsetInfo, dAngCur, dAngApply);
		}
		*/
		//////////////////////////////////////////////////////////////////////////////////////////////////////////

		// 상부슬래브 상,하면 피복
		CDPoint xyStt	= pbRebar.m_xyCrown;
				
		// 상부슬래브는 선형의 영향을 받으므로 속도저하가 생길 가능성이 있더라도 일일이 계산 해줘야 됨.
		double dRadRebar	= bApplyDir ? -REBAR_RADIUS : 0;
		
		CDPoint xy		= xyStt;
		double xDis		= pbRebar.GetDistByXPos(xy.x);
		CDPoint xyDir	= pbRebar.GetXyDirPerByDist(xDis, !bUpper);
		CDPoint xyR(0, 0);


		if(bLeft)
		{
			pXyArr->Add(xy+xyDir*(dRadRebar+dCoverDiff));
			pXyArrDir->Add(xyDir);
		}
		
		long nSize	= pPlace->m_xyArr.GetSize();

		for(long block = 0; block < pPlace->m_nCountBlock; block++)
		{
			if(nSize-1 < block) break;
			xyR	= pPlace->m_xyArr.GetAt(block);

			long i = 0; for(i = 0; i < xyR.x; i++)
			{
				xDis	= pbRebar.GetDistByDistToLen(xDis, xyR.y * sw);
				xyDir	= pbRebar.GetXyDirPerByDist(xDis, !bUpper);
				xy		= pbRebar.GetXyByDist(xDis) + xyDir * (dRadRebar + dCoverDiff);
				pXyArr->Add(xy);
				pXyArrDir->Add(xyDir);
			}
		}

		// 하면
		if(!bUpper)
		{
			nSize	= m_pArrRCMainRib[0][iLOWER][0].GetSize();
			CRebarInfoCycle *pRC	= m_pArrRCMainRib[0][iLOWER][0].GetAt(0);
			double xDisFir	= pbRebarL.GetDistByXPos(pRC->m_xyMid2.x);
			pRC	= m_pArrRCMainRib[0][iLOWER][0].GetAt(nSize-1);
			double xDisLast	= pbRebarL.GetDistByXPos(pRC->m_bUseEndExt ? pRC->m_xyEnd.x : pRC->m_xyMid1.x);
			
			long i = 0; for(i = 0; i < pXyArr->GetSize(); i++)
			{
				xy		= pXyArr->GetAt(i);
				xyDir	= pXyArrDir->GetAt(i);

				xy		= pbRebarL.GetXyMatchXyAndAngle(xy, xyDir);
				double dist	= 0;
				dist	= pbRebarL.GetDistByXPos(xy.x);
				if(dist > xDisFir && dist < xDisLast)
				{
					if(bApplyDir)
						xy	= xy + xyDir * (dRadRebar + dCoverDiff);
					
					pXyArr->SetAt(i, xy);
				}
				else
				{
					pXyArr->RemoveAt(i);
					pXyArrDir->RemoveAt(i);
					i--;
				}
			}
		}

		// 2단부터는 실제로 주철근이 배근된 곳에만 배력철근이 배근된다. 
		if(nDan > 0)
		{
//			long nCountOffset	= 2;	// 2단 배근시 1단철근 몇개마다 하나씩 배근할지?
			// 2단, 3단은 입력을 받지 않음
			long nCountSame	= 0;

			CDPointArray xyArrTmp, xyArrDirTmp;
			xyArrTmp	= *pXyArr;
			xyArrDirTmp	= *pXyArrDir;
			if(!bLeft)
			{
				if(xyArrTmp.GetSize() > 0 && xyArrDirTmp.GetSize() > 0)
				{
					xyArrTmp.RemoveAt(0);
					xyArrDirTmp.RemoveAt(0);
				}
			}

			long nSize		= xyArrTmp.GetSize();
			long nSizeDir	= xyArrDirTmp.GetSize();
			pXyArr->RemoveAll();
			pXyArrDir->RemoveAll();
			if(nSize > nCountSame)
			{
				long i = 0; for(i = 0; i < nCountSame; i++)
				{
					pXyArr->Add(xyArrTmp.GetAt(i));
					if(nSizeDir > i)
						pXyArrDir->Add(xyArrDirTmp.GetAt(i));
				}

				long nCountOffset	= 2;	// 2단 배근시 1단철근 몇개마다 하나씩 배근할지?
				for(i = nCountSame; i < nSize-(nCountOffset-1); i+=nCountOffset)
				{
					pXyArr->Add(xyArrTmp.GetAt(i));
					if(nSizeDir > i)
						pXyArrDir->Add(xyArrDirTmp.GetAt(i));
				}
			}

			CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = &m_pArrRCMainRib[0][upper][nDan];
			CHgBaseConcStd baseConcStd;
			baseConcStd.GetXyRangeOfRebarInfoCycleArray(*pXyArr, pArrRC, TRUE, *pXyArrDir);
		}
	}
}

void CRcBridgeRebar::GetRebarRib(CParabola &pb, BOOL bUpper, long nDan)
{
	long upper	= bUpper ? iUPPER : iLOWER;
	double dCover	= bUpper ? -m_dCoverRib[iUPPER][nDan] : m_dCoverRib[iLOWER][nDan];
	m_pbRib[upper].GetOffsetParabola(pb, dCover);
}

void CRcBridgeRebar::GetTvRebarShear_VertSection_ArchRib(CTwinVectorArray &tvArrL, CTwinVectorArray &tvArrR, long nVertDir)
{
	tvArrL.RemoveAll();
	tvArrR.RemoveAll();
	if(m_nTypeBridge != BRIDGE_TYPE_ARCH) return;

	CParabola pbRebar, pbRebarL;
	GetRebarRib(pbRebar, TRUE, 0);
	GetRebarRib(pbRebarL, FALSE, 0);
	CTwinVectorArray tvArrLower;
	AddFromParabola(tvArrLower, pbRebarL);

	long left = 0; for(left = 0; left < 2; left++)
	{
		BOOL bLeft	= left == iLEFT;
		double sw	= bLeft ? -1 : 1;
		CTwinVectorArray *pTvArr	= bLeft ? &tvArrL : &tvArrR;

		CDPoint xyStt	= pbRebar.m_xyCrown;

		// 전단철근 배치함.
		CRebarPlacing rb;
		CDPointArray xyArr, xyArrOffsetInfo;
		CPlaceRebarByBlock *pPlace	= &m_placeByBlock_ShearRebar_ArchRib[left];
		xyArrOffsetInfo	= pPlace->m_xyArr;


		// 주철근에 따라 직거리 사거리로 배근하는데, 실제 그려야 되는게 입력된거랑 다르면 데이타를 수정해줌 //////
		/*
		BOOL bVertDirMainRebar	= IsVertDir();
		BOOL bVertDir	= nVertDir == -1 ? TRUE : (nVertDir == 0 ? bVertDirMainRebar : FALSE);
		if(bVertDirMainRebar != bVertDir && nVertDir != 0)
		{
			double dAngCur		= GetAngleJijum(0, bVertDirMainRebar).GetAngleDegree();
			double dAngApply	= bVertDir ? 90 : GetAngleJijum(0).GetAngleDegree();
			ApplyAngleToOffsetInfo(xyArrOffsetInfo, dAngCur, dAngApply);
		}
		*/
		//////////////////////////////////////////////////////////////////////////////////////////////////////////


		// 상부슬래브는 선형의 영향을 받으므로 속도저하가 생길 가능성이 있더라도 일일이 계산 해줘야 됨.
		CDPoint xyR(0, 0);
		CDPoint xy(0, 0), xyMatch(0, 0), xyDir(0, 0);
		CTwinVector tv;
		double dist	= 0;
		long nSize		= xyArrOffsetInfo.GetSize();
		if(nSize < 0) return;

		CDPointArray xyArrMatch;
		xy		= xyStt;
		dist	= pbRebar.GetDistByXPos(xyStt.x);

		// 좌측으로 가는것만 시작위치에 배근함.
		if(bLeft)
		{
			tv.m_v1	= xyStt;
			tv.m_v2	= pbRebarL.GetXyMatchXyAndAngle(xy, CDPoint(0, -1));
			pTvArr->Add(tv);
		}

		for(long block = 0; block < pPlace->m_nCountBlock; block++)
		{
			if(nSize-1 < block) break;
			xyR	= xyArrOffsetInfo.GetAt(block);

			long i = 0; for(i = 0; i < xyR.x; i++)
			{
				dist	= pbRebar.GetDistByDistToLen(dist, xyR.y*sw);
				tv.m_v1	= pbRebar.GetXyByDist(dist);
				xyDir	= pbRebar.GetXyDirPerByDist(dist, TRUE);
				tv.m_v2	= pbRebarL.GetXyMatchXyAndAngle(tv.m_v1, xyDir);
				pTvArr->Add(tv);
			}
		}
	}
}

// 상하면 동시에 권고안
void CRcBridgeRebar::SetDataDefaultRebarSupport_VertSection_ArchRib()
{
	CParabola pbRebarU, pbRebarL;
	GetRebarRib(pbRebarU, TRUE, 0);
	GetRebarRib(pbRebarL, FALSE, 0);
	long nSize	= m_pArrRCMainRib[0][iUPPER][0].GetSize();
	if(nSize == 0) return;
	long left = 0; for(left = 0; left < 2; left++)
	{
		BOOL bLeft	= left == iLEFT;
		CPlaceRebarByBlock *pPlaceU	= &m_placeByBlock_SupportRebar_ArchRib[iUPPER][0][left];
		CPlaceRebarByBlock *pPlaceL	= &m_placeByBlock_SupportRebar_ArchRib[iLOWER][0][left];
		pPlaceU->m_xyArr.RemoveAll();
		pPlaceU->m_nCountBlock	= 0;
		pPlaceL->m_xyArr.RemoveAll();
		pPlaceL->m_nCountBlock	= 0;

		if(m_nTypeBridge != BRIDGE_TYPE_ARCH) continue;
	
		// 상면
		CRebarInfoCycle *pRC	= m_pArrRCMainRib[0][iUPPER][0].GetAt(0);
		double xDisFir	= pbRebarU.GetDistByXPos(pRC->m_xyMid2.x);
		pRC	= m_pArrRCMainRib[0][iUPPER][0].GetAt(nSize-1);
		double xDisLast	= pbRebarU.GetDistByXPos(pRC->m_bUseEndExt ? pRC->m_xyEnd.x : pRC->m_xyMid1.x);
		double dLenRib	= bLeft ? pbRebarU.GetLenByDistToDist(xDisFir, 0) : pbRebarU.GetLenByDistToDist(0, xDisLast);
		double dCTC		= GetCTCRebarSupport_Slab(TRUE, TRUE, 0, TRUE);
		long nCount		= (long)(dLenRib / dCTC);
		double dRemain	= dLenRib - (dCTC * nCount);
		if(dRemain < MIN_LEN_BLOCK)
		{
			dRemain += dCTC/2;
			nCount --;
		}				
		pPlaceU->m_xyArr.Add(CDPoint(nCount, dCTC));
		pPlaceU->m_xyArr.Add(CDPoint(1, dRemain));
		pPlaceU->m_nCountBlock	= pPlaceU->m_xyArr.GetSize();
	}

	// 하면은 따로 입력받지 않고 상면에서 뻗어서 사용함.
	/*
	CDPointArray xyArrL;
	CDPointArray xyArrU, xyArrDir;
	GetXyRebarSupport_VertSection_ArchRib(xyArrU, xyArrDir, TRUE, 0, 0, TRUE);
	nSize		= m_pArrRCMainRib[0][iLOWER][0].GetSize();
	pRC			= m_pArrRCMainRib[0][iLOWER][0].GetAt(0);
	xDisFir		= pbRebarL.GetDistByXPos(pRC->m_xyMid2.x);
	pRC			= m_pArrRCMainRib[0][iLOWER][0].GetAt(nSize-1);
	xDisLast	= pbRebarL.GetDistByXPos(pRC->m_bUseEndExt ? pRC->m_xyEnd.x : pRC->m_xyMid1.x);

	CDPoint vAng	= CDPoint(0, 0);
	CDPoint xyMatch(0, 0), xy(0, 0);
	double xDisMatch	= 0;
	xyArrL.Add(pbRebarL.GetXyByDist(xDisFir));
	long i = 0; for(i = 0; i < xyArrU.GetSize(); i++)
	{
		xy		= xyArrU.GetAt(i);
		vAng	= ToDPointFrDegree(xyArrDir.GetAt(i).GetAngleDegree() + 180);
		xyMatch	= pbRebarL.GetXyMatchXyAndAngle(xy, vAng);
		xDisMatch	= pbRebarL.GetDistByXPos(xyMatch.x);

		if(xDisMatch > xDisFir && xDisMatch < xDisLast)
			xyArrL.Add(xyMatch);
	}
	xyArrL.Add(pbRebarL.GetXyByDist(xDisLast));

	// 위치 구했으면 offset 정보로 변환
	CDoubleArray dArrDist;
	double dist	= 0;
	for(i = 0; i < xyArrL.GetSize()-1; i++)
	{
		dist	= pbRebarL.GetLenByDistToDist(pbRebarL.GetDistByXPos(xyArrL[i].x), pbRebarL.GetDistByXPos(xyArrL[i+1].x));
		dArrDist.Add(dist);
	}
	CRebarPlacing rb;
	rb.ConvertOffsetDoubleArrayToOffsetInfo(dArrDist, pPlaceL->m_xyArr);
	pPlaceL->m_nCountBlock	= pPlaceL->m_xyArr.GetSize();
	*/
}

void CRcBridgeRebar::SetDataDefaultRebarShear_VertSection_ArchRib()
{
	CDPointArray xyArr[2], xyArrDir[2];
	GetXyRebarSupport_VertSection_ArchRib(xyArr[iLEFT], xyArrDir[iLEFT], xyArr[iRIGHT], xyArrDir[iRIGHT], TRUE, 0, 0, FALSE);

	CParabola pbRebarU;
	GetRebarRib(pbRebarU, TRUE, 0);
	CParabola pbRebar;
	GetRebarRib(pbRebar, FALSE, 0);
	long nSize	= m_pArrRCMainRib[0][iLOWER][0].GetSize();
	if(nSize == 0) return;
	CRebarInfoCycle *pRC1	= m_pArrRCMainRib[0][iLOWER][0].GetAt(0);
	CRebarInfoCycle *pRC2	= m_pArrRCMainRib[0][iLOWER][0].GetAt(nSize-1);
	double xDisFir	= pbRebar.GetDistByXPos(pRC1->m_xyMid2.x);
	double xDisLast	= pbRebar.GetDistByXPos(pRC2->m_bUseEndExt ? pRC2->m_xyEnd.x : pRC2->m_xyMid1.x);

	long left = 0; for(left = 0; left < 2; left++)
	{
		CPlaceRebarByBlock *pPlace	= &m_placeByBlock_ShearRebar_ArchRib[left];
		pPlace->m_xyArr.RemoveAll();
		pPlace->m_nCountBlock	= 0;
		if(m_nTypeBridge != BRIDGE_TYPE_ARCH) continue;;

		CDPoint xy(0, 0), xyDir(0, 0), xyMatch(0, 0);
		double dist(0);
		long i = 0; for(i = 0; i < xyArr[left].GetSize(); i++)
		{
			xy		= xyArr[left].GetAt(i);
			xyDir	= pbRebarU.GetXyDirPerByDist(pbRebarU.GetDistByXPos(xy.x), TRUE);
			xyMatch	= pbRebar.GetXyMatchXyAndAngle(xy, ToDPointFrDegree(xyDir.GetAngleDegree()+180));
			dist	= pbRebar.GetDistByXPos(xyMatch.x);

			if(dist < xDisFir || dist > xDisLast)
			{
				xyArr[left].RemoveAt(i);
				i--;
			}
		}

		// 전단철근은 상면철근 두개당 하나씩 들어감.
		CDPointArray xyArrTmp;
		for(i = 0; i < xyArr[left].GetSize()-1; i+=2)
		{
			xyArrTmp.Add(xyArr[left].GetAt(i));
		}

		// 전단철근을 offset정보로 바꿈.
		CDoubleArray dArrDist;
		for(i = 0; i < xyArrTmp.GetSize()-1; i++)
		{
			dist	= pbRebarU.GetLenByDistToDist(pbRebarU.GetDistByXPos(xyArrTmp[i].x), pbRebarU.GetDistByXPos(xyArrTmp[i+1].x));
			dArrDist.Add(dist);
		}
		CRebarPlacing rb;
		rb.ConvertOffsetDoubleArrayToOffsetInfo(dArrDist, pPlace->m_xyArr, 0);
		pPlace->m_nCountBlock	= pPlace->m_xyArr.GetSize();
	}
}

// 아치리브 주철근 권고안
void CRcBridgeRebar::SetDataDefaultRebarJewonArchRib()
{
	if(m_nTypeBridge != BRIDGE_TYPE_ARCH) return;

	CHgBaseConcStd baseConc;
	double dCover	= 0;
	double dRebarSpace	= 0;

	long cycle = 0; for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
	{
		long upper = 0; for(upper = 0; upper < 2; upper++)
		{
			BOOL bUpper	= upper == iUPPER;

			long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
			{
				dCover	= m_dCoverRib[upper][dan];
				dRebarSpace	= m_dCTC_MainRebar/2;

				long nSize	= m_pArrRCMainRib[cycle][upper][dan].GetSize();
				for(long rc = 0; rc < nSize; rc++)
				{
					CRebarInfoCycle *pRC	= GetRebarInfoCycleArchRib(cycle, dan, bUpper, rc);
					if(!pRC) continue;
					if(!pRC->m_bExist) continue;
					CTwinVectorArray tvArr, tvArrJoint;
					GetTvRebarMain_Plane_ArchRib(tvArr, tvArrJoint, cycle, bUpper, dan, rc, 0);
					if(tvArr.GetSize() == 0) continue;

					CRebar *pRB	= new CRebar;
					pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
					pRB->m_sDescription	= pRC->m_sDescription;
					pRB->m_sMark		= pRC->m_szMark;
					pRB->m_dDia			= pRC->m_Dia;
					if(nSize == 1)	// 이음없이 하나로 연결된 철근
					{
						pRB->m_nTypeRebar		= 100;
						pRB->m_dLengthMax_A		= pRC->GetLengthStt();
						pRB->m_dLengthMax_B		= pRC->GetLengthMid();
						pRB->m_dLengthMax_C		= tvArr.GetAt(0).GetLength();
						pRB->m_dLengthMax_D		= pRC->GetLengthMidExt();
						pRB->m_dLengthMax_R1	= pRC->m_R_Mid;
						pRB->m_dLengthMax_R2	= pRC->m_R_MidExt;
					}
					else if(pRC->m_nPosStt != pRC->m_nPosEnd)	// 기초에서 나오는거
					{
						pRB->m_nTypeRebar		= 99;
						pRB->m_dLengthMax_A		= rc == 0 ? pRC->GetLengthStt() : pRC->GetLengthEnd();
						pRB->m_dLengthMax_B		= pRC->GetLengthMid(TRUE);
						pRB->m_dLengthMax_C		= tvArr.GetAt(0).GetLength();
						pRB->m_dLengthMax_R1	= pRC->m_R_Mid;
					}
					else	// 구부러진 1자 
					{
						pRB->m_nTypeRebar	= 73;
						pRB->m_dLengthMax_A	= tvArr.GetAt(0).GetLength();
					}
					pRB->m_bMainRebar	= TRUE;
					baseConc.OptimizationRebar(pRB);	// 철근 최적화
					m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
					pRB->m_dRateAdd	= MAKE_RATE;
					pRB->m_nEa			= tvArr.GetSize();
					AddOrDeleteRebarInList(&m_pArrRebarMain, pRB);
				}
			}
		}
	}
}

// 아치리브 주철근
void CRcBridgeRebar::GetTvRebarMain_Plane_ArchRib(CTwinVectorArray &tvArr, CTwinVectorArray &tvArrJoint, long nCycle, BOOL bUpper, long nDan, long nIdx, long nDrawLeft)
{
	tvArr.RemoveAll();
	tvArrJoint.RemoveAll();

	CLineInfo *pLine	= GetLineBase();
	CDoubleArray dArrDist;
	GetDistArrayMainRebarArchRib(dArrDist, nCycle, nDrawLeft);
	dArrDist.Sort(FALSE);

	CParabola pbRebar;
	GetRebarRib(pbRebar, bUpper, nDan);

	CRebarInfoCycle *pRC	= GetRebarInfoCycleArchRib(nCycle, nDan, bUpper, nIdx);
	if(!pRC) return;
	if(!pRC->m_bExist) return;
	CRebarInfoCycle *pRCNext	= GetRebarInfoCycleArchRib(nCycle, nDan, bUpper, nIdx+1);


	double xDisFir	= pRC->m_nPosStt == REBARINFO_POS_FOOTING_LOWER ? pbRebar.GetDistByXPos(pRC->m_xyMid2.x) : pbRebar.GetDistByXPos(pRC->m_xyStt.x);
	double xDisLast	= pRC->m_nPosStt == REBARINFO_POS_FOOTING_LOWER ? (pRC->m_nPosEnd == REBARINFO_POS_FOOTING_LOWER ? pbRebar.GetDistByXPos(pRC->m_xyEnd.x) : pbRebar.GetDistByXPos(pRC->m_xyEnd.x)) : pbRebar.GetDistByXPos(pRC->m_xyMid1.x);
	double dXFir	= xDisFir > 0 ? pbRebar.m_xyCrown.x + pbRebar.GetLenByDistToDist(0, xDisFir) : pbRebar.m_xyCrown.x - pbRebar.GetLenByDistToDist(xDisFir, 0);
	double dXLast	= xDisLast > 0 ? pbRebar.m_xyCrown.x + pbRebar.GetLenByDistToDist(0, xDisLast) : pbRebar.m_xyCrown.x - pbRebar.GetLenByDistToDist(xDisLast, 0);
	dXFir -= pLine->m_dStationBp;
	dXLast -= pLine->m_dStationBp;
	
	BOOL bJoint	= FALSE;
//	double xDisFirNext	= 0;
	double dXFirNext	= 0;
	if(pRCNext)
	{
		if(pRCNext->m_bExist)
		{
			double xDisFirNext	= 0;
			xDisFirNext		= pbRebar.GetDistByXPos(pRCNext->m_xyStt.x);
			dXFirNext	= xDisFirNext > 0 ? pbRebar.m_xyCrown.x + pbRebar.GetLenByDistToDist(0, xDisFirNext) : pbRebar.m_xyCrown.x - pbRebar.GetLenByDistToDist(xDisFirNext, 0);
			dXFirNext -= pLine->m_dStationBp;

			if(dXFirNext < dXLast)
				bJoint	= TRUE;
		}
	}


	CTwinVector tv;
//	double dY	= 0;
	long i = 0; for(i = 0; i < dArrDist.GetSize(); i++)
	{
		double dY	= 0;
		dY	= dArrDist.GetAt(i);
		tv.m_v1	= CVector(dXFir, -dY, 0);
		tv.m_v2	= CVector(dXLast, -dY, 0);
		tvArr.Add(tv);

		if(bJoint)
		{
			tv.m_v1	= CVector(dXFirNext, -dY + m_dGapJoint, 0);
			tv.m_v2	= CVector(dXLast, -dY + m_dGapJoint, 0);
			tvArrJoint.Add(tv);
		}
	}
}

// 아치리브 주철근 dist
void CRcBridgeRebar::GetDistArrayMainRebarArchRib(CDoubleArray &dArrDist, long nCycle, long nDrawLeft)
{
	dArrDist.RemoveAll();


	double dCover	= GetCoverSideArchRib(0);
	double dWidth	= GetWidthArchRib(0) - dCover * 2;
	double dCTC		= GetCtcRebarMain(FALSE)/2;
	long nCount		= (long)(dWidth / dCTC);
	double dRemain	= dWidth - (nCount * dCTC);
	if(dRemain/2 < MIN_LEN_BLOCK)
	{
		dRemain += dCTC;
		nCount --;
	}


	CDoubleArray dArrDistTmp;
	double dXLeft	= -GetWidthArchRib(-1) + dCover;
	dArrDistTmp.Add(dXLeft);
	dXLeft += dRemain/2;
	dArrDistTmp.Add(dXLeft);
	long i = 0; for(i = 0; i < nCount; i++)
	{
		dXLeft += dCTC;
		dArrDistTmp.Add(dXLeft);
	}
	dXLeft += dRemain/2;
	dArrDistTmp.Add(dXLeft);


	// 해당 사이클의 것만 골라냄
	if(nCycle != -1)
	{
		double dMid	= GetMidCrossSection();
		long nCountCycleMainRebar	= GetCountCycleMainRebar();
		
		for(i = nCycle; i <= dArrDistTmp.GetSize()-(nCountCycleMainRebar-1); i+=nCountCycleMainRebar)
		{
			double dist	= 0;
			dist	= dArrDistTmp.GetAt(i);
			if(nDrawLeft != 0)
			{
				if(nDrawLeft == -1 && dist > dMid) continue;
				if(nDrawLeft == 1 && dist < dMid) continue;
			}
			dArrDist.Add(dArrDistTmp.GetAt(i));
		}
	}
	else
		dArrDist	= dArrDistTmp;
}

CRebarInfoCycle* CRcBridgeRebar::GetRebarInfoCycleArchRib(long nCycle, long nDan, BOOL bUpper, long nIdx)
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return FALSE;
	if(nDan == -1) nDan = MAX_REBAR_DAN-1;
	if(nDan < 0 || nDan > MAX_REBAR_DAN-1) return FALSE;

	// 필요한 RebarInfoCycle 배열을 찾음
	long upper	= bUpper ? iUPPER : iLOWER;
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = &m_pArrRCMainRib[nCycle][upper][nDan];
	if(!pArrRC) return NULL;

	long nSize	= pArrRC->GetSize();
	if(nIdx == -1) nIdx = nSize-1;
	if(nIdx >= nSize) return NULL;
	if(nIdx < 0) return NULL;

	return pArrRC->GetAt(nIdx);
}

// 아치리브 배력근
void CRcBridgeRebar::GetTvRebarSupport_Plane_ArchRib(CTwinVectorArray &tvArr, BOOL bUpper, long nDan, long nDrawLeft)
{
	tvArr.RemoveAll();
	if(m_nTypeBridge != BRIDGE_TYPE_ARCH) return;

	CLineInfo *pLine	= GetLineBase();
	CParabola pbRebar;
	GetRebarRib(pbRebar, bUpper, nDan);
	CDPointArray xyArrLeft, xyArrRight;
	CDPointArray xyArrDirLeft, xyArrDirRight;
	GetXyRebarSupport_VertSection_ArchRib(xyArrLeft, xyArrDirLeft, xyArrRight, xyArrDirRight, bUpper, nDan, 0, FALSE);

	// 배력근 위치
	CDoubleArray dArrX;
	CDPoint xy(0, 0);
	double dDist	= 0;
	long i = 0; for(i = 0; i < xyArrLeft.GetSize(); i++)
	{
		xy		= xyArrLeft.GetAt(i);
		dDist	= pbRebar.GetDistByXPos(xy.x);
		xy.x	= dDist > 0 ? pbRebar.m_xyCrown.x + pbRebar.GetLenByDistToDist(0, dDist) : pbRebar.m_xyCrown.x - pbRebar.GetLenByDistToDist(dDist, 0);
		xy.x -= pLine->m_dStationBp;
		dArrX.Add(xy.x);
	}

	for(i = 0; i < xyArrRight.GetSize(); i++)
	{
		xy		= xyArrRight.GetAt(i);
		dDist	= pbRebar.GetDistByXPos(xy.x);
		xy.x	= dDist > 0 ? pbRebar.m_xyCrown.x + pbRebar.GetLenByDistToDist(0, dDist) : pbRebar.m_xyCrown.x - pbRebar.GetLenByDistToDist(dDist, 0);
		xy.x -= pLine->m_dStationBp;
		dArrX.Add(xy.x);
	}

	dArrX.Sort(TRUE);


	// 배력근 배근
	CTwinVector tv;
	double dCover	= GetCoverSideArchRib(nDan);
	double dYStt	= GetWidthArchRib(1) * -1 + dCover;
	double dYEnd	= GetWidthArchRib(-1) - dCover;
	if(nDrawLeft == -1)
	{
		dYStt	= (dYEnd+dYStt)/2;
	}
	else if(nDrawLeft == 1)
	{
		dYEnd	= (dYEnd+dYStt)/2;
	}
	tv.m_v1.y	= dYStt;
	tv.m_v2.y	= dYEnd;
	for(i = 0; i < dArrX.GetSize(); i++)
	{
		tv.m_v1.x	= dArrX.GetAt(i);
		tv.m_v2.x	= tv.m_v1.x;
		tvArr.Add(tv);
	}
}

CDPoint CRcBridgeRebar::GetInfoMainRebar_ArchRib(BOOL bUpper, long nSpan, long nCycle, long nDan, long nLeft, BOOL bCrown)
{
	CDPoint xyInfo	= CDPoint(0, 0);
	double dDia	= 0;
	double dCTC	= GetCtcRebarMain(FALSE);
	if(nSpan == 0 && nLeft == -1)
	{
		xyInfo.x	= GetDiaMainRebarRib(nCycle, nDan, bUpper, 0);
		xyInfo.y	= dCTC;
		return xyInfo;
	}
	else if(nSpan == m_nQtyJigan-1 && nLeft == 1)
	{
		xyInfo.x	= GetDiaMainRebarRib(nCycle, nDan, bUpper, -1);
		xyInfo.y	= dCTC;
		return xyInfo;
	}
	
	// 걸려야 되는 위치
	// 상면은 각 지점에 걸리면 되고, 하면은 지간의 중앙sta에 걸리면 된다.
	double dStaCheck	= 0;	// 철근이 걸려야 되는 sta
	
	dStaCheck = GetStationRibBySpan(nSpan, nLeft+1, bCrown);	//-1,0,1 => 0,1,2
	
	// 걸리는 철근을 찾는다.
	long upper	= bUpper ? iUPPER : iLOWER;
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC	= &m_pArrRCMainRib[nCycle][upper][nDan];
	long nCount	= pArrRC->GetSize();
	for(long rc = 0; rc < nCount; rc++)
	{
		double dXLeft	= 0;
		double dXRight	= 0;
		CRebarInfoCycle *pRC	= pArrRC->GetAt(rc);
		dXLeft	= pRC->m_xyStt.x;
		dXRight	= pRC->m_nPosStt == pRC->m_nPosEnd ? pRC->m_xyMid1.x : pRC->m_xyEnd.x;
		if(pRC->m_bUseEndExt)
			dXRight	= pRC->m_xyEndExt.x;
		if(dXRight < dXLeft)
			GetSwap(dXRight, dXLeft);
		
		if(dXLeft <= dStaCheck && dXRight >= dStaCheck && pRC->m_bExist)
		{
			dDia	= pRC->m_Dia;
			break;
		}
	}
	
	xyInfo.x	= dDia;
	xyInfo.y	= Compare(dDia, 0.0, "=") ? 0 : dCTC;
	return xyInfo;
}

CDPoint CRcBridgeRebar::GetInfoSupportRebar_ArchRib(BOOL bUpper, long nSpan, long nDan, long nLeft, BOOL bCrown)
{
	CDPoint xyInfo	= CDPoint(0, 0);
	double dDia	= 0;
	double dCTC	= 0;
	double dStaCheck	= 0;	// 철근이 걸려야 되는 sta
	double dDistCheck	= 0;	// 아치 크라운을 중심으로 좌우거리
	dStaCheck = GetStationRibBySpan(nSpan, nLeft+1, bCrown);	//-1,0,1 => 0,1,2

	CParabola pParab;
	GetRebarRib(pParab, bUpper, nDan);
	long upper	= bUpper ? iUPPER : iLOWER;
	long iLeft = (dStaCheck < pParab.m_xyCrown.x)? 0 : 1;
	double dDistLeft	= 0;
	double dDistRight	= 0;
	CDPointArray xyArr;
	CDPoint xyC = CDPoint(0,0);

	// 간격은 상면과 하면을 같이 쓴다.
	dDia = m_placeByBlock_SupportRebar_ArchRib[upper][nDan][iLeft].m_dDia;
	dDistCheck = fabs(pParab.m_xyCrown.x - dStaCheck);

	long nCount	= 0;
	if(nDan == 0)
	{
		xyArr = m_placeByBlock_SupportRebar_ArchRib[iUPPER][nDan][iLeft].m_xyArr;
		nCount	= xyArr.GetSize();
		if(nCount == 0) return xyInfo;

		dDistRight = pParab.GetDistByXPos(pParab.m_xyCrown.x);
		dDistLeft	= dDistRight;
		for(long rc = 0; rc < nCount; rc++)
		{
			xyC = xyArr.GetAt(rc);
			dDistRight = pParab.GetDistByDistToLen(dDistRight, xyC.x * xyC.y);

			if((dDistLeft <= dDistCheck && dDistRight > dDistCheck))
			{
				if(xyC.x > 1)
				{
					dCTC = xyC.y;
					break;
				}
				else
				{
					if(nLeft == 1)
					{
						long i=0; for(i=1; i<rc; i++)
						{
							if(rc-i < 0) continue;
							xyC = xyArr.GetAt(rc-i);
							if(xyC.x > 1) break;
						}
					}
					else
					{
						long i=0; for(i=1; i<nCount-rc; i++)
						{
							xyC = xyArr.GetAt(rc+i);
							if(xyC.x > 1) break;
						}
					}
					
					dCTC = xyC.y;
					break;
				}
			}
			else if(rc == nCount-1 && dDistCheck > dDistRight)
			{
				if(xyC.x > 1)
				{
					dCTC = xyC.y;
					break;
				}
				else
				{
					long i=0; for(i=1; i<nCount; i++)
					{
						if(rc-i < 0) continue;
						xyC = xyArr.GetAt(rc-i);
						if(xyC.x > 1) break;
					}
					dCTC = xyC.y;
					break;
				}
			}
			
			dDistLeft = dDistRight;
		}
	}
	else
	{
		CDPointArray xyArrL, xyArrR, xyArrD1, xyArrD2;
		GetXyRebarSupport_VertSection_ArchRib(xyArrL, xyArrD1, xyArrR, xyArrD2, bUpper, nDan, 1);
		CDPoint xyTemp1(0, 0), xyTemp2(0, 0);
		xyArr = (iLeft==0)?  xyArrL : xyArrR;

		nCount = xyArr.GetSize();
		if(nCount == 0) return xyInfo;
		
		if(nLeft == -1) dStaCheck += 300;
		else if(nLeft == 1) dStaCheck -= 300;

		dDistCheck = fabs(pParab.m_xyCrown.x - dStaCheck);
		
		for(long rc = 0; rc < nCount-1; rc++)
		{
			xyTemp1 = xyArr.GetAt(rc);
			xyTemp2 = xyArr.GetAt(rc+1);
			dDistLeft = fabs(pParab.GetDistByXPos(xyTemp1.x));
			dDistRight	= fabs(pParab.GetDistByXPos(xyTemp2.x));
			
			if((dDistLeft < dDistCheck && dDistRight >= dDistCheck))
			{
				dCTC = pParab.GetLenByDistToDist(dDistRight, dDistLeft);
				if(dCTC > 600) dDia = 0;
				break; 
			}
			else dCTC = 0;
		}
	}
	if(dCTC == 0) dDia = 0;
	xyInfo.x	= dDia;
	xyInfo.y	= Compare(dDia, 0.0, "=") ? 0 : dCTC;
	return xyInfo;
}

CDPoint CRcBridgeRebar::GetInfoShearRebar_ArchRib(long nSpan, long nLeft, BOOL bCrown)
{
	CDPoint xyInfo	= CDPoint(0, 0);
	double dDia	= 0;
	double dCTC	= 0;
	double dStaCheck	= 0;	// 철근이 걸려야 되는 sta
	dStaCheck	= GetStationRibBySpan(nSpan, nLeft+1, bCrown);	//-1,0,1 => 0,1,2
	double dDistLeft	= 0;
	double dDistRight	= 0;

	CParabola pParab;
	GetRebarRib(pParab, TRUE, 0);
	long iLeft = (dStaCheck < pParab.m_xyCrown.x)? 0 : 1;

	CDPoint xyC;
	CDPointArray xyArr;
	dDia = m_RebarShearDetail_ArchRib.m_dDia;
	xyArr = m_placeByBlock_ShearRebar_ArchRib[iLeft].m_xyArr;

	double dDistCheck = fabs(pParab.m_xyCrown.x - dStaCheck);
	
	long nCount	= xyArr.GetSize();
	if(nCount == 0) return xyInfo;
	
	for(long rc = 0; rc < nCount; rc++)
	{
		xyC = xyArr.GetAt(rc);
		dDistRight = pParab.GetDistByDistToLen(dDistRight, xyC.x * xyC.y);
		if((dDistLeft <= dDistCheck && dDistRight >= dDistCheck))
		{
			if(xyC.x > 1)
			{
				dCTC = xyC.y;
				break;
			}
			else
			{
				long i=0; for(i=1; i<nCount-rc; i++)
				{
					if(nLeft == 1)
					{
						if(rc-i < 0) continue;
						xyC = xyArr.GetAt(rc-i);
					}
					else 
					{
						if(rc+i >= 0) continue;
						xyC = xyArr.GetAt(rc+i);
					}
					
					if(xyC.x > 1) break;
				}
				dCTC = xyC.y;
				break;
			}
		}
		else if(rc == nCount-1 && dDistCheck > dDistRight)
		{
			if(xyC.x > 1)
			{
				dCTC = xyC.y;
				break;
			}
			else
			{
				long i=0; for(i=1; i<nCount; i++)
				{
					if(rc-i < 0) continue;
					xyC = xyArr.GetAt(rc-i);
					if(xyC.x > 1) break;
				}
				dCTC = xyC.y;
				break;
			}
		}
		
		dDistLeft = dDistRight;
	}
	
	xyInfo.x	= dDia;
	xyInfo.y	= Compare(dDia, 0.0, "=") ? 0 : dCTC;
	return xyInfo;
}

// CDPoint CRcBridgeRebar::GetXyRebarMain_ArchRib(BOOL bUpper, BOOL bFirst)
// {
// 	CRebarInfoCycle *pRCFir		= GetRebarInfoCycleArchRib(0, 0, bUpper, 0);	
// 	CRebarInfoCycle *pRCLast	= GetRebarInfoCycleArchRib(0, 0, bUpper, -1);
// 	if(!pRCFir || !pRCLast) return CDPoint(0, 0);
// 
// 	CDPoint xyFir	= pRCFir->m_xyMid2;
// 	CDPoint xyLast	= pRCLast->m_xyMid1;
// 	if(pRCLast->m_nPosStt == REBARINFO_POS_FOOTING_LOWER)
// 		xyLast	= pRCLast->m_xyMidExt;
// 
// 	return bFirst ? xyFir : xyLast;
// }

// 횡단면도 배력근 상하면
// nDrawLeft 수평에서 우측이 평면의 -1(좌측)이 됨
CTwinVector CRcBridgeRebar::GetTvOffset_ArchRib(double dXDisOfUpper, BOOL bUpper, long nDan, long nDrawLeft)
{
	// 해당 위치에 주철근이 없으면 배력근도 리턴 안함
	CTwinVector tv;
	if(!GetRebarInfoCycleArchRibByDist(-1, nDan, bUpper, dXDisOfUpper)) return tv;

	CTwinVectorArray tvArrCrossSection;
	GetTvCrossSection_ArchRib(tvArrCrossSection, dXDisOfUpper, 0);

	tv	= tvArrCrossSection.GetTvByInfo("아치리브횡단상면");
	tv.m_sInfoHor.Format("cover:%.0f", m_dCoverRib[iUPPER][nDan]);
	tvArrCrossSection.SetTvByInfo("아치리브횡단상면", tv);

	tv	= tvArrCrossSection.GetTvByInfo("아치리브횡단하면");
	tv.m_sInfoHor.Format("cover:%.0f", m_dCoverRib[iLOWER][nDan]);
	tvArrCrossSection.SetTvByInfo("아치리브횡단하면", tv);
	
	tv	= tvArrCrossSection.GetTvByInfo("아치리브횡단좌측면");
	tv.m_sInfoHor.Format("cover:%.0f", GetCoverSideArchRib(nDan));
	tvArrCrossSection.SetTvByInfo("아치리브횡단좌측면", tv);

	tv	= tvArrCrossSection.GetTvByInfo("아치리브횡단우측면");
	tv.m_sInfoHor.Format("cover:%.0f", GetCoverSideArchRib(nDan));
	tvArrCrossSection.SetTvByInfo("아치리브횡단우측면", tv);


	CRebarPlacing rb;
	rb.GetOffsetTvArray(tvArrCrossSection, m_dCoverRib[iUPPER][nDan], FALSE);

	tv	= tvArrCrossSection.GetTvByInfo(bUpper ? "아치리브횡단상면" : "아치리브횡단하면");
	if(tv.m_v1.x > tv.m_v2.x)
		GetSwap(tv.m_v1, tv.m_v2);

	if(nDrawLeft == -1)
	{
		tv.m_v1	= tv.GetXyMid();
	}
	else if(nDrawLeft == 1)
	{
		tv.m_v2	= tv.GetXyMid();
	}

	return tv;

}

// 아치리브 횡단 주철근 좌표
// 일단을 구한뒤에 2단철근에 포함되는것만 골라내는 방식임
CRebarInfoCycle* CRcBridgeRebar::GetXyRebarMain_CrossSection_ArchRib(CDPointArray &xyArr, double dXDisOfUpper, long nCycle, BOOL bUpper, long nDan, long nDrawLeft)
{
	xyArr.RemoveAll();
	if(m_nTypeBridge != BRIDGE_TYPE_ARCH) return NULL;

	// 해당 dis에 실제 주철근이 존재하는지 검사 ////
	CRebarInfoCycle *pRC	= GetRebarInfoCycleArchRibByDist(nCycle, nDan, bUpper, dXDisOfUpper);
	if(!pRC) return NULL;
	//////////////////////////////////////////////


	// 일단 철근 구함
	CDoubleArray dArrDist;
	GetDistArrayMainRebarArchRib(dArrDist, nCycle, nDrawLeft);	// 우측에서 좌측으로 구하는 간격

	CTwinVector tvRebar	= GetTvOffset_ArchRib(dXDisOfUpper, bUpper, 0, nDrawLeft);
	long i = 0; for(i = 0; i < dArrDist.GetSize(); i++)
	{
		xyArr.Add(CDPoint(dArrDist.GetAt(i), tvRebar.m_v1.y));
	}

	xyArr.Sort(TRUE);

	// 2단이상 철근
	if(nDan > 0)
	{
		tvRebar	= GetTvOffset_ArchRib(dXDisOfUpper, bUpper, nDan, nDrawLeft);
		CDPoint xy(0, 0);
		for(i = 0; i < xyArr.GetSize(); i++)
		{
			xy	= xyArr.GetAt(i);
			if(xy.x > tvRebar.m_v1.x && xy.x < tvRebar.m_v2.x)
				xyArr.SetAt(i, CDPoint(xy.x, tvRebar.m_v1.y));
		}

		// 왼쪽
		if(nDrawLeft == -1 || nDrawLeft == 0)
			xyArr.InsertAt(0, tvRebar.m_v1);

		// 오른쪽
		if(nDrawLeft == 1 || nDrawLeft == 0)
			xyArr.Add(tvRebar.m_v2);
	}

	// 상면철근은 위로, 하면 철근은 아래로 이동
	CRebarPlacing rb;
	rb.MoveRebar(xyArr, CDPoint(0, bUpper ? REBAR_RADIUS : -REBAR_RADIUS));

	return pRC;
}

long CRcBridgeRebar::GetCountDanMainRebar_ArchRib(double dXDisOfUpper, BOOL bUpper)
{
	long nCountDan	= 0;
	long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
	{
		BOOL bOK	= FALSE;
		long cycle = 0; for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
		{
			CRebarInfoCycle *pRC	= GetRebarInfoCycleArchRibByDist(cycle, dan, bUpper, dXDisOfUpper);
			if(pRC)
			{
				bOK	= TRUE;
				break;
			}
		}
		if(bOK)
			nCountDan	= dan+1;
	}

	return nCountDan;
}

CRebarInfoCycle* CRcBridgeRebar::GetRebarInfoCycleArchRibByDist(long nCycle, long nDan, BOOL bUpper, double dXDisOfUpper)
{
	// 해당 dis에 실제 주철근이 존재하는지 검사 ////
// 	double xDisCheck	= dXDisOfUpper;
	CParabola pbRebar;
	GetRebarRib(pbRebar, bUpper, nDan);
	CDPoint xyCheck	= pbRebar.GetXyMatchXyAndAngle(m_pbRib[iUPPER].GetXyByDist(dXDisOfUpper), m_pbRib[iUPPER].GetXyDirPerByDist(dXDisOfUpper, TRUE));
	double xDisCheck	= pbRebar.GetDistByXPos(xyCheck.x);

	
	long upper	= bUpper ? iUPPER : iLOWER;
	CRebarInfoCycle *pRC	= NULL;

	long sttCycle	= nCycle == -1 ? 0 : nCycle;
	long endCycle	= nCycle == -1 ? GetCountCycleMainRebar() : nCycle + 1;
	long cycle = 0; for(cycle = sttCycle; cycle < endCycle; cycle++)
	{
		for(long rc = 0; rc < m_pArrRCMainRib[cycle][upper][nDan].GetSize(); rc++)
		{
			CRebarInfoCycle *pRCCheck	= m_pArrRCMainRib[cycle][upper][nDan].GetAt(rc);
			if(!pRCCheck->m_bExist) continue;

			double xDisFir	= pbRebar.GetDistByXPos(rc==0 ? pRCCheck->m_xyMid2.x : pRCCheck->m_xyStt.x);
			double xDisLast	= pbRebar.GetDistByXPos(rc==0 ? pRCCheck->m_xyEnd.x : pRCCheck->m_xyMid1.x);

			if(xDisCheck >= xDisFir && xDisCheck <= xDisLast)
			{
				pRC	= pRCCheck;
				break;
			}
		}
	}
	//////////////////////////////////////////////

	return pRC;
}

void CRcBridgeRebar::GetTvRebarShear_CrossSection_ArchRib(CTwinVectorArray &tvArr, double dXDisOfUpper, long nDrawLeft)
{
	tvArr.RemoveAll();
	if(m_nTypeBridge != BRIDGE_TYPE_ARCH) return;

	double dThick	= GetThickArchRib(dXDisOfUpper);
	double dCoverU	= m_dCoverRib[iUPPER][0];
	double dCoverL	= m_dCoverRib[iLOWER][0];

	CDPointArray xyArrMain;
	GetXyRebarMain_CrossSection_ArchRib(xyArrMain, dXDisOfUpper, 0, TRUE, 0, 0);

	double dMid	= GetMidCrossSection();
	CTwinVector tv;
	long i = 0; for(i = 1; i < xyArrMain.GetSize()-1; i++)
	{
		tv.m_v2	= xyArrMain.GetAt(i);
		tv.m_v2.y -= REBAR_RADIUS;
		tv.m_v1	= tv.m_v2 + CDPoint(0, -(dThick-dCoverU-dCoverL));

		if(nDrawLeft == -1 && dMid > tv.m_v1.x) continue;
		if(nDrawLeft == 1 && dMid < tv.m_v1.x) continue;
		tvArr.Add(tv);
	}
}

// 아치리브 평면 좌우측 리브중심쪽에 파내기 위함.
void CRcBridgeRebar::GetInfoCuttingCircle_Plane_ArchRib(CDPoint &xyCen, double &dR, double &dAngStt, double &dAngEnd, long nDrawLeft)
{
	if(nDrawLeft == 0) return;
	CTwinVectorArray tvArrPlane;
	GetTvPlaneArchRib(tvArrPlane, TRUE, 0);

	CDRect rect	= tvArrPlane.GetRect();
	xyCen	= rect.CenterPoint();
	dR		= rect.Width() * 20;
	double dHeightFootingStt	= m_footingStt.GetHeight();
	double dHeightFootingEnd	= m_footingEnd.GetHeight();
	if(nDrawLeft == -1)
	{
		xyCen.y	+= dR + fabs(rect.Height()/8);
		dAngStt	= (CDPoint(rect.left-dHeightFootingStt, rect.top) - xyCen).Unit().GetAngleDegree();
		dAngEnd	= (CDPoint(rect.right+dHeightFootingEnd, rect.top) - xyCen).Unit().GetAngleDegree();
	}
	else
	{
		xyCen.y -= dR + fabs(rect.Height()/8);
		dAngStt	= (CDPoint(rect.right+dHeightFootingEnd, rect.bottom) - xyCen).Unit().GetAngleDegree();
		dAngEnd	= (CDPoint(rect.left-dHeightFootingStt, rect.bottom) - xyCen).Unit().GetAngleDegree();
	}
}

void CRcBridgeRebar::GetInfoCuttingCircle_Plane_ArchRib_ForDan(CDPoint &xyCen, double &dR, double &dAngStt, double &dAngEnd, BOOL bUpper, long nDan, long nDrawLeft)
{
	dR	= 0;
	if(nDrawLeft == 0) return;
	if(nDan == 0) return;
	if(GetCountDanMainRebar_ArchRib(bUpper) <= nDan) return;
	CLineInfo *pLine	= GetLineBase();

	CTwinVectorArray tvArrPlane;
	GetTvPlaneArchRib(tvArrPlane, bUpper, nDrawLeft);

	CDRect rect	= tvArrPlane.GetRect();
	dR	= fabs(rect.Height()) / 4;
	xyCen.x	= rect.left + (rect.Width()/3 * nDan);
	xyCen.y	= bUpper ? rect.top : rect.bottom;

	// 2단은 첫번째 2단철근 가운데 파고
	// 3단은 첫번째 3단철근 끝에 판다.
	CParabola pbRebar;
	GetRebarRib(pbRebar, bUpper, nDan);
	long upper	= bUpper ? iUPPER : iLOWER;
	BOOL bOK	= FALSE;
	long cycle = 0; for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
	{
		for(long rc = 0; rc < m_pArrRCMainRib[cycle][upper][nDan].GetSize(); rc++)
		{
			CRebarInfoCycle *pRC	= GetRebarInfoCycleArchRib(cycle, nDan, bUpper, rc);
			if(!pRC) continue;
			if(!pRC->m_bExist) continue;

			double dist	= 0;
			if(rc == 0)
				dist	= nDan == 1 ? pbRebar.GetDistByXPos((pRC->m_xyMid2.x+pRC->m_xyEnd.x)/2) : pbRebar.GetDistByXPos(pRC->m_xyEnd.x);
			else
				dist	= nDan == 1 ? pbRebar.GetDistByXPos((pRC->m_xyStt.x+pRC->m_xyMid1.x)/2) : pbRebar.GetDistByXPos(pRC->m_xyMid1.x);


			if(dist < 0)
			{
				xyCen.x	= pbRebar.m_xyCrown.x - pbRebar.GetLenByDistToDist(dist, 0);
				xyCen.x -= pLine->m_dStationBp;
			}
			else
			{
				xyCen.x	= pbRebar.m_xyCrown.x + pbRebar.GetLenByDistToDist(0, dist);
				xyCen.x -= pLine->m_dStationBp;
			}
			bOK	= TRUE;
			break;
		}

		if(bOK) break;
	}


	dAngStt	= bUpper ? 180 : 0;
	dAngEnd	= bUpper ? 360 : 180;
}

long CRcBridgeRebar::GetCountDanMainRebar_ArchRib(BOOL bUpper)
{
	long nCountDan	= 0;
	long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
	{
		BOOL bOK	= FALSE;
		long cycle = 0; for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
		{
			CRebarInfoCycle *pRC	= GetRebarInfoCycleArchRib(cycle, dan, bUpper, 0);
			if(pRC)
			{
				bOK	= TRUE;
				break;
			}
		}
		if(bOK)
			nCountDan	= dan+1;
	}

	return nCountDan;
	
}

// 아치리브 전단철근
void CRcBridgeRebar::GetTvRebarShear_Plane_ArchRib(CTwinVectorArray &tvArr, long nDrawLeft)
{
	tvArr.RemoveAll();
	if(m_nTypeBridge != BRIDGE_TYPE_ARCH) return;

	CLineInfo *pLine	= GetLineBase();
	// 전단철근 들어가는 위치 찾기
	CParabola pbRebar;
	GetRebarRib(pbRebar, TRUE, 0);
	CDoubleArray dArrX;
	long left = 0; for(left = 0; left < 2; left++)
	{
		BOOL bLeft	= left == iLEFT;
		CPlaceRebarByBlock *pPlace	= &m_placeByBlock_ShearRebar_ArchRib[left];
		double dX	= pbRebar.m_xyCrown.x;
		dX -= pLine->m_dStationBp;

		if(bLeft)
			dArrX.Add(dX);
		long i = 0; for(i = 0; i < pPlace->m_nCountBlock; i++)
		{
			CDPoint xyR	= pPlace->m_xyArr.GetAt(i);
			long j = 0; for(j = 0; j < xyR.x; j++)
			{
				dX += bLeft ? -xyR.y : +xyR.y; 
				dArrX.Add(dX);
			}
		}
	}

	// 왼쪽에서 오른쪽으로 정렬
	dArrX.Sort(TRUE);

	// 횡단면상의 전단철근에 따라 배치함.
	CTwinVectorArray tvArrShear;
	GetTvRebarShear_CrossSection_ArchRib(tvArrShear, 0, nDrawLeft);
	CDoubleArray dArrY;
	long i = 0; for(i = 0; i < tvArrShear.GetSize(); i++)
		dArrY.Add(tvArrShear.GetAt(i).m_v1.x);

	CTwinVector tv;
	double dLenShear	= GetLenShearArchRib();
	for(i = 0; i < dArrX.GetSize(); i++)
	{
		tv.m_v1.x	= dArrX.GetAt(i);
		tv.m_v2.x	= dArrX.GetAt(i);
		long nIdxStt	= (i % 2 == 0) ? 0 : 1;
		long j = 0; for(j = nIdxStt; j < dArrY.GetSize()-1; j+=2)
		{
			tv.m_v1.y	= dArrY.GetAt(j);
			tv.m_v2.y	= tv.m_v1.y + dLenShear;
			tvArr.Add(tv);
		}
	}
}

// 아치리브 전단철근 
void CRcBridgeRebar::GetInfoCuttingCircle_Plane_ArchRib_Shear(CDPoint &xyCen, double &dR)
{
	CLineInfo *pLine	= GetLineBase();
	CParabola pbRebar;
	GetRebarRib(pbRebar, TRUE, 0);
	xyCen.x	= pbRebar.m_xyCrown.x;
	xyCen.x -= pLine->m_dStationBp;

	double dWidthL	= GetWidthArchRib(-1);
	double dWidthR	= GetWidthArchRib(1);
	xyCen.y	= (dWidthL+dWidthR)/2 + GetWidthArchRib(0)/3;
	dR		= GetWidthArchRib(0)/10;
}

// 아치리브 배력철근 권고안
void CRcBridgeRebar::SetDataDefaultRebarJewon_ArchRib_Support()
{
	CHgBaseConcStd baseConc;
	double dCover	= 0;
	double dRebarSpace	= 0;

	long nSize	= m_tvArrVertSectionRib[iUPPER].GetSize();
	double dXStt	= nSize > 0 ? m_tvArrVertSectionRib[iUPPER].GetAt(0).m_v1.x : 0;
	double dXEnd	= nSize > 0 ? m_tvArrVertSectionRib[iUPPER].GetAt(m_tvArrVertSectionRib[iUPPER].GetSize()-1).m_v2.x : 0;
	double dMaxHeight	= max(max(GetThickArchRib(0), GetThickArchRib(m_pbRib[iUPPER].GetDistByXPos(dXStt))), GetThickArchRib(m_pbRib[iUPPER].GetDistByXPos(dXEnd)));
	double dMinHeight	= min(min(GetThickArchRib(0), GetThickArchRib(m_pbRib[iUPPER].GetDistByXPos(dXStt))), GetThickArchRib(m_pbRib[iUPPER].GetDistByXPos(dXEnd)));
	dMaxHeight -= (m_dCoverRib[iUPPER][0] + m_dCoverRib[iLOWER][0]);
	dMinHeight -= (m_dCoverRib[iUPPER][0] + m_dCoverRib[iLOWER][0]);

	long upper = 0; for(upper = 0; upper < 2; upper++)
	{
		BOOL bUpper	= upper == iUPPER;

		long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
		{
			CTwinVectorArray tvArr;
			GetTvRebarSupport_Plane_ArchRib(tvArr, bUpper, dan, 0);
			if(tvArr.GetSize() == 0) continue;

			long nTypeRebar	= AR_REBAR_S_U1;
			switch(dan)
			{
				case 0: nTypeRebar	= bUpper ? AR_REBAR_S_U1 : AR_REBAR_S_L1; break;
				case 1: nTypeRebar	= bUpper ? AR_REBAR_S_U2 : AR_REBAR_S_L2; break;
				case 2: nTypeRebar	= bUpper ? AR_REBAR_S_U3 : AR_REBAR_S_L3; break;
			}
			CPlaceRebarByBlock *pPlace	= &m_placeByBlock_SupportRebar_ArchRib[upper][0][iLEFT];
			dCover	= m_dCoverRib[upper][dan];
			dRebarSpace	= dan == 0 ? pPlace->GetCTC() : pPlace->GetCTC()/2;

			CRebar *pRB	= new CRebar;
			pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
			pRB->m_sDescription.Format("아치리브 %s %d단 배력철근", bUpper ? "배선" : "복선", dan+1);
			pRB->m_sMark		= GetMarkRebarSupportArchRib(nTypeRebar, FALSE, TRUE, FALSE);
			pRB->m_dDia			= pPlace->m_dDia;
			pRB->m_dLengthMax_A	= tvArr.GetAt(0).GetLength();
			pRB->m_dLengthMax_B	= dMaxHeight;
			pRB->m_dLengthMin_B	= dMinHeight;
			pRB->m_nTypeRebar	= 3;
			pRB->m_bMainRebar	= FALSE;
			pRB->m_nEa			= tvArr.GetSize();
			baseConc.OptimizationRebar(pRB);	// 철근 최적화
			m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
			pRB->m_dRateAdd	= MAKE_RATE;
			AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
		}
	}
}

void CRcBridgeRebar::SetDataDefaultRebarJewon_ArchRib_Shear()
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();

	CHgBaseConcStd baseConc;
	double dCover	= 0;
	double dRebarSpace	= 0;

	CTwinVectorArray tvArrPlane, tvArrVertSectionL, tvArrVertSectionR;
	GetTvRebarShear_Plane_ArchRib(tvArrPlane, 0);
	GetTvRebarShear_VertSection_ArchRib(tvArrVertSectionL, tvArrVertSectionR, 0);
	if(tvArrPlane.GetSize() == 0) return;
	if(tvArrVertSectionL.GetSize() + tvArrVertSectionR.GetSize() == 0) return;

	CRebarShearDetail *pDetail	= &m_RebarShearDetail_ArchRib;
	CPlaceRebarByBlock *pPlace	= &m_placeByBlock_ShearRebar_ArchRib[iLEFT];
	dCover	= m_dCoverRib[iUPPER][0];
	dRebarSpace	= pPlace->GetCTC();

	CRebar *pRB	= new CRebar;
	pRB->m_Fy			= bLsd? 0 : m_pARcBridgeDataStd->m_Fy; //한계상태일 경우 아치리브 x
	pRB->m_sDescription.Format("아치리브 전단철근");
	pRB->m_sMark		= GetMarkRebarShearArchRib(AR_REBAR_V, FALSE, TRUE, FALSE);
	pRB->m_dDia			= m_RebarShearDetail_ArchRib.m_dDia;
	double dDiaMainUpper	= GetDiaMainRebarRib(0, 0, TRUE, 0);
	double dDiaMainLower	= GetDiaMainRebarRib(0, 0, FALSE, 0);
	double dHeightMax		= max(tvArrVertSectionL.GetLengthMax(), tvArrVertSectionR.GetLengthMax());
	double dHeightMin		= min(tvArrVertSectionL.GetLengthMin(), tvArrVertSectionR.GetLengthMin());
	double dSettle			= m_pARcBridgeDataStd->GetValueJoint((long)pPlace->m_dDia, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
	double dWidthMax		= tvArrPlane.GetAt(0).GetLength();
	double dWidthMin		= dWidthMax;
	pDetail->SetRB(pRB, dDiaMainUpper, dDiaMainLower, dWidthMax, dHeightMax, dSettle);
	pDetail->SetMin(dWidthMin, dHeightMin);
	pDetail->SetDataDefaultRebarJewon();
	pRB->m_bMainRebar	= FALSE;
	pRB->m_nEa			= tvArrPlane.GetSize();	
	baseConc.OptimizationRebar(pRB);	// 철근 최적화
	m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
	pRB->m_dRateAdd	= MAKE_RATE;
	AddOrDeleteRebarInList(&m_pArrRebarShear, pRB);
}

// 아치교는 내측벽체 이음수를 권고안 할 필요가 있다.
void CRcBridgeRebar::SetDataDefaultCountJointMainRebarInWall()
{
	if(m_nTypeBridge == BRIDGE_TYPE_ARCH)
	{
		long nCountInWall	= GetCountInWall();
		for(long wall = 0; wall < nCountInWall; wall++)
		{
			CWallApp *pWall	= GetInWall(wall);
			if(!pWall) continue;
			if(!pWall->m_bIs) continue;

			long left = 0; for(left = 0; left < 2; left++)
			{
				long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
				{
					pWall->m_nCountJointMainRebar_Cycle1[left][dan]	= 0;
					pWall->m_nCountJointMainRebar_Cycle2[left][dan]	= 0;
				}
			}
		}
	}
}

void CRcBridgeRebar::SetDataDefaultRebarInfoCycleArchRib(long nCycle, BOOL bOnlyCountArray, BOOL bOnlyDiffJoint)
{
	if(m_nTypeBridge != BRIDGE_TYPE_ARCH)
		return;

	long stt	= nCycle == -1 ? 0 : nCycle;
	long end	= nCycle == -1 ? GetCountCycleMainRebar() : nCycle+1;

	if(stt < 0 || stt > GetCountCycleMainRebar()) return;
	if(end < 0 || end > GetCountCycleMainRebar()) return;


	long joint(0), upper(0);
	BOOL bUpper(TRUE);
	double dMove	= 0;
	
	long cycle = 0; for(cycle = stt; cycle < end; cycle++)
	{
		BOOL bCycle34	= cycle == 0 || cycle == 1 ? FALSE : TRUE;

		// 벽체는 거리나 지름이나 모두 이음 개수만큼만 받으면 된다.
		for(upper = 0; upper < 2; upper++)
		{
			bUpper	= upper == iUPPER;

			CParabola pbRebar;
			GetRebarRib(pbRebar, bUpper, 0);
			double dLenTot	= pbRebar.GetLenByDistToDist(pbRebar.m_dDistStt, pbRebar.m_dDistEnd);
			long nCountJoint	= nCycle == 0 || nCycle == 2 ? m_nCountJointMainRebar_ArchRib_Cycle1[upper][0] : m_nCountJointMainRebar_ArchRib_Cycle2[upper][0];

			// 이음개수가 변경된 경우에만 권고안 하도록 하는 경우 /////////
			if(bOnlyDiffJoint)
			{
				long nCountJoint	= nCycle == 0 || nCycle == 2 ? m_nCountJointMainRebar_ArchRib_Cycle1[upper][0] : m_nCountJointMainRebar_ArchRib_Cycle2[upper][0];
				long nCountJointOld	= nCycle == 0 || nCycle == 2 ? m_nCountJointMainRebar_ArchRib_Cycle1_Old[upper][0] : m_nCountJointMainRebar_ArchRib_Cycle2_Old[upper][0];

				if(nCountJoint == nCountJointOld) continue;
			}
			//////////////////////////////////////////////////////////////////
			
			CDoubleArray dArrDistRC;
			CDoubleArray dArrDiaRC;
			CDoubleArray dArrExistRC;
			dArrDistRC	= m_dArrDistRib[cycle][upper][0];
			dArrDiaRC	= m_dArrDiaRib[cycle][upper][0];
			dArrExistRC	= m_dArrExistRib[cycle][upper][0];

			m_dArrDistRib[cycle][upper][0].RemoveAll();
			m_dArrDiaRib[cycle][upper][0].RemoveAll();
			m_dArrExistRib[cycle][upper][0].RemoveAll();
			
			// 거리/지름
			if(!bCycle34)
			{
				for(joint = 0; joint < nCountJoint; joint++)
				{
					dMove	= GetDistMoveJointCycle13_ArchRib(bUpper, cycle==2, joint);
					m_dArrDistRib[cycle][upper][0].Add(Round(dLenTot/(nCountJoint+1)+dMove, -1));
					m_dArrDiaRib[cycle][upper][0].Add(22);
					m_dArrExistRib[cycle][upper][0].Add((double)TRUE);
				}
				m_dArrDiaRib[cycle][upper][0].Add(22);
				m_dArrExistRib[cycle][upper][0].Add((double)TRUE);

				if(bOnlyCountArray)
				{
					long i = 0; for(i = 0; i < m_dArrDistRib[cycle][upper][0].GetSize(); i++)
					{
						if(i < dArrDistRC.GetSize())
							m_dArrDistRib[cycle][upper][0].SetAt(i, dArrDistRC.GetAt(i));
					}

					for(i = 0; i < m_dArrDiaRib[cycle][upper][0].GetSize(); i++)
					{
						if(i < dArrDiaRC.GetSize())
							m_dArrDiaRib[cycle][upper][0].SetAt(i, dArrDiaRC.GetAt(i));
					}

					for(i = 0; i < m_dArrExistRib[cycle][upper][0].GetSize(); i++)
					{
						if(i < dArrExistRC.GetSize())
							m_dArrExistRib[cycle][upper][0].SetAt(i, dArrExistRC.GetAt(i));
					}
				}
			}
			else
			{
				m_dArrDistRib[cycle][upper][0]	= m_dArrDistRib[cycle == 2 ? 0 : 1][upper][0];
				m_dArrDiaRib[cycle][upper][0]	= m_dArrDiaRib[cycle == 2 ? 0 : 1][upper][0];
				m_dArrExistRib[cycle][upper][0]	= m_dArrExistRib[cycle == 2 ? 0 : 1][upper][0];

				long i = 0; for(i = 0; i < m_dArrDistRib[cycle][upper][0].GetSize(); i++)
					m_dArrDistRib[cycle][upper][0].SetAt(i, m_dArrDistRib[cycle][upper][0].GetAt(i)+(i == 0 ? dMove*2 : 0));
			}
		}
	}
	
}

// 아치리브도 권고안시 이음개수 권고안 해주야 함.
void CRcBridgeRebar::SetDataDefaultCountJointMainArchRib()
{
	if(m_nTypeBridge != BRIDGE_TYPE_ARCH)
		return;

	CParabola pbRebar;
	GetRebarRib(pbRebar, TRUE, 0);

	double dLenUnit	= 8000;
	double dLenTot	= pbRebar.GetLenByDistToDist(pbRebar.m_dDistStt, pbRebar.m_dDistEnd);
	long nCount		= (long)((dLenTot / dLenUnit) +1);

	long upper = 0; for(upper = 0; upper < 2; upper++)
	{
		m_nCountJointMainRebar_ArchRib_Cycle1[upper][0]	= nCount;
		m_nCountJointMainRebar_ArchRib_Cycle2[upper][0]	= nCount;
	}
}

double CRcBridgeRebar::GetDistMoveJointCycle13_ArchRib(BOOL bUpper, BOOL bCycle3, long nJoint)
{
	if(GetCountCycleMainRebar() < 4) return 0;
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;

	double dDist	= 0;
	
	long cycle		= bCycle3 ? 2 : 0;
	long upper		= bUpper ? iUPPER : iLOWER;
	
	double dCover	= m_dCoverRib[upper][0];
	double dSpace	= m_dCTC_MainRebar/2;
	long nType		= JOINT_TENS_NORMAL_A;
	CDoubleArray *pDArr	= &m_dArrDiaRib[cycle][upper][0];
	double dDia		= pDArr->GetSize() > nJoint ? pDArr->GetAt(nJoint) : 0;
	double dDiaNext	= pDArr->GetSize() > nJoint+1 ? pDArr->GetAt(nJoint+1) : 0;
	double dLenJoint	= pStd->GetValueJoint(max(dDia, dDiaNext), nType, dCover, dSpace, 2, 1);


	if(m_nTypeDefaultCycle3_ArchRib != 0)
	{
		dDist	= GetDistMoveJointByTypeDefaultCycle3(m_nTypeDefaultCycle3_ArchRib, dLenJoint);
	}

	if(!bCycle3)
		dDist	= -dDist;

	return dDist;
}

// 아치교 접합부 스터럽 철근
void CRcBridgeRebar::GetTvRebarStirrup_VertSection_ConnectSection(CTwinVectorArray &tvArrLeft, CTwinVectorArray &tvArrRight)
{
	tvArrLeft.RemoveAll();
	tvArrRight.RemoveAll();
	if(m_nTypeBridge != BRIDGE_TYPE_ARCH) return;
	
	long nJ	= GetJijumConnectRibAndSlab();
	if(nJ == -1) return;

	CTwinVectorArray tvArrShear, tvArrShearHunch, tvArrShearRib;
	GetTvRebarShear_VertSection_UpperSlab(tvArrShear, tvArrShearHunch, tvArrShearRib, 0);
	if(tvArrShearRib.GetSize() == 0) return;
	CWallApp *pWall	= GetInWall(nJ-1);
	if(!pWall) return;
	if(!pWall->m_bIs) return;

	long left = 0; for(left = 0; left < 2; left++)
	{
		BOOL bLeft	= left == iLEFT;
		CPlaceRebarByBlock *pPlace	= &m_placeByBlock_StirrupRebar_ConnectSection[left];
		long nCountWrap	= m_nCountWrapShearRebar_StirrupRebar_ConnectSection[left];
		if(nCountWrap < 0)
			continue;
		
		CTwinVector tv;
		long nSize	= tvArrShearRib.GetSize();
		if(nSize < 2) continue;
		if(nCountWrap > nSize) nCountWrap	= nSize;
		if(nCountWrap == 0) continue;

		tv.m_v1	= tvArrShearRib.GetAt(bLeft ? 0 : nSize-1).m_v1;
		tv.m_v2	= tvArrShearRib.GetAt(bLeft ? nCountWrap-1 : nSize-nCountWrap-1).m_v1;
		tv.m_v2.y	= tv.m_v1.y;
		if(0)//!bLeft)
			GetSwap(tv.m_v1, tv.m_v2);
		CTwinVector tvRebar	= tvArrShearRib.GetAt(bLeft ? 0 : nSize-1);

		
		pPlace->m_nCountBlock	= 3;
		pPlace->FitCount();
		CDPoint xyR	= pPlace->m_xyArr.GetAt(0);
		xyR.x	= 1;
		pPlace->m_xyArr.SetAt(0, xyR);
		xyR	= pPlace->m_xyArr.GetAt(2);
		xyR.x	= 1;
		pPlace->m_xyArr.SetAt(2, xyR);

		CRebarPlacing rb;
		CDPointArray xyArr;
		rb.GetXyDivideLine(xyArr, tvRebar.m_v2, tvRebar.m_v1, pPlace->m_xyArr, FALSE, FALSE, FALSE);

		CTwinVectorArray *pTvArr	= bLeft ? &tvArrLeft : &tvArrRight;
		long i = 0; for(i = 0; i < xyArr.GetSize(); i++)
		{
			tv.m_v1.y	= xyArr.GetAt(i).y;
			tv.m_v2.y	= tv.m_v1.y;
			pTvArr->Add(tv);
		}
	}
}

// CTwinVector tvRebar	: 사보강의 측면 철근
// CDPoint vAngStt		: 철근 배치 방향
// CDPoint vAngEnd		: 철근 배치 방향
CTwinVector CRcBridgeRebar::ConvertFromVertialRebarToLineRebarAtSabogang(CTwinVector tvRebar, CDPoint vAngStt, CDPoint vAngEnd, BOOL bLeft)
{
	if(m_nTypeSideRebarMain_UpperSlabSabogang == 0) return tvRebar;
	vAngStt = Compare(vAngStt.GetAngleDegree(), 90.0, "=") ? GetAngleAzimuthJijum(0) : GetAngleAzimuthJijum(m_nQtyJigan);
	vAngEnd = Compare(vAngEnd.GetAngleDegree(), 90.0, "=") ? GetAngleAzimuthJijum(0) : GetAngleAzimuthJijum(m_nQtyJigan);

	CLineInfo *pLine	= GetLineLeftCenRight(bLeft ? -1 : 1, FALSE, FALSE);
	double dSta			= GetStationByTarget(BRIDGE_OFF_STT_SLAB, 0, FALSE);
	CDPoint vAng		= GetAngleAzimuthJijum(0);
	CDPoint xySlabEnd	= GetXySlabEdgeAct(dSta, GetAngleByTarget(BRIDGE_OFF_STT_SLAB, 0), bLeft, FALSE);
	CDPoint xyMatch		= xySlabEnd;
	GetXyMatchLineAndLine(xySlabEnd, vAng, tvRebar.m_v1, tvRebar.GetXyDir(), xyMatch);
	double dDist	= pLine->GetDisMatchVerticalByXy(xyMatch);
	double dStaStt(0), dStaEnd(0);
	pLine->GetStationMatchByXyAndAngle(tvRebar.m_v1, vAngStt, dStaStt, dDist);
	pLine->GetStationMatchByXyAndAngle(tvRebar.m_v2, vAngEnd, dStaEnd, dDist);

	tvRebar.m_v1	= pLine->GetXyLineDis(dStaStt, dDist);
	tvRebar.m_v2	= pLine->GetXyLineDis(dStaEnd, dDist);
	tvRebar.m_v1.z	= 4;
	CLineInfo *pLineCen	= GetLineBase();
	double dDistFromCenter	= pLineCen->GetDisMatchVerticalByXy(xyMatch);
	double dMid				= GetMidCrossSection();

	tvRebar.m_v2.z	= dDistFromCenter < dMid ? -1 : 1;
	tvRebar.m_v2.z	= pLine->GetDisMatchVerticalByXy(xyMatch);
	
	return tvRebar;
}

// 실제 현장에서는 전단철근을 필요한 부분만 대충 그린다.
// 집계역시 슬래브 폭과 CTC등을 이용해서계산함
// 첨에는 일일이 그려서 집계하고 필요한 부분 잘라 냈지만, 시간도 오래 걸리고, 
// 철근 배치 방법에 따라서 오류가 발생함에 따라 실제 현장에서 적용하는 방법을
// 이혜철 차장님께 문의해서 아래와 같이 변경작업함. 2006.03.09
void CRcBridgeRebar::GetTvRebarShear_Plane_Slab_Real(BOOL bUpperslab, CTwinVectorArray &tvArr)
{
	tvArr.RemoveAll();

	// 일단 주철근과 배력근이 구해져 있어야 함. ///////
	if(!m_bCaledRebarMain_Plane)
	{
		SettingTvArrRebarMainPlane();
	}

	if(!m_bCaledRebarSupport_Plane)
	{
		SettingTvArrRebarSupportPlane();
	}
	///////////////////////////////////////////////////

	// 필요한 범위의 폭과 길이를 정함
	// 슬래브 폭의 1/4
	double dWidthNeed	= GetWidthSlabAct(m_dStationBridgeStt, CDPoint(0, 1), 0) / 4;
	
	// 길이가 폭보다 크면 폭과 같이 하고, 작으면 길이의 1/5
	double dDistNeed	= m_dLengthBridge > dWidthNeed * 4 ? dWidthNeed : m_dLengthBridge / 5;

	// 필요폭과 길이중 작은걸 사용함
	dWidthNeed	= min(dWidthNeed, dDistNeed);
	dDistNeed	= min(dWidthNeed, dDistNeed);

	// 구하고자 하는 하는 시작과 끝 스테이션
	BOOL bVertDir	= IsVertDir();
	//double dLenBridge	= GetLengthBridge(bVertDir);
	//double dStaStt	= GetStationOnJijum(0, 0, bVertDir) + dLenBridge/2;
	//double dStaEnd	= dStaStt + dWidthNeed;
	// 일단 전 스테이션 다 구함
	double dStaStt	= GetStationOnJijum(0, 0, bVertDir);
	double dStaEnd	= GetStationOnJijum(m_nQtyJigan, 0, bVertDir);

	// 실제 종단에 배근된 스테이션을 가져옴
	CTwinVectorArray tvArrShear, tvArrShearHunch, tvArrShearRib;
	if(bUpperslab)
		GetTvRebarShear_VertSection_UpperSlab(tvArrShear, tvArrShearHunch, tvArrShearRib, 0);
	else
		GetTvRebarShear_VertSection_LowerSlab(tvArrShear, tvArrShearHunch, 0);

	tvArrShear.AddFromTvArray(tvArrShearHunch);

	double dDiffStaForVert = GetDiffStationSupportForVert();
	CDoubleArray dArrShearVert;
	CTwinVector tv;
	double dSta(0);
	long i = 0; for(i = 0; i < tvArrShear.GetSize(); i++)
	{
		tv	= tvArrShear.GetAt(i);
		
		// (ARCBRIDGE-2898) 배력철근 사보강 배치일때 종단면에서의 Station에서 직구간 배력철근을 보정해서 그래고 있다
		// 배력철근에 맞춰주기 위해서 전단철근도 Station을 맞춘다.
		dSta = tv.m_v1.x - dDiffStaForVert;
		if(dStaStt <= dSta && dStaEnd >= dSta)
			dArrShearVert.Add(dSta);
	}
	
	if(bUpperslab && m_tvArr_RebarMain_Plane[0][0][iUPPER].GetSize() == 0) return;
	if(!bUpperslab && m_tvArr_RebarMain_LowerPlane[0][0][iUPPER].GetSize() == 0) return;
	// 주가 되는 방향의 주철근과 배력근에 배근함.
	CTwinVectorArray tvArrRebarMain, tvArrRebarSupport;
	if(bUpperslab)
	{
		tvArrRebarMain		= *m_tvArr_RebarMain_Plane[0][0][iUPPER].GetAt(0);
		tvArrRebarSupport	= m_tvArr_RebarSupport_Plane[0][iUPPER];
		tvArrRebarSupport.AddFromTvArray(m_tvArrAngStt_RebarSupport_Plane[0][iUPPER]);
		tvArrRebarSupport.AddFromTvArray(m_tvArrAngEnd_RebarSupport_Plane[0][iUPPER]);
		tvArrRebarSupport.AddFromTvArray(m_tvArrRAngStt_RebarSupport_Plane[0][iUPPER]);
		tvArrRebarSupport.AddFromTvArray(m_tvArrRAngEnd_RebarSupport_Plane[0][iUPPER]);
	}
	else
	{
		tvArrRebarMain		= *m_tvArr_RebarMain_LowerPlane[0][0][iUPPER].GetAt(0);
		tvArrRebarSupport	= m_tvArr_RebarSupport_LowerPlane[0][iUPPER];
		tvArrRebarSupport.AddFromTvArray(m_tvArrAngStt_RebarSupport_LowerPlane[0][iUPPER]);
		tvArrRebarSupport.AddFromTvArray(m_tvArrAngEnd_RebarSupport_LowerPlane[0][iUPPER]);
		tvArrRebarSupport.AddFromTvArray(m_tvArrRAngStt_RebarSupport_LowerPlane[0][iUPPER]);
		tvArrRebarSupport.AddFromTvArray(m_tvArrRAngEnd_RebarSupport_LowerPlane[0][iUPPER]);
	}
	
	if(tvArrRebarSupport.GetSize() == 0) return;

	CLineInfoApp *pLine	= static_cast<CLineInfoApp*>(GetLineBase(bVertDir));

	////{ARCBRIDGE-2723
	//포함이 안된 좌우측의 사보강 절반을 tvArrRebarMain앞뒤로 넣어줍니다(bVertDir == TRUE일때만, 사보강 절반 배치일때만 적용)
	if(bVertDir && m_nTypePlacingMainRebar_UpperSlab == 2)
	{
		CTwinVectorArray *pTvArrAngLeft = m_tvArrAngLeft_RebarMain_Plane[0][0][iUPPER].GetAt(0);
		CTwinVectorArray *pTvArrAngRight = m_tvArrAngRight_RebarMain_Plane[0][0][iUPPER].GetAt(0);

		CTwinVectorArray tvArrHalfMainLeft, tvArrHalfMainRight;
		for (long nLR =0; nLR < 2; nLR++)
		{
			BOOL bLeft = nLR == 0? TRUE : FALSE;
			long nSize = bLeft?  m_tvArrAngLeftHalf_RebarMain_Plane[0][0][iUPPER].GetSize() : m_tvArrAngRightHalf_RebarMain_Plane[0][0][iUPPER].GetSize();
			for (long nx =0; nx < nSize; nx++)
			{
				CTwinVectorArray *pTvArrHalf = nLR==0? m_tvArrAngLeftHalf_RebarMain_Plane[0][0][iUPPER].GetAt(nx) : 
					m_tvArrAngRightHalf_RebarMain_Plane[0][0][iUPPER].GetAt(nx);
			if(pTvArrHalf == NULL || pTvArrHalf->GetSize() ==0)
				continue;

			bLeft? tvArrHalfMainLeft.AddFromTvArray(*pTvArrHalf) : tvArrHalfMainRight.AddFromTvArray(*pTvArrHalf);;
			}
		}
		//시작선형부터 하나씩 Sorting한다.
		CTwinVector tvT1, tvT2, tvT_Tmp;
		for (long nLR =0; nLR < 2; nLR ++)
		{
			BOOL bLeft	= nLR == 0? TRUE : FALSE;
			long nSize	= bLeft? tvArrHalfMainLeft.GetSize() : tvArrHalfMainRight.GetSize();
			CString sDir	= _T(">"); 

			for (long ixL = 0; ixL < nSize; ixL++)
			{
				for (long nxL =ixL+1; nxL < nSize; nxL++)
				{
					tvT1 = bLeft? tvArrHalfMainLeft.GetAt(ixL) : tvArrHalfMainRight.GetAt(ixL);
					tvT2 = bLeft? tvArrHalfMainLeft.GetAt(nxL) : tvArrHalfMainRight.GetAt(nxL);

					double dDist1 = pLine->GetDisMatchVerticalByXy(tvT1.m_v1);
					double dDist2 = pLine->GetDisMatchVerticalByXy(tvT2.m_v1);

					if(Compare(dDist1, dDist2, sDir, 0.1))
					{
						bLeft? tvArrHalfMainLeft.SetAt(ixL, tvT2) : tvArrHalfMainRight.SetAt(ixL, tvT2);
						bLeft? tvArrHalfMainLeft.SetAt(nxL, tvT1) : tvArrHalfMainRight.SetAt(nxL, tvT1);
					}
				}
			}
		}

		//Left 가 있을 첫철근 Right가 있을 경우 마지막 철근의 Dist가 같다면 정보가 있기 때문에 사용하지 않는다.
		for (long nLR =0; nLR < 2; nLR ++)
		{
			BOOL bLeft = nLR == 0? TRUE : FALSE;
			long nSize = bLeft? tvArrHalfMainLeft.GetSize() : tvArrHalfMainRight.GetSize();
			if(nSize == 0)
				continue;

			CTwinVector tv_First			= bLeft? tvArrHalfMainLeft.GetAt(0) : tvArrHalfMainRight.GetAt(0);
			CTwinVector tv_Last			= bLeft? tvArrHalfMainLeft.GetAt(tvArrHalfMainLeft.GetSize()-1) : tvArrHalfMainRight.GetAt(tvArrHalfMainRight.GetSize()-1);
			CTwinVector tvMain_First	= tvArrRebarMain.GetAt(bLeft? 0 : tvArrRebarMain.GetSize()-1);

			double dDist_F	= pLine->GetDisMatchVerticalByXy(tv_First.m_v1);
			double dDist_L	= pLine->GetDisMatchVerticalByXy(tv_Last.m_v1);
			double dDist_M = pLine->GetDisMatchVerticalByXy(tvMain_First.m_v1);

			if(Compare(dDist_M, dDist_F, _T(">="), 0.1) && Compare(dDist_M, dDist_L, _T("<="), 0.1))
				continue;

			//Left이면 Main철근의 앞쪽에 Right이면 뒤쪽에
			CTwinVectorArray tvArrTemp;
			if(bLeft)
			{
				tvArrTemp.AddFromTvArray(tvArrHalfMainLeft);
				tvArrTemp.AddFromTvArray(tvArrRebarMain);
				tvArrRebarMain.RemoveAll();
				tvArrRebarMain.AddFromTvArray(tvArrTemp);
			}
			else
			{
				tvArrRebarMain.AddFromTvArray(tvArrHalfMainRight);
			}
		}
	}	
	/////}


	// 주철근 양 끝에는 짜투리 치수이므로 뺀다.
	if(tvArrRebarMain.GetSize() > 2)
	{
		tvArrRebarMain.RemoveAt(0);
		tvArrRebarMain.RemoveAt(tvArrRebarMain.GetSize()-1);
	}
	
	// 전단철근 정보 가져옴.
	CDPoint xyDirShear	= tvArrRebarSupport.GetAt(0).GetXyDir();

	if(bVertDir)
	{
		dStaStt	-= m_dStationBridgeStt;
		dStaEnd -= m_dStationBridgeStt;
	}
	CRebarPlacing rb;
	BOOL bFirst	= TRUE;
	
	long nCntWrapMainRebar = bUpperslab? m_nCountWrapMainRebarUpperSlab : m_nCountWrapMainRebarLowerSlab;
	long nCount	= nCntWrapMainRebar/2;
	//double dMid	= bVertDir ? 0 : GetMidCrossSection();
	for(i = 0; i < dArrShearVert.GetSize(); i++)
	{
		double dSta	= bVertDir ? dArrShearVert.GetAt(i)-m_dStationBridgeStt : dArrShearVert.GetAt(i);
		
		long nStt	= bFirst ? 0 : nCount;
		long j = 0; for(j = nStt; j < tvArrRebarMain.GetSize()-nCntWrapMainRebar; j+=nCntWrapMainRebar)
		{
			double dDist1	= 0;
			double dDist2	= 0;
			CTwinVector tvRebarMain1	= tvArrRebarMain.GetAt(j);
			CTwinVector tvRebarMain2	= tvArrRebarMain.GetAt(j+nCount);
			if(tvRebarMain1.m_v1.z == 6)
			{
				dDist1	= tvRebarMain1.m_v1.y;
				dDist2	= tvRebarMain2.m_v1.y;
			}
			else
			{
				dDist1	= pLine->GetDisMatchVerticalByXy(tvRebarMain1.m_v1);
				dDist2	= pLine->GetDisMatchVerticalByXy(tvRebarMain2.m_v1);
			}

			//if(dDist1 > dMid || dDist2 > dMid) continue;

			CTwinVector tv;
			
			// 사보강 배치면 직각으로 교차점 찾고
			if(m_nTypePlacingSupportRebar_UpperSlab == 2)
			{
				 tv.m_v1	= pLine->GetXyLineDis(dSta, dDist1);
				 tv.m_v2	= pLine->GetXyLineDis(dSta, dDist2);
				 tvArr.Add(tv);
			}
			else	// 아니면 배력근 방향으로 찾음
			{
				CTwinVectorArray tvArrRebarMain1;
				CTwinVectorArray tvArrRebarMain2;

				tvArrRebarMain1.AddFromLineInfo(pLine, dStaStt, dStaEnd, dDist1);
				tvArrRebarMain2.AddFromLineInfo(pLine, dStaStt, dStaEnd, dDist2);
				CDPointArray xyArrMatch1, xyArrMatch2;
				CDPoint xy	= pLine->GetXyLine(dSta);
				rb.GetXyMatchTvArrAndLine(tvArrRebarMain1, xy, xyDirShear, xyArrMatch1);
				rb.GetXyMatchTvArrAndLine(tvArrRebarMain2, xy, xyDirShear, xyArrMatch2);
				if(xyArrMatch1.GetSize() > 0 && xyArrMatch2.GetSize() > 0)
				{
					tv.m_v1	= xyArrMatch1.GetAt(0);
					tv.m_v2	= xyArrMatch2.GetAt(0);
					tvArr.Add(tv);
				}
			}
		}
		bFirst = !bFirst;
	}
}

BOOL CRcBridgeRebar::IsExistMainRebarUpperSlabExp(BOOL bStt, BOOL bLeft, BOOL bUpper, long nCycle)
{
	if(!IsGagakForLine(bStt, bLeft)) return FALSE;


	return TRUE;
}

// 상황에 따라서 가각철근이 필요 없는 경우가 있다.(주철근 사보강(절반)배치인 경우중 몇가지 상황)
// 가각이 있으면서도 가각 철근이 필요 없는 경우에는 피복철근만 넣어준다.
BOOL CRcBridgeRebar::IsNeedGagakRebar(BOOL bStt, BOOL bLeft)
{
	if(!IsGagakForLine(bStt, bLeft)) return FALSE;
	if(m_nTypePlacingMainRebar_UpperSlab != 2) return TRUE;

	// 없는 경우
	BOOL bNeed	= TRUE;
	// 1. 가각이 슬래브 중심을 넘어서서 설치될 경우 항상 철근이 필요하다.(직방향 절반 철근으로 도저히 감당안됨)
	double dStaStt	= GetStationByTarget(BRIDGE_OFF_STT_SLAB, bLeft ? -1 : 1, FALSE);
	double dStaEnd	= GetStationByTarget(BRIDGE_OFF_END_SLAB, bLeft ? -1 : 1, FALSE);
	long nLeft	= bLeft ? 0 : 1;
	double dWGagak	= bStt ? m_dExpSttW[nLeft] : m_dExpEndW[nLeft];
	if((dStaEnd-dStaStt)/2 < dWGagak) return TRUE;

	// 2. 가각모서리의 각이 직방향 철근에 비해서 둔각이어야 필요가 없음
	if(!IsObtuseEdgeOfGagak(bStt, bLeft)) return TRUE;

	// 3. 가각위치가 슬래브의 둔각부비어야 필요가 없음
	if(IsObtuseEdgeOfSlab(bStt, bLeft)) bNeed	= FALSE;

	return bNeed;
}

// 가각모서리의 각이 직방향 철근에 비해서 둔각인지 판단.
// 사보강 배치가 아니라면 무조건 TRUE 리턴
BOOL CRcBridgeRebar::IsObtuseEdgeOfGagak(BOOL bStt, BOOL bLeft)
{
	if(!IsGagakForLine(bStt, bLeft)) return FALSE;
	if(m_nTypePlacingMainRebar_UpperSlab != 2) return TRUE;

	double dAngJijum	= GetAngleJijum(bStt ? 0 : m_nQtyJigan).GetAngleDegree();
	double dAngGagak	= GetXyDirExpForRebar(bStt, bLeft).GetAngleDegree();
	double dAngDiff		= 0;

	if(bLeft)
		dAngJijum += 180;

	if((bStt && !bLeft) || (!bStt && bLeft))
	{
		if(dAngJijum < dAngGagak)
			dAngJijum += 360;

		dAngDiff	= dAngJijum - dAngGagak;
	}
	else
	{
		if(dAngGagak < dAngJijum)
			dAngGagak += 360;

		dAngDiff	= dAngGagak - dAngJijum;
	}

	return dAngDiff > 90;
}

// 상부슬래브 모서리 부분이 둔각인지 판단
BOOL CRcBridgeRebar::IsObtuseEdgeOfSlab(BOOL bStt, BOOL bLeft)
{
	BOOL bObtuse	= FALSE;
	double dAng	= GetAngleJijum(bStt ? 0 : m_nQtyJigan).GetAngleDegree();
	if(bStt)
	{
		if(dAng > 90 && !bLeft) bObtuse	= TRUE;
		else if(dAng < 90 && bLeft) bObtuse	= TRUE;
	}
	else
	{
		if(dAng > 90 && bLeft) bObtuse	= TRUE;
		else if(dAng < 90 && !bLeft) bObtuse	= TRUE;
	}
	
	return bObtuse;
}

// 신축이음 철근인지?
BOOL CRcBridgeRebar::IsFlexibleJointRebar(BOOL bStt, CRebarInfoCycle *pRC)
{
	if(!pRC) return FALSE;
	if(!IsBlockOut(bStt)) return FALSE;
	
	BOOL bIs	= FALSE;

	if(bStt)
	{
		if(pRC->m_nPosStt == REBARINFO_POS_UPPERSLAB_SIDE && pRC->m_nPosEnd == REBARINFO_POS_UPPERSLAB_LOWER)
		{
			bIs	= TRUE;
		}
	}
	else
	{
		if(pRC->m_nPosStt == REBARINFO_POS_UPPERSLAB_LOWER && pRC->m_nPosEnd == REBARINFO_POS_UPPERSLAB_SIDE)
		{
			bIs	= TRUE;
		}
	}

	return bIs;
}

CString CRcBridgeRebar::GetStringDiaMu(double dDia)
{
	CString sFy = GetCharRebarMark(m_dMonuR_Fy);
	if(dDia==0) return _T("");
	
	return sFy+Comma(dDia);
}

double CRcBridgeRebar::GetDiffLeftRightDistForGagakSabogang(BOOL bStt, BOOL bLeft)
{
	if(m_nTypePlacingMainRebar_UpperSlab != 1) return 0;

	double dDiff	= 0;
	// 가각 있고 전체사보강이면 dDist를 최대로 넓힌다.
	// 단 직방향 철근을 뻗어서 가각의 어느 부분이라도 닿으면 배근하지 않음
	CTwinVectorArray tvArrExp;
	double dAngStt	= GetAngleJijum(0).GetAngleDegree();

	// 우측 거리 조정
	CTwinVector tvExp;
	CTwinVector tv, tvStt, tvEnd;
	CTwinVectorArray tvArrPlane;
	tvStt	= GetTvJijum(0, -m_dWS);
	tvEnd	= GetTvJijum(m_nQtyJigan, m_dWE);
	GetSwap(tvStt.m_v1, tvStt.m_v2);
	GetSwap(tvEnd.m_v1, tvEnd.m_v2);
	if(bStt && !bLeft)
	{
		if(dAngStt > 90 && m_tvArrPlane1DanOrg.GetTvByInfo("우측(시점우측가각부)", tv))
		{
			m_tvArrPlane1DanOrg.GetTvArrByInfo("우측(시점우측가각부)", tvArrExp, FALSE, TRUE);
			CTwinVector tvSttTmp	= m_tvArrPlane1DanOrg.GetTvByInfo("시점");
			CDPoint xy	= tvArrExp.GetAt(0).m_v1;
			CDPoint xyDir	= GetAngleAzimuthJijum(0).Rotate90();
			CDPoint xyMatch	= CDPoint(0, 0);
			GetXyMatchLineAndLine(tvSttTmp.m_v1, tvSttTmp.GetXyDir(), xy, xyDir, xyMatch);
			dDiff	= ~(tvStt.m_v1 - xyMatch);
		}
	}

	if(!bStt && bLeft)
	{
		// 좌측 거리 조정
		if(dAngStt > 90 && m_tvArrPlane1DanOrg.GetTvByInfo("좌측(종점좌측가각부)", tv))
		{
			m_tvArrPlane1DanOrg.GetTvArrByInfo("좌측(종점좌측가각부)", tvArrExp, FALSE, TRUE);
			CTwinVector tvEndTmp	= m_tvArrPlane1DanOrg.GetTvByInfo("종점");
			CDPoint xy	= tvArrExp.GetAt(0).m_v1;
			CDPoint xyDir	= GetAngleAzimuthJijum(m_nQtyJigan).Rotate90();
			CDPoint xyMatch	= CDPoint(0, 0);
			GetXyMatchLineAndLine(tvEndTmp.m_v1, tvEndTmp.GetXyDir(), xy, xyDir, xyMatch);
			dDiff	= ~(tvEnd.m_v2 - xyMatch);
		}
	}

	if(bStt && bLeft)
	{
		// 좌측 거리 조정
		if(dAngStt < 90 && m_tvArrPlane1DanOrg.GetTvByInfo("좌측(시점좌측가각부)", tv))
		{
			m_tvArrPlane1DanOrg.GetTvArrByInfo("좌측(시점좌측가각부)", tvArrExp, FALSE, TRUE);
			CTwinVector tvSttTmp	= m_tvArrPlane1DanOrg.GetTvByInfo("시점");
			CDPoint xy	= tvArrExp.GetAt(tvArrExp.GetSize()-1).m_v2;
			CDPoint xyDir	= GetAngleAzimuthJijum(0).Rotate90();
			CDPoint xyMatch	= CDPoint(0, 0);
			GetXyMatchLineAndLine(tvSttTmp.m_v1, tvSttTmp.GetXyDir(), xy, xyDir, xyMatch);
			dDiff	= ~(tvStt.m_v2 - xyMatch);
		}
	}

	if(!bStt && !bLeft)
	{
		// 우측 거리 조정
		if(dAngStt < 90 && m_tvArrPlane1DanOrg.GetTvByInfo("우측(종점우측가각부)", tv))
		{
			m_tvArrPlane1DanOrg.GetTvArrByInfo("우측(종점우측가각부)", tvArrExp, FALSE, TRUE);
			CTwinVector tvEndTmp	= m_tvArrPlane1DanOrg.GetTvByInfo("종점");
			CDPoint xy	= tvArrExp.GetAt(tvArrExp.GetSize()-1).m_v2;
			CDPoint xyDir	= GetAngleAzimuthJijum(m_nQtyJigan).Rotate90();
			CDPoint xyMatch	= CDPoint(0, 0);
			GetXyMatchLineAndLine(tvEnd.m_v1, tvEnd.GetXyDir(), xy, xyDir, xyMatch);
			dDiff	= ~(tvEnd.m_v1 - xyMatch);
		}
	}

	return dDiff;
}


void CRcBridgeRebar::SetXyArrConvertRebarVirtualLow(CDPointArray &xyArr, BOOL bStt, BOOL bLeft)
{
	CDPointArray xyArrTemp;
	CWingWall *pWing = GetWingWall(bStt, bLeft);

	BOOL bRangEnd = pWing->m_bRAngEnd;
	BOOL bTwoBase = (pWing->m_dL2!=0 && pWing->m_dL1!=0) ? TRUE : FALSE;

	BOOL bSide		= (pWing->m_nAttachPos == 0 )? FALSE : TRUE;
	CDPoint vAng = GetAngleWingWallBetweenWall(bStt, bLeft);
	double dAngle = (bStt==bLeft)? 180-vAng.GetAngleDegree():vAng.GetAngleDegree();
	BOOL bSideAngAffect = (vAng.GetAngleDegree() < 90);

	if(!(pWing->m_nDirHunch==1 && !pWing->m_bRAngEnd) || (dAngle==90)) return;


	if(bSide)
	{
		double dAngJijum = GetAngleJijum(bStt? 0 : m_nQtyJigan).GetAngleDegree();
		double dAngA1 = (dAngle - dAngJijum) * (bLeft? -1 : 1);
		if((bStt && bLeft) || (!bStt && !bLeft))
		{
			dAngJijum = 180 - dAngJijum;
			dAngA1	= (dAngle - dAngJijum) * (bLeft ? 1 : -1);
		}
		
		if(!pWing->m_bRAngEnd) dAngle = dAngA1;
		bSideAngAffect = (dAngle < 90);
	}
	
	double dT1 = pWing->m_dT1;
	double dT2 = pWing->m_dT2;
	//double dDist1 = (dAngle==90)? 0.0 : fabs((dT1 - m_dCoverWingIn[0] - m_dCoverWingOut[0] - REBAR_RADIUS*2)/tan(ToRadian(dAngle)));
	//double dDist2 = (dAngle==90)? 0.0 : fabs((dT2 - m_dCoverWingIn[0] - m_dCoverWingOut[0] - REBAR_RADIUS*2)/tan(ToRadian(dAngle)));	
	//double dDistGap = dDist2 - dDist1;
	double dDistGap = (dAngle==90)? 0.0 : fabs((dT2 - dT1)/tan(ToRadian(dAngle)));	


	if(bSideAngAffect == FALSE)		// 철근이 빠져야 하는 경우
	{
		xyArrTemp = xyArr;
		xyArr.RemoveAll();

		long nSize = xyArrTemp.GetSize();
		double dDistExt = dDistGap;
		long i=0; for(i=0; i<nSize; i++)
		{
			// 이조건은 뭐지? 끝단직각이 아닌고 D구간이 없으면 철근이 다 빠지는데?
			//if(!bRangEnd && !bTwoBase)
			//	continue;

			CDPoint xyR = xyArrTemp.GetAt(i);
			if(dDistExt == 0)
			{
				xyArr.Add(xyR);
				continue;
			}

			for(long j=0; j<xyR.x; j++)
			{
				if(dDistExt >= xyR.y - 100) dDistExt -= xyR.y;
				//if(dDistExt < xyR.y)
				else
				{
					if(dDistExt != 0)
					{
						// (ARCBRIDGE-2743) 철근이 빠져야 되는경우 인데 들어가고 있다.
// 						if(dDistExt > 50) xyArr.Add(CDPoint(1, dDistExt));
// 						else
// 						{
// 							xyArr.Add(CDPoint(1, dDistExt+xyR.y));
// 							j +=1;
// 						}
						xyArr.Add(CDPoint(1, fabs(xyR.y - dDistExt)));
					}
					if(j != xyR.x-1)
					{
						xyArr.Add(CDPoint(xyR.x-(j+1), xyR.y));
					}
					dDistExt = 0;
					break;
				}
			}
		}
	}
	else					// 철근이 추가되어야 하는 경우
	{
		xyArr.InsertAt(0, CDPoint(1, dDistGap));
	}
}

//날개벽 단면도에서 기초와 날개벽 연결 여부(기초와 연결 되지 않는 다면 FALSE)
BOOL CRcBridgeRebar::IsWindWallSectionExistFoot(BOOL bStt, BOOL bLeft, long nOut, int nDan)
{
	BOOL bExistWingWallFoot = FALSE;

	CTwinVectorArray tvArrGen;
	CTwinVector tvOut, tvHuPrev, tvHuNext, tvHunch, tvEnd, tvLower, tvFoot, tvFootHunch;
	GetTvWingWallSection(bStt, bLeft, tvArrGen);

	tvArrGen.GetTvByInfo(_T("날개벽단면외측"), tvOut);
	tvArrGen.GetTvByInfo(_T("날개벽단면내측헌치전"), tvHuPrev);
	tvArrGen.GetTvByInfo(_T("날개벽단면내측헌치후"), tvHuNext);
	tvArrGen.GetTvByInfo(_T("날개벽단면내측헌치"), tvHunch);
	tvArrGen.GetTvByInfo(_T("날개벽단면노리끝"), tvEnd);
	tvArrGen.GetTvByInfo(_T("날개벽단면하단"), tvLower);
	tvArrGen.GetTvByInfo(_T("날개벽단면기초"), tvFoot);
	tvArrGen.GetTvByInfo(_T("날개벽단면기초헌치"), tvFootHunch);

	double dR = GetWingWallVertRebarCurveRadius(bStt, bLeft, nOut, nDan);
	if(dR > 0)
	{
		bExistWingWallFoot = TRUE;
	}
	else
	{
		CDPoint xyMat;
		CTwinVector tvLast = tvFootHunch.GetLength() > 0? tvFootHunch : tvHuNext;

		BOOL bMat = GetXyMatchSegAndLine(tvLast.m_v1, tvLast.m_v2, tvFoot.m_v1, tvFoot.GetXyDir(),  xyMat);
		if(bMat)
			bExistWingWallFoot = TRUE;	
	}
	
	return bExistWingWallFoot;
}


// 2,3단 주철근 초기화
void CRcBridgeRebar::Clear23DanMainRebar()
{
	long upper(0), cycle(0), dan(0), left(0), inner(0), stt(0);
	long i(0), j(0);

	// 상부슬래브
	for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
	{
		for(upper = 0; upper < 2; upper++)
		{
			for(dan = 1; dan < MAX_REBAR_DAN; dan++)
			{
				// 철근 직경
				for(i = 0; i < m_pArrDiaUpperSlab[cycle][upper][dan].GetSize(); i++)
				{
					CDoubleArray *pDArr	= m_pArrDiaUpperSlab[cycle][upper][dan].GetAt(i);
					for(j = 0; j < pDArr->GetSize(); j++)
					{
						pDArr->SetAt(j, 0.0);
					}
				}

				for(i = 0; i < m_pArrExistUpperSlab[cycle][upper][dan].GetSize(); i++)
				{
					CDoubleArray *pDArr	= m_pArrExistUpperSlab[cycle][upper][dan].GetAt(i);
					for(j = 0; j < pDArr->GetSize(); j++)
					{
						pDArr->SetAt(j, (double)FALSE);
					}
				}

				for(i = 0; i < m_pArrDistUpperSlab[cycle][upper][dan].GetSize(); i++)
				{
					CDoubleArray *pDArr	= m_pArrDistUpperSlab[cycle][upper][dan].GetAt(i);
					for(j = 0; j < pDArr->GetSize(); j++)
					{
						pDArr->SetAt(j, 0.0);
					}
				}

				// 하부 슬래브
				for(i = 0; i < m_pArrDiaLowerSlab[cycle][upper][dan].GetSize(); i++)
				{
					CDoubleArray *pDArr	= m_pArrDiaLowerSlab[cycle][upper][dan].GetAt(i);
					for(j = 0; j < pDArr->GetSize(); j++)
					{
						pDArr->SetAt(j, 0.0);
					}
				}

				for(i = 0; i < m_pArrExistLowerSlab[cycle][upper][dan].GetSize(); i++)
				{
					CDoubleArray *pDArr	= m_pArrExistLowerSlab[cycle][upper][dan].GetAt(i);
					for(j = 0; j < pDArr->GetSize(); j++)
					{
						pDArr->SetAt(j, (double)FALSE);
					}
				}

				for(i = 0; i < m_pArrDistLowerSlab[cycle][upper][dan].GetSize(); i++)
				{
					CDoubleArray *pDArr	= m_pArrDistLowerSlab[cycle][upper][dan].GetAt(i);
					for(j = 0; j < pDArr->GetSize(); j++)
					{
						pDArr->SetAt(j, 0.0);
					}
				}
			}
		}
	}

	// 외측벽체
	for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
	{
		for(stt = 0; stt < 2; stt++)
		{
			for(inner = 0; inner < 2; inner++)
			{
				for(dan = 1; dan < MAX_REBAR_DAN; dan++)
				{
					for(i = 0; i < m_pArrDiaOutWall[cycle][stt][inner][dan].GetSize(); i++)
					{
						m_pArrDiaOutWall[cycle][stt][inner][dan].SetAt(i, 0.0);
					}

					for(i = 0; i < m_pArrExistOutWall[cycle][stt][inner][dan].GetSize(); i++)
					{
						m_pArrExistOutWall[cycle][stt][inner][dan].SetAt(i, (double)FALSE);
					}

					for(i = 0; i < m_pArrDistOutWall[cycle][stt][inner][dan].GetSize(); i++)
					{
						m_pArrDistOutWall[cycle][stt][inner][dan].SetAt(i, 0.0);
					}
				}
			}
		}
	}
	
	// 내측벽체
	long nCountInWall	= GetCountInWall();
	for(long wall = 0; wall < nCountInWall; wall++)
	{
		CWallApp *pWall	= GetInWall(wall);
		if(!pWall) continue;

		for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle++)
		{
			for(left = 0; left < 2; left++)
			{
				for(dan = 1; dan < MAX_REBAR_DAN; dan++)
				{
					for(i = 0; i < pWall->m_dArrDiaRC[cycle][left][dan].GetSize(); i++)
					{
						pWall->m_dArrDiaRC[cycle][left][dan].SetAt(i, 0.0);
					}

					for(i = 0; i < pWall->m_dArrExistRC[cycle][left][dan].GetSize(); i++)
					{
						pWall->m_dArrExistRC[cycle][left][dan].SetAt(i, (BOOL)FALSE);
					}

					for(i = 0; i < pWall->m_dArrDistRC[cycle][left][dan].GetSize(); i++)
					{
						pWall->m_dArrDistRC[cycle][left][dan].SetAt(i, 0.0);
					}
				}
			}
		}
	}
}



double CRcBridgeRebar::GetRebarCtcWingwall(BOOL bStt, BOOL bLeft, long nSect, BOOL bFront, BOOL bMain, long nDan)
{
	double dCtc = 0;
	long nOut = bFront ? 1 : 0;
	CDPointArray xyArr;

	CWingWall *pWing = GetWingWall(bStt, bLeft);
	double dDistSum = 0;
	double dCheckDist = 0;
	double dHeight = 0;
	double dHgtB = GetLengthWingWallBlockBC(bStt, bLeft, FALSE);
	long i=0; for(i=0; i<pWing->m_xyArrSide[0][nDan].GetSize(); i++)
	{
		CDPoint xyR = pWing->m_xyArrSide[0][nDan].GetAt(i);
		dHeight += xyR.x * xyR.y;
	}

	if(nSect == WINGWALL_SECTA)
	{
		xyArr = bMain? pWing->m_xyArrSide[nOut][nDan] : pWing->m_xyArrUpper[nOut][nDan];
		dCheckDist = bMain? (dHgtB + (dHeight-dHgtB)/2) : (pWing->m_dL1 + pWing->m_dStdVerCTC);	
	}
	else if(nSect == WINGWALL_SECTB)
	{
		xyArr = bMain? pWing->m_xyArrSide[nOut][nDan] : pWing->m_xyArrLower[nOut][nDan];
		dCheckDist = bMain? dHgtB/2 : pWing->m_dStdVerCTC;	
	}
	else if(nSect == WINGWALL_SECTC)
	{
		xyArr = bMain? pWing->m_xyArrLower[nOut][nDan] : pWing->m_xyArrSide[nOut][nDan];
		dCheckDist = bMain?  (pWing->m_dStdVerCTC) : dHgtB/2;	
	}
	else if(nSect == WINGWALL_SECTD)
	{
		xyArr = bMain? pWing->m_xyArrSide[nOut][nDan] : pWing->m_xyArrUpper[nOut][nDan];
		dCheckDist = bMain? (dHeight-(pWing->m_dHL+pWing->m_dL1 / pWing->m_dSW)/2) : pWing->m_dStdVerCTC;
	}

	long nCnt = xyArr.GetSize();
	for(i=0; i<nCnt; i++)
	{
		CDPoint xyR = xyArr.GetAt(i);
		
		if(dDistSum < dCheckDist && dDistSum+(xyR.x*xyR.y) > dCheckDist)
		{
			if(xyR.x > 1)
			{
				dCtc = xyR.y;
				break;
			}
			else
			{
				if(nCnt>i+1) 
				{
					xyR = xyArr.GetAt(i+1);
					if(xyR.x > 1) 
					{
						dCtc = xyR.y;
						break;
					}
					else if(i == nCnt-2)
					{
						dCtc = xyR.y;
					}
				}
				else if(nCnt>1)
				{
					xyR = xyArr.GetAt(i-1);
					if(xyR.x > 1) 
					{
						dCtc = xyR.y;
						break;
					}
				}
				else dCtc = xyR.y;
			}
		}
		dDistSum += (xyR.x*xyR.y);
	}

	if(nSect == WINGWALL_SECTD && bMain && !bFront && pWing->m_bSelMainCTCD) dCtc = dCtc*2;
	if(dCtc ==0 && nCnt > 0)
	{
		dCtc = xyArr.GetAt(0).y;
	}

	return dCtc;
}

// 거더 스터럽 철근 초기 권고안
void CRcBridgeRebar::SetDataDefaultGirderStirrupFirst()
{
	for(long nSlab = iUPPER ; nSlab <= iLOWER; nSlab++)
	{
		for(long jijum = 0; jijum < GetCountJijum(); jijum++)
		{
			CGirderSectionRebar *pGS	= &m_SlabGirderRebar[nSlab][jijum];
			pGS->m_nCountStirrup	= 1;
			pGS->m_xyDistStirrup[0].x	= 0;
			pGS->m_xyDistStirrup[0].y	= GetWidthHunchBottomByJijum(jijum, nSlab) - (m_dCoverUpper_UpperSlab[0] * 2);
		}
	}
}


// 종거더 시작이나 끝 각도
CDPoint CRcBridgeRebar::GetAngleJongGirder(BOOL bStt, BOOL bLeft, BOOL bGagak, BOOL bRetSttAngle)
{
	long left	= bLeft ? iLEFT : iRIGHT;
	double dSta	= bRetSttAngle ? GetStationForInputJongGirder(bStt, bLeft, bGagak) : GetStationForInputJongGirder(bStt, bLeft, bGagak) + m_dLengthBridge;
	
	if(bGagak)
	{
	}
	else
	{
		dSta += bRetSttAngle ? m_dDistGirderRebarJong[left][iSTT] : -m_dDistGirderRebarJong[left][iEND];
	}

	long nJ	= GetJijumNumberByStation(dSta);
	double dStaJijum	= GetStationOnJijum(nJ);
	CDPoint vAngAZ		= GetAngleAzimuthJijum(nJ);
	CLineInfo *pLine	= GetLineBase();
	CDPoint vAng	= pLine->GetAngleByOffsetWidth(dStaJijum, dStaJijum-dSta, vAngAZ);

	return vAng;
}


// 배력근을 가각부에 교차되는 부분에 대해서 구분함(집계및 마크용)
// tvArr에서 가각 변수로 분리됨(tvArr은 분리되고 남는거)
void CRcBridgeRebar::DivideRebarSupport_Plane_UpperSlabExpSection(CTwinVectorArray &tvArr, CTwinVectorArray &tvArrSttLeftAndRight, CTwinVectorArray &tvArrSttLeftOrRight, CTwinVectorArray &tvArrEndLeftAndRight, CTwinVectorArray &tvArrEndLeftOrRight)
{
	tvArrSttLeftAndRight.RemoveAll();
	tvArrSttLeftOrRight.RemoveAll();
	tvArrEndLeftAndRight.RemoveAll();
	tvArrEndLeftOrRight.RemoveAll();
	if(!m_bIsExp) return;

	CTwinVector tv;
	long i = 0; for(i = 0; i < tvArr.GetSize(); i++)
	{
		tv	= tvArr.GetAt(i);

		if(tv.m_sInfo.Find("시점좌측가각부", 0) != -1 && tv.m_sInfo.Find("시점우측가각부", 0) != -1)
		{
			tvArrSttLeftAndRight.Add(tv);
			tvArr.RemoveAt(i);
			i--;
		}
		else if(tv.m_sInfo.Find("시점좌측가각부", 0) != -1 || tv.m_sInfo.Find("시점우측가각부", 0) != -1)
		{
			tvArrSttLeftOrRight.Add(tv);
			tvArr.RemoveAt(i);
			i--;
		}
		else if(tv.m_sInfo.Find("종점좌측가각부", 0) != -1 && tv.m_sInfo.Find("종점우측가각부", 0) != -1)
		{
			tvArrEndLeftAndRight.Add(tv);
			tvArr.RemoveAt(i);
			i--;
		}
		else if(tv.m_sInfo.Find("종점좌측가각부", 0) != -1 || tv.m_sInfo.Find("종점우측가각부", 0) != -1)
		{
			tvArrEndLeftOrRight.Add(tv);
			tvArr.RemoveAt(i);
			i--;
		}
	}
}

// 가각부 상부 슬래브 주철근 단수 결정
long CRcBridgeRebar::GetDanMainRebarUpperSlabExp(long nCycle, BOOL bUpper, BOOL bStt)
{
	long upper	= bUpper ? iUPPER : iLOWER;
	long nSize = m_pArrSetRebarDanUpperSlab[upper].GetSize();
	long nIdx	= bStt ? 0 : m_pArrSetRebarDanUpperSlab[upper].GetSize()-1;
	if(nIdx < 0 || nIdx >= nSize) return 1;

	CSetRebarDan *pRD	= m_pArrSetRebarDanUpperSlab[upper].GetAt(nIdx);

	long nDan	= pRD->m_nCountDan;
	if(nDan < 1 || nDan > MAX_REBAR_DAN) 
	{
		nDan = 1;
	}

	long nDanReal	= 1;

	if(m_bDetailInput23DanMainRebar)
	{
		long dan = 0; for(dan = 1; dan < MAX_REBAR_DAN; dan++)
		{
			BOOL bOKDia	= FALSE;
			BOOL bOKExist	= FALSE;
			if(m_pArrDiaUpperSlab[nCycle][upper][dan].GetSize() == 0) continue;
			CDoubleArray *pDArr	= m_pArrDiaUpperSlab[nCycle][upper][dan].GetAt(bStt ? 0 : m_pArrDiaUpperSlab[nCycle][upper][dan].GetSize()-1);
			if(pDArr->GetSize() > 0)
			{
				bOKDia	= pDArr->GetAt(bStt ? 0 : pDArr->GetSize()-1) > 0;

				pDArr	= m_pArrExistUpperSlab[nCycle][upper][dan].GetAt(bStt ? 0 : m_pArrExistUpperSlab[nCycle][upper][dan].GetSize()-1);
				bOKExist	= (BOOL)pDArr->GetAt(bStt ? 0 : pDArr->GetSize()-1) == TRUE;

				if(bOKDia && bOKExist)
					nDanReal++;
			}
		}
	}
	else
	{
		long i = 0; for(i = 1; i < nDan; i++)
		{
			if(pRD->m_dDia[nCycle][i] > 0)
				nDanReal++;
		}

		if(nDanReal < 1 || nDanReal > MAX_REBAR_DAN) 
		{
			nDanReal = 1;
		}
	}

	return nDanReal;
}

void CRcBridgeRebar::SaveCountJointMainRebar()
{
	// 이음 개수
	long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
	{
		long upper = 0; for(upper = 0; upper < 2; upper++)
		{
			long i = 0; for(i = 0; i < MAX_JIJUM_COUNT_RC; i++)
			{
				m_nCountJointMainRebar_UpperSlab_Cycle1_Old[i][upper][dan]	= m_nCountJointMainRebar_UpperSlab_Cycle1[i][upper][dan];	// 상부슬래브 상,하면 각 지간별 이음 개수
				m_nCountJointMainRebar_UpperSlab_Cycle2_Old[i][upper][dan]	= m_nCountJointMainRebar_UpperSlab_Cycle2[i][upper][dan];	// 상부슬래브 상,하면 각 지간별 이음 개수

				m_nCountJointMainRebar_LowerSlab_Cycle1_Old[i][upper][dan]	= m_nCountJointMainRebar_LowerSlab_Cycle1[i][upper][dan];	// 하부슬래브 상,하면 각 지간별 이음 개수
				m_nCountJointMainRebar_LowerSlab_Cycle2_Old[i][upper][dan]	= m_nCountJointMainRebar_LowerSlab_Cycle2[i][upper][dan];	// 하부슬래브 상,하면 각 지간별 이음 개수
			}
		}

		long stt = 0; for(stt = 0; stt < 2; stt++)
		{
			long left = 0; for(left = 0; left < 2; left++)
			{
				m_nCountJointMainRebar_OutWall_Cycle1_Old[stt][left][dan]	= m_nCountJointMainRebar_OutWall_Cycle1[stt][left][dan];	// 외측벽체 시종점,좌우측 이음 개수
				m_nCountJointMainRebar_OutWall_Cycle2_Old[stt][left][dan]	= m_nCountJointMainRebar_OutWall_Cycle2[stt][left][dan];	// 외측벽체 시종점,좌우측 이음 개수
			}
		}

		for(upper = 0; upper < 2; upper++)
		{
			m_nCountJointMainRebar_ArchRib_Cycle1_Old[upper][dan]	= m_nCountJointMainRebar_ArchRib_Cycle1[upper][dan];	// 리브 상하면,1~3단 이음 개수(리브만 특별히 각 단에 대해서 이음을 입력받음)
			m_nCountJointMainRebar_ArchRib_Cycle2_Old[upper][dan]	= m_nCountJointMainRebar_ArchRib_Cycle2[upper][dan];	// 리브 상하면,1~3단 이음 개수(리브만 특별히 각 단에 대해서 이음을 입력받음)
		}
	}

	for(long wall = 0; wall < GetCountInWall(); wall++)
	{
		CWallApp *pWall	= GetInWall(wall);
		if(!pWall) continue;

		pWall->SaveCountJointRebar();
	}
}

void CRcBridgeRebar::CalcCouplerRebar(CDPointArray &xyArrRoundRebar, CDPointArray &xyArrMainRebar, CTypedPtrArray <CObArray, CRebar*> *pArrRebar)
{
	xyArrRoundRebar.RemoveAll();
	xyArrMainRebar.RemoveAll();

	
	long i = 0; for(i = 0; i < pArrRebar->GetSize(); i++)
	{
		CRebar *pRB	= NULL;
		pRB	= pArrRebar->GetAt(i);
		if(!pRB->IsTrue()) continue;

		if(pRB->m_nTypeRebar == 34 && pRB->m_nJoint > 0)
		{
			AddCoupler(xyArrMainRebar, pRB->m_nEa, pRB->m_dDia);
		}
		else
		{
			if(pRB->m_nTypeRebar == 30 || pRB->m_nTypeRebar == 54 || pRB->m_nTypeRebar == 56 || pRB->m_nTypeRebar == 52)
				AddCoupler(xyArrRoundRebar, pRB->m_nEa * 2, pRB->m_dDia);
			else if(pRB->m_nTypeRebar == 69 || pRB->m_nTypeRebar == 70 || pRB->m_nTypeRebar == 71 || pRB->m_nTypeRebar == 72)
				AddCoupler(xyArrRoundRebar, pRB->m_nEa * 1, pRB->m_dDia);
		}
	}

	xyArrRoundRebar.Sort(FALSE);
	xyArrMainRebar.Sort(FALSE);
}

void CRcBridgeRebar::AddCoupler(CDPointArray &xyArr, long nEa, double dDia)
{
	BOOL bAdd	= FALSE;

	long i = 0; for(i = 0; i < xyArr.GetSize(); i++)
	{
		if(Compare(xyArr.GetAt(i).y, dDia, "="))
		{
			xyArr.SetAt(i, CDPoint(xyArr.GetAt(i).x + nEa, dDia));
			bAdd	= TRUE;
			break;
		}
	}

	if(!bAdd)
	{
		xyArr.Add(CDPoint(nEa, dDia));
	}
}

BOOL CRcBridgeRebar::IsCoupler(CTypedPtrArray <CObArray, CRebar*> *pArrRebar)
{
	CDPointArray xyArrRoundRebar;
	CDPointArray xyArrMainRebar;

	CalcCouplerRebar(xyArrRoundRebar, xyArrMainRebar, pArrRebar);


	return xyArrRoundRebar.GetSize() + xyArrMainRebar.GetSize() > 0;
}


// nIdx에 해당하는 철근의 주인철근을 리턴
// 슬래브 표준도 작업할때만 필요
// 같은 cycle, dan, bUpper에서 철근형태가 같으면 인덱스가 작은것을 리턴하게 됨
// 단 bExist = TRUE이어야 함.
CRebarInfoCycle* CRcBridgeRebar::GetOwerRebarInfoCycleSlab(BOOL bUpperSlab, long nCycle, long nDan, BOOL bUpper, long nIdx)
{
	if(m_pARcBridgeDataStd->m_nTypeProcess == TYPE_PROCESS_NORMAL || nIdx == 0)
	{
		if(bUpperSlab)
			return GetRebarInfoCycleUpperSlab(nCycle, nDan, bUpper, nIdx);
		else
			return GetRebarInfoCycleLowerSlab(nCycle, nDan, bUpper, nIdx);
	}

	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return FALSE;
	if(nDan == -1) nDan = MAX_REBAR_DAN-1;
	if(nDan < 0 || nDan > MAX_REBAR_DAN-1) return FALSE;

	// 필요한 RebarInfoCycle 배열을 찾음
	long upper	= bUpper ? iUPPER : iLOWER;
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = bUpperSlab? &m_pArrRCMainUpperSlab[nCycle][upper][nDan] : &m_pArrRCMainLowerSlab[nCycle][upper][nDan];
	if(!pArrRC) return NULL;

	long nSize	= pArrRC->GetSize();
	if(nIdx == -1) nIdx = nSize-1;
	if(nIdx >= nSize) return NULL;
	if(nIdx < 0) return NULL;

	CRebarInfoCycle *pRC	= GetOwnerRebarInfoCycle(pArrRC, nIdx);

	return pRC;
}

CRebarInfoCycle* CRcBridgeRebar::GetOwnerRebarInfoCycle(CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC, long nIdx)
{
	if(!pArrRC) return NULL;
	if(pArrRC->GetSize() <= nIdx) return NULL;

	CRebarInfoCycle *pRC	= pArrRC->GetAt(nIdx);

	// 가장먼저 나오는 같은 철근을 리턴한다.
	long i = 0; for(i = 0; i < pArrRC->GetSize(); i++)
	{
		CRebarInfoCycle *pRCOwner	= pArrRC->GetAt(i);
		if(i == nIdx) return pRC;

		if(!pRCOwner->m_bExist) continue;
		if(!Compare(pRC->m_Dia, pRCOwner->m_Dia, "=")) continue;

		if(i == 0 && nIdx == pArrRC->GetSize()-1)
		{
			if(Compare(pRC->GetLength(), pRCOwner->GetLength(), "=")) return pRCOwner;
		}

		if(!Compare(pRC->GetLengthStt(), pRCOwner->GetLengthStt(), "=")) continue;
		if(!Compare(pRC->GetLengthMid(), pRCOwner->GetLengthMid(), "=")) continue;
		if(!Compare(pRC->GetLengthEnd(), pRCOwner->GetLengthEnd(), "=")) continue;

		return pRCOwner;
	}

	return pRC;
}

// bStt, bLeft, bUpper의 주인철근 리턴
// 슬래브 표준도일때만 가능
CRebarInfoCycle* CRcBridgeRebar::GetOwnerRebarInfoCycleObtuseAngle(BOOL bStt, BOOL bLeft, BOOL bUpper, BOOL bLowSlab)
{
	long stt	= bStt ? iSTT : iEND;
	long left	= bLeft ? iLEFT : iRIGHT;
	long upper	= bUpper ? iUPPER : iLOWER;
	BOOL bBoxType = IsBoxType();

	CRebarInfoCycle *pRC	= NULL;
	if(!bLowSlab || !bBoxType)
		pRC= &m_rebarInfoCycle_ObtuseAngle_Upperslab[stt][left][upper];
	else
		pRC= &m_rebarInfoCycle_ObtuseAngle_Lowerslab[stt][left][upper];
	if(stt == 0 && left == 0) return pRC;

	if(m_pARcBridgeDataStd->m_nTypeProcess != TYPE_PROCESS_SLAB_STANDARD_OUTPUT) return pRC;


	long s = 0; for(s = 0; s < 2; s++)
	{
		for(long l = 0; l < 2; l++)
		{
			if(s == stt && l == left) return pRC;

			if(!IsSameRebarObtusAngle(bStt, bLeft, s == iSTT, l == iLEFT)) continue;

			if(!bLowSlab || !bBoxType)
				return &m_rebarInfoCycle_ObtuseAngle_Upperslab[s][l][upper];
			else
				return &m_rebarInfoCycle_ObtuseAngle_Lowerslab[s][l][upper];
		}
	}

	return pRC;
}

// 둔각부 배력근 주인철근 찾기
// 주철근과 배력근이 모두 같아야 됨.
void CRcBridgeRebar::GetOwnerRebarSupportObtuseAngle(BOOL bStt, BOOL bLeft, BOOL &bSttOwner, BOOL &bLeftOwner)
{
	bSttOwner	= bStt;
	bLeftOwner	= bLeft;

	long stt	= bStt ? iSTT : iEND;
	long left	= bLeft ? iLEFT : iRIGHT;

	long s = 0; for(s = 0; s < 2; s++)
	{
		for(long l = 0; l < 2; l++)
		{
			if(s == stt && l == left) return;

			if(IsSameRebarObtusAngle(bStt, bLeft, s==iSTT, l==iLEFT))
			{
				bSttOwner	= s == iSTT;
				bLeftOwner	= l == iLEFT;

				return;
			}
		}
	}
}

// bStt1, bLeft1 vs bStt2, bLeft2의 주철근 배력근이 모두 같은지?(상하면 모두 같아야 됨)
BOOL CRcBridgeRebar::IsSameRebarObtusAngle(BOOL bStt1, BOOL bLeft1, BOOL bStt2, BOOL bLeft2)
{
	if(bStt1 == bStt2 && bLeft1 == bLeft2) return TRUE;

	long stt1	= bStt1 ? iSTT : iEND;
	long stt2	= bStt2 ? iSTT : iEND;
	long left1	= bLeft1 ? iLEFT : iRIGHT;
	long left2	= bLeft2 ? iLEFT : iRIGHT;


	long upper = 0; for(upper = 0; upper < 2; upper++)
	{
		BOOL bUpper	= upper == iUPPER;

		// 주철근 검사
		CRebarInfoCycle *pRC1	= &m_rebarInfoCycle_ObtuseAngle_Upperslab[stt1][left1][upper];
		CRebarInfoCycle *pRC2	= &m_rebarInfoCycle_ObtuseAngle_Upperslab[stt2][left2][upper];
		CPlaceRebarByBlock *pPlace1	= &m_placeByBlock_ObtuseAngle_Main_UpperSlab[stt1][left1][upper];
		CPlaceRebarByBlock *pPlace2	= &m_placeByBlock_ObtuseAngle_Main_UpperSlab[stt2][left2][upper];

		if(!pRC1->m_bExist || !pRC2->m_bExist) return FALSE;
		if(!Compare(pRC1->m_Dia, pRC2->m_Dia, "=")) return FALSE;
		if(!Compare(pRC1->GetLength(), pRC2->GetLength(), "=")) return FALSE;
		if(pPlace1->m_xyArr != pPlace2->m_xyArr) return FALSE;

		// 배력근 검사
		// 개수, 직경, 하나의 길이
		CTwinVectorArrayArray pTvArr;
		CTwinVectorArray tvArr1, tvArr2;
		pPlace1	= &m_placeByBlock_ObtuseAngle_Support_UpperSlab[stt1][left1][upper];
		pPlace2	= &m_placeByBlock_ObtuseAngle_Support_UpperSlab[stt2][left2][upper];

		GetTvRebarMain_Plane_Slab_Obtuse(&pTvArr, tvArr1, bStt1, bLeft1, bUpper);
		GetTvRebarMain_Plane_Slab_Obtuse(&pTvArr, tvArr2, bStt2, bLeft2, bUpper);

		AhTPADelete(&pTvArr, (CTwinVectorArray*)0);

		if(!Compare(pPlace1->m_dDia, pPlace2->m_dDia, "=")) return FALSE;
		if(tvArr1.GetSize() != tvArr2.GetSize()) return FALSE;
		if(tvArr1.GetSize() > 0)
		{
			if(!Compare(tvArr1.GetAt(0).GetLength(), tvArr2.GetAt(0).GetLength(), "=")) return FALSE;
		}
	}

	return TRUE;
}

// dSta에 주철근이 있는지 판단
BOOL CRcBridgeRebar::IsRebarMainBySta(BOOL bUpperSlab, double dSta, long nCycle, BOOL bUpper, long nDan, long &nIdxFind)
{
	BOOL bFind	= FALSE;
	
	// 철근이 없다면 그냥 리턴
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = NULL;
	if(bUpperSlab)
		pArrRC = &m_pArrRCMainUpperSlab[nCycle==-1?0:nCycle][bUpper ? iUPPER : iLOWER][nDan];
	else
		pArrRC = &m_pArrRCMainLowerSlab[nCycle==-1?0:nCycle][bUpper ? iUPPER : iLOWER][nDan];

	if(pArrRC == NULL) return bFind;

	long i = 0; for(i = 0; i < pArrRC->GetSize(); i++)
	{
		CRebarInfoCycle *pRC	= pArrRC->GetAt(i);
		if(!pRC->m_bExist) continue;
		double dLeft	= pRC->m_xyStt.x;
		double dRight	= pRC->m_nPosStt == pRC->m_nPosEnd ? pRC->m_xyMid1.x : (pRC->m_bUseEndExt ? pRC->m_xyEndExt.x : pRC->m_xyEnd.x);
		if(dLeft > dRight) GetSwap(dLeft, dRight);
		if(!bUpper && IsFlexibleJointRebar(TRUE, pRC))
		{
			dLeft	= pRC->m_xyMid1.x;
		}
		else if(!bUpper && IsFlexibleJointRebar(FALSE, pRC))
		{
			dRight	= pRC->m_xyMid2.x;
		}
		
		if((fabs(dSta-dLeft) <= 100 || Compare(dSta, dLeft, ">=")) && (fabs(dSta-dRight) <= 100 || Compare(dSta, dRight, "<=")))
		{
			nIdxFind	= i;
			bFind	= TRUE;
			break;
		}
	}

	return bFind;
}

// 단부 철근 개수
// 주철근과 같아야 함
// 단, 가각부가 있으면 가각부 철근 개수도 세야 함.
long CRcBridgeRebar::GetCountRebarDanbu(BOOL bStt, long nCycle, BOOL bUpper)
{
	long stt	= bStt ? iSTT : iEND;

	return m_nCountRebarDanbu[bUpper? iUPPER : iLOWER][nCycle][stt];

// 	long nCount	= 0;
// 
// 	CVectorArray vecArr1, vecArrHunch1;
// 	CVectorArray vecArr2, vecArrHunch2;
// 	double dSta	= GetStationByTarget(bStt ? BRIDGE_OFF_STT_STT : BRIDGE_OFF_END_END, 0, TRUE);
// 	GetXyRebarMain_CrossSection_UpperSlab(vecArr1, vecArrHunch1, dSta, TRUE, 0, nCycle==0?0:1);
// 	GetXyRebarMain_CrossSection_UpperSlab(vecArr2, vecArrHunch2, dSta, TRUE, 0, nCycle==0?2:3);
// 	//double dWidthGagak	= GetWidthSlabActByGagak(dSta, GetAngleJijum(bStt ? 0 : m_nQtyJigan), 0, FALSE) - m_dCoverSide_UpperSlab[0] * 2;
// 	//double dCTC			= GetCtcRebarMain(TRUE)/2;	// 간격
// 
// 	nCount	= vecArr1.GetSize() + vecArr2.GetSize();//dWidthGagak / dCTC;
// 	return nCount;
}

//부상방지저판 전단철근 개수
long CRcBridgeRebar::GetCountShearRebarBFooting()
{
	CTwinVectorArray tvArrTemp;
	long nHoriShear = GetTvRebarShear_VertSection_BFooting(tvArrTemp, TRUE);
	double dSupportWidth = fabs(m_dWidthSlabLeft) + fabs(m_dWidthSlabRight) - m_dCoverSide_UpperSlab[0] * 2;
	double dShearWidth = GetCTCRebarPRF_Main() * m_nPRF_Count_Shear;
	
	//시점, 종점 합해서
	return (long)Round(dSupportWidth / (dShearWidth * 2) * nHoriShear, 0) * 2;
}


void CRcBridgeRebar::SerializeEnv(CArchive &ar)
{
	// 1 : m_nSelectFootingReactionForce;
	// 3 : m_bMaterialDetail, m_Fck[ePartCount], m_Fy[ePartCount], m_Fvy[ePartCount], m_Ec[ePartCount], m_dRateDryAndShrinkage, m_dCoefficientExpansion, m_bIsDBar_ForDowelBar, m_dUnitWeigthBackFillWater, 
	//		m_nSelectWingCalc, m_nTypeDesingEQ, m_dCoffKh_Sei, m_nDegreeEarthQuake, m_nRegionEarthQuake, m_dCoefficientGround, m_gValue, m_nTypeRigidFootingEQ, m_bApplyRigidWallEQRotate, m_nTypeJointPosFootingEQ
	//		m_nTypePropertyPosFootingEQ, m_nTypeSoilPressureEQ, m_nTypeUpperWeightEQ, m_plsdEnvRating, m_bCheckSupportSlabArea, m_bCheckSupportWallArea, m_bCheckSupportFootArea, m_bCheckSupportWingWallArea
	//		m_bCheckSupportApsArea, m_nApplyCalcShearDistSlab, m_nApplyCalcShearDistWall, m_nSelectApsShearCheck, m_nApplyCalcShearDistFrontPile, m_nApplyCalcShearDistBackPile, m_dThetaShearDesign
	//		m_dElasticModularRatioUseCheck, m_nSelectUsebilityCheck, m_nSelectPminColumn, m_bSelectHunchDesignCheck, m_nSelectLiveLoadSpanLength, m_nSelectStartLane, m_bCheckUseri, m_dCheckUseriValue, 
	//		m_bCheckFrontFootTrap2, m_nSelectInWallSectionDesign, m_nSelectTempLoadSlab, m_bSelectHunchModeling, m_nSelectDesignSpanApply, m_nArchRibSectionMomentPos, m_plsdRebar 추가
	// 4 : m_nSelectExposureCoverCheck;
	// 5 : m_bCheckSuppoerBarSlabMainOver20
	// 6 : m_bApplyT1CalcWingWallLeft;
	// 7 : m_bApplyMinAvHyunTa
	// 8 : m_nSelectBM_ConcCare_Cal

	const CString sID	= _T("ARcBridge 설계환경 파일");
	long nFlagEnv = 8;

	if(ar.IsStoring())
	{
		ar << nFlagEnv;
		ar << sID;

		ar << m_nFormType_ConcNormal;
		ar << m_nFormType_Footing;
		ar << m_nFormType_WallFront;
		ar << m_nFormType_WallBack;
		long stt = 0; for(stt = 0; stt < 2; stt++)
		{
			long left = 0; for(left = 0; left < 2; left++)
			{
				ar << m_nFormType_WingFront[stt][left];
				ar << m_nFormType_WingBack[stt][left];
			}
		}

		ar << m_nFormType_Aps;
		ar << m_nFormType_MassConc;
		ar << m_nFormType_LeanConc;
		ar << m_bSelectBM_ConcCare_Main;
		ar << m_bSelectBM_ConcCare_Aps;
		ar << m_nSelectBM_ConcCare_Cal;
		ar << m_nTypeRcBridgeBlock;
		ar << m_dAngleRcBridgeBlock;
		ar << m_bSelectBM_ApsCnsInclude;
		ar << m_nTypeHeightWall;
		ar << m_nTypeSurfaceProof;
		ar << m_nTypePostBaseLine;
		ar << m_dPostLineEL;
		ar << m_nTypeScaffoldBaseLine;
		ar << m_dScaffoldLineEL;
		ar << m_nTypePost;
		ar << m_dThickScaffold;
		ar << m_dAggregate_Footing;
		ar << m_dAggregate_Main;
		ar << m_dAggregate_Aps;
		ar << m_dAggregate_Lean;
		ar << m_dAggregate_Mass;
		ar << m_dAggregate_Etc;
		ar << m_dSlump_Footing;
		ar << m_dSlump_Main;
		ar << m_dSlump_Aps;
		ar << m_dSlump_Lean;
		ar << m_dSlump_Mass;
		ar << m_dSlump_Etc;
		ar << m_nMonumenu;
		ar << m_nDesPanel;
		ar << m_nNamePanel;
		ar << m_nHeightForSlabBM;

		// 신축이음 수량
		for(stt = 0; stt < 2; stt++)
		{
			BOOL bStt	= stt == iSTT;
			CFlexibleJoint *pFx	= bStt ? &m_fxJointStt : &m_fxJointEnd;
			ar << pFx->m_sName;
			ar << pFx->m_rb[0].m_dDia;
			ar << pFx->m_rb[0].m_dLengthTotal;
			ar << pFx->m_rb[1].m_dDia;
			ar << pFx->m_rb[1].m_dLengthTotal;
		}

		ar << m_dTackCotting;
		ar << m_nTypePileMilkBM;

		// SetGridDataCombineEccLoad
		long i = 0; for(i = 0; i < RCBRIDGE_COMBO_COUNT; i++)
		{
			long j = 0; for(j = 0; j < MAX_RCBRIDGE_COMBO; j++)
				ar << m_bApplyCombo3D[i][j];
		}

		m_MatComboEcc.Serialize(ar);

		// SetGridDataCombineEQLoad
		m_MatComboEQ.Serialize(ar);

		// SetGridDataCombineUltLoad
		m_MatComboUlt.Serialize(ar);

		// SetGridDataCombineUseLoad
		m_MatComboUse.Serialize(ar);

		// SetGridDataCondition
		ar << m_dUnitWeigthBackFill;
		ar << m_dAngleFrictionBackFill;
		ar << m_dLiveLoadAlways;
		ar << m_dDeadLoadAlways;
		ar << m_dLiveLoadAlways;
		ar << m_nSelectLiveLoadHori;
		ar << m_dLiveLoadFootway;
		ar << m_dUnitWeightHeapSoil;
		ar << m_dValidDepthBaseGround;
		ar << m_nSelectAlphaKhKv_XXX;
		ar << m_dEo_CalcWallSpringEQ;
		ar << m_dNValue_Eo_Hori_XXX;
		ar << m_dNValue_Eo_Vert_XXX;
		ar << m_SafeFactorOverturning[0];
		ar << m_SafeFactorOverturning[1];
		ar << m_SafeFactorSliding[0];
		ar << m_SafeFactorSliding[1];
		ar << m_nSelectModelingCountEQ;
		ar << m_nSelectFootForce;
		ar << m_nSelect2DFrameTool;
		ar << m_nSelect3DShellTool;
		ar << m_nSelect3DOutputValue;
		ar << m_dFckLeanConc;
		ar << m_dFckMassConc;

		// SetGridDataCover
		ar << m_dCoverUpper_UpperSlab[0];
		ar << m_dCoverLower_UpperSlab[0];
		ar << m_dCoverSide_UpperSlab[0];
		ar << m_dCoverWallOut[0];
	
		ar << m_dCoverWallIn[0];
		ar << m_dCoverWallMid[0];
		ar << m_dCoverColumn[0];
		ar << m_dCoverWingOut[0];
		ar << m_dCoverWingIn[0];
		ar << m_dCoverWingUpper;
		ar << m_dCoverWingEnd;
		ar << m_dCoverUpper_Footing[0];
		ar << m_dCoverLower_Footing_Lean[0];
		ar << m_dCoverLower_Footing_Pile[0];

		ar << m_dCoverRib[iUPPER][0];
		ar << m_dCoverRib[iLOWER][0];

		// SetGridDataEnv
		ar << m_bCheckMainSlabAndFootTemper;
		ar << m_bCheckSuppoerBarSlabMain;
		ar << m_bCheckSuppoerBarSlabArea;
		ar << m_bCheckSuppoerBarSlab300;
		ar << m_bCheckSuppoerBarWall15hs;
		ar << m_bCheckSuppoerBarWallArea;
		ar << m_dCheckSuppoerBarWallAreaForOver400;
		ar << m_dCheckSuppoerBarWallArea;
		ar << m_bCheckSuppoerBarWall300;
		ar << m_bSelectSupportBarWall;
		ar << m_bCheckSuppoerBarArchRibMinDia1;
		ar << m_bCheckSuppoerBarArchRibMinDia2;
		ar << m_bCheckSuppoerBarFoot300;
		ar << m_bCheckSuppoerBarFoot15hs;
		ar << m_bCheckSuppoerBarFootArea;
		ar << m_dCheckSuppoerBarFootArea;
		ar << m_bCheckSuppoerBarSlabMainOver20;
		ar << m_bCheckSuppoerBarFootMainOver20;
		ar << m_bCheckSuppoerBarWallMainOver20;

		ar << m_bApplyT1CalcWingWall;

		ar << m_bCheckSuppoerBarWing300;
		ar << m_bCheckSuppoerBarWing15hs;
		ar << m_bCheckSuppoerBarWingArea;
		ar << m_bApplyMinAvSlab;
		ar << m_bApplyMinAvWall;
		ar << m_bApplyMinAvFoot;
		ar << m_bApplyMinAvWing;
		ar << m_bApplyMinAvAps;
		ar << m_bApplyMinAvHyunTa;
		ar << m_bCheckMinCtcShearWing;
		ar << m_bCheckMinCtcShearAps;
		ar << m_bCheckCornerInside;
		ar << m_nSelCalcCornerFt;
		ar << m_nApplyCalcShearDistFront;
		ar << m_nApplyCalcShearDistBack;
		ar << m_dFactorToap;
		ar << m_dFactorLive;
		ar << m_nTypeCrackDesignSlab;
		ar << m_nTypeCrackDesignWall;
		ar << m_nTypeCrackDesignFoot;
		ar << m_nTypeCrackDesignWing;
		ar << m_nTypeCrackDesignAps;
		ar << m_bApplyFootingGForce;
		ar << m_bApplyMassCalcSafe;
		ar << m_bApplyFootingMinThick;
		ar << m_bCalcShearCenter;
		ar << m_nSelectJointUpperRange;
		ar << m_nTypeJongdanForRebar;
		ar << m_nTypeWallForRebarGen;
		ar << m_nIdxCountCycleMainRebar;
		ar << m_nTypeStandardCTCRebarMain;
		ar << m_nTypePlacingSupportRebar_UpperSlab;
		ar << m_nTypePlacingMainRebar_UpperSlab;
		ar << m_nTypeSideRebarMain_UpperSlabSabogang;
		ar << m_nTypePlacingMainRebar_Footing;
		ar << m_nTypeCurveOfWallVertRebar;
		ar << m_bFixOutSideMainRebarBy1Cyle;
		ar << m_bRemoveShearRebarAtSlabYundan;
		ar << m_nTypeCouplerColumnMainRebar;
		ar << m_bApplySameSupportRebar;
		ar << m_bApplySameMainRebar;					// 상하행 주철근관련 입력 동일 적용
		ar << m_nSelFactorKhStt;
		ar << m_nSelFactorKhEnd;
		ar << m_nSelectRigidModeling;
		ar << m_nSelectModelingHeight;
		ar << m_bSelectTempLoadAddWall;
		ar << m_bSelectShrinkLoadAddWall;
		ar << m_bSelectEnvToapOne;
		ar << m_bSelectEnvSubsid;
		ar << m_bSelectRigidCalcHunch;
		ar << m_nSelSubsideType;
		ar << m_nSelectDesignSpanLength;
		ar << m_bSelectSpanLengthApplyShoe;
		ar << m_nSelectForceCheckPos;
		ar << m_nSelectDesignRoadWidth;
		ar << m_nSelectWallSectionDesign;
		ar << m_nSelectFootingReactionForce;

		// SetGridDataSelectLoad
		for(i = 0; i < BRIDGE_LOAD_BASIC; i++)
			ar << m_bApplyLoad[i];

		// Lsd
		ar << m_bMaterialDetail;
		StoreArray(ar, m_Fck, ePartCount);
		StoreArray(ar, m_Fy, ePartCount);
		StoreArray(ar, m_Fy, ePartCount);
		StoreArray(ar, m_Fvy, ePartCount);
		StoreArray(ar, m_Ec, ePartCount);
		ar << m_dRateDryAndShrinkage;
		ar << m_dCoefficientExpansion;
		ar << m_bIsDBar_ForDowelBar;
		ar << m_dUnitWeigthBackFillWater;
		ar << m_nSelectWingCalc;
		ar << m_nTypeDesingEQ;
		ar << m_dCoffKh_Sei;
		ar << m_nDegreeEarthQuake;
		ar << m_nRegionEarthQuake;
		ar << m_dCoefficientGround;
		ar << m_gValue;
		ar << m_nTypeRigidFootingEQ;
		ar << m_bApplyRigidWallEQRotate;
		ar << m_nTypeJointPosFootingEQ;
		ar << m_nTypePropertyPosFootingEQ;
		ar << m_nTypeSoilPressureEQ;
		ar << m_nTypeUpperWeightEQ;
		ar << m_bCheckSupportSlabArea;
		ar << m_bCheckSupportWallArea;
		ar << m_bCheckSupportFootArea;
		ar << m_bCheckSupportWingWallArea;
		ar << m_bCheckSupportApsArea;
		ar << m_nApplyCalcShearDistSlab;
		ar << m_nApplyCalcShearDistWall;
		ar << m_nSelectApsShearCheck;
		ar << m_nApplyCalcShearDistFrontPile;
		ar << m_nApplyCalcShearDistBackPile;
		ar << m_dThetaShearDesign;
		ar << m_dElasticModularRatioUseCheck;
		ar << m_nSelectUsebilityCheck;
		ar << m_nSelectExposureCoverCheck;
		ar << m_nSelectPminColumn;
		ar << m_bSelectHunchDesignCheck;
		ar << m_nSelectLiveLoadSpanLength;
		ar << m_nSelectStartLane;
		ar << m_bCheckUseri;
		ar << m_dCheckUseriValue;
		ar << m_bCheckFrontFootTrap2;
		ar << m_nSelectInWallSectionDesign;
		ar << m_nSelectTempLoadSlab;
		ar << m_bSelectHunchModeling;
		ar << m_nSelectDesignSpanApply;
		ar << m_nArchRibSectionMomentPos;
		m_plsdEnvRating->Serialize(ar);
		m_plsdRebar->Serialize(ar);
	}
	else
	{
		ar >> nFlagEnv;
		CString str	= _T("");
		ar >> str;
		if(sID != str)
		{
			AfxMessageBox("ARcBridge 설계환경 파일이 아닙니다.");
			return;
		}

		ar >> m_nFormType_ConcNormal;
		ar >> m_nFormType_Footing;
		ar >> m_nFormType_WallFront;
		ar >> m_nFormType_WallBack;
		long stt = 0; for(stt = 0; stt < 2; stt++)
		{
			long left = 0; for(left = 0; left < 2; left++)
			{
				ar >> m_nFormType_WingFront[stt][left];
				ar >> m_nFormType_WingBack[stt][left];
			}
		}

		ar >> m_nFormType_Aps;
		ar >> m_nFormType_MassConc;
		ar >> m_nFormType_LeanConc;
		ar >> m_bSelectBM_ConcCare_Main;
		ar >> m_bSelectBM_ConcCare_Aps;
		if(nFlagEnv > 7)
			ar >> m_nSelectBM_ConcCare_Cal;
		ar >> m_nTypeRcBridgeBlock;
		ar >> m_dAngleRcBridgeBlock;
		ar >> m_bSelectBM_ApsCnsInclude;
		ar >> m_nTypeHeightWall;
		ar >> m_nTypeSurfaceProof;
		ar >> m_nTypePostBaseLine;
		ar >> m_dPostLineEL;
		ar >> m_nTypeScaffoldBaseLine;
		ar >> m_dScaffoldLineEL;
		ar >> m_nTypePost;
		ar >> m_dThickScaffold;
		ar >> m_dAggregate_Footing;
		ar >> m_dAggregate_Main;
		ar >> m_dAggregate_Aps;
		ar >> m_dAggregate_Lean;
		ar >> m_dAggregate_Mass;
		ar >> m_dAggregate_Etc;
		ar >> m_dSlump_Footing;
		ar >> m_dSlump_Main;
		ar >> m_dSlump_Aps;
		ar >> m_dSlump_Lean;
		ar >> m_dSlump_Mass;
		ar >> m_dSlump_Etc;
		ar >> m_nMonumenu;
		ar >> m_nDesPanel;
		ar >> m_nNamePanel;
		ar >> m_nHeightForSlabBM;

		// 신축이음 수량
		for(stt = 0; stt < 2; stt++)
		{
			BOOL bStt	= stt == iSTT;
			CFlexibleJoint *pFx	= bStt ? &m_fxJointStt : &m_fxJointEnd;
			ar >> pFx->m_sName;
			ar >> pFx->m_rb[0].m_dDia;
			ar >> pFx->m_rb[0].m_dLengthTotal;
			ar >> pFx->m_rb[1].m_dDia;
			ar >> pFx->m_rb[1].m_dLengthTotal;
		}

		ar >> m_dTackCotting;
		ar >> m_nTypePileMilkBM;

		// SetGridDataCombineEccLoad
		long i = 0; for(i = 0; i < RCBRIDGE_COMBO_COUNT; i++)
		{
			long j = 0; for(j = 0; j < MAX_RCBRIDGE_COMBO; j++)
				ar >> m_bApplyCombo3D[i][j];
		}

		m_MatComboEcc.Serialize(ar);

		// SetGridDataCombineEQLoad
		m_MatComboEQ.Serialize(ar);

		// SetGridDataCombineUltLoad
		m_MatComboUlt.Serialize(ar);

		// SetGridDataCombineUseLoad
		m_MatComboUse.Serialize(ar);

		// SetGridDataCondition
		ar >> m_dUnitWeigthBackFill;
		ar >> m_dAngleFrictionBackFill;
		ar >> m_dLiveLoadAlways;
		ar >> m_dDeadLoadAlways;
		ar >> m_dLiveLoadAlways;
		ar >> m_nSelectLiveLoadHori;
		ar >> m_dLiveLoadFootway;
		ar >> m_dUnitWeightHeapSoil;
		ar >> m_dValidDepthBaseGround;
		ar >> m_nSelectAlphaKhKv_XXX;
		ar >> m_dEo_CalcWallSpringEQ;
		ar >> m_dNValue_Eo_Hori_XXX;
		ar >> m_dNValue_Eo_Vert_XXX;
		ar >> m_SafeFactorOverturning[0];
		ar >> m_SafeFactorOverturning[1];
		ar >> m_SafeFactorSliding[0];
		ar >> m_SafeFactorSliding[1];
		ar >> m_nSelectModelingCountEQ;
		ar >> m_nSelectFootForce;
		ar >> m_nSelect2DFrameTool;
		ar >> m_nSelect3DShellTool;
		ar >> m_nSelect3DOutputValue;
		ar >> m_dFckLeanConc;
		ar >> m_dFckMassConc;

		// SetGridDataCover
		ar >> m_dCoverUpper_UpperSlab[0];
		ar >> m_dCoverLower_UpperSlab[0];
		ar >> m_dCoverSide_UpperSlab[0];
		ar >> m_dCoverWallOut[0];
	
		ar >> m_dCoverWallIn[0];
		ar >> m_dCoverWallMid[0];
		ar >> m_dCoverColumn[0];
		ar >> m_dCoverWingOut[0];
		ar >> m_dCoverWingIn[0];
		ar >> m_dCoverWingUpper;
		ar >> m_dCoverWingEnd;
		ar >> m_dCoverUpper_Footing[0];
		ar >> m_dCoverLower_Footing_Lean[0];
		ar >> m_dCoverLower_Footing_Pile[0];

		ar >> m_dCoverRib[iUPPER][0];
		ar >> m_dCoverRib[iLOWER][0];

		// SetGridDataEnv
		ar >> m_bCheckMainSlabAndFootTemper;
		ar >> m_bCheckSuppoerBarSlabMain;
		ar >> m_bCheckSuppoerBarSlabArea;
		ar >> m_bCheckSuppoerBarSlab300;
		ar >> m_bCheckSuppoerBarWall15hs;
		ar >> m_bCheckSuppoerBarWallArea;
		ar >> m_dCheckSuppoerBarWallAreaForOver400;
		ar >> m_dCheckSuppoerBarWallArea;
		ar >> m_bCheckSuppoerBarWall300;
		ar >> m_bSelectSupportBarWall;
		ar >> m_bCheckSuppoerBarArchRibMinDia1;
		ar >> m_bCheckSuppoerBarArchRibMinDia2;
		ar >> m_bCheckSuppoerBarFoot300;
		ar >> m_bCheckSuppoerBarFoot15hs;
		ar >> m_bCheckSuppoerBarFootArea;
		ar >> m_dCheckSuppoerBarFootArea;
		if(nFlagEnv > 4)
		{
			ar >> m_bCheckSuppoerBarSlabMainOver20;
			ar >> m_bCheckSuppoerBarFootMainOver20;
			ar >> m_bCheckSuppoerBarWallMainOver20;
		}
		if(nFlagEnv > 5)
		{
			ar >> m_bApplyT1CalcWingWall;
		}

		ar >> m_bCheckSuppoerBarWing300;
		ar >> m_bCheckSuppoerBarWing15hs;
		ar >> m_bCheckSuppoerBarWingArea;
		ar >> m_bApplyMinAvSlab;
		ar >> m_bApplyMinAvWall;
		ar >> m_bApplyMinAvFoot;
		ar >> m_bApplyMinAvWing;
		ar >> m_bApplyMinAvAps;
		if(nFlagEnv > 6)
			ar >> m_bApplyMinAvHyunTa;
		ar >> m_bCheckMinCtcShearWing;
		ar >> m_bCheckMinCtcShearAps;
		ar >> m_bCheckCornerInside;
		ar >> m_nSelCalcCornerFt;
		ar >> m_nApplyCalcShearDistFront;
		ar >> m_nApplyCalcShearDistBack;
		ar >> m_dFactorToap;
		ar >> m_dFactorLive;
		ar >> m_nTypeCrackDesignSlab;
		ar >> m_nTypeCrackDesignWall;
		ar >> m_nTypeCrackDesignFoot;
		ar >> m_nTypeCrackDesignWing;
		ar >> m_nTypeCrackDesignAps;
		ar >> m_bApplyFootingGForce;
		ar >> m_bApplyMassCalcSafe;
		ar >> m_bApplyFootingMinThick;
		ar >> m_bCalcShearCenter;
		ar >> m_nSelectJointUpperRange;
		ar >> m_nTypeJongdanForRebar;
		ar >> m_nTypeWallForRebarGen;
		ar >> m_nIdxCountCycleMainRebar;
		ar >> m_nTypeStandardCTCRebarMain;
		ar >> m_nTypePlacingSupportRebar_UpperSlab;
		ar >> m_nTypePlacingMainRebar_UpperSlab;
		ar >> m_nTypeSideRebarMain_UpperSlabSabogang;
		ar >> m_nTypePlacingMainRebar_Footing;
		ar >> m_nTypeCurveOfWallVertRebar;
		ar >> m_bFixOutSideMainRebarBy1Cyle;
		ar >> m_bRemoveShearRebarAtSlabYundan;
		ar >> m_nTypeCouplerColumnMainRebar;
		ar >> m_bApplySameSupportRebar;
		ar >> m_bApplySameMainRebar;					// 상하행 주철근관련 입력 동일 적용
		ar >> m_nSelFactorKhStt;
		ar >> m_nSelFactorKhEnd;
		ar >> m_nSelectRigidModeling;
		ar >> m_nSelectModelingHeight;
		ar >> m_bSelectTempLoadAddWall;
		ar >> m_bSelectShrinkLoadAddWall;
		if(nFlagEnv > 1)
		{
			ar >> m_bSelectEnvToapOne;
			ar >> m_bSelectEnvSubsid;
		}
		ar >> m_bSelectRigidCalcHunch;
		ar >> m_nSelSubsideType;
		ar >> m_nSelectDesignSpanLength;
		ar >> m_bSelectSpanLengthApplyShoe;
		ar >> m_nSelectForceCheckPos;
		ar >> m_nSelectDesignRoadWidth;
		ar >> m_nSelectWallSectionDesign;
		if(nFlagEnv > 0) ar >> m_nSelectFootingReactionForce;

		// SetGridDataSelectLoad
		for(i = 0; i < BRIDGE_LOAD_BASIC; i++)
			ar >> m_bApplyLoad[i];

		if (nFlagEnv > 2)
		{
			// Lsd
			ar >> m_bMaterialDetail;
			LoadArray(ar, m_Fck, ePartCount);
			LoadArray(ar, m_Fy, ePartCount);
			LoadArray(ar, m_Fy, ePartCount);
			LoadArray(ar, m_Fvy, ePartCount);
			LoadArray(ar, m_Ec, ePartCount);
			ar >> m_dRateDryAndShrinkage;
			ar >> m_dCoefficientExpansion;
			ar >> m_bIsDBar_ForDowelBar;
			ar >> m_dUnitWeigthBackFillWater;
			ar >> m_nSelectWingCalc;
			ar >> m_nTypeDesingEQ;
			ar >> m_dCoffKh_Sei;
			ar >> m_nDegreeEarthQuake;
			ar >> m_nRegionEarthQuake;
			ar >> m_dCoefficientGround;
			ar >> m_gValue;
			ar >> m_nTypeRigidFootingEQ;
			ar >> m_bApplyRigidWallEQRotate;
			ar >> m_nTypeJointPosFootingEQ;
			ar >> m_nTypePropertyPosFootingEQ;
			ar >> m_nTypeSoilPressureEQ;
			ar >> m_nTypeUpperWeightEQ;
			ar >> m_bCheckSupportSlabArea;
			ar >> m_bCheckSupportWallArea;
			ar >> m_bCheckSupportFootArea;
			ar >> m_bCheckSupportWingWallArea;
			ar >> m_bCheckSupportApsArea;
			ar >> m_nApplyCalcShearDistSlab;
			ar >> m_nApplyCalcShearDistWall;
			ar >> m_nSelectApsShearCheck;
			ar >> m_nApplyCalcShearDistFrontPile;
			ar >> m_nApplyCalcShearDistBackPile;
			ar >> m_dThetaShearDesign;
			ar >> m_dElasticModularRatioUseCheck;
			ar >> m_nSelectUsebilityCheck;
			if(nFlagEnv > 3)
			{
				ar >> m_nSelectExposureCoverCheck;
			}
			ar >> m_nSelectPminColumn;
			ar >> m_bSelectHunchDesignCheck;
			ar >> m_nSelectLiveLoadSpanLength;
			ar >> m_nSelectStartLane;
			ar >> m_bCheckUseri;
			ar >> m_dCheckUseriValue;
			ar >> m_bCheckFrontFootTrap2;
			ar >> m_nSelectInWallSectionDesign;
			ar >> m_nSelectTempLoadSlab;
			ar >> m_bSelectHunchModeling;
			ar >> m_nSelectDesignSpanApply;
			ar >> m_nArchRibSectionMomentPos;
			m_plsdEnvRating->Serialize(ar);
			m_plsdRebar->Serialize(ar);
		}
	}
}

/**
	@brief
		상부슬래브 주철근 첫번째와 마지막 선형방향 철근이 'ㅡ'자가 되어야 하는지?
		사보강 배치인 경우 시점각도가 90도 보다 작으면 왼족이 ㅡ자, 90보다 크면 오른쪽이 ㅡ자
		                   종점각도가 90보 보다 작으면 오른쪽이 ㅡ자, 90보다 크면 왼쪽이 ㅡ자
*/
BOOL CRcBridgeRebar::IsRebarMainOneLineUpperSlab(BOOL bLeft, BOOL bStt)
{
	if(m_nTypePlacingMainRebar_UpperSlab == 0) return FALSE;

	if(bStt)
	{
		double dAngJijum	= GetAngleJijum(0).GetAngleDegree();
		if(Compare(dAngJijum, 90.0, "=")) return FALSE;

		if(bLeft && dAngJijum < 90) return TRUE;
		if(!bLeft && dAngJijum > 90) return TRUE;
	}
	else
	{
		double dAngJijum	= GetAngleJijum(m_nQtyJigan).GetAngleDegree();
		if(Compare(dAngJijum, 90.0, "=")) return FALSE;

		if(!bLeft && dAngJijum < 90) return TRUE;
		if(bLeft && dAngJijum > 90) return TRUE;
	}

	return FALSE;


}

void CRcBridgeRebar::StretchTvOfTvArr(CTwinVectorArray &tvArr, double dStt, double dEnd)
{
	CTwinVector *pTv	= NULL;
	CDPoint vAng(0, 0);
	long i = 0; for(i = 0; i < tvArr.GetSize(); i++)
	{
		pTv	= tvArr.GetPAt(i);
		vAng	= pTv->GetXyDir();

		pTv->m_v1	= pTv->m_v1 + vAng * -dStt;
		pTv->m_v2	= pTv->m_v2 + vAng * dEnd;
		pTv->m_v1.z	= 0;
		
	}
}

void CRcBridgeRebar::SetDataDefaultRebarInfoCycle_LowerSlab( long nCycle, BOOL bDefaultUpper/*=TRUE*/, BOOL bDefaultLower/*=TRUE*/, BOOL bOnlyCountArray/*=FALSE*/, long nDan/*=0*/, BOOL bOnlyDiffJoint/*=FALSE*/ )
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar() - 1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar() - 1) return;

	// 아치교는 1사이클 권고안과 같이 권고안 함.(특별 케이스)
	if((nCycle == 1 || nCycle == 3) && !bOnlyCountArray && m_nTypeBridge != BRIDGE_TYPE_ARCH)
	{
		if(!bOnlyDiffJoint)
		{
			SetDataDefaultRebarInfoCycle_LowerSlab_Cycle2(nCycle, bOnlyCountArray, TRUE, TRUE, nDan);
			return;
		}
	}

	//ARCBRIDGE-2877 삭제: m_bSlopeLowerSlab,  2사이클일 경우 해당 종단 스테이션과 다를수 밖에 없다(사각일 경우)
	BOOL bVertDir	= IsVertDir();
	BOOL bCycle3	= nCycle == 2 ? TRUE : FALSE;

	long upper(0), jigan(0), dia(0), joint(0);
	for(upper = 0; upper < 2; upper++)
	{
		BOOL bUpper	= upper == iUPPER;

		if(bUpper && !bDefaultUpper) continue;
		if(!bUpper && !bDefaultLower) continue;

		// 이음개수가 변경된 경우에만 권고안 하도록 하는 경우 /////////
		if(bOnlyDiffJoint)
		{
			BOOL bDiff	= FALSE;
			for(long dia	= 0; dia < m_nQtyJigan; dia++)
			{
				long nCountJoint	= nCycle == 0 || nCycle == 2 ? m_nCountJointMainRebar_LowerSlab_Cycle1[dia][upper][nDan] : m_nCountJointMainRebar_LowerSlab_Cycle2[dia][upper][nDan];
				long nCountJointOld	= nCycle == 0 || nCycle == 2 ? m_nCountJointMainRebar_LowerSlab_Cycle1_Old[dia][upper][nDan] : m_nCountJointMainRebar_LowerSlab_Cycle2_Old[dia][upper][nDan];
				if(nCountJoint != nCountJointOld)
					bDiff	= TRUE;
			}

			if(!bDiff) continue;
		}
		//////////////////////////////////////////////////////////////////
		if(!bCycle3)	// 3cycle이 아닌 경우 일반 권고안 함
		{
			CSafetyTypedPtrArray <CObArray, CDoubleArray*> pArrDiaLowerSlab;
			CSafetyTypedPtrArray <CObArray, CDoubleArray*> pArrExistLowerSlab;
			AhTPACopy(&pArrDiaLowerSlab, &m_pArrDiaLowerSlab[nCycle][upper][nDan], (CDoubleArray*)0);
			AhTPACopy(&pArrExistLowerSlab, &m_pArrExistLowerSlab[nCycle][upper][nDan], (CDoubleArray*)0);

			// 각 지간별 지름을 모두 22로 만든다.
			// 지름은 지간보다 1개 더 들어감.(마지막 지간에 하나 더 들어감)
			AhTPADelete(&m_pArrDiaLowerSlab[nCycle][upper][nDan], (CDoubleArray*)0);
			AhTPADelete(&m_pArrExistLowerSlab[nCycle][upper][nDan], (CDoubleArray*)0);
			for(dia	= 0; dia < m_nQtyJigan; dia++)
			{
				long nCountJoint	= nCycle == 0 || nCycle == 2 ? m_nCountJointMainRebar_LowerSlab_Cycle1[dia][upper][nDan] : m_nCountJointMainRebar_LowerSlab_Cycle2[dia][upper][nDan];

				CDoubleArray *pDArr			= new CDoubleArray;
				CDoubleArray *pDArrExist	= new CDoubleArray;
				for(joint = 0; joint < nCountJoint; joint++)
				{
					pDArr->Add(22);
					pDArrExist->Add((double)nDan == 0 ? TRUE : FALSE);
				}
				if(dia == m_nQtyJigan - 1) 
				{
					pDArr->Add(22);
					pDArrExist->Add((double)nDan == 0 ? TRUE : FALSE);
				}

				m_pArrDiaLowerSlab[nCycle][upper][nDan].Add(pDArr);
				m_pArrExistLowerSlab[nCycle][upper][nDan].Add(pDArrExist);
			}

			if(bOnlyCountArray)
			{
				long i = 0; for(i = 0; i < m_pArrDiaLowerSlab[nCycle][upper][nDan].GetSize(); i++)
				{
					CDoubleArray *pDArr	= m_pArrDiaLowerSlab[nCycle][upper][nDan].GetAt(i);
					CDoubleArray *pDArrSrc	= NULL;
					if(pArrDiaLowerSlab.GetSize() > i)
						pDArrSrc	= pArrDiaLowerSlab.GetAt(i);
					else
					{
						pArrDiaLowerSlab.Add(new CDoubleArray);
						pDArrSrc	= pArrDiaLowerSlab.GetAt(i);
					}
					long j = 0; for(j = 0; j < pDArr->GetSize(); j++)
					{
						if(pDArrSrc->GetSize() > j)
							pDArr->SetAt(j, pDArrSrc->GetAt(j));
					}
				}
				for(i = 0; i < m_pArrExistLowerSlab[nCycle][upper][nDan].GetSize(); i++)
				{
					CDoubleArray *pDArr	= m_pArrExistLowerSlab[nCycle][upper][nDan].GetAt(i);
					CDoubleArray *pDArrSrc	= NULL;
					if(pArrExistLowerSlab.GetSize() > i)
						pDArrSrc	= pArrExistLowerSlab.GetAt(i);
					else
					{
						pArrExistLowerSlab.Add(new CDoubleArray);
						pDArrSrc	= pArrExistLowerSlab.GetAt(i);
					}
					long j = 0; for(j = 0; j < pDArr->GetSize(); j++)
					{
						if(pDArrSrc->GetSize() > j)
							pDArr->SetAt(j, pDArrSrc->GetAt(j));
					}
				}

			}
			AhTPADelete(&pArrDiaLowerSlab, (CDoubleArray*)0);
			AhTPADelete(&pArrExistLowerSlab, (CDoubleArray*)0);

			// 각 지간별 이음 거리는 각 지간의 간격의 반정도를 한다.
			// 거리는 지간개수 만큼 들어감.
			double dWS	= IsOutWall(TRUE) ? m_dWS-m_dCoverWallOut[nDan] : -GetCoverSide_UpperSlab(nDan);
			double dWE	= IsOutWall(FALSE) ? m_dWE-m_dCoverWallOut[nDan] : -GetCoverSide_UpperSlab(nDan);
			if(!bVertDir)
			{
				dWS	/= GetAngleJijum(0).y;
				dWE	/= GetAngleJijum(m_nQtyJigan).y;
			}
			if(upper!=iUPPER)
			{
				dWS	-= GetLenRebarAtEdge(22, FALSE);
				dWE	-= GetLenRebarAtEdge(22, FALSE);
			}

			CSafetyTypedPtrArray <CObArray, CDoubleArray*> pArrDistLowerSlab;
			AhTPACopy(&pArrDistLowerSlab, &m_pArrDistLowerSlab[nCycle][upper][nDan], (CDoubleArray*)0);

			AhTPADelete(&m_pArrDistLowerSlab[nCycle][upper][nDan], (CDoubleArray*)0);
			for(jigan = 0; jigan < m_nQtyJigan; jigan++)
			{
				long nCountJoint	= nCycle == 0 || nCycle == 2 ? m_nCountJointMainRebar_LowerSlab_Cycle1[jigan][upper][nDan] : m_nCountJointMainRebar_LowerSlab_Cycle2[jigan][upper][nDan];
				double dDist	= GetLengthJigan(jigan, 0, bVertDir);
				if(jigan == 0) dDist += dWS;
				if(jigan == m_nQtyJigan-1) dDist += dWE;

				CDoubleArray *pDArr	= new CDoubleArray;
				for(joint = 0; joint < nCountJoint; joint++)
				{
					// 4cycle까지 지원되면 3cycle 자동 권고안에 의해 이음 위치가 조금씩 이동 할 수 있다.
					dDist += GetDistMoveJointCycle13_LowerSlab(bUpper, bCycle3, jigan, joint);

					pDArr->Add(Round(dDist/(nCountJoint+1), -1));
				}
				m_pArrDistLowerSlab[nCycle][upper][nDan].Add(pDArr);
			}

			if(bOnlyCountArray)
			{
				long i = 0; for(i = 0; i < m_pArrDistLowerSlab[nCycle][upper][nDan].GetSize(); i++)
				{
					CDoubleArray *pDArr	= m_pArrDistLowerSlab[nCycle][upper][nDan].GetAt(i);
					CDoubleArray *pDArrSrc	= NULL;
					if(pArrDistLowerSlab.GetSize() > i)
						pDArrSrc	= pArrDistLowerSlab.GetAt(i);
					else
					{
						pArrDistLowerSlab.Add(new CDoubleArray);
						pDArrSrc	= pArrDistLowerSlab.GetAt(i);
					}
					long j = 0; for(j = 0; j < pDArr->GetSize(); j++)
					{
						if(pDArrSrc->GetSize() > j)
							pDArr->SetAt(j, pDArrSrc->GetAt(j));
					}
				}
			}

			AhTPADelete(&pArrDistLowerSlab, (CDoubleArray*)0);
		}
		else	// 3cycle인 경우 1cycle을 참고해서 권고안 함
		{
			AhTPACopy(&m_pArrDiaLowerSlab[nCycle][upper][nDan], &m_pArrDiaLowerSlab[0][upper][nDan], (CDoubleArray*)0);
			AhTPACopy(&m_pArrExistLowerSlab[nCycle][upper][nDan], &m_pArrExistLowerSlab[0][upper][nDan], (CDoubleArray*)0);
			AhTPACopy(&m_pArrDistLowerSlab[nCycle][upper][nDan], &m_pArrDistLowerSlab[0][upper][nDan], (CDoubleArray*)0);

			long i = 0; for(i = 0; i < m_pArrDistLowerSlab[nCycle][upper][nDan].GetSize(); i++)
			{
				CDoubleArray *pdArr	= m_pArrDistLowerSlab[nCycle][upper][nDan].GetAt(i);
				long j = 0; for(j = 0; j < pdArr->GetSize(); j++)
				{
					double dMove	= GetDistMoveJointCycle13_LowerSlab(bUpper, bCycle3, i, j) * 2;
					pdArr->SetAt(j, pdArr->GetAt(j)+(j == 0 ? dMove : 0));
				}
			}
		}
	}
}

void CRcBridgeRebar::SetDataDefaultRebarInfoCycle_LowerSlab_Cycle2( long nCycle, BOOL bOnlyCountArray, BOOL bDefaultUpper/*=TRUE*/, BOOL bDefaultLower/*=TRUE*/, long nDan/*=0*/ )
{
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar() - 1) return;

	long jigan(0), dia(0);
	
	//ARCBRIDGE-2877 삭제: m_bSlopeLowerSlab,  2사이클일 경우 해당 종단 스테이션과 다를수 밖에 없다(사각일 경우)
	BOOL bVertDir	= IsVertDir(); 

	// 하부 
	if(bDefaultLower)
	{
		CSafetyTypedPtrArray <CObArray, CDoubleArray*> pArrDiaLowerSlab;
		AhTPACopy(&pArrDiaLowerSlab, &m_pArrDiaLowerSlab[nCycle][iLOWER][nDan], (CDoubleArray*)0);

		// 각 지간별 지름을 모두 22로 만든다.
		// 지름은 마지막 지간만 2개들어가고 나머지는 1개씩 들어감.
		// 지름은 지간보다 1개 더 들어감.(지점마다 하나씩)
		AhTPADelete(&m_pArrDiaLowerSlab[nCycle][iLOWER][nDan], (CDoubleArray*)0);
		for(dia	= 0; dia < m_nQtyJigan; dia++)
		{
			CDoubleArray *pDArr	= new CDoubleArray;
			pDArr->Add(22);
			if(dia == m_nQtyJigan-1)
				pDArr->Add(22);
			else if(m_bExpJoint[dia+1])	// 신축이음일때는 나머지 지간에도 하나씩 더 들어간다.
				pDArr->Add(22);
			m_pArrDiaLowerSlab[nCycle][iLOWER][nDan].Add(pDArr);
		}

		if(bOnlyCountArray)
		{
			long i = 0; for(i = 0; i < m_pArrDiaLowerSlab[nCycle][iLOWER][nDan].GetSize(); i++)
			{
				CDoubleArray *pDArr	= m_pArrDiaLowerSlab[nCycle][iLOWER][nDan].GetAt(i);
				CDoubleArray *pDArrSrc	= pArrDiaLowerSlab.GetAt(i);
				long j = 0; for(j = 0; j < pDArr->GetSize(); j++)
				{
					if(pDArrSrc->GetSize() > j)
						pDArr->SetAt(j, pDArrSrc->GetAt(j));
				}
			}
		}
		AhTPADelete(&pArrDiaLowerSlab, (CDoubleArray*)0);

		CSafetyTypedPtrArray <CObArray, CDoubleArray*> pArrDistLowerSlab;
		AhTPACopy(&pArrDistLowerSlab, &m_pArrDistLowerSlab[nCycle][iLOWER][nDan], (CDoubleArray*)0);

		// 각 지간별 이음 거리는 각 지간의 간격의 반정도를 한다.
		// 거리는 지간개수 만큼 들어감.
		AhTPADelete(&m_pArrDistLowerSlab[nCycle][iLOWER][nDan], (CDoubleArray*)0);
		for(jigan = 0; jigan < m_nQtyJigan; jigan++)
		{
			//long nJijum		= jigan+1;
			double dDist	= GetLengthJigan(jigan, 0, bVertDir, TRUE);//GetStationOnJijum(nJijum, 0) - GetStationOnJijum(nJijum-1, 0);

			
			if(jigan == 0)
			{
				double dAng = bVertDir ? 1 : GetAngleJijum(0).y;
				dDist += m_dWS / dAng;
				dDist -= m_dCoverWallOut[nDan] / dAng;
				dDist -= GetLenRebarAtEdge(22, FALSE, 0, TRUE);
			}

			if(jigan == m_nQtyJigan-1) 
			{
				double dAng = bVertDir ? 1 : GetAngleJijum(m_nQtyJigan).y;
				dDist += m_dWE / dAng;
				dDist -= m_dCoverWallOut[nDan] / dAng;
				dDist -= GetLenRebarAtEdge(22, FALSE, 0, TRUE);
			}

			CDoubleArray *pDArr	= new CDoubleArray;
			pDArr->Add(Round(dDist/4, -1));
			pDArr->Add(Round(dDist/4*2, -1));
			m_pArrDistLowerSlab[nCycle][iLOWER][nDan].Add(pDArr);
		}

		if(bOnlyCountArray)
		{
			long i = 0; for(i = 0; i < m_pArrDistLowerSlab[nCycle][iLOWER][nDan].GetSize(); i++)
			{
				CDoubleArray *pDArr	= m_pArrDistLowerSlab[nCycle][iLOWER][nDan].GetAt(i);
				CDoubleArray *pDArrSrc	= pArrDistLowerSlab.GetAt(i);
				long j = 0; for(j = 0; j < pDArr->GetSize(); j++)
				{
					if(pDArrSrc->GetSize() > j)
						pDArr->SetAt(j, pDArrSrc->GetAt(j));
				}
			}
		}
		AhTPADelete(&pArrDistLowerSlab, (CDoubleArray*)0);
	}

	// 상부
	if(bDefaultUpper)
	{
		CSafetyTypedPtrArray <CObArray, CDoubleArray*> pArrDiaLowerSlab;
		AhTPACopy(&pArrDiaLowerSlab, &m_pArrDiaLowerSlab[nCycle][iUPPER][nDan], (CDoubleArray*)0);

		// 각 지간별 지름을 모두 22로 만든다.
		// 지름은 지간개수만큼 있음(지간마다 하나씩)
		AhTPADelete(&m_pArrDiaLowerSlab[nCycle][iUPPER][nDan], (CDoubleArray*)0);
		for(dia	= 0; dia < m_nQtyJigan; dia++)
		{
			CDoubleArray *pDArr	= new CDoubleArray;
			pDArr->Add(22);
			m_pArrDiaLowerSlab[nCycle][iUPPER][nDan].Add(pDArr);
		}

		if(bOnlyCountArray)
		{
			long i = 0; for(i = 0; i < m_pArrDiaLowerSlab[nCycle][iUPPER][nDan].GetSize(); i++)
			{
				CDoubleArray *pDArr	= m_pArrDiaLowerSlab[nCycle][iUPPER][nDan].GetAt(i);
				CDoubleArray *pDArrSrc	= pArrDiaLowerSlab.GetAt(i);
				long j = 0; for(j = 0; j < pDArr->GetSize(); j++)
				{
					if(pDArrSrc->GetSize() > j)
						pDArr->SetAt(j, pDArrSrc->GetAt(j));
				}
			}
		}
		AhTPADelete(&pArrDiaLowerSlab, (CDoubleArray*)0);

		CSafetyTypedPtrArray <CObArray, CDoubleArray*> pArrDistLowerSlab;
		AhTPACopy(&pArrDistLowerSlab, &m_pArrDistLowerSlab[nCycle][iUPPER][nDan], (CDoubleArray*)0);

		// 각 지간별 이음 거리는 각 지간의 간격의 반정도를 한다.
		// 거리는 지간마다 2개씩 들어감.
		AhTPADelete(&m_pArrDistLowerSlab[nCycle][iUPPER][nDan], (CDoubleArray*)0);
		for(jigan = 0; jigan < m_nQtyJigan; jigan++)
		{
			CDoubleArray *pDArr	= new CDoubleArray;
			long nIdxHunchPrev	= GetIdxHunchInWall(jigan-1, TRUE);
			long nIdxHunchNext	= GetIdxHunchInWall(jigan, TRUE);
			CWallApp *pWallPrev	= GetInWall(jigan-1);
			CWallApp *pWallNext	= GetInWall(jigan);
			double dW			= 0;

			CJijum *pJ = GetJijum(jigan);
			CDPoint vAng = pJ == NULL? GetAngleAzimuthJijum(jigan) : pJ->m_vAngle;

			if(jigan == 0)
			{
				double dSttLenOut = IsOutWall(TRUE) ? Round(m_dWS+m_dWSHW-m_dCoverWallOut[nDan], -1) : 0;

				if(bVertDir == FALSE)
				{
					dSttLenOut /= vAng.y;
					dSttLenOut = fabs(dSttLenOut);					
				}

				pDArr->Add(dSttLenOut);	// 시점벽체와헌치너비
			}
			else
			{
				if(nIdxHunchPrev > -1)
				{
					dW	= m_dHRW[nIdxHunchPrev][iLOWER];
					if(pWallPrev) dW += pWallPrev->m_dW/2;

					if(bVertDir == FALSE)
					{
						dW /= vAng.y;
						dW = fabs(dW);
					}

					pDArr->Add(Round(dW, -1));
				}
			}

			if(jigan == m_nQtyJigan-1)
			{
				double dEndLenOut = IsOutWall(FALSE) ? Round(m_dWE+m_dWEHW-m_dCoverWallOut[nDan], -1) : 0;

				if(bVertDir == FALSE)
				{
					dEndLenOut /= vAng.y;
					dEndLenOut = fabs(dEndLenOut);
				}

				pDArr->Add(dEndLenOut);	// 종점벽체와 헌치너비
			}
			else
			{
				if(nIdxHunchNext > -1)
				{
					dW	= m_dHLW[nIdxHunchNext][iLOWER];
					if(pWallNext) dW += pWallNext->m_dW/2;

					if(bVertDir == FALSE)
					{
						dW /= vAng.y;
						dW = fabs(dW);
					}

					pDArr->Add(Round(dW, -1));
				}
			}

			m_pArrDistLowerSlab[nCycle][iUPPER][nDan].Add(pDArr);
		}		

		if(bOnlyCountArray)
		{
			long i = 0; for(i = 0; i < m_pArrDistLowerSlab[nCycle][iUPPER][nDan].GetSize(); i++)
			{
				CDoubleArray *pDArr	= m_pArrDistLowerSlab[nCycle][iUPPER][nDan].GetAt(i);
				CDoubleArray *pDArrSrc	= pArrDistLowerSlab.GetAt(i);
				long j = 0; for(j = 0; j < pDArr->GetSize(); j++)
				{
					if(pDArrSrc->GetSize() > j)
						pDArr->SetAt(j, pDArrSrc->GetAt(j));
				}
			}
		}
		AhTPADelete(&pArrDistLowerSlab, (CDoubleArray*)0);
	}

	SyncRebar2CycleMainRebarOldAndNew(3, bDefaultUpper, bDefaultLower);
}

double CRcBridgeRebar::GetDistMoveJointCycle13_LowerSlab( BOOL bUpper, BOOL bCycle3, long nJigan, long nJoint )
{
	if(GetCountCycleMainRebar() < 4) return 0;
	double dDist		= 0;
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;

	long cycle		= bCycle3 ? 2 : 0;
	long upper		= bUpper ? iUPPER : iLOWER;
	double dCover	= bUpper ? m_dCoverUpper_LowerSlab[0] : m_dCoverLower_LowerSlab[0];
	double dSpace	= m_dCTC_MainRebar/2;
	long nType		= bUpper && m_nSelectJointUpperRange != 2 ? JOINT_TENS_UPPER_A : JOINT_TENS_NORMAL_A;
	CDoubleArray *pDArr	= m_pArrDiaLowerSlab[cycle][upper][0][nJigan];
	double dDia		= pDArr->GetSize() > nJoint ? pDArr->GetAt(nJoint) : 0;
	double dDiaNext	= pDArr->GetSize() > nJoint+1 ? pDArr->GetAt(nJoint+1) : 0;
	double dLenJoint(0);
	if(pStd->IsLsdDesign())
	{
		SRebarEnvOption LsdRebarOpt;
		SetRebarLsdOptionSlab(&LsdRebarOpt, FALSE, bUpper, TRUE, cycle, 0);
		pStd->m_pBasicConcInfo->GetValueJoint(max(dDia, dDiaNext), &LsdRebarOpt);
	}
	else
	{
		dLenJoint	= pStd->GetValueJoint(max(dDia, dDiaNext), nType, dCover, dSpace, 2, 1);
	}

	// 하부슬래브 상면은 상부슬래브 하면과 같게...
	if(bUpper)
	{
		if(m_nTypeDefaultCycle3_UpperSlabLower != 0)
		{
			dDist	= GetDistMoveJointByTypeDefaultCycle3(m_nTypeDefaultCycle3_UpperSlabLower, dLenJoint);
		}
	}
	else
	{
		if(m_nTypeDefaultCycle3_OutRebar != 0)
		{
			dDist	= GetDistMoveJointByTypeDefaultCycle3(m_nTypeDefaultCycle3_OutRebar, dLenJoint);
		}
	}

	if(!bCycle3)
		dDist	= -dDist;

	return dDist;
}

BOOL CRcBridgeRebar::IsJointMainRebarLowerSlab_Upper_Cycle2( double dSta )
{
	long nJijum		= 0;
	double dNearest	= fabs(dSta - GetStationOnJijum(0, 0));
	for(long jijum = 1; jijum < m_nQtyJigan+1; jijum++)
	{
		if(fabs(dSta-GetStationOnJijum(jijum, 0)) < dNearest)
		{
			dNearest	= fabs(dSta - (dSta-GetStationOnJijum(jijum, 0)));
			nJijum		= jijum;
		}
	}

	return IsJointMainRebarLowerSlab_Upper_Cycle2((long)nJijum);
}

BOOL CRcBridgeRebar::IsJointMainRebarLowerSlab_Upper_Cycle2( long nJijum )
{
	long nSize = m_pArrSetRebarJointLowerSlab[iUPPER].GetSize();
	if(nJijum == -1) nJijum = nSize-1;
	if(nJijum >= nSize) return FALSE;
	if(nJijum < 0) return FALSE;

// 	BOOL bJoint = FALSE;

	CSetRebarJoint *pRJ	= m_pArrSetRebarJointLowerSlab[iUPPER].GetAt(nJijum);
	BOOL bJoint = pRJ->m_bJoint;

	return bJoint;
}

BOOL CRcBridgeRebar::IsJointMainRebarLowerSlab_Lower_Cycle2( long nJigan )
{
	long nSize = m_pArrSetRebarJointLowerSlab[iLOWER].GetSize();
	if(nJigan == -1) nJigan = nSize-1;
	if(nJigan >= nSize) return FALSE;
	if(nJigan < 0) return FALSE;

// 	BOOL bJoint = FALSE;

	CSetRebarJoint *pRJ	= m_pArrSetRebarJointLowerSlab[iLOWER].GetAt(nJigan);
	BOOL bJoint = pRJ->m_bJoint;

	return bJoint;
}

void CRcBridgeRebar::MakeJointMainRebarLowerSlab( CJointArray &arrJoint, long nCycle, long nDan, BOOL bUpper )
{
	arrJoint.RemoveAll();
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return;

	// 필요한 RebarInfoCycle를 찾음
	long upper	= bUpper ? iUPPER : iLOWER;
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = &m_pArrRCMainLowerSlab[nCycle][upper][nDan];
	if(!pArrRC) return;

	// 정보분석
	m_Util.GetJointAtRebarInfoCycleArray(arrJoint, pArrRC);
}

BOOL CRcBridgeRebar::IsMainRebarJointLowerSlabAndLowerSlab( CRebarInfoCycle *pRC )
{
	if(!pRC) return FALSE;

	BOOL bOK	= FALSE;
	// 하부슬래브는 철근을 합지면 방향이 돌아갈수도 있으니까. 반대의 경우도 TRUE이다.
	if(pRC->m_nPosStt == REBARINFO_POS_STTWALL_OUTTER && pRC->m_nPosEnd == REBARINFO_POS_ENDWALL_OUTTER)
		bOK	= TRUE;
	else if(pRC->m_nPosStt == REBARINFO_POS_ENDWALL_OUTTER && pRC->m_nPosEnd == REBARINFO_POS_STTWALL_OUTTER)
		bOK	= TRUE;

	return bOK;
}

BOOL CRcBridgeRebar::IsMainRebarJointLowerSlabAndOutWall( CRebarInfoCycle *pRC, BOOL &bStt )
{
	if(!pRC) return FALSE;

	BOOL bOK	= FALSE;
	if((pRC->m_nPosStt == REBARINFO_POS_UPPERSLAB_UPPER && pRC->m_nPosEnd == REBARINFO_POS_LOWERSLAB_LOWER))
	{
		bOK		= TRUE;
		bStt	= TRUE;
	}
	else if(pRC->m_nPosStt == REBARINFO_POS_LOWERSLAB_LOWER && pRC->m_nPosEnd == REBARINFO_POS_UPPERSLAB_UPPER)
	{
		bOK		= TRUE;
		bStt	= FALSE;
	}

	return bOK;
}

CTwinVector CRcBridgeRebar::GetTvOffset_LowerSlab( long nDan, BOOL bUpper, double dSttSta/*=-1*/, double dEndSta/*=-1*/, BOOL bVertDir/*=FALSE*/ )
{
	CTwinVector tv;
	CDPoint vAngStt	= bVertDir ? CDPoint(0, 1) : GetAngleJijum(0);
	CDPoint vAngEnd	= bVertDir ? CDPoint(0, 1) : GetAngleJijum(m_nQtyJigan);

	// dSttSta와 dEndSta가 모두 -1이면 벽체 시작부터 끝까지로 인식...
	double dCoverSideStt	= nDan > -1 ? m_dCoverWallOut[nDan] : 0;//IsOutWall(TRUE) ? m_dCoverWallOut[nDan] : GetCoverSide_UpperSlab(nDan);
	double dCoverSideEnd	= nDan > -1 ? m_dCoverWallOut[nDan] : 0;//IsOutWall(FALSE) ? m_dCoverWallOut[nDan] : GetCoverSide_UpperSlab(nDan);

	CTwinVectorArray *pTvArrVertSection	= bVertDir ? &m_tvArrVertSection_Vert_Center[m_nTypeJongdanForRebar] : &m_tvArrVertSection_Ang_Center[m_nTypeJongdanForRebar][0];;

	if(Compare(dSttSta, -1.0, "=") && Compare(dEndSta, -1.0, "="))
	{
		CTwinVector tvUpper;
		CTwinVector tvStt, tvEnd;
		CString str	= m_bExistProtectionRiseFooting ? "시점벽체(부상방지저판)" : "시점벽체좌측면";
		pTvArrVertSection->GetTvByInfo(str, tvStt);
		dSttSta = tvStt.m_v2.x;


		str	= m_bExistProtectionRiseFooting ? "종점벽체(부상방지저판)" : "종점벽체우측면";
		pTvArrVertSection->GetTvByInfo(str, tvEnd);
		dEndSta = tvEnd.m_v1.x;

		dSttSta += dCoverSideStt / vAngStt.y;
		dEndSta -= dCoverSideEnd / vAngEnd.y;

		tv.m_v1	= m_bExistProtectionRiseFooting? tvStt.m_v2 : tvStt.m_v1;
		tv.m_v2	= tvEnd.m_v2;
	}

	// 하부슬래브에서 구하고자하는 tv까지의 거리
	double dOffset = bUpper ? (nDan > -1 ? m_dTS_Lower - m_dCoverUpper_LowerSlab[nDan] : 0) : 
		(nDan > -1 ? m_dCoverLower_LowerSlab[nDan] : m_dTS_Lower);
	if(nDan == -1)
		dOffset	= bUpper ? m_dTS_Lower : 0;

	GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), CDPoint(dSttSta, 0), CDPoint(0, 1), tv.m_v1);
	GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), CDPoint(dEndSta, 0), CDPoint(0, 1), tv.m_v2);
	tv.m_v1.y += dOffset;
	tv.m_v2.y += dOffset;

	return tv;
}

// 입력된 정보로 하부슬래브 철근 생성(1, 2, 3, 4cycle) 1~3단..
void CRcBridgeRebar::MakeRebarInfoCycle_LowerSlab( long nCycle, long nDan, BOOL bInput, long nVertDir/*=0*/ )
{
	// 사용할 변수들.. 
	CSafetyTypedPtrArray <CObArray, CDoubleArray*> *pArrDistUpper	= &m_pArrDistLowerSlab[nCycle][iUPPER][0];
	CSafetyTypedPtrArray <CObArray, CDoubleArray*> *pArrDistLower	= &m_pArrDistLowerSlab[nCycle][iLOWER][0];

	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRCUpper	= &m_pArrRCMainLowerSlab[nCycle][iUPPER][nDan];
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRCLower	= &m_pArrRCMainLowerSlab[nCycle][iLOWER][nDan];

	AhTPADelete(pArrRCUpper, (CRebarInfoCycle*)0);
	AhTPADelete(pArrRCLower, (CRebarInfoCycle*)0);

	if(IsBoxType() == FALSE) return;

	if(nCycle == -1) nCycle = GetCountCycleMainRebar() - 1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar() - 1) return;

	BOOL bVertDir	= IsVertDir();
	if(nVertDir!=0)
		bVertDir	= nVertDir == -1 ? TRUE : FALSE;
	m_bMakedRebarInfoCycleByVert = m_bMakedRebarInfoCycleByVertUpperSlab	= bVertDir;

	long nCycleReal	= nCycle;
	if(!m_bDetailInput23DanMainRebar)
	{
		if(nDan > 0)
			nCycle = 1;
	}
	
	CRebarPlacing rbPlacing;
	CTwinVector tv;
	CTwinVectorArray tvArr, tvArrTmp;

	CRebarInfoCycle *pRC = NULL;

	// 공통사용 변수
	CTwinVector tvRebar;		// 하부슬래브 좌표
	//double dOffset		= 0;	// 하단슬래브 상면에서 철근까지의 거리
	double dNextStt		= -1;	// 다음 철근의 시작위치(이음길이 고려한 위치)
	long nSize			= 0;	
	double dLenRoundDnabu	= 0; // 2Cycle철근 구부림 옵션 적용 길이
	double dDia			= 0;	// 철근 지름
	double dDiaNext		= 0;	// 다음 철근의 지름
	double dDiaReal		= 0;
	BOOL bExist			= TRUE;
	long nCountJoint	= 0;	// 이음개수
	long nIdx			= 0;
	CDPoint vAng		= CDPoint(0, 1);
	double dLenJoint	= 0;
	double dLenJointLast	= 0;

	// description 정보 /////
	CString sCycle	= m_pARcBridgeDataStd->GetStringCircleNum(1);
	CString sUpper	= "하";
	BOOL b2CycleBending	= ((nCycleReal == 1 || nCycleReal == 3) && m_bBendingDanBuRebar)? TRUE : FALSE; 
	///////////////////////////

	// 하부 슬래브 주철근 1단 1사이클
	tvRebar		= GetTvOffset_LowerSlab(nDan, FALSE, -1, -1, bVertDir);	
	//dOffset		= m_dCoverLower_LowerSlab[nDan];
// 	dNextStt	= -1;	
	nSize		= pArrDistLower->GetSize();
	long i = 0; for(i = 0; i < m_nQtyJigan; i++)
	{
		if(nSize <= i) continue;
		if(m_bDetailInput23DanMainRebar && nDan > 0)
		{
			if(nDan >= GetDanMainRebarLowerSlab(nCycleReal, FALSE, 0))
				break;

		}
		nCountJoint = GetCountJointMainRebarLowerSlab(nCycle, nDan, FALSE, i);
		nCountJoint	= nCountJoint > 0 ? nCountJoint : 1;
		nIdx		= 0;
		vAng		= bVertDir ? CDPoint(0, 1) : GetAngleJijum(i+1);
		dLenJointLast	= 0;
		dLenJoint		= 0;
		
		long j = 0; for(j = 0; j <  nCountJoint; j++)
		{
			dLenJointLast	= dLenJoint;
			double dist = GetDistMainRebarLowerSlab(nCycle, nDan, FALSE, i, j, FALSE, nVertDir);

			// 철근 지름과 가장자리철근 모따기밑 라운드 크기 ////////////
			dDia		= GetDiaMainRebarLowerSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, FALSE, i, nIdx);
			dDiaReal	= GetDiaMainRebarLowerSlab(nCycleReal, nDan, FALSE, i, nIdx);
			bExist		= IsExistMainRebarLowerSlab(nCycleReal, nDan, FALSE, i, nIdx++);
			dDiaNext	= GetDiaMainRebarLowerSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, FALSE, i, nIdx);
			if(nIdx == nCountJoint && i < m_nQtyJigan-1)
				dDiaNext	= GetDiaMainRebarLowerSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, FALSE, i+1, 0);

			dLenRoundDnabu	= GetLenRebarAtEdge(dDiaReal, FALSE, nVertDir, TRUE, b2CycleBending);
			if(i == 0 && !IsOutWall(TRUE)) 
			{
				dLenRoundDnabu	= 0;
			}
			if(i == m_nQtyJigan-1 && !IsOutWall(FALSE))
			{
				dLenRoundDnabu	= 0;
			}
			/////////////////////////////////////////////////////////////////
				

			// 철근 하나 추가
			pArrRCLower->Add(new CRebarInfoCycle);
			pRC		= pArrRCLower->GetAt(pArrRCLower->GetSize()-1);

			// 공통속성
			pRC->m_nTypeRebar	= REBAR_TYPE_MAIN;
 			pRC->m_nRebarDan	= 0;
			pRC->m_Dia			= dDia;
			pRC->m_bExist		= bExist;
			
			// 첫번째 지간에 첫번째 이음까지의 철근 
			if(i == 0 && j == 0)
			{
				double dLen		= GetLenRebarBeforeEdge_LowerSlab_Cycle13(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, FALSE, nVertDir);
				pRC->m_nPosStt	= REBARINFO_POS_STTWALL_OUTTER;
				pRC->m_nPosEnd	= REBARINFO_POS_LOWERSLAB_LOWER;
				dLenJoint		= GetValueJoint(pRC, dDiaNext, NULL, nVertDir);
				pRC->m_Dia		= dDiaReal;
				pRC->m_xyStt	= CDPoint(tvRebar.m_v1.x, tvRebar.m_v1.y + (dLenRoundDnabu+dLen));
				GetXyTanOfArc(tvRebar.m_v1, tvRebar.GetXyDir(), CDPoint(0, 1), dLenRoundDnabu, pRC->m_xyCen, pRC->m_xyMid2, pRC->m_xyMid1);
				//pRC->m_xyEnd	= GetXyToDistFromSlabUpper(pRC->m_xyMid2.x, dist + dLenJoint/2, 0, dOffset, bVertDir);
				GetXyMatchLineAndLine(pRC->m_xyMid2+CDPoint(dist+dLenJoint/2, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyEnd);
				pRC->m_R_Mid	= (b2CycleBending) ? 0 : dLenRoundDnabu;
				pRC->m_bRevArc	= TRUE;
				dNextStt		= pRC->m_xyEnd.x - dLenJoint;
			}
			else
			{
				// 첫번째 지간 이후의 첫번째 철근
				if(j == 0)
				{
					pRC->m_nPosStt	= REBARINFO_POS_LOWERSLAB_LOWER;
					pRC->m_nPosEnd	= REBARINFO_POS_LOWERSLAB_LOWER;
					dLenJoint		= GetValueJoint(pRC, dDiaNext, NULL, nVertDir);
					pRC->m_Dia		= dDiaReal;
					//pRC->m_xyStt	= GetXyToDistFromSlabUpper(dNextStt, 0, 0, dOffset, bVertDir);
					GetXyMatchLineAndLine(CDPoint(dNextStt, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyStt);
					//pRC->m_xyMid1	= GetXyToDistFromSlabUpper(GetStationOnJijum(i, 0, bVertDir), dist + dLenJoint/2, 0, dOffset, bVertDir);
					GetXyMatchLineAndLine(CDPoint(GetStationOnJijum(i, 0, bVertDir)+dist+dLenJoint/2, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyMid1);
					pRC->m_xyMid2	= pRC->m_xyMid1;
					pRC->m_xyEnd	= pRC->m_xyMid1;
					pRC->m_R_Mid	= 0;
					pRC->m_nPosStt	= REBARINFO_POS_LOWERSLAB_LOWER;
					pRC->m_nPosEnd	= REBARINFO_POS_LOWERSLAB_LOWER;
					dNextStt		= pRC->m_xyMid1.x - dLenJoint;

					// 첫번째 지간 이후의 첫번째 철근은 이전 철근과 합쳐 져야 한다.
					long nCount		= pArrRCLower->GetSize();
					m_Util.MergeRebarInfoCycle(pArrRCLower, nCount-2, nCount-1);

					// 각 지점에 걸리는 철근이다.
					// 2,3단일 경우 1단철근과 길이를 일치 시켜 준다.
					if(nDan > 0 && !m_bDetailInput23DanMainRebar)
					{
						pRC	= pArrRCLower->GetAt(pArrRCLower->GetSize()-1);
						CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRCLower1Dan	= 
							&m_pArrRCMainLowerSlab[nCycle][iLOWER][0];
						double dSta	= GetStationOnJijum(i, 0, bVertDir);

						for(long k = 0; k < pArrRCLower1Dan->GetSize(); k++)
						{
							CRebarInfoCycle *pRC1Dan	= pArrRCLower1Dan->GetAt(k);
							if(pRC1Dan->m_xyStt.x <= dSta && pRC1Dan->m_xyMid1.x >= dSta)
							{
								pRC->m_xyStt.x	= pRC1Dan->m_xyStt.x;
								pRC->m_xyMid1.x	= pRC1Dan->m_xyMid1.x;
							}
						}
					}
				}
				// 첫번째 이음 이후의 철근, 마지막 철근은 아님.
				else if(j > 0 && j < nCountJoint)
				{
					pRC->m_nPosStt	= REBARINFO_POS_LOWERSLAB_LOWER;
					pRC->m_nPosEnd	= REBARINFO_POS_LOWERSLAB_LOWER;
					dLenJoint		= GetValueJoint(pRC, dDiaNext, NULL, nVertDir);
					pRC->m_Dia		= dDiaReal;
					//pRC->m_xyStt	= GetXyToDistFromSlabUpper(dNextStt, 0, 0, dOffset, bVertDir);
					GetXyMatchLineAndLine(CDPoint(dNextStt, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyStt);
					//pRC->m_xyMid1	= GetXyToDistFromSlabUpper(dNextStt, dist + dLenJointLast/2 + dLenJoint/2, 0, dOffset, bVertDir);
					GetXyMatchLineAndLine(CDPoint(dNextStt + dist + dLenJointLast/2 + dLenJoint/2, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyMid1);
					pRC->m_xyMid2	= pRC->m_xyMid1;
					pRC->m_xyEnd	= pRC->m_xyMid1;
					pRC->m_R_Mid	= 0;
					dNextStt		= pRC->m_xyMid1.x - dLenJoint;

					if(nDan > 0 && !m_bDetailInput23DanMainRebar)
					{
						delete pRC;
						pArrRCLower->RemoveAt(pArrRCLower->GetSize()-1);
					}
				}
			}

			// 현재 지간의 마지막 철근을 구해야 되면..
			if(j == nCountJoint-1)
			{
				pArrRCLower->Add(new CRebarInfoCycle);
				pRC = pArrRCLower->GetAt(pArrRCLower->GetSize()-1);

				// 마지막 지간이면
				if(i == m_nQtyJigan-1)
				{
					dDia			= GetDiaMainRebarLowerSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, FALSE, i, -1);
					dDiaReal		= GetDiaMainRebarLowerSlab(nCycleReal, nDan, FALSE, i, -1);
					bExist			= IsExistMainRebarLowerSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, FALSE, i, -1);
					pRC->m_Dia		= dDiaReal;
					pRC->m_bExist	= bExist;
					pRC->m_nPosStt	= REBARINFO_POS_LOWERSLAB_LOWER;
					pRC->m_nPosEnd	= REBARINFO_POS_ENDWALL_OUTTER;

					double dLen		= GetLenRebarBeforeEdge_LowerSlab_Cycle13(nCycle, nDan, FALSE, FALSE, nVertDir);
					dLenRoundDnabu	= GetLenRebarAtEdge(dDiaReal, FALSE, nVertDir, TRUE, b2CycleBending);
					if(i == 0 && !IsOutWall(TRUE)) 
					{
						dLenRoundDnabu	= 0;
					}
					if(i == m_nQtyJigan-1 && !IsOutWall(FALSE))
					{
						dLenRoundDnabu	= 0;
					}
					//pRC->m_xyStt	= GetXyToDistFromSlabUpper(dNextStt, 0, 0, dOffset, bVertDir);
					GetXyMatchLineAndLine(CDPoint(dNextStt, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyStt);
					GetXyTanOfArc(tvRebar.m_v2, CDPoint(0, 1), tvRebar.GetXyDir(TRUE), dLenRoundDnabu, pRC->m_xyCen, pRC->m_xyMid2, pRC->m_xyMid1);
					pRC->m_xyEnd	= pRC->m_xyMid2 + CDPoint(0, dLen);
					pRC->m_R_Mid	= (b2CycleBending) ? 0 : dLenRoundDnabu;
					pRC->m_bRevArc	= TRUE;
					dNextStt		= pRC->m_xyEnd.x;
				}
				// 마지막 지간이 아니면
				else
				{
					dDia			= GetDiaMainRebarLowerSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, FALSE, i+1, 0);
					dDiaReal		= GetDiaMainRebarLowerSlab(nCycleReal, nDan, FALSE, i+1, 0);
					bExist			= IsExistMainRebarLowerSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, FALSE, i+1, 0);
					dDiaNext		= GetDiaMainRebarLowerSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, FALSE, i+2, 0);

					pRC->m_Dia		= dDia;
					pRC->m_bExist	= bExist;
					dLenJoint		= GetValueJoint(pRC, dDiaNext, NULL, nVertDir);
					pRC->m_Dia		= dDiaReal;

					//pRC->m_xyStt	= GetXyToDistFromSlabUpper(dNextStt, 0, 0, dOffset, bVertDir);
					GetXyMatchLineAndLine(CDPoint(dNextStt, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyStt);
					///pRC->m_xyMid1	= GetXyToDistFromSlabUpper(GetStationOnJijum(i+1, 0), 0, 0, dOffset, bVertDir);
					GetXyMatchLineAndLine(CDPoint(GetStationOnJijum(i+1, 0), 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyMid1);
					pRC->m_xyMid2	= pRC->m_xyMid1;
					pRC->m_xyEnd	= pRC->m_xyMid1;
					pRC->m_R_Mid	= 0;
					pRC->m_nPosStt	= REBARINFO_POS_LOWERSLAB_LOWER;
					pRC->m_nPosEnd	= REBARINFO_POS_LOWERSLAB_LOWER;
					dNextStt		= pRC->m_xyMid1.x - dLenJoint;
				}
			}

			// 두번째 지간부터는 이전 지간에 이음이 있는지 없는지 검사를 해야 되며
			// 마지막 지간의 경우 현재 지간에 이음이 있는지 없는지 검사를 해야 된다.
			if(j == 0)
			{
				if(i > 0)
				{
					if(GetCountJointMainRebarLowerSlab(nCycle, nDan, FALSE, i-1) == 0)
					{
						long nSize	= pArrRCLower->GetSize();
						if(nSize > 1)
						{
							if(nCountJoint == 1)
								m_Util.MergeRebarInfoCycle(pArrRCLower, nSize-3, nSize-2);
							else
								m_Util.MergeRebarInfoCycle(pArrRCLower, nSize-2, nSize-1);
						}
					}
				}

				if(i == m_nQtyJigan-1)
				{
					if(GetCountJointMainRebarLowerSlab(nCycle, nDan, FALSE, i) == 0)
					{
						long nSize	= pArrRCLower->GetSize();
						if(nSize > 1)
							m_Util.MergeRebarInfoCycle(pArrRCLower, nSize-2, nSize-1);
					}
				}
			}
		}
	}

	if(nDan > 0 && !m_bDetailInput23DanMainRebar)
	{
		// 하부철근 2,3단에서 시작철근이 끝좌표와 마지막철근의 시작좌표는 2cycle1단철근의 끝과시작좌표와 맞춰줘야 한다.
		// 그리고 벽체가 있는 경우 y좌표를 맞춰줘야 된다.
		if(pArrRCLower->GetSize() > 0)
		{
			const long cycle2	= 1;
			long i = 0; for(i = 0; i < 2; i++)
			{
				CRebarInfoCycle *pRC	= pArrRCLower->GetAt(i == 0 ? 0 : pArrRCLower->GetSize()-1);
				CRebarInfoCycle *pRC2Cycle	= GetRebarInfoCycleLowerSlab(cycle2, 0, FALSE, i==0 ? 0 : -1);

				if(pRC2Cycle)
				{
					if(i == 0)
					{
						// 상부 슬래브쪽 조정
						double dSta		= pRC2Cycle->m_xyEnd.x;
						//pRC->m_xyEnd	= GetXyToDistFromSlabUpper(dSta, 0, 0, dOffset, bVertDir);
						GetXyMatchLineAndLine(CDPoint(dSta, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyEnd);

						// 벽체쪽 조정
						pRC->m_xyStt.y	= pRC2Cycle->m_xyStt.y;
					}
					else
					{
						// 상부 슬래브쪽 조정
						double dSta		= pRC2Cycle->m_xyStt.x;
						//pRC->m_xyStt	= GetXyToDistFromSlabUpper(dSta, 0, 0, dOffset, bVertDir);	
						GetXyMatchLineAndLine(CDPoint(dSta, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyStt);

						// 벽체쪽 조정
						pRC->m_xyEnd.y	= pRC2Cycle->m_xyEnd.y;
					}
				}
			}
		}

		// 2단 이상일 경우 옵션에 의해서 설치되는 철근만 남기고 모두 제거 한다.
		// 각 지점에 하나씩 옵션이 지정됨
		long nIdx	= 0;
		for(i = 0; i < pArrRCLower->GetSize(); i++)
		{
			CRebarInfoCycle *pRC	= pArrRCLower->GetAt(i);
			pRC->m_Dia	= GetDiaMainRebarLowerSlab(nCycleReal, nDan, FALSE, 0, nIdx);
			ApplyExtLength23DanMainRebar_LowerSlab(pRC, GetLengthExt23DanRebarLowerSlab(FALSE, nIdx));
			if(nDan >= GetDanMainRebarLowerSlab(nCycleReal, FALSE, nIdx++))
			{
				delete pRC;
				pArrRCLower->RemoveAt(i);
				i--;
			}
		}
	}


	// Not Exist인 rc 제거
	/*
	if(!bInput)
		RemoveNotExistRebarInfoCycle(pArrRCUpper);
		*/

	// szMark 설정
	SetStringMarkToRebarInfoCycle(pArrRCLower, MARK_LOWERSLAB_LOWER, nCycleReal, bInput, bInput || (nCycleReal==0 && nDan==0), nDan);
	// sDescription 설정
	SetStringDescriptionRebarInfoCycle_LowerSlab(pArrRCLower, nCycleReal, FALSE, nDan);
	// 사각은 상부슬래브와 동일하므로 그냥 쓰자.
	SettingAngleInfoAtRebarInfoCycle_UpperSlab(pArrRCLower, 0, -1, -1, bVertDir);


	// 하부슬래브 상면 
// 	double dLenVerStt	= 100;	// 시종점 하면 철근 위로 올라가는 길이
// 	double dLenVerEnd	= 100;	// 시종점 하면 철근 위로 올라가는 길이
	
	// 벽체가 있으면 하면철근 꺽이는거 없음
//	double dLenVerStt	= 0;
//	double dLenVerEnd	= 0;

	nSize		= pArrDistUpper->GetSize();
	tvRebar		= GetTvOffset_LowerSlab(nDan, TRUE, -1, -1, bVertDir);	// 하부슬래브 좌표
	dNextStt	= tvRebar.m_v1.x;
	//dOffset		= m_dTS_Lower - m_dCoverUpper_LowerSlab[nDan];
	dLenJointLast	= 0;

	long nCountJointTot	= 0;
	for(i = 0; i < m_nQtyJigan; i++)
		nCountJointTot += GetCountJointMainRebarLowerSlab(nCycle, nDan, TRUE, i);

	if(nCountJointTot == 0)
	{
		if(nDan < GetDanMainRebarLowerSlab(nCycleReal, TRUE, 0))
		{
			dDiaReal	= GetDiaMainRebarLowerSlab(nCycleReal, nDan, TRUE, 0, 0);
			bExist		= IsExistMainRebarLowerSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, 0, 0);
			pArrRCUpper->Add(new CRebarInfoCycle);
			pRC = pArrRCUpper->GetAt(pArrRCUpper->GetSize()-1);

			

			// 공통속성
			pRC->m_nTypeRebar	= REBAR_TYPE_MAIN;
			pRC->m_nRebarDan	= 0;
			pRC->m_nPosStt		= REBARINFO_POS_LOWERSLAB_UPPER;
			pRC->m_nPosEnd		= REBARINFO_POS_LOWERSLAB_UPPER;
			pRC->m_Dia			= dDiaReal;
			pRC->m_bExist		= bExist;		

			pRC->m_xyStt		= tvRebar.m_v1;
			pRC->m_xyMid1		= tvRebar.m_v2;
			pRC->m_xyMid2		= tvRebar.m_v2;
			pRC->m_xyEnd		= tvRebar.m_v2;
		}
	}
	else
	{
		for(i = 0; i < m_nQtyJigan; i++)
		{
			if(i >= nSize) continue;
			if(m_bDetailInput23DanMainRebar && nDan > 0)
			{
				if(nDan >= GetDanMainRebarLowerSlab(nCycleReal, TRUE, 0))
					break;
			}
		
			nCountJoint	= GetCountJointMainRebarLowerSlab(nCycle, nDan, TRUE, i);
			nCountJoint	= nCountJoint > 0 ? nCountJoint : 1;
			nIdx		= 0;
			long j = 0; for(j = 0; j < nCountJoint; j++)
			{
				dLenJointLast	= dLenJoint;
				double dist = GetDistMainRebarLowerSlab(nCycle, nDan, TRUE, i, j, FALSE, nVertDir);
				dDia		= GetDiaMainRebarLowerSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, i, nIdx);
				dDiaReal	= GetDiaMainRebarLowerSlab(nCycleReal, nDan, TRUE, i, nIdx);
				bExist		= IsExistMainRebarLowerSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, i, nIdx++);
				dDiaNext	= GetDiaMainRebarLowerSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, i, nIdx);
				if(nIdx-1 == nCountJoint-1 && i < m_nQtyJigan-1)
				{
					dDiaNext	= GetDiaMainRebarLowerSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE , i+1, 0);
				}

				// 철근 하나 추가
				pArrRCUpper->Add(new CRebarInfoCycle);
				pRC = pArrRCUpper->GetAt(pArrRCUpper->GetSize()-1);

				// 공통속성
				pRC->m_nTypeRebar	= REBAR_TYPE_MAIN;
				pRC->m_nRebarDan	= 0;
				pRC->m_nPosStt		= REBARINFO_POS_LOWERSLAB_UPPER;
				pRC->m_nPosEnd		= REBARINFO_POS_LOWERSLAB_UPPER;
				pRC->m_Dia			= dDia;
				pRC->m_bExist		= bExist;


				// 첫번째 지간에 첫번째 이음까지의 철근 
				if(i == 0 && j == 0)
				{
					double dLenVerStt	= 0;

					pRC->m_nPosStt	= REBARINFO_POS_LOWERSLAB_SIDE;
					dLenJoint		= GetValueJoint(pRC, dDiaNext, NULL, nVertDir);
					pRC->m_Dia		= dDiaReal;

					//pRC->m_xyMid1	= GetXyToDistFromSlabUpper(tvRebar.m_v1.x, 0, 0, dOffset, bVertDir);
					pRC->m_xyMid1	= tvRebar.m_v1;
					pRC->m_xyStt	= pRC->m_xyMid1 + CDPoint(0, 1) * dLenVerStt;
					pRC->m_xyMid2	= pRC->m_xyMid1;
					//pRC->m_xyEnd	= GetXyToDistFromSlabUpper(pRC->m_xyMid1.x, dist+dLenJoint/2, 0, dOffset, bVertDir);
					GetXyMatchLineAndLine(CDPoint(pRC->m_xyMid1.x+dist+dLenJoint/2, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyEnd);
					pRC->m_R_Mid	= 0;
					dNextStt		= pRC->m_xyEnd.x - dLenJoint;
				}
				else
				{
					// 첫번째 지간 이후의 첫번째 철근
					if(j == 0)
					{
						dLenJoint		= GetValueJoint(pRC, dDiaNext, NULL, nVertDir);
						pRC->m_Dia		= dDiaReal;

						//pRC->m_xyStt	= GetXyToDistFromSlabUpper(dNextStt, 0, 0, dOffset, bVertDir);
						GetXyMatchLineAndLine(CDPoint(dNextStt, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyStt);
						//pRC->m_xyMid1	= GetXyToDistFromSlabUpper(GetStationOnJijum(i, 0, bVertDir), dist + dLenJoint/2, 0, dOffset, bVertDir);
						GetXyMatchLineAndLine(CDPoint(GetStationOnJijum(i, 0, bVertDir) + dist + dLenJoint/2, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyMid1);
						pRC->m_xyMid2	= pRC->m_xyMid1;
						pRC->m_xyEnd	= pRC->m_xyMid1;
						pRC->m_R_Mid	= 0;
						dNextStt		= pRC->m_xyMid1.x - dLenJoint;
						// 첫번째 지간 이후의 첫번째 철근은 이전 철근과 합쳐 져야 한다.
						long nCount		= pArrRCUpper->GetSize();
						m_Util.MergeRebarInfoCycle(pArrRCUpper, nCount-2, nCount-1);
					}
					// 첫번째 이음 이후의 철근, 마지막 철근은 아님.
					else if(j > 0 && j < nCountJoint)
					{
						dLenJoint		= GetValueJoint(pRC, dDiaNext, NULL, nVertDir);
						pRC->m_Dia		= dDiaReal;

						//pRC->m_xyStt	= GetXyToDistFromSlabUpper(dNextStt, 0, 0, dOffset, bVertDir);
						GetXyMatchLineAndLine(CDPoint(dNextStt, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyStt);
						//pRC->m_xyMid1	= GetXyToDistFromSlabUpper(dNextStt, dist + dLenJointLast/2 + dLenJoint/2, 0, dOffset, bVertDir);
						GetXyMatchLineAndLine(CDPoint(dNextStt + dist + dLenJointLast/2 + dLenJoint/2, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyMid1);
						pRC->m_xyMid2	= pRC->m_xyMid1;
						pRC->m_xyEnd	= pRC->m_xyMid1;
						pRC->m_R_Mid	= 0;
						dNextStt		= pRC->m_xyMid1.x - dLenJoint;
					}
				}

				// 현재 지간의 마지막 철근을 구해야 되면..
				if(j == nCountJoint-1)
				{
					pArrRCUpper->Add(new CRebarInfoCycle);
					pRC = pArrRCUpper->GetAt(pArrRCUpper->GetSize()-1);

					// 공통 속성
					pRC->m_nPosStt		= REBARINFO_POS_LOWERSLAB_UPPER;
					pRC->m_nPosEnd		= REBARINFO_POS_LOWERSLAB_UPPER;

					// 마지막 지간이면
					if(i == m_nQtyJigan-1)
					{
						double dLenVerEnd	= 0;

						dDia			= GetDiaMainRebarLowerSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, i, nIdx);
						dDiaReal		= GetDiaMainRebarLowerSlab(nCycleReal, nDan, TRUE, i, nIdx);
						bExist			= IsExistMainRebarLowerSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, i, nIdx++);
						pRC->m_Dia		= dDiaReal;
						pRC->m_bExist	= bExist;

						pRC->m_nPosEnd	= REBARINFO_POS_LOWERSLAB_SIDE;
						//pRC->m_xyStt	= GetXyToDistFromSlabUpper(dNextStt, 0, 0, dOffset, bVertDir);
						GetXyMatchLineAndLine(CDPoint(dNextStt, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyStt);
						//pRC->m_xyMid1	= GetXyToDistFromSlabUpper(tvRebar.m_v2.x, 0, 0, dOffset, bVertDir);
						pRC->m_xyMid1	= tvRebar.m_v2;
						pRC->m_xyMid2	= pRC->m_xyMid1;
						pRC->m_xyEnd	= pRC->m_xyMid2 + CDPoint(0, 1) * dLenVerEnd;
						pRC->m_R_Mid	= 0;
						dNextStt		= pRC->m_xyMid1.x;
					}
					// 마지막 지간이 아니면
					else
					{
						dDia			= GetDiaMainRebarLowerSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, i+1, 0);
						dDiaReal		= GetDiaMainRebarLowerSlab(nCycleReal, nDan, TRUE, i+1, 0);
						bExist			= IsExistMainRebarLowerSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, i+1, 0);
						dDiaNext		= GetDiaMainRebarLowerSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, i+2, 0);
						pRC->m_Dia		= dDia;
						pRC->m_bExist	= bExist;
						dLenJoint		= GetValueJoint(pRC, dDiaNext, NULL, nVertDir);
						pRC->m_Dia		= dDiaReal;

						//pRC->m_xyStt	= GetXyToDistFromSlabUpper(dNextStt, 0, 0, dOffset, bVertDir);
						GetXyMatchLineAndLine(CDPoint(dNextStt, 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyStt);
						//pRC->m_xyMid1	= GetXyToDistFromSlabUpper(GetStationOnJijum(i+1, 0), 0, 0, dOffset, bVertDir);
						GetXyMatchLineAndLine(CDPoint(GetStationOnJijum(i+1, 0), 0), CDPoint(0, 1), tvRebar.m_v1, tvRebar.GetXyDir(), pRC->m_xyMid1);
						pRC->m_xyMid2	= pRC->m_xyMid1;
						pRC->m_xyEnd	= pRC->m_xyMid1;
						pRC->m_xyCen	= pRC->m_xyMid1;
						pRC->m_R_Mid	= 0;
						dNextStt		= pRC->m_xyMid1.x - dLenJoint/2;
					}
				}

				// 두번째 지간부터는 이전 지간에 이음이 있는지 없는지 검사를 해야 되며
				// 마지막 지간의 경우 현재 지간에 이음이 있는지 없는지 검사를 해야 된다.
				if(j == 0)
				{
					if(i > 0)
					{
						if(GetCountJointMainRebarLowerSlab(nCycle, nDan, TRUE, i-1) == 0)
						{
							long nSize	= pArrRCUpper->GetSize();
							if(nSize > 1)
							{
								if(nCountJoint == 1)
									m_Util.MergeRebarInfoCycle(pArrRCUpper, nSize-3, nSize-2);
								else
									m_Util.MergeRebarInfoCycle(pArrRCUpper, nSize-2, nSize-1);
							}
						}
					}

					if(i == m_nQtyJigan-1)
					{
						if(GetCountJointMainRebarLowerSlab(nCycle, nDan, TRUE, i) == 0)
						{
							long nSize	= pArrRCUpper->GetSize();
							if(nSize > 1)
								m_Util.MergeRebarInfoCycle(pArrRCUpper, nSize-2, nSize-1);
						}
					}
				}
			}

			// 두번째 지간부터는 이전 지간의 이음이 0개인지 검사해서 0개이면 합쳐 버린다.
			if(i > 0)
			{
				if(GetCountJointMainRebarLowerSlab(nCycle, nDan, TRUE, i-1) == 0)
				{
					long nSize	= pArrRCUpper->GetSize();
					if(nSize > 1)
					{
						m_Util.MergeRebarInfoCycle(pArrRCUpper, nSize-2, nSize-1);
					}
				}
			}
		}
	}


	// 상면은 2,3에 대해서 모두 만든 뒤에 각 지각의 중앙에 있는 철근에 대해서만 설치여부를 결정한다.
	// 그리고 철근 위치를 1단 철근과 같게 만들어 준다.
	if(nDan > 0 && !m_bDetailInput23DanMainRebar)
	{
		CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRCUpper1Dan	= &m_pArrRCMainLowerSlab[nCycle][iUPPER][0];

		long i = 0; for(i = 0; i < pArrRCUpper->GetSize(); i++)
		{
			CRebarInfoCycle *pRC	= pArrRCUpper->GetAt(i);
			pRC->m_xyMid1	= pRC->m_xyEnd;
			pRC->m_xyMid2	= pRC->m_xyEnd;
			long j = 0; for(j = 0; j < pArrRCUpper1Dan->GetSize(); j++)
			{
				CRebarInfoCycle *pRC1	= pArrRCUpper1Dan->GetAt(j);
				double dMidX	= (pRC->m_xyStt.x+pRC->m_xyMid1.x)/2;
				if(pRC1->m_xyStt.x < dMidX && pRC1->m_xyMid1.x > dMidX)
				{
					pRC->m_xyStt.x	= pRC1->m_xyStt.x;
					pRC->m_xyMid1.x	= pRC1->m_xyEnd.x;
					pRC->m_xyMid2.x	= pRC1->m_xyEnd.x;
					pRC->m_xyEnd.x	= pRC1->m_xyEnd.x;
				}
			}

			BOOL bIs	= FALSE;
			for(long jigan = 0; jigan < m_nQtyJigan; jigan++)
			{
				double dXMid	= GetStationOnJijum(jigan, 0, bVertDir) + (GetStationOnJijum(jigan+1, 0, bVertDir) - GetStationOnJijum(jigan, 0, bVertDir))/2;

				if(pRC->m_xyStt.x < dXMid && pRC->m_xyMid1.x > dXMid)
				{
					bIs	= TRUE;
					if(nCountJointTot > 0)
					{
						pRC->m_Dia	= GetDiaMainRebarLowerSlab(nCycleReal, nDan, TRUE, 0, jigan);
						ApplyExtLength23DanMainRebar_LowerSlab(pRC, GetLengthExt23DanRebarLowerSlab(TRUE, jigan));
						if(nDan >= GetDanMainRebarLowerSlab(nCycleReal, TRUE, jigan)) 
							bIs	= FALSE;
					}
				}
			}


			if(!bIs)
			{
				delete pRC;
				pArrRCUpper->RemoveAt(i);
				i--;
			}
		}
	}

	// 교량 주철근이 하나의 철근으로 만들어지짖 않는 이상 이부분은 필요 없어 보인다.
	// 외측벽체 이음이 0개인 경우 하부슬래브와 연결되서 편입된다.
// 	long stt = 0; for(stt = 0; stt < 2; stt++)
// 	{
// 		BOOL bStt	= stt == iSTT;
// 		if(GetCountJointMainRebarOutWall(nCycle, nDan, bStt, FALSE) == 0 && IsEnableJointMainRebar_OutWallOutterAndUpperSlabUpper(bStt, nCycle==0||nCycle==2))
// 		{
// 			CRebarInfoCycle *pRCUpperSlab	= GetRebarInfoCycleUpperSlab(nCycle, nDan, TRUE, bStt?0:-1);
// 			CRebarInfoCycle *pRCOutWall		= GetRebarInfoCycleOutWall(nCycle, nDan, bStt, FALSE, bStt?0:-1);
// 			if(pRCUpperSlab && pRCOutWall)
// 			{
// 				if(bStt)
// 				{
// 					pRCUpperSlab->m_xyEndExt	= pRCUpperSlab->m_xyEnd;
// 					pRCUpperSlab->m_xyMidExt	= pRCUpperSlab->m_xyMid2;
// 					pRCUpperSlab->m_xyEnd		= pRCUpperSlab->m_xyMid1;
// 					pRCUpperSlab->m_xyCenExt	= pRCUpperSlab->m_xyCen;
// 					pRCUpperSlab->m_R_MidExt	= pRCUpperSlab->m_R_Mid;
// 					pRCUpperSlab->m_bUseCenExt	= TRUE;
// 					pRCUpperSlab->m_bUseMidExt	= TRUE;
// 					pRCUpperSlab->m_bUseEndExt	= TRUE;
// 					pRCUpperSlab->m_xyMid2		= pRCOutWall->m_xyMid2;
// 					pRCUpperSlab->m_xyMid1		= pRCOutWall->m_xyMid1;
// 					pRCUpperSlab->m_xyStt		= pRCOutWall->m_xyStt;
// 					pRCUpperSlab->m_xyCen		= pRCOutWall->m_xyCen;
// 					pRCUpperSlab->m_R_Mid		= pRCOutWall->m_R_Mid;
// 
// 					pRCUpperSlab->m_nPosStt		= pRCOutWall->m_nPosStt;
// 					AhTPADelete(&m_pArrRCMainOutWall[nCycleReal][stt][iOUTTER][nDan], (CRebarInfoCycle*)0);
// 				}
// 				else
// 				{
// 					pRCUpperSlab->m_xyEnd		= pRCOutWall->m_xyMid2;
// 					pRCUpperSlab->m_xyMidExt	= pRCOutWall->m_xyMid1;
// 					pRCUpperSlab->m_xyEndExt	= pRCOutWall->m_xyStt;
// 					pRCUpperSlab->m_xyCenExt	= pRCOutWall->m_xyCen;
// 					pRCUpperSlab->m_R_MidExt	= pRCOutWall->m_R_Mid;
// 					pRCUpperSlab->m_bUseMidExt	= TRUE;
// 					pRCUpperSlab->m_bUseEndExt	= TRUE;
// 					pRCUpperSlab->m_bUseCenExt	= TRUE;
// 
// 					pRCUpperSlab->m_nPosEnd		= pRCOutWall->m_nPosStt;
// 					AhTPADelete(&m_pArrRCMainOutWall[nCycleReal][stt][iOUTTER][nDan], (CRebarInfoCycle*)0);
// 				}
// 			}
// 		}
// 	}

	// Not Exist인 rc 제거
	/*
	if(!bInput)
		RemoveNotExistRebarInfoCycle(pArrRCLower);
		*/

	// szMark 설정
	SetStringMarkToRebarInfoCycle(pArrRCUpper, MARK_LOWERSLAB_UPPER, nCycleReal, bInput, bInput, nDan);
	// sDescription 설정
	SetStringDescriptionRebarInfoCycle_LowerSlab(pArrRCUpper, nCycleReal, TRUE, nDan);
	// 사각은 상부슬래브와 동일하므로 그냥 쓰자.
	SettingAngleInfoAtRebarInfoCycle_UpperSlab(pArrRCUpper, 0, -1, -1, bVertDir);
}

// 입력된 정보로 하부슬래브 상면 헌치 철근(모든 사이클)
void CRcBridgeRebar::MakeRebarInfoCycle_LowerSlabHunch( long nCycle, BOOL bInput, long nVertDir/*=0*/ )
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar() - 1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar() - 1) return;

	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC	= &m_pArrRCMainLowerSlabHunch[nCycle];
	if(!pArrRC) return;
	AhTPADelete(pArrRC, (CRebarInfoCycle*)0);

	if(IsBoxType() == FALSE) return;

	BOOL bVertDir	= IsVertDir();
	if(nVertDir != 0)
		bVertDir	= nVertDir == -1 ? TRUE : FALSE;

//	const double dSettle	= 100;	// 시종점 헌치철근 좌우로 확장되는 길이(정착장)
	CRebarPlacing rb;
	long nCountJijum	= m_nQtyJigan+1;
	
	CWallApp *pWall		= NULL;
	double dCover		= m_dCoverUpper_LowerSlab[0];
	CTwinVector tvRebarLower	= GetTvOffset_LowerSlab(0, FALSE, -1, -1, bVertDir);	// 상부슬래브 상면 주철근 1단
	CTwinVector tvInner;


	// 벽체 없는 경우의 피복 적용 ////////////////////////////
	CDPoint vAngStt	= bVertDir ? CDPoint(0, 1) : GetAngleJijum(0);
	CDPoint vAngEnd	= bVertDir ? CDPoint(0, 1) : GetAngleJijum(m_nQtyJigan);

	////////////////////////////////////////////////////////////////

	for(long jijum = 0; jijum < nCountJijum; jijum++)
	{
		double dDia			= 0;
		dDia	= GetDiaMainRebarLowerSlabHunch(nCycle, jijum);
		if(Compare(dDia, 0.0, "<=")) continue;
		//if(!IsHunch(jijum, FALSE)) continue;

		pArrRC->Add(new CRebarInfoCycle);
		CRebarInfoCycle *pRC	= pArrRC->GetAt(pArrRC->GetSize()-1);

		// 공통속성
		pRC->m_nTypeRebar		= REBAR_TYPE_MAIN;
		pRC->m_nRebarDan		= 0;
		pRC->m_nPosStt			= REBARINFO_POS_LOWERSLAB_UPPER;
		pRC->m_nPosEnd			= REBARINFO_POS_LOWERSLAB_UPPER;
		pRC->m_Dia				= dDia;
		pRC->m_bUseTvArrRebar	= TRUE;
		pRC->m_nPosHunch		= jijum;	// 이 철근이 어느 지점의 철근이지 기억 해둔다. (배근할때 반드시 필요함)

		// (39755) 양끝이 정착장 만큼 들어가야 하는데 100 만 넣어줬네.. 철근 그릴때 길이 표현하면 실제 수량과 다름
		double dRebarSpace	= GetCtcRebarMain(TRUE);
		double dSettle(0);
		if(m_pARcBridgeDataStd->IsLsdDesign())
		{
			SRebarEnvOption LsdRebarOpt;
			SetRebarLsdOptionSlab(&LsdRebarOpt, FALSE, TRUE, TRUE, 0, 0);
			dSettle = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueSettle(dDia, &LsdRebarOpt);
		}
		else
		{
			dSettle	= m_pARcBridgeDataStd->GetValueSettleByCalc((long)dDia, SETTLE_TENS_NORMAL, dCover, dRebarSpace, 2, 1);
		}

		BOOL bOK = FALSE;
		if(jijum == 0)
		{
			CTwinVector tvHunch;
			if(IsOutWall(TRUE))
			{
				m_tvArrVertSection.GetTvByInfo("시점벽체하부헌치", tvHunch);
				//헌치가 없는데 직경이 있는경우 모서리 기준으로 헌치 만들어줌
				if(!IsHunch(jijum, FALSE))
				{
					CDPoint xyHunchLeft = tvHunch.GetXyLeft();
					tvHunch.m_v1 = xyHunchLeft + 100 * CDPoint(-1, 1);
					tvHunch.m_v2 = xyHunchLeft + 100 * CDPoint(1, -1);
				}
				rb.Offset(tvHunch.m_v1, tvHunch.m_v2, dCover);

				if(Compare(m_dHRS, 0.0, ">") && m_nTypeRoundOfHunchStt == 1)
				{
					CDPoint xyCen	= tvHunch.GetXyCircleCenter();
					double dAngStt	= (tvHunch.m_v1 - xyCen).Unit().GetAngleDegree();
					double dAngEnd	= (tvHunch.m_v2 - xyCen).Unit().GetAngleDegree();
					CDPoint xyMid	= xyCen + ToDPointFrDegree((dAngStt+dAngEnd)/2) * fabs(tvHunch.m_v2.z);
					CDPoint vAng	= ((CDPoint)tvHunch.m_v2 - (CDPoint)tvHunch.m_v1).Unit();
					tvHunch.m_v1	= xyMid + vAng*-100;
					tvHunch.m_v2	= xyMid + vAng*100;
					tvHunch.m_v1.z	= 0;
					tvHunch.m_v2.z	= 0;
				}

				// 시점측 외측벽체 1단 철근
				CTwinVector tvOutWall	= GetTvOffset_OutWall(0, TRUE, FALSE, bVertDir);


				// 시점측벽체 외측면 철근과의 교점
				if(1)//Compare(m_dHRS, 0.0, "<=") || m_nTypeRoundOfHunchStt == 0)
				{
					bOK = GetXyMatchLineAndLine(tvHunch.m_v1, tvHunch.GetXyDir(), tvOutWall.m_v1, tvOutWall.GetXyDir(), pRC->m_xyMid1);

					// 33303 헌치가 수직이면 절대 외측면의 철근과는 만날 수 없다..
					CDPoint vHunchDir = tvHunch.GetXyDir();
					CDPoint vVerticalTop(0,1), vVertical(0,-1);
					if(ComparePt(vHunchDir,vVerticalTop, _T("="),0.01 ) || ComparePt(vHunchDir,vVertical, _T("="),0.01 ))
						bOK = FALSE;

					// 하부슬래브하면철근과의 교점
					if(bOK)
						bOK = GetXyMatchLineAndLine(tvHunch.m_v1, tvHunch.GetXyDir(TRUE), tvRebarLower.m_v1, tvRebarLower.GetXyDir(), pRC->m_xyMid2);

					pRC->m_xyStt	= pRC->m_xyMid1 + CDPoint(0, 1) * dSettle;
					pRC->m_xyEnd	= pRC->m_xyMid2 + tvRebarLower.GetXyDir() * dSettle;
					if(bOK)
					{
						CTwinVector tv;
						tv.m_v1	= pRC->m_xyStt;
						tv.m_v2	= pRC->m_xyMid1;
						pRC->m_tvArrRebar.Add(tv);

						tv.m_v1	= tv.m_v2;
						tv.m_v2	= pRC->m_xyMid2;
						pRC->m_tvArrRebar.Add(tv);

						tv.m_v1	= tv.m_v2;
						tv.m_v2	= pRC->m_xyEnd;
						pRC->m_tvArrRebar.Add(tv);
					}
				}
			}
		}
		else if(jijum == nCountJijum-1)
		{
			CTwinVector tvHunch;
			if(IsOutWall(FALSE))
			{
				m_tvArrVertSection.GetTvByInfo("종점벽체하부헌치", tvHunch);
				//헌치가 없는데 직경이 있는경우 모서리 기준으로 헌치 만들어줌
				if(!IsHunch(jijum, FALSE))
				{
					CDPoint xyHunchRight = tvHunch.GetXyRight();
					tvHunch.m_v1 = xyHunchRight + 100 * CDPoint(-1, -1);
					tvHunch.m_v2 = xyHunchRight + 100 * CDPoint(1, 1);
				}
				Offset(tvHunch.m_v1, tvHunch.m_v2, dCover);

				if(Compare(m_dHRE, 0.0, ">") && m_nTypeRoundOfHunchEnd == 1)
				{
					CDPoint xyCen	= tvHunch.GetXyCircleCenter();
					double dAngStt	= (tvHunch.m_v1 - xyCen).Unit().GetAngleDegree();
					double dAngEnd	= (tvHunch.m_v2 - xyCen).Unit().GetAngleDegree();
					if(dAngStt > dAngEnd)
						dAngStt -= 360;
					CDPoint xyMid	= xyCen + ToDPointFrDegree((dAngStt+dAngEnd)/2) * fabs(tvHunch.m_v2.z);
					CDPoint vAng	= (CDPoint(tvHunch.m_v2) - CDPoint(tvHunch.m_v1)).Unit();
					tvHunch.m_v1	= xyMid + vAng*-100;
					tvHunch.m_v2	= xyMid + vAng*100;
					tvHunch.m_v1.z	= 0;
					tvHunch.m_v2.z	= 0;
				}

				// 시점측 외측벽체 1단 철근
				if(1)//Compare(m_dHRE, 0.0, "<=") || m_nTypeRoundOfHunchEnd == 0)
				{
					CTwinVector tvOutWall	= GetTvOffset_OutWall(0, FALSE, FALSE, bVertDir);

					// 시점측벽체 외측면 철근과의 교점
					bOK = GetXyMatchLineAndLine(tvHunch.m_v1, tvHunch.GetXyDir(TRUE), tvOutWall.m_v1, tvOutWall.GetXyDir(), pRC->m_xyMid1);

					// 33303 
					CDPoint vHunchDir = tvHunch.GetXyDir();
					CDPoint vVerticalTop(0,1), vVertical(0,-1);
					if(ComparePt(vHunchDir,vVerticalTop, _T("="),0.01 ) || ComparePt(vHunchDir,vVertical, _T("="),0.01 ))
						bOK = FALSE;

					// 하부슬래브하면철근과의 교점
					if(bOK)
						bOK = GetXyMatchLineAndLine(tvHunch.m_v1, tvHunch.GetXyDir(), tvRebarLower.m_v1, tvRebarLower.GetXyDir(), pRC->m_xyMid2);

					pRC->m_xyStt	= pRC->m_xyMid1 + CDPoint(0, 1) * dSettle;
					pRC->m_xyEnd	= pRC->m_xyMid2 + tvRebarLower.GetXyDir(TRUE) * dSettle;
					if(bOK)
					{
						CTwinVector tv;
						tv.m_v1	= pRC->m_xyStt;
						tv.m_v2	= pRC->m_xyMid1;
						pRC->m_tvArrRebar.Add(tv);

						tv.m_v1	= tv.m_v2;
						tv.m_v2	= pRC->m_xyMid2;
						pRC->m_tvArrRebar.Add(tv);

						tv.m_v1	= tv.m_v2;
						tv.m_v2	= pRC->m_xyEnd;
						pRC->m_tvArrRebar.Add(tv);
					}
				}
			}
		}
		else
		{
			long nIdxWall		= jijum-1;
			CString sNumWall	= _T("");
			sNumWall.Format("%d", nIdxWall+1);
			pWall				= GetInWall(nIdxWall);
			//if(!IsHunch(jijum, FALSE)) continue;

			BOOL bHunchRebarV	= TRUE;
			if(pWall)
			{
				if(pWall->m_bIs)
				{
					if(pWall->m_bTopIsColumn)
						bHunchRebarV	= TRUE;
					else
						bHunchRebarV	= FALSE;
				}
			}

			if(m_bExpJoint[jijum])
			{
			}
			else
			{
				long nIdxHunch[2]		= {0, 0};
				CString sInfoFir		= _T("");
				CString sInfoLast		= _T("");
				CTwinVectorArray tvArrHunch;

				nIdxHunch[iLEFT]		= GetIdxHunchInWall(nIdxWall, TRUE);
				nIdxHunch[iRIGHT]		= GetIdxHunchInWall(nIdxWall, FALSE);

				double dH = GetHeightHunchByJijum(jijum, FALSE);
				double dW = GetWidthHunchByJijum(jijum, FALSE);
				double dHunchHB = m_dHBH[nIdxHunch[iLEFT]][iLOWER];

				long left = 0; for(left = 0; left < 2; left++)
				{
					// 오른쪽 구할때는 오른쪽와 왼쪽의 헌치 인덱스가 달라야 됨.
					if(left == iRIGHT)
					{
						if(nIdxHunch[iLEFT] == nIdxHunch[iRIGHT]) continue;

						// 오른쪽 구할때는 철근 하나더 추가.
						pArrRC->Add(new CRebarInfoCycle);
						pRC		= pArrRC->GetAt(pArrRC->GetSize()-1);
						*pRC	= *pArrRC->GetAt(pArrRC->GetSize()-2);	// 공통 속성 복사.
					}

					//상부슬래이브랑 순서가 반대인듯.
					sInfoFir.Format("%d번째내측하부헌치우측면", nIdxHunch[left]+1);
					sInfoLast.Format("%d번째내측하부헌치좌측면", nIdxHunch[left]+1);

					// 기둥식 벽체거나 V형인 경우
					long nTypeLowerSlabHunch	= m_dArrTypeLowerSlabHunch.GetSize() > jijum ? (long)m_dArrTypeLowerSlabHunch.GetAt(jijum) : 0;

					// 헌치에 R이 있는 경우 X형만 지원함
					if((bHunchRebarV || nTypeLowerSlabHunch == 1))
					{
						if(m_tvArrVertSection.GetTvArrByInfoRange(sInfoLast, sInfoFir, tvArrHunch))
						{
							for(long a = 0; a < tvArrHunch.GetSize(); a++)
								tvArrHunch.GetPAt(a)->m_bApplyAngle	= FALSE;

							rb.GetOffsetTvArray(tvArrHunch, dCover);

							// 처음과 끝은 하부슬래브철근과 교차점 찾음
							long nSize	= tvArrHunch.GetSize();
							if(nSize > 1)
							{
								CDPoint xyMatch(0, 0);
								CTwinVector tv = tvArrHunch.GetAt(0);
								//대각선헌치없고 HB만 있는경우 내측헌치아래우측면이 아니라 그냥 내측헌치우측면을 가지고와서..
								if((dH == 0 ||dW == 0) && dHunchHB > 0 && tv.m_sInfo == sInfoLast)
								{
									CString strHunch;
									strHunch.Format(_T("%d번째내측하부헌치위좌측면"),nIdxHunch[left]+1);
									tv = tvArrHunch.GetTvByInfo(strHunch);		
								}

								bOK = GetXyMatchLineAndLine(tv.m_v2, tv.GetXyDir(TRUE), tvRebarLower.m_v1, tvRebarLower.GetXyDir(), xyMatch);
								tv.m_v1	= xyMatch;
								tvArrHunch.SetAt(0, tv);

								if(bOK) 
								{
									tv	= tvArrHunch.GetAt(nSize-1);
									//대각선헌치없고 HB만 있는경우 내측헌치아래우측면이 아니라 그냥 내측헌치우측면을 가지고와서..
									if((dH == 0 ||dW == 0) && dHunchHB > 0 && tv.m_sInfo == sInfoFir)
									{
										CString strHunch;
										strHunch.Format(_T("%d번째내측하부헌치위우측면"),nIdxHunch[left]+1);
										tv = tvArrHunch.GetTvByInfo(strHunch);		
									}
									bOK = GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), tvRebarLower.m_v1, tvRebarLower.GetXyDir(), xyMatch);
									tv.m_v2	= xyMatch;
									tvArrHunch.SetAt(nSize-1, tv);
								}

								
								CString strHunch;
								strHunch.Format(_T("%d번째내측하부헌치윗면좌측"),nIdxHunch[left]+1);
								tvInner = tvArrHunch.GetTvByInfo(strHunch);		
							}
							
							// 철근이 3개 이상이면 첫번째 끝에꺼 그리고 첫번째와 끝을 연결한거만 남기고 다 지움
							long nSizeHunch	= tvArrHunch.GetSize();
							if(nSizeHunch > 3)
							{
								CTwinVector tv1	= tvArrHunch.GetAt(0);
								CTwinVector tv2	= tvArrHunch.GetAt(nSizeHunch-1);
								CTwinVector tvMid;
								tvArrHunch.RemoveAll();

								//#38436 
								// 좌우 헌치 높이가 다를 수 있다.
								//if(!Compare(tv1.m_v2.y, tv2.m_v1.y, "="))
								//{
								//	CDPointArray xyArrMatch;
								//	if(tv1.m_v2.y < tv2.m_v1.y)
								//	{
								//		rb.GetXyMatchLineAndArc2(tv2.m_v1, CDPoint(1, 0), tv1.m_v1, tv1.m_v2, fabs(tv1.m_v2.z), tv1.m_v1.z == -1, tv1.m_v2.z>0, xyArrMatch);
								//		if(xyArrMatch.GetSize() > 0)
								//		{
								//			tv1.m_v2	= xyArrMatch.GetAt(0);
								//		}
								//	}
								//	else
								//	{
								//		rb.GetXyMatchLineAndArc2(tv1.m_v2, CDPoint(1, 0), tv2.m_v1, tv2.m_v2, fabs(tv2.m_v2.z), tv2.m_v1.z == -1, tv2.m_v2.z>0, xyArrMatch);
								//		if(xyArrMatch.GetSize() > 0)
								//		{
								//			tv2.m_v1	= xyArrMatch.GetAt(0);
								//		}
								//	}
								//}

								//헌치 대각선헌치 + 돌출 높이가 있는경우
								if(dHunchHB > 0 && dH > 0 && dW > 0)
								{
									CTwinVector tvHBR, tvHBL;
									tvHBR.m_v1 = tvHBR.m_v2 = tv1.m_v2;
									//tvHBR.m_v2.y = tvHBR.m_v2.y + dHunchHB;
									tvHBR.m_v2.y = tvInner.m_v1.y;

									tvHBL.m_v1 = tvHBL.m_v2 = tv2.m_v1;
									//tvHBL.m_v1.y = tvHBL.m_v2.y + dHunchHB;
									tvHBL.m_v1.y = tvInner.m_v1.y;

									tvMid.m_v1 = tvHBR.m_v2;
									tvMid.m_v2 = tvHBL.m_v1;

									tvArrHunch.Add(tv1);
									tvArrHunch.Add(tvHBR);
									tvArrHunch.Add(tvMid);
									tvArrHunch.Add(tvHBL);
									tvArrHunch.Add(tv2);
								}
								else
								{
									tvMid.m_v1		= tv1.m_v2;
									tvMid.m_v2		= tv2.m_v1;
									tvMid.m_v2.y	= tvMid.m_v1.y;
									tvMid.m_v1.z	= 0;
									tvMid.m_v2.z	= 0;

									tvArrHunch.Add(tv1);
									tvArrHunch.Add(tvMid);
									tvArrHunch.Add(tv2);
								}
							}

							// 구해진 철근을 rebar info cycle에 넣음
							tvArrHunch.m_sInfo	= sNumWall;	// 벽체 번호
							pRC->m_tvArrRebar	= tvArrHunch;
						}
					}
					// 벽식 벽체인경우.
					else
					{
						// 좌측
						CTwinVector tvHunch;
						if(m_tvArrVertSection.GetTvByInfo(sInfoLast, tvHunch))
						{
							//헌치가 없는데 직경이 있는경우 모서리 기준으로 헌치 만들어줌
							if(!IsHunch(jijum, FALSE))
							{
								CDPoint xyHunchRight = tvHunch.GetXyRight();
								tvHunch.m_v1 = xyHunchRight + 100 * CDPoint(-1, -1);
								tvHunch.m_v2 = xyHunchRight + 100 * CDPoint(1, 1);
							}
							Offset(tvHunch.m_v1, tvHunch.m_v2, dCover);
							CTwinVector tvHunchOld	= tvHunch;

							long h = 0; for(h = 0; h < 2; h++)
							{
								tvHunch	= tvHunchOld;
								if(h == 1 && tvHunch.m_v1.z == 0) continue;

								tvHunch.m_v1.z	= 0;
								tvHunch.m_v2.z	= 0;

								// 벽체 1단 우측철근
								CTwinVector tvOutWall	= pWall->GetTvOffset_Front(nCycle, 0, TRUE, left==iLEFT, FALSE, bVertDir);

								// 벽체 철근과의 교점
								bOK = GetXyMatchLineAndLine(tvHunch.m_v1, tvHunch.GetXyDir(TRUE), tvOutWall.m_v1, tvOutWall.GetXyDir(), pRC->m_xyStt);

								// 상부슬래브상면철근과의 교점
								if(bOK) bOK = GetXyMatchLineAndLine(tvHunch.m_v1, tvHunch.GetXyDir(), tvRebarLower.m_v1, tvRebarLower.GetXyDir(), pRC->m_xyMid1);

								pRC->m_xyMid2	= pRC->m_xyMid1;
								pRC->m_xyEnd	= pRC->m_xyMid1;
								if(bOK)
								{
									CTwinVector tv;
									tv.m_v1	= pRC->m_xyStt;
									tv.m_v2	= pRC->m_xyMid1;
									pRC->m_tvArrRebar.Add(tv);
									pRC->m_tvArrRebar.m_sInfo	= sNumWall;
								}
							}
						}

						// 우측
						if(bOK && m_tvArrVertSection.GetTvByInfo(sInfoFir, tvHunch))
						{
							pArrRC->Add(new CRebarInfoCycle);
							pRC		= pArrRC->GetAt(pArrRC->GetSize()-1);
							*pRC	= *pArrRC->GetAt(pArrRC->GetSize()-2);	// 공통 속성 복사.
							pRC->m_tvArrRebar.RemoveAll();

							//헌치가 없는데 직경이 있는경우 모서리 기준으로 헌치 만들어줌
							if(!IsHunch(jijum, FALSE))
							{
								CDPoint xyHunchLeft = tvHunch.GetXyLeft();
								tvHunch.m_v1 = xyHunchLeft + 100 * CDPoint(-1, 1);
								tvHunch.m_v2 = xyHunchLeft + 100 * CDPoint(1, -1);
							}

							Offset(tvHunch.m_v1, tvHunch.m_v2, dCover);
							CTwinVector tvHunchOld	= tvHunch;

							long h = 0; for(h = 0; h < 2; h++)
							{
								tvHunch	= tvHunchOld;

								if(tvHunch.m_v1.z == 0 && h == 1) continue;

								tvHunch.m_v1.z	= 0;
								tvHunch.m_v2.z	= 0;

								// 벽체 1단 좌측철근
								CTwinVector tvOutWall	= pWall->GetTvOffset_Front(nCycle, 0, TRUE, left==iLEFT, TRUE, bVertDir);

								// 벽체 철근과의 교점
								bOK = GetXyMatchLineAndLine(tvHunch.m_v1, tvHunch.GetXyDir(TRUE), tvOutWall.m_v1, tvOutWall.GetXyDir(), pRC->m_xyStt);

								// 상부슬래브상면철근과의 교점
								if(bOK) bOK = GetXyMatchLineAndLine(tvHunch.m_v1, tvHunch.GetXyDir(), tvRebarLower.m_v1, tvRebarLower.GetXyDir(), pRC->m_xyMid1);

								pRC->m_xyMid2	= pRC->m_xyMid1;
								pRC->m_xyEnd	= pRC->m_xyMid1;
								if(bOK)
								{
									CTwinVector tv;
									tv.m_v1	= pRC->m_xyStt;
									tv.m_v2	= pRC->m_xyMid1;
									pRC->m_tvArrRebar.Add(tv);
									pRC->m_tvArrRebar.m_sInfo	= sNumWall;
								}
							}
						}
					}
				}
			}
		}

		// 헌치가 수직이나 수평이라 철근이 없는 경우...
		if(!bOK)
		{
			delete pRC;
			pArrRC->RemoveAt(pArrRC->GetSize()-1);
		}
	}

	// szMark 설정
	SetStringMarkToRebarInfoCycle(pArrRC, MARK_LOWERSLAB_HUNCH, nCycle, TRUE, FALSE, 0);
	// sDescription 설정
	SetStringDescriptionRebarInfoCycle_LowerSlabHunch(pArrRC, nCycle);
}

// RebarInfoCycle 하나를 찾아서 리턴한다.
CRebarInfoCycle * CRcBridgeRebar::GetRebarInfoCycleLowerSlab( long nCycle, long nDan, BOOL bUpper, long nIdx )
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return FALSE;
	if(nDan == -1) nDan = MAX_REBAR_DAN-1;
	if(nDan < 0 || nDan > MAX_REBAR_DAN-1) return FALSE;

	// 필요한 RebarInfoCycle 배열을 찾음
	long upper	= bUpper ? iUPPER : iLOWER;
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = &m_pArrRCMainLowerSlab[nCycle][upper][nDan];
	if(!pArrRC) return FALSE;

	long nSize	= pArrRC->GetSize();
	if(nIdx == -1) nIdx = nSize-1;
	if(nIdx >= nSize) return FALSE;
	if(nIdx < 0) return FALSE;

	return pArrRC->GetAt(nIdx);
	/*
	// 포인터를 넘겨도 되지만 별개로 관리해야 메모리 관리가 어지럽지 않을꺼 같아서 이렇게 함.
	*pRC	= *pArrRC->GetAt(nIdx);
	*/
}

// 존재하는 철근에서 사용되는 철근중의 nIdx에 해당하는 철근을 리턴한다. 
CRebarInfoCycle * CRcBridgeRebar::GetRebarInfoCycleLowerSlabCheckExist( long nCycle, long nDan, BOOL bUpper, long nIdx )
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return FALSE;
	if(nDan == -1) nDan = MAX_REBAR_DAN-1;
	if(nDan < 0 || nDan > MAX_REBAR_DAN-1) return FALSE;

	// 필요한 RebarInfoCycle 배열을 찾음
	long upper	= bUpper ? iUPPER : iLOWER;
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = &m_pArrRCMainLowerSlab[nCycle][upper][nDan];
	if(!pArrRC) return FALSE;

	long nSize	= pArrRC->GetSize();
	if(nIdx == -1)
	{
//		long nRealIdx = -1;
		long i = 0; for(i = nSize-1; i >= 0; --i)
		{
			CRebarInfoCycle *pRc = pArrRC->GetAt(i);
			if(!pRc)	continue;

			if(pRc->m_bExist && pRc->m_Dia > 0)
			{
				nIdx = i;
				break;
			}
		}
	}
	else
	{
		long nRealIdx = -1;
		long i = 0; for(i = 0; i < nSize; i++)
		{
			CRebarInfoCycle *pRc = pArrRC->GetAt(i);
			if(!pRc)	continue;

			if(pRc->m_bExist && pRc->m_Dia > 0)
				nRealIdx++;

			if(nIdx == nRealIdx)
			{
				nIdx = i;
				break;
			}
		}
	}
	
	if(nIdx >= nSize) return FALSE;
	if(nIdx < 0) return FALSE;

	return pArrRC->GetAt(nIdx);
}

long CRcBridgeRebar::GetDanMainRebarLowerSlab( long nCycle, BOOL bUpper, long nIdx )
{
	long upper	= bUpper ? iUPPER : iLOWER;
	long nSize = m_pArrSetRebarDanLowerSlab[upper].GetSize();
	if(nIdx == -1) nIdx = nSize-1;
	if(nIdx < 0 || nIdx >= nSize) return 1;

	CSetRebarDan *pRD	= m_pArrSetRebarDanLowerSlab[upper].GetAt(nIdx);

	long nDan	= pRD->m_nCountDan;
	if(nDan < 1 || nDan > MAX_REBAR_DAN) 
	{
		nDan = 1;
	}

	long nDanReal	= 1;

	if(m_bDetailInput23DanMainRebar)
	{
		long dan = 0; for(dan = 1; dan < MAX_REBAR_DAN; dan++)
		{
			BOOL bOKDia	= FALSE;
			BOOL bOKExist	= FALSE;
			long i = 0; for(i = 0; i < m_pArrDiaLowerSlab[nCycle][upper][dan].GetSize(); i++)
			{
				CDoubleArray *pDArr	= m_pArrDiaLowerSlab[nCycle][upper][dan].GetAt(i);
				long j = 0; for(j = 0; j < pDArr->GetSize(); j++)
				{
					if(pDArr->GetAt(j) > 0)
					{
						bOKDia	= TRUE;
						break;
					}
				}
			}

			for(i = 0; i < m_pArrExistLowerSlab[nCycle][upper][dan].GetSize(); i++)
			{
				CDoubleArray *pDArr	= m_pArrExistLowerSlab[nCycle][upper][dan].GetAt(i);
				long j = 0; for(j = 0; j < pDArr->GetSize(); j++)
				{
					if((BOOL)pDArr->GetAt(j) == TRUE)
					{
						bOKExist	= TRUE;
						break;
					}
				}
			}

			if(bOKDia && bOKExist)
				nDanReal++;
		}
	}
	else
	{
		long i = 0; for(i = 1; i < nDan; i++)
		{
			if(pRD->m_dDia[nCycle][i] > 0)
				nDanReal++;
		}

		if(nDanReal < 1 || nDanReal > MAX_REBAR_DAN) 
		{
			nDanReal = 1;
		}
	}

	return nDanReal;
}

long CRcBridgeRebar::GetCountJointMainRebarLowerSlab( long nCycle, long nDan, BOOL bUpper, long nJigan )
{
	if(nJigan >= m_nQtyJigan) nJigan = m_nQtyJigan-1;
	if(!m_bDetailInput23DanMainRebar)
		nDan	= 0;


	long nCount = 0;
	long upper	= bUpper ? iUPPER : iLOWER;
	nCount = nCycle == 0 || nCycle == 2 ? m_nCountJointMainRebar_LowerSlab_Cycle1[nJigan][upper][nDan] : m_nCountJointMainRebar_LowerSlab_Cycle2[nJigan][upper][nDan];

	if(nCount < 0) nCount = 0;

	return nCount;
}

double CRcBridgeRebar::GetDiaMainRebarLowerSlab( long nCycle, long nDan, BOOL bUpper, long nJigan, long nIdx )
{
	if(IsBoxType() == FALSE) return 0;
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return 0;
	if(nJigan == -1) nJigan = m_nQtyJigan-1;
	if(nJigan < 0 || nJigan > m_nQtyJigan-1) return 0;
	double dDia	= 0;
	long nSize	= 0;
	long upper	= bUpper ? iUPPER : iLOWER;

	if(nDan == 0 || m_bDetailInput23DanMainRebar)
	{
		nSize	= m_pArrDiaLowerSlab[nCycle][upper][nDan].GetSize();
		if(nJigan < nSize)
		{
			nSize	= m_pArrDiaLowerSlab[nCycle][upper][nDan][nJigan]->GetSize();
			if(nIdx == -1) nIdx = nSize-1;

			if(nIdx < nSize && nIdx > -1)
				dDia	= m_pArrDiaLowerSlab[nCycle][upper][nDan][nJigan]->GetAt(nIdx);
			else 
			{
				// 개수가 없는 경우 상부슬래브 철근에 이음이 한개도 없어서 마지막 지간에만 직경이 하나 들어 가 있을 수 있다.
				nSize	= m_pArrDiaLowerSlab[nCycle][upper][nDan][m_nQtyJigan-1]->GetSize();
				if(nIdx == -1)
					nIdx = nSize - 1;

				if(nIdx < nSize && nIdx > -1)
					dDia	= m_pArrDiaLowerSlab[nCycle][upper][nDan][m_nQtyJigan-1]->GetAt(nIdx);
				else
					dDia	= 0;
			}
		}
	}
	// 2단부터는 다른 변수에 저장되어 있다
	// 2단이상은 그냥 내측 외측으로 지름이 구분되어 있음.
	// 2단이 index 0이고 3단이 1이다.
	else if(nDan > 0)
	{
		if(nDan == -1) nDan = MAX_REBAR_DAN-1;
		if(nDan < 0) return 0;
		if(nDan > MAX_REBAR_DAN-1) return 0;
		if(nCycle == -1) nCycle = MAX_REBAR_CYCLE-1;
		if(nCycle < 0) return 0;
		if(nCycle > MAX_REBAR_CYCLE-1) return 0;

		nSize	=  m_pArrSetRebarDanLowerSlab[upper].GetSize();
		if(nSize == 1 && !bUpper)
			nIdx	= 0;

		if(nIdx == -1) nIdx	= nSize-1;
		if(nIdx < 0 || nIdx > nSize-1) return 0;

		CSetRebarDan *pRD	= m_pArrSetRebarDanLowerSlab[upper].GetAt(nIdx);
		if(pRD->m_nCountDan > nDan && GetCountCycleMainRebar() > nCycle)
		{
			dDia	= pRD->m_dDia[nCycle][nDan];
		}
		else 
			dDia	= 0;
	}

	return dDia;
}

double CRcBridgeRebar::GetDiaMainRebarLowerSlabHunch( long nCycle, long nJijum )
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return 0;
	if(nJijum == -1) nJijum = m_nQtyJigan;
	if(nJijum < 0 || nJijum > m_nQtyJigan) return 0;

	CDoubleArray *pdArr	= &m_dArrDiaLowerSlabHunch[nCycle];
	if(!pdArr) return 0;

	double dDia	= 0;
	long nSize	= pdArr->GetSize();
	if(nSize-1 < nJijum) dDia = 0;
	else dDia	= pdArr->GetAt(nJijum);

	// 진짜 헌치가 있는지 한번 더 검사.
	//if(!IsHunch(nJijum, FALSE)) dDia	= 0;

	return dDia;
}

BOOL CRcBridgeRebar::SetDiaMainRebarUpperSlabHunch(long nCycle, long nJijum, double dDia)
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return FALSE;
	if(nJijum == -1) nJijum = m_nQtyJigan;
	if(nJijum < 0 || nJijum > m_nQtyJigan) return FALSE;

	CDoubleArray *pdArr	= &m_dArrDiaUpperSlabHunch[nCycle];
	if(!pdArr) return FALSE;

	long nSize	= pdArr->GetSize();
	if(nSize-1 < nJijum) return FALSE;
	else pdArr->SetAt(nJijum, dDia);

	// 진짜 헌치가 있는지 한번 더 검사.
	//if(!IsHunch(nJijum)) dDia	= 0;

	return TRUE;
}


BOOL CRcBridgeRebar::SetDiaMainRebarLowerSlabHunch( long nCycle, long nJijum, double dDia )
{
	if(nCycle == -1) nCycle = GetCountCycleMainRebar()-1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar()-1) return FALSE;
	if(nJijum == -1) nJijum = m_nQtyJigan;
	if(nJijum < 0 || nJijum > m_nQtyJigan) return FALSE;

	CDoubleArray *pdArr	= &m_dArrDiaLowerSlabHunch[nCycle];
	if(!pdArr) return 0;

	long nSize	= pdArr->GetSize();
	if(nSize-1 < nJijum) return FALSE;
	else pdArr->SetAt(nJijum, dDia);

	return TRUE;
}

// 하부부슬래브 가장자리 이전 철근의 길이
// 예를 들어 벽체와 슬래브연결시 모따기(라운드)이전 직선 철근의 길이.(1cycle전용함수)
// 1,3 cycle
double CRcBridgeRebar::GetLenRebarBeforeEdge_LowerSlab_Cycle13( long nCycle, long nDan, BOOL bStt, BOOL bInner, long nVertDir )
{
// 	BOOL bVertDir	= IsVertDir();
// 	if(nVertDir!=0)
// 		bVertDir	= nVertDir == -1 ? TRUE : FALSE;

	CTwinVector tvLower;		// 하부슬래브 하면 철근
	CTwinVector tvOutWallRebar;	// 외측벽체철근
	CTwinVector tvUpper;		// 상부슬래브 상면
	CRebarPlacing rb;

	double dTot			= GetDistMainRebarOutWall(nCycle, nDan, bStt, bInner, 0, TRUE);			// 외측벽체철근이 배근된 첫번째 길이.
// 	long nJigan			= bStt ? 0 : m_nQtyJigan-1;
// 	double dDiaSlab		= GetDiaMainRebarLowerSlab(nCycle, nDan, FALSE, nJigan, bStt ? 0 : -1);
// 	double dRSlab		= bInner ? 0 : IsOutWall(TRUE) ? GetLenRebarAtEdge(dDiaSlab, FALSE, 0, TRUE) : 0;
	double dLengthJoint	= 0;

	// 외측 벽체의 경우 경사에 의해서 R 높이가 달라 지는 경우가 있음 
// 	if(!bStt && !bInner && m_nTypeJongdanForRebar == 1 && m_bSlopeLowerSlab)
// 	{
// 		double dAng = 0;
// 		double dDiff = 0;
// 		dAng	= GetTvOffset_LowerSlab(0, FALSE, -1, -1, bVertDir).GetXyDir().GetAngleDegree();
// 
// 		CDPoint xyMatch1(0, 0), xyMatch2(0, 0), xyCen(0, 0);
// 		GetXyTanOfArc(CDPoint(0, 0), ToDPointFrDegree(dAng+180), CDPoint(0, -1), dRSlab, xyCen, xyMatch1, xyMatch2);
// 		dDiff	= fabs(dRSlab - fabs(xyMatch2.y));
// 		// 이전 위치를 구할때 GetXyTanOfArc()를 사용하는 경우에는 경사에대한 R값이 반영되어야 한다.
// 
// 		if(dAng > 0 && dAng < 180)
// 		{
// 			dRSlab += dDiff;
// 		}
// 		else
// 		{
// 			dRSlab -= dDiff;
// 		}
// 	}

	// 이음 길이 구함 /////////////////////
	// Box형일때 외측벽체 이음이 1개일때 외측벽체 철근이 없기 때문에 상부슬래브 철근을...
	CRebarInfoCycle *pRCWall	= bInner ? GetRebarInfoCycleOutWall(nCycle, nDan, bStt, bInner, GetCountJointMainRebarOutWall(nCycle, nDan, bStt, bInner)-1) : GetRebarInfoCycleOutWall(nCycle, nDan, bStt, bInner, -1);
	CRebarInfoCycle *pRCSlab	= bInner ? GetRebarInfoCycleOutWall(nCycle, nDan, bStt, bInner, -1) : GetRebarInfoCycleLowerSlab(nCycle, nDan, FALSE, bStt ? 0 : -1);
	if(pRCWall == NULL && !bInner && IsBoxType())
	{
		pRCWall  =GetRebarInfoCycleUpperSlab(nCycle, nDan, TRUE, bStt? 0:-1);
	}

	if(pRCWall)
	{
		double dDiaNext = (pRCSlab)? pRCSlab->m_Dia : 0;

		// 시점측은 구해온 벽체 철근이 아래에서 위로 올라가므로 하부슬래브 이음을 구할때는 철근 시작점의 이음을 구한다.
		dLengthJoint	= GetValueJoint(pRCWall, dDiaNext, NULL, 0, bStt)/2;
	}

	// 이음 길이 구함 /////////////////////

	// 첫번째 구간 길이에 Joint 길이만 고려해준다.
	double dLen		= dTot + dLengthJoint;
	return dLen;
}

void CRcBridgeRebar::ApplyExtLength23DanMainRebar_LowerSlab( CRebarInfoCycle* pRC, double dLengthExt23DanRebar )
{
	if(!pRC) return;
	if(!pRC->m_bExist) return;

	if(pRC->m_nPosStt != pRC->m_nPosEnd)
	{
		CDPoint xyDir	= CDPoint(0, 1);

		if(pRC->m_nPosStt != REBARINFO_POS_STTWALL_OUTTER || IsOutWall(TRUE))
		{
			xyDir	= (pRC->m_xyMid1 - pRC->m_xyStt).Unit();
			pRC->m_xyStt	= pRC->m_xyStt + (xyDir * -	dLengthExt23DanRebar);
		}


		if(pRC->m_nPosEnd != REBARINFO_POS_ENDWALL_OUTTER || IsOutWall(FALSE))
		{
			xyDir	= (pRC->m_xyEnd - pRC->m_xyMid2).Unit();
			pRC->m_xyEnd	= pRC->m_xyEnd + (xyDir * dLengthExt23DanRebar);
		}
	}
	else
	{
		CDPoint xyDir	= (pRC->m_xyMid1 - pRC->m_xyStt).Unit();
		pRC->m_xyStt	= pRC->m_xyStt + (xyDir * -dLengthExt23DanRebar);
		pRC->m_xyMid1	= pRC->m_xyMid1 + (xyDir * dLengthExt23DanRebar);
		pRC->m_xyMid2	= pRC->m_xyMid1;
		pRC->m_xyEnd	= pRC->m_xyMid1;
	}
}

double CRcBridgeRebar::GetLengthExt23DanRebarLowerSlab( BOOL bUpper, long nIdx )
{
	long upper	= bUpper ? iUPPER : iLOWER;
	long nSize = m_pArrSetRebarDanLowerSlab[upper].GetSize();
	if(nIdx == -1) nIdx = nSize-1;
	if(nIdx < 0 || nIdx >= nSize) return 1;

	CSetRebarDan *pRD	= m_pArrSetRebarDanLowerSlab[upper].GetAt(nIdx);
	return pRD->m_dLengthExt23DanRebar;
}

void CRcBridgeRebar::SetStringDescriptionRebarInfoCycle_LowerSlab( CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC, long nCycle, BOOL bUpper, long nDan )
{
	if(!pArrRC) return;

	CString sUpper	= bUpper ? "상" : "하";
	CString sCycle	= m_pARcBridgeDataStd->GetStringCircleNum(nCycle+1);
	long nIdx		= 1;

	long nSize	= pArrRC->GetSize();
	long i = 0; for(i = 0; i < nSize; i++)
	{
		CRebarInfoCycle *pRC	= pArrRC->GetAt(i);
		if(!pRC->m_bExist) continue;

		pRC->m_sDescription.Format("하부SLAB %s면 %d단 %s %d", sUpper, nDan+1, sCycle, nIdx++);
	}
}

void CRcBridgeRebar::SetStringDescriptionRebarInfoCycle_LowerSlabHunch( CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC, long nCycle )
{
	if(!pArrRC) return;

	CString sCycle	= m_pARcBridgeDataStd->GetStringCircleNum(nCycle+1);
	long nIdx		= 1;

	long nSize	= pArrRC->GetSize();
	long i = 0; for(i = 0; i < nSize; i++)
	{
		CRebarInfoCycle *pRC	= pArrRC->GetAt(i);
		pRC->m_sDescription.Format("하부SLAB 헌치부철근 %s %d", sCycle, nIdx++);
	}
}

void CRcBridgeRebar::MakeRebarInfoCycle_OutWallBoxType( long nCycle, long nDan, BOOL bInput, long nVertDir/*=0*/ )
{
	if(IsBoxType() == FALSE) return;

	if(nCycle == -1) nCycle = GetCountCycleMainRebar() - 1;
	if(nCycle < 0 || nCycle > GetCountCycleMainRebar() - 1) return;
	BOOL bVertDir	= IsVertDir();
	if(nVertDir != 0)
		bVertDir	= nVertDir == -1 ? TRUE : FALSE;

	AhTPADelete(&m_pArrRCMainOutWall[nCycle][iSTT][iINNER][nDan], (CRebarInfoCycle*)0);
	AhTPADelete(&m_pArrRCMainOutWall[nCycle][iSTT][iOUTTER][nDan], (CRebarInfoCycle*)0);
	AhTPADelete(&m_pArrRCMainOutWall[nCycle][iEND][iINNER][nDan], (CRebarInfoCycle*)0);
	AhTPADelete(&m_pArrRCMainOutWall[nCycle][iEND][iOUTTER][nDan], (CRebarInfoCycle*)0);
	
	long nCycleReal	= nCycle;
	if(!m_bDetailInput23DanMainRebar)
	{
 		if(nDan > 0)
			nCycle	= 1;
	}
	CRebarPlacing rbPlacing;
	CTwinVector tv;
	CTwinVectorArray tvArr, tvArrTmp;

	// 공통사용 변수
	CTwinVector tvRebar;	// 외측벽체 외측 좌표
	CDPoint xyStt(0, 0);
	double dNextStt		= -1;	// 다음 철근의 시작위치(이음길이 고려한 위치)
	long nSize			= 0;	
	double dist			= 0;
	double dLenRound	= 0;	// 가장자리 철근의 모따리나 라운드 크기
	double dDia			= 0;	// 철근 지름
	double dDiaReal		= 0;
	BOOL bExist			= FALSE;
	double dDiaNext		= 0;	// 이음 길이를 구하기 위한 다음 철근 지름
	BOOL bStt			= TRUE;
	BOOL bInner			= TRUE;
	long nCountJoint	= 0;
	long nCountRealJoint	= 0;
	CDPoint vAng	= CDPoint(0, 1);
	double dLenJoint	= 0;
	double dLenJointLast	= 0;

	
	BOOL bCheckDist	= TRUE;	// 벽체 내측의 경우 이음이 없어도 생성이 될 수 있으므로 실제 이음 거리를 체크하지 않아야 할 때가 있다.
	BOOL bIsMainRebarUpperSlab	= FALSE;	// 상부슬래브와 연결되서 실제 지름이 상부슬래브 철근이 적용되어야 하는지??
	
	// 시,종점측 외측벽체 외측면 주철근 1단 1사이클
	long stt = 0; for(stt = 0; stt < 2; stt++)
	{
		bStt	= (stt == iSTT);
		vAng	= bVertDir ? CDPoint(0, 1) : GetAngleJijum(bStt ? 0 : m_nQtyJigan);
		if(IsOutWall(bStt))
		{
			CTwinVector tv;
			m_tvArrVertSection.GetTvByInfo(bStt? _T("하부슬래브하면(시점벽체아래)") : _T("하부슬래브하면(종점벽체아래)"), tv);
			
			// 내측, 외측 
			for(long inner = 0; inner < 2; inner++)
			{ 
				bInner		= (inner == iINNER);
				tvRebar		= GetTvOffset_OutWall(nDan, bStt, bInner, bVertDir);
				xyStt		= tvRebar.m_v1 ;	// 시작위치
				dNextStt	= xyStt.y;
				nCountJoint	= GetCountJointMainRebarOutWall(nCycle, nDan, bStt, bInner);
				nCountRealJoint	= nCountJoint;
				bCheckDist	= TRUE;
				bIsMainRebarUpperSlab	= FALSE;

				if(nDan >= GetDanMainRebarOutWall(nCycleReal, bStt, bInner)) continue;

			
				if(nCountJoint == 0)
				{
					nCountJoint	= 1;	// 외측벽체는 이음이 무조건 1개이상이다.(상부슬래브와 항상 연결되면서 이음이 생김)
					// 내측벽체의 경우 계산 실제 변수까지 속여야 됨.
					if(bInner)
					{
						if(nCycle == 0 || nCycle == 2)
							m_nCountJointMainRebar_OutWall_Cycle1[stt][inner][0]	= 1;
						else
							m_nCountJointMainRebar_OutWall_Cycle2[stt][inner][0]	= 1;
						bCheckDist	= FALSE;
					}
					else
					{
						if(nDan == 0 && IsEnableJointMainRebar_OutWallOutterAndUpperSlabUpper(bStt, nCycle==0||nCycle==2))
						{
							bCheckDist	= FALSE;
							bIsMainRebarUpperSlab	= TRUE;
						}

						//#0029461
						//m_bDetailInput23DanMainRebar의 값이 FALSE면서 nDan이 0보다 큰경우 기본값을 설정하지 않게된다... 때문에 dDist와 bExist가 0값이 되어 철근을 그리지 못하게 된다.
						if(m_bDetailInput23DanMainRebar == FALSE && nDan > 0)
							bCheckDist = FALSE;
					}

					
				}

				for(long joint = 0; joint < nCountJoint; joint++)
				{
					dLenJointLast	= dLenJoint;
					dist = GetDistMainRebarOutWall(nCycle, nDan, bStt, bInner, joint, FALSE);
					
					if(Compare(dist, 0.0, "=") && bCheckDist) continue;

					// 철근 지름과 가장자리철근 모따기밑 라운드 크기 ////////////
					dDia	= !bIsMainRebarUpperSlab ? GetDiaMainRebarOutWall(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, bStt, bInner, joint) : GetDiaMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, 0, 0);
					dDiaReal	= !bIsMainRebarUpperSlab ? GetDiaMainRebarOutWall(nCycleReal, nDan, bStt, bInner, joint) : GetDiaMainRebarUpperSlab(nCycleReal, nDan, TRUE, 0, 0);
					bExist	= !bIsMainRebarUpperSlab ? IsExistMainRebarOutWall(nCycleReal, nDan, bStt, bInner, joint) : IsExistMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, 0, 0);
					dDiaNext	= GetDiaMainRebarOutWall(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, bStt, bInner, joint+1);

					//#0029461
					//m_bDetailInput23DanMainRebar의 값이 FALSE이고 nDan이 0보다 큰경우 기본값을 설정하지 않게된다... 때문에 dDist와 bExist가 0값이 되어 철근을 그리지 못하게 된다.
					if(bCheckDist == FALSE && m_bDetailInput23DanMainRebar == FALSE && nDan > 0)
						bExist = TRUE;

					// 외측벽체 첫철근이면 하부슬래브 철근을 적용
					if(!bInner && joint == 0)
					{
						dDiaReal =  GetDiaMainRebarLowerSlab(nCycleReal, nDan, FALSE, bStt? 0 : m_nQtyJigan-1, 0);
					}
					dLenRound	= GetLenRebarAtEdge(dDiaReal);
					/////////////////////////////////////////////////////////////////

					// 외측벽체 철근 마지막이면 상부슬래브 첫번째나 마지막 철근과 비교해서 이음장 구함.
					if(Compare(dDiaNext, 0.0, "=") && !bInner && joint == nCountJoint-1)
					{
						dDiaNext	= GetDiaMainRebarUpperSlab(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, TRUE, bStt ? 0 : m_nQtyJigan-1, bStt ? 0 : -1);
					}

					// 내측벽체이고 첫 이음이면 하부슬래브와 연결되는 철근을 하나 더 만들어 뿐다.
					if(joint == 0)
					{
						if(bInner)
						{
							m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan].Add(new CRebarInfoCycle);
							CRebarInfoCycle *pRC	= m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan].GetAt(m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan].GetSize()-1);

							// 공통속성
							pRC->m_nTypeRebar	= REBAR_TYPE_MAIN;
							pRC->m_nPosStt		= bStt ? REBARINFO_POS_STTWALL_INNER : REBARINFO_POS_ENDWALL_INNER;
							pRC->m_nPosEnd		= pRC->m_nPosStt;
							pRC->m_bExist		= bExist;
							pRC->m_nRebarDan	= 0;

							pRC->m_Dia		= dDia;
							dLenJoint		= GetValueJoint(pRC, dDiaNext);
							pRC->m_Dia		= dDiaReal;

							pRC->m_xyStt	= xyStt;
							pRC->m_xyMid1	= CDPoint(pRC->m_xyStt.x, pRC->m_xyStt.y + dist + dLenJoint/2);
							pRC->m_xyMid2	= pRC->m_xyMid1;;
							pRC->m_xyEnd	= pRC->m_xyMid1;
							pRC->m_xyCen	= pRC->m_xyMid1;
							pRC->m_R_Mid	= 0;
							dNextStt		= pRC->m_xyEnd.y - dLenJoint;
						}
						else
						{
							CRebarInfoCycle *pRC	= GetRebarInfoCycleLowerSlab(nCycle, nDan, FALSE, bStt? 0:-1);
							dLenJoint		= GetValueJoint(pRC, dDiaNext, NULL, 0 , bStt);
							dNextStt		= xyStt.y + dLenRound + dist - dLenJoint/2;
						}
					}
					else if(joint > 0)
					{
						m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan].Add(new CRebarInfoCycle);
						CRebarInfoCycle *pRC	= m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan].GetAt(m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan].GetSize()-1);

						pRC->m_nTypeRebar	= REBAR_TYPE_MAIN;
						pRC->m_nPosStt		= bStt ? (bInner ? REBARINFO_POS_STTWALL_INNER : REBARINFO_POS_STTWALL_OUTTER) 
							: (bInner ? REBARINFO_POS_ENDWALL_INNER : REBARINFO_POS_STTWALL_OUTTER);
						pRC->m_nPosEnd		= pRC->m_nPosStt;
						pRC->m_bExist		= bExist;
						pRC->m_nRebarDan	= 0;
						pRC->m_Dia		= dDia;
						dLenJoint	= GetValueJoint(pRC, dDiaNext);
						pRC->m_Dia		= dDiaReal;

						pRC->m_xyStt	= CDPoint(xyStt.x, dNextStt);
						pRC->m_xyMid1	= CDPoint(pRC->m_xyStt.x, pRC->m_xyStt.y + dist + dLenJoint/2 + dLenJointLast/2);
						pRC->m_xyMid2	= pRC->m_xyMid1;
						pRC->m_xyEnd	= pRC->m_xyMid1;
						pRC->m_xyCen	= pRC->m_xyMid1;
						pRC->m_R_Mid	= 0;
						dNextStt		= pRC->m_xyMid1.y - dLenJoint;
					}

					// 내측벽체이고 마지막 이음이면 상부슬래브와 연결되는 철근을 하나 더 만들어 뿐다.
					if(bInner && joint == nCountJoint-1)
					{
						m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan].Add(new CRebarInfoCycle);
						CRebarInfoCycle *pRC	= m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan].GetAt(m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan].GetSize()-1);
						dDia				= GetDiaMainRebarOutWall(nCycle, m_bDetailInput23DanMainRebar ? nDan : 0, bStt, bInner, -1);
						dDiaReal			= GetDiaMainRebarOutWall(nCycleReal, nDan, bStt, bInner, -1);
						bExist				= IsExistMainRebarOutWall(nCycleReal, nDan, bStt, bInner, -1);
						
						// 공통속성
						pRC->m_nTypeRebar	= REBAR_TYPE_MAIN;
						pRC->m_nPosStt		= bStt ? REBARINFO_POS_STTWALL_INNER : REBARINFO_POS_ENDWALL_INNER;
						pRC->m_nPosEnd		= pRC->m_nPosStt;
						pRC->m_Dia			= dDiaReal;
						pRC->m_bExist		= bExist;
						pRC->m_nRebarDan	= 0;
						
						// 내측철근 마지막 이음 끝부터 상부슬래브 1단철근까지의 거리
						double dLen		= GetLenRebarBeforeEdge_UpperSlab_Cycle13(nCycle, nDan, bStt, bInner, nVertDir) - dLenJoint/2;	
						pRC->m_xyStt	= CDPoint(xyStt.x, dNextStt);
						pRC->m_xyMid1	= CDPoint(pRC->m_xyStt.x, pRC->m_xyStt.y + dLen + dLenJoint/2);
						pRC->m_xyMid2	= pRC->m_xyMid1;
						pRC->m_xyEnd	= pRC->m_xyMid1;
						pRC->m_xyCen	= pRC->m_xyMid1;
						pRC->m_R_Mid	= 0;
						dNextStt		= pRC->m_xyMid1.y - dLenJoint;
					}
				}

				// 내측일 경우 이음이 없으면 앞뒤로 합쳐준다.
				if(bInner && nCountRealJoint == 0)
				{
					nSize = m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan].GetSize();
					if(nSize > 1)
					{
						m_Util.MergeRebarInfoCycle(&m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan], nSize-2, nSize-1);
					}
					if(nCycle == 0 || nCycle == 2)
						m_nCountJointMainRebar_OutWall_Cycle1[stt][inner][0]	= 0;
					else
						m_nCountJointMainRebar_OutWall_Cycle2[stt][inner][0]	= 0;
				}

				// 2,3단은 확장길이 적용
				if(nDan > 0 && !m_bDetailInput23DanMainRebar)
				{ 
					ApplyExtLength23DanMainRebar_OutWall(&m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan], GetLengthExt23DanRebarOutWall(bStt, bInner));
				}

				// Not Exist인 rc 제거
				/*
				if(!bInput)
					RemoveNotExistRebarInfoCycle(&m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan]);
					*/

				// szMark 설정
				long nType	= bStt ? (bInner ? MARK_STTWALL_INNER : MARK_STTWALL_OUTTER) : (bInner ? MARK_ENDWALL_INNER : MARK_ENDWALL_OUTTER);
				SetStringMarkToRebarInfoCycle(&m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan], nType, nCycleReal, bInput, bInput || (stt==0&&inner==0&&nCycleReal==0&&nDan==0), nDan);

				// sDescription 설정
				SetStringDescriptionRebarInfoCycle_OutWall(&m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan], bStt, bInner, nDan, nCycleReal);

				// 내측이든 외측이던 마지막 철근을 길이 변화가능 철근으로 지정한다. ///
				long nSize	= m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan].GetSize();
				if(nSize > 0)
				{
					CRebarInfoCycle *pRC	= m_pArrRCMainOutWall[nCycleReal][stt][inner][nDan].GetAt(nSize-1);
					pRC->m_bVariableLength	= TRUE;
					pRC->m_bVariablePos		= FALSE;
				}
				/////////////////////////////////////////////////////////////////////////
			}
		}
	}
}

void CRcBridgeRebar::GetXyRebarSupport_VertSection_LowerSlab( CDPointArray &xyArr, BOOL bUpper, long nDan, long nVertDir/*=0*/, BOOL bCalSupRebar/*=TRUE*/ )
{
	xyArr.RemoveAll();

	if(nDan == -1) 
		nDan = MAX_REBAR_DAN - 1;

	if(nDan < 0 || nDan > MAX_REBAR_DAN - 1) 
		return;

	long upper	= bUpper ? iUPPER : iLOWER;
	CRebarPlacing rb;

	static CDPointArray xyArrSupRebar1Dan[2];
	if(bCalSupRebar == FALSE && xyArrSupRebar1Dan[upper].GetSize() > 0)
	{
		//Issue Number:#28115
		if(bUpper == TRUE && nDan > 0 && m_bPlacing23DanByStandardOffset == TRUE)
		{
			long nUpperSize = xyArrSupRebar1Dan[iUPPER].GetSize();
			long nLowerSize = xyArrSupRebar1Dan[iLOWER].GetSize();
			CDPoint xyUp, xyLo;
			double dUpXPos = 0.0;
			//double dLoXPos = 0.0;

			//상부 배력철근 2단 철근일 경우 하부배력철근이 있는 곳 정보만 넣어줌.
			for(long nLoIdx = 0; nLoIdx < nLowerSize; nLoIdx++)
			{
				xyLo = xyArrSupRebar1Dan[iLOWER][nLoIdx];
//				double dLoXPos = 0.0;
				double dLoXPos = RoundDown(xyLo.x,0);

				for(long nUpIdx = 0; nUpIdx < nUpperSize; nUpIdx++)
				{
					xyUp = xyArrSupRebar1Dan[iUPPER][nUpIdx];
					dUpXPos = RoundDown(xyUp.x,0);

					if(dUpXPos == dLoXPos)
					{
						xyArr.Add(xyUp);
						break;
					}
				}
			}
		}
		else
		{
			xyArr = xyArrSupRebar1Dan[upper];
		}
		//

		double dCover	= bUpper ? m_dCoverUpper_LowerSlab[nDan] : m_dCoverLower_LowerSlab[nDan];
		double dCover1	= bUpper ? m_dCoverUpper_LowerSlab[0] : m_dCoverLower_LowerSlab[0];

		if(bUpper)
			rb.MoveRebar(xyArr, CDPoint(0, dCover1-dCover));
		else
			rb.MoveRebar(xyArr, CDPoint(0, dCover-dCover1));
	}
	else
	{
		// 2단, 3단은 입력을 받지 않고 1단의 3개까지 같고 다음부터는 1단 2개에 하나씩 2,3단에 들어간다.
		// 그러다가 끝에 3개도 무조건 들어감
		CPlaceRebarByBlock *pPlace	= &m_placeByBlock_SupportRebar_LowerSlab[upper][0];
		CDPointArray xyArrOffsetInfo;
		xyArrOffsetInfo	= pPlace->m_xyArr;

		// 주철근에 따라 직거리 사거리로 배근하는데, 실제 그려야 되는게 입력된거랑 다르면 데이타를 수정해줌 //////
		BOOL bVertDirMainRebar	= IsVertDir();
		BOOL bVertDir	= nVertDir == -1 ? TRUE : (nVertDir == 0 ? bVertDirMainRebar : FALSE);
		if(bVertDirMainRebar != bVertDir && nVertDir != 0)
		{
			double dAngCur		= GetAngleJijum(0, bVertDirMainRebar).GetAngleDegree();
			double dAngApply	= bVertDir ? 90 : GetAngleJijum(0).GetAngleDegree();
			ApplyAngleToOffsetInfo(xyArrOffsetInfo, dAngCur, dAngApply);
		}
		//////////////////////////////////////////////////////////////////////////////////////////////////////////



		// 상부슬래브 상,하면 피복
		//double dCover			= bUpper ? m_dTS_Lower - m_dCoverUpper_LowerSlab[nDan] : m_dCoverLower_LowerSlab[nDan];
		double dRadRebar		= bUpper ? -REBAR_RADIUS : REBAR_RADIUS;
		CRebarInfoCycle *pRC	= GetRebarInfoCycleLowerSlab(0, 0, bUpper, 0);

		// 상부슬래브는 선형의 영향을 받으므로 속도저하가 생길 가능성이 있더라도 일일이 계산 해줘야 됨.
		CDPoint xyR(0, 0);
		CDPoint xy(0, 0);
		CTwinVector tvLower	= GetTvOffset_LowerSlab(nDan, bUpper, -1, -1, bVertDir);

		long nSize	= xyArrOffsetInfo.GetSize();
		double dSta	= pRC ? (bUpper ? pRC->m_xyStt.x : pRC->m_xyStt.x + pRC->m_R_Mid) : tvLower.m_v1.x;
		
		BOOL bSttRebar	= TRUE;
		if(IsMainRebarJointLowerSlabAndOutWall(pRC, bSttRebar))
			dSta	= pRC->m_xyMidExt.x;

		// 시작위치부터 철근 생성
		// 단 상부와 하부는 시작위치가 다르다.
		if(IsOutWall(TRUE))
		{
			if(bUpper == FALSE)
			{
				//xy	= GetXyMatchLineAndSlabUpper(CDPoint(dSta, 0), CDPoint(0, 1), 0, dCover, bVertDir);
				GetXyMatchLineAndLine(CDPoint(dSta, 0), CDPoint(0, 1), tvLower.m_v1, tvLower.GetXyDir(), xy);
				xy.y += dRadRebar;
			}
			else
			{
				CDPoint vAng	= GetAngleJijum(0, bVertDir);
				dSta	+= (m_dWS-(m_dCoverWallIn[0]+m_dCoverWallOut[0]))/vAng.y;
				//xy		= GetXyMatchLineAndSlabUpper(CDPoint(dSta, 0), CDPoint(0, 1), 0, dCover, bVertDir);
				GetXyMatchLineAndLine(CDPoint(dSta, 0), CDPoint(0, 1), tvLower.m_v1, tvLower.GetXyDir(), xy);
				xy.y	+= dRadRebar;
			}
		}
		xyArr.Add(xy);

		for(long block = 0; block < pPlace->m_nCountBlock; block++)
		{
			if(nSize-1 < block) break;
			xyR	= xyArrOffsetInfo.GetAt(block);

			long i = 0; for(i = 0; i < xyR.x; i++)
			{
				dSta += xyR.y;
				//xy	= GetXyMatchLineAndSlabUpper(CDPoint(dSta, 0), CDPoint(0, 1), 0, dCover, bVertDir);
				GetXyMatchLineAndLine(CDPoint(dSta, 0), CDPoint(0, 1), tvLower.m_v1, tvLower.GetXyDir(), xy);
				xy.y += dRadRebar;
				xyArr.Add(xy);
			}
		}

		xyArrSupRebar1Dan[upper].RemoveAll();
		xyArrSupRebar1Dan[upper]	= xyArr;
	}




	// 2단부터는 실제로 주철근이 배근된 곳에만 배력철근이 배근된다. 
	if(nDan > 0)
	{
		//2단 배력철근의 배치 오프셋 크기
		long nCountOffset = 1;

		// 동일 간격이 아닐때는 표준간격의 1/2씩 배근된 곳이 있다.
		// 그 곳에는 m_bPlacing23DanByStandardOffset 옵션 적용 가능함
		if(m_bSameOffsetPlaceTAndCBlock == FALSE)
		{
			nCountOffset = 2;
			if(m_bPlacing23DanByStandardOffset == TRUE)
				nCountOffset = 1;
		}

		//Issue Number:#28115
		if(nDan > 0 && bUpper == FALSE)
			nCountOffset = 1;


		// 2단, 3단은 입력을 받지 않고 1단의 3개까지 같고 다음부터는 1단 2개에 하나씩 2,3단에 들어간다.
		long nCountSame	= bUpper ? 1 : 2;

		CDPointArray xyArrTmp;
		xyArrTmp	= xyArr;
		long nSize		= xyArrTmp.GetSize();
		xyArr.RemoveAll();

		if(m_bPlacing23DanByStandardOffset == FALSE)
		{
			if(nSize > nCountSame)
			{
				for(long i = 0; i < nCountSame; i++)
					xyArr.Add(xyArrTmp.GetAt(i));

				for(long i = nCountSame; i < nSize-(nCountOffset-1)-nCountSame; i+=nCountOffset)
				{

					xyArr.Add(xyArrTmp.GetAt(i));
				}

				for(long i = nSize-(nCountOffset-1)-nCountSame; i < nSize; i++)
					xyArr.Add(xyArrTmp.GetAt(i));
			}
		}
		else
		{
			//Issue Number:#28115
			//교본 구간 표준 CTC에 맞게끔 수정함.
			double dStdCTC = m_dCTC_SupportRebar[iLOWER];
			double dCTCSum = 0.0;
			for(long nIdx = 0; nIdx < nSize; nIdx++)
			{
				if(nIdx==0)
				{
					xyArr.Add(xyArrTmp.GetAt(nIdx));
					continue;
				}
				CDPoint xyCurr;
				CDPoint xyPre;
				xyCurr = xyArrTmp.GetAt(nIdx);
				xyPre = xyArrTmp.GetAt(nIdx - 1);
				double dDis;
				dDis = xyCurr.x - xyPre.x;
				dCTCSum += dDis;
				if(dCTCSum < dStdCTC)
					continue;
				else
				{
					dCTCSum = 0.0;
					xyArr.Add(xyArrTmp.GetAt(nIdx));
				}
			}
		}

		CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = &m_pArrRCMainLowerSlab[0][upper][nDan];
		CHgBaseConcStd baseConcStd;
		baseConcStd.GetXyRangeOfRebarInfoCycleArray(xyArr, pArrRC, TRUE);
	}
}

void CRcBridgeRebar::GetTvRebarShear_VertSection_LowerSlab( CTwinVectorArray &tvArr, CTwinVectorArray &tvArrHucnh, long nVertDir/*=0*/ )
{
	tvArr.RemoveAll();
	tvArrHucnh.RemoveAll();

	// 상부슬래브 상하면 1단철근에 전단철근 배근함.
	// 단.. 전단철근이 피복을 적용하지 않은 벽체 외측부터 시작되어야 하므로 1단철근 좌표 구할때 피복을 적용하지 않고 구함.
	CTwinVector tvUpper, tvLower;
	CTwinVector tvSide;
	tvUpper				= GetTvOffset_LowerSlab(0, TRUE);
	tvLower				= GetTvOffset_LowerSlab(0, FALSE);
	tvSide				= m_tvArrVertSection.GetTvByInfo("시점벽체좌측면");
	tvUpper.m_v1.x = tvSide.m_v1.x;
	tvLower.m_v1.x = tvSide.m_v1.x;

	// 전단철근 배치함.
	CRebarPlacing rb;
	CDPointArray xyArr, xyArrOffsetInfo;
	CPlaceRebarByBlock *pPlace	= &m_placeByBlock_ShearRebar_LowerSlab;
	xyArrOffsetInfo	= pPlace->m_xyArr;


	// 주철근에 따라 직거리 사거리로 배근하는데, 실제 그려야 되는게 입력된거랑 다르면 데이타를 수정해줌 //////
	BOOL bVertDirMainRebar	= IsVertDir();
	BOOL bVertDir	= nVertDir == -1 ? TRUE : (nVertDir == 0 ? bVertDirMainRebar : FALSE);
	if(bVertDirMainRebar != bVertDir && nVertDir != 0)
	{
		double dAngCur		= GetAngleJijum(0, bVertDirMainRebar).GetAngleDegree();
		double dAngApply	= bVertDir ? 90 : GetAngleJijum(0).GetAngleDegree();
		ApplyAngleToOffsetInfo(xyArrOffsetInfo, dAngCur, dAngApply);
	}
	//////////////////////////////////////////////////////////////////////////////////////////////////////////


	// 상부슬래브는 선형의 영향을 받으므로 속도저하가 생길 가능성이 있더라도 일일이 계산 해줘야 됨.
	CDPoint xyR(0, 0);
	CDPoint xy(0, 0);
	long nSize		= xyArrOffsetInfo.GetSize();
	double dSta		= tvLower.m_v1.x;

	if(nSize < 0) return;

	// 전단철근은 시작위치에 배근하지 않음

	//
	for(long block = 0; block < pPlace->m_nCountBlock; block++)
	{
		if(nSize-1 < block) break;
		xyR	= xyArrOffsetInfo.GetAt(block);

		long i = 0; for(i = 0; i < xyR.x; i++)
		{
			dSta += xyR.y;
			//xy	= GetXyMatchLineAndSlabUpper(CDPoint(dSta, 0), CDPoint(0, 1), 0, dCover, bVertDir);
			GetXyMatchLineAndLine(CDPoint(dSta, 0), CDPoint(0, 1), tvLower.m_v1, tvLower.GetXyDir(), xy);
			xyArr.Add(xy);
		}
	}

	// 위치를 알았으면 길이를 줘서 전단철근을 만듬
	double dLen	= m_dTS_Lower - (m_dCoverLower_LowerSlab[0] + m_dCoverUpper_LowerSlab[0]);
	rb.MakePointArrayToLineArray(xyArr, tvArr, CDPoint(0, 1), dLen, FALSE);

	// 헌치철근까지 연장할까?
	if(m_bExtendShearRebarBoHunchRebar)
	{
		CTwinVector tv;
		CDPointArray xyArrMatch;
		CDPointArray xyArrMatchTot;
		CDPoint xyMatch(0, 0);
		long nSizeHunchRebar	= m_pArrRCMainLowerSlabHunch[0].GetSize();
		long i = 0; for(i = 0; i < tvArr.GetSize(); i++)
		{
			tv	= tvArr.GetAt(i);

			// 헌치철근 사이에 있는지 체크한다.
			xyArrMatchTot.RemoveAll();
			long nJHunch	= -1;
			long j = 0; for(j = 0; j < nSizeHunchRebar; j++)
			{
				CRebarInfoCycle *pRC	= m_pArrRCMainLowerSlabHunch[0].GetAt(j);
				// 같은 지점의 헌치 철근 끼리만 교차점을 찾는다.
				if(nJHunch != pRC->m_nPosHunch && nJHunch != -1)
				{
					// 다른 지점이 나오면 검사를 시작
					if(xyArrMatchTot.GetSize() > 0)
					{
						xyMatch	= rb.GetXyEdgePoint(xyArrMatchTot, UPRIGHT_AREA);
						if(xyMatch.y > tv.m_v2.y)
						{
							tv.m_v2	= xyMatch;
							// 전단철근을 헌치까지 뻗었더니 구조물선에 걸리는 것들은 (경사교.)잘라내고 슬래브 하면까지만 뻗자.
							rb.GetXyMatchTvArrAndSeg(m_tvArrVertSection, tv.m_v1, tv.m_v2, xyArrMatch, FALSE);
							if(xyArrMatch.GetSize() == 0)
							{
								tvArr.RemoveAt(i);
								tvArrHucnh.Add(tv);
								i--;
							}
						}
					}
					break;
				}

				rb.GetXyMatchTvArrAndLine(pRC->m_tvArrRebar, tv.m_v1, tv.GetXyDir(), xyArrMatch);

				for(long k = 0; k < xyArrMatch.GetSize(); k++)
					xyArrMatchTot.Add(xyArrMatch.GetAt(k));

				if(xyArrMatchTot.GetSize() > 0 && nJHunch == -1)
					nJHunch	= pRC->m_nPosHunch;

				// 마지막은 그냥 지나칠수 잇으므로 검사한번 더함.ㄴ
				if(j == nSizeHunchRebar-1)
				{
					// 같은 지점의 헌치 철근 끼리만 교차점을 찾는다.
					if(nJHunch != -1)
					{
						// 다른 지점이 나오면 검사를 시작
						if(xyArrMatchTot.GetSize() > 0)
						{
							xyMatch	= rb.GetXyEdgePoint(xyArrMatchTot, UPRIGHT_AREA);
							if(xyMatch.y >  tv.m_v2.y)
							{
								tv.m_v2	= xyMatch;

								// 전단철근을 헌치까지 뻗었더니 구조물선에 걸리는 것들은 (경사교.)잘라내고 슬래브 하면까지만 뻗자.
								rb.GetXyMatchTvArrAndSeg(m_tvArrVertSection, tv.m_v1, tv.m_v2, xyArrMatch, FALSE);
								if(xyArrMatch.GetSize() == 0)
								{
									tvArr.RemoveAt(i);
									tvArrHucnh.Add(tv);
									i--;
								}
							}
						}
						break;
					}
				}

			}
		}
	}
}

long CRcBridgeRebar::GetXyRebarSupport_VertSection_LowerSlabHunch( CDPointArray &xyArrLeft, CDPointArray &xyArrRight, long nIdxHunchRebar )
{
	xyArrLeft.RemoveAll();
	xyArrRight.RemoveAll();
	if(!m_bPlacingSupportAtHunchRebar) return -1;

	long nJ	= -1;
	
	// 배력철근을 배치할 헌치철근 가져옴
	// 해당 헌치부분에만 들어가며, 슬래브 하면 철근과 동일한 sta에 들어감.
	CRebarInfoCycle *pRC	= GetRebarInfoCycleLowerSlab_Hunch(0, nIdxHunchRebar);
	CRebarPlacing rb;
	if(pRC)
	{
		nJ	= pRC->m_nPosHunch;
		
		// 배력근이 들어갈 헌치부 찾아 옴
		CTwinVectorArray tvArrHunchL, tvArrHunchR;
		CTwinVector tvHunchL, tvHunchR;
		if(nJ > 0 && nJ < GetCountJijum()-1)	// 내측헌치인경우
		{
			CString sHunch	= _T("");

			sHunch.Format("%d번째내측하부헌치좌측면", nJ);
			if(m_tvArrVertSection.GetTvByInfo(sHunch, tvHunchL))
				tvArrHunchL.Add(tvHunchL);
			sHunch.Format("%d번째내측하부헌치우측면", nJ);
			if(m_tvArrVertSection.GetTvByInfo(sHunch, tvHunchR))
				tvArrHunchR.Add(tvHunchR);
		}
		else	// 외측헌치인 경우
		{
			if(nJ == 0)
			{
				if(m_tvArrVertSection.GetTvByInfo("시점벽체하부헌치", tvHunchL))
					tvArrHunchL.Add(tvHunchL);
			}
			else
			{
				if(m_tvArrVertSection.GetTvByInfo("종점벽체하부헌치", tvHunchR))
					tvArrHunchR.Add(tvHunchR);
			}
		}

		// 배근함
		CDPointArray xyArrSup;
		GetXyRebarSupport_VertSection_LowerSlab(xyArrSup, TRUE, 0);
		CDPointArray xyArrMatch, xyArrMatchL, xyArrMatchR;
		CDPoint xy(0, 0);
		long nSize	= xyArrSup.GetSize();
		long i = 0; for(i = 0; i < nSize; i++)
		{
			xy	= xyArrSup.GetAt(i);
			rb.GetXyMatchTvArrAndLine(pRC->m_tvArrRebar, xyArrSup.GetAt(i), CDPoint(0, -1), xyArrMatch);

			if(xyArrMatch.GetSize() > 0)
			{
				rb.GetXyMatchTvArrAndLine(tvArrHunchL, xyArrSup.GetAt(i), CDPoint(0, -1), xyArrMatchL);
				rb.GetXyMatchTvArrAndLine(tvArrHunchR, xyArrSup.GetAt(i), CDPoint(0, -1), xyArrMatchR);

				xy	= xyArrMatch.GetAt(0);
				if(xyArrMatchL.GetSize() > 0)
					xyArrLeft.Add(CDPoint(xy.x, xy.y - REBAR_RADIUS));
				if(xyArrMatchR.GetSize() > 0)
					xyArrRight.Add(CDPoint(xy.x, xy.y - REBAR_RADIUS));
			}
		}
	}

	return nJ;
}

void CRcBridgeRebar::SetDataDefaultRebarJewonLowerSlab()
{
	if(IsBoxType() == FALSE) return;

	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();
	const double dMulti = bLsd? 10 : 1;

	long dan(0), upper(0), cycle(0), nIdx(0), nSize(0), left(0), stt(0);
	BOOL bUpper(TRUE), bStt(TRUE), bLeft(TRUE);
	CString sUpper(_T("")), sCycle(_T("")), sStt(_T("")), sLeft(_T("")), sInner(_T(""));

	for(stt = 0; stt < 2; stt++)
	{
		m_nCountRebarDanbu[iLOWER][0][stt]	= 0;
		m_nCountRebarDanbu[iLOWER][1][stt]	= 0;
	}

	CHgBaseConcStd baseConc;
	CRebarPlacing rb;
	
	CTwinVectorArray tvArr, tvArrAngLeft, tvArrAngRight, tvArrVertLeft, tvArrVertRight, tvArrVertTotLen;
	CTwinVectorArray tvArrJoint, tvArrHidden, tvArrHiddenLeft, tvArrHiddenRight;
	CTwinVector tv;
	CRebarInfoCycle *pRC	= NULL;
	double dLenRound	= 0;	// 라운드된 철근에서 라운드부분의 평면상의 길이
	double dLenRoundL	= 0;	// 사보강일때 왼쪽 R
	double dLenRoundR	= 0;	// 사보강일때 오른쪽 R
	double dLenMax		= 0;	// 최대길이
	double dLenMin		= 0;	// 최소길이
	double dCover		= 0;	// 피복
	double dRebarSpace	= 0;	// 간격

	double dRad		= 1;
	// 경사로 구하는 경우 수평 거리는 경사각도를 적용한다.
	// 종단옵션이 경사이고 하부슬래브가 종단적용일때
	if(m_nTypeJongdanForRebar != 0 && m_bSlopeLowerSlab)
	{
		CTwinVector tvUpper	= m_tvArrVertSection.GetTvByInfo(m_nTypeBridge == BRIDGE_TYPE_SLAB ? "슬래브상면(1번째지간)" : "슬래브상면(외측벽체안쪽)");
		dRad	= fabs(sin(ToRadian(90 - tvUpper.GetXyDir().GetAngleDegree())));
	}
	
	// 주철근 배치 타입은 상부와 같게..
	// 사보강(절반) 배치 일때 직방향 철근 잘린거 있을 수 있다.(따로 집계함

	// 주철근
	dRebarSpace	= m_dCTC_MainRebar/2;

	// 하부 슬래브
	for(cycle = 0; cycle < GetCountCycleMainRebar(); cycle++)
	{
		sCycle	= m_pARcBridgeDataStd->GetStringCircleNum(cycle+1);

		for(upper = 1; upper >= 0; --upper)
		{
			bUpper	= upper == iUPPER ? TRUE : FALSE;
			sUpper	= bUpper ? "상" : "하";
			
			for(dan = 0; dan < MAX_REBAR_DAN; dan++)
			{
				dCover	= bUpper ? m_dCoverUpper_LowerSlab[dan] : m_dCoverLower_LowerSlab[dan];


				long nSizeRC	= m_pArrRCMainLowerSlab[cycle][upper][dan].GetSize();
				for(nIdx = 0; nIdx < nSizeRC; nIdx++)
				{
					tvArr.RemoveAll();

					GetTvRebarMain_Plane_LowerSlab_TypeNormal_Std(tvArr, tvArrAngLeft, tvArrAngRight, bUpper, cycle, dan, 0, nIdx, FALSE, FALSE, FALSE, tvArrJoint, tvArrHidden, tvArrHiddenLeft, tvArrHiddenRight, TRUE, tvArrVertLeft, tvArrVertRight);
					pRC	= GetRebarInfoCycleLowerSlab(cycle, dan, bUpper, nIdx);
					if(!pRC) continue;
					if(!pRC->m_bExist) continue;

					// 사보강(절반) 배치일때 직방향 철근 분리.
					/*
					if(m_nTypePlacingMainRebar_UpperSlab == 2)
					{
						m_Util.DivideVertMainRebarBySabogang(tvArrVertTotLen, tvArrVertLeft, tvArrVertRight);
					}
					*/

					// Round반지름이 차지 하는 길이 
					dLenRound	= 0;
					dLenRoundL	= 0;
					dLenRoundR	= 0;
					if(pRC->m_nPosStt != pRC->m_nPosEnd)
					{
						dLenRound	= tvArrHidden.GetSize() > 0 ? tvArrHidden.GetAt(0).GetLength() : 0;
						dLenRoundL	= tvArrHiddenLeft.GetSize() > 0 ? tvArrHiddenLeft.GetAt(0).GetLength() : 0;
						dLenRoundR	= tvArrHiddenRight.GetSize() > 0 ? tvArrHiddenRight.GetAt(0).GetLength() : 0;
					}

					BOOL bSttTmp	= nIdx == 0;
					if(nIdx == 0 || nIdx == nSizeRC-1)
					{
						if(IsRebarMainOneLineUpperSlab(TRUE, bSttTmp))
							dLenRoundL	= 0;
						if(IsRebarMainOneLineUpperSlab(FALSE, bSttTmp))
							dLenRoundR	= 0;
					}

					// 평면상에서 최대와 최소 길이를 판단해서 철근 집계함.
					// ang == 0 : 기본철근
					// ang == 1 : 좌측철근
					// ang == 2 : 우측철근
					// ang == 3 : 좌측변화구간(직방향)
					// ang == 4 : 우측변화구간(직방향)
					double dLenRoundApply	= dLenRound;
					for(long ang = 0; ang < 5; ang++)
					{
						CTwinVectorArray *pTvArr	= NULL;
						switch(ang)
						{
							case 0: 
								pTvArr	= &tvArr; 
								dLenRoundApply = dLenRound; 
								break;
							case 1: 
								pTvArr	= &tvArrAngLeft; 
								dLenRoundApply	= dLenRoundL;
								break;
							case 2: 
								pTvArr	= &tvArrAngRight; 
								dLenRoundApply	= dLenRoundR;
								break;
							case 3:
								pTvArr	= &tvArrVertLeft;
								dLenRoundApply	= 0;
								break;
							case 4:
								pTvArr	= &tvArrVertRight;
								dLenRoundApply	= 0;
								break;
							default: break;
						}
						if(!pTvArr) return;

						dLenMax	= 0;
						dLenMin	= 0;
						nSize	= pTvArr->GetSize();
						if(nSize > 0)
						{
							CLineInfo *pLineCur	= NULL;
							if(ang == 0)
								pLineCur	= GetLineBase(IsVertDir());
							else if(ang == 1)
								pLineCur	= GetLineLeftRight(TRUE);
							else if(ang == 2)
								pLineCur	= GetLineLeftRight(FALSE);

							long i = 0; for(i = 0; i < pTvArr->GetSize(); i++)
							{
								tv	= pTvArr->GetAt(i);

								
								if(i == 0)
								{
									dLenMax	= GetLengthLineByPlaneXy(tv.m_v1, tv.m_v2, pLineCur);
									dLenMin	= GetLengthLineByPlaneXy(tv.m_v1, tv.m_v2, pLineCur);
								}
								else
								{
									dLenMax	= max(GetLengthLineByPlaneXy(tv.m_v1, tv.m_v2, pLineCur), dLenMax);
									dLenMin	= min(GetLengthLineByPlaneXy(tv.m_v1, tv.m_v2, pLineCur), dLenMin);
								}
							}

							// 주인철근이 있으면 주인 철근에 묻어가자.
							CRebarInfoCycle *pRCOwner	= GetOwerRebarInfoCycleSlab(FALSE, cycle, dan, bUpper, nIdx);
							if(pRCOwner && pRCOwner != pRC)
							{
								CRebar *pRBOwner	= NULL;
								for(i = 0; i < m_pArrRebarMain.GetSize(); i++)
								{
									pRBOwner	= m_pArrRebarMain.GetAt(i);
									if(pRBOwner->m_sDescription == pRCOwner->m_sDescription)
									{
										pRBOwner->m_nEa += nSize;
										break;
									}
								}
							}
							else
							{
								CRebar *pRB	= new CRebar;
								pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
								pRB->m_sDescription	= pRC->m_sDescription;
								pRB->m_sMark		= pRC->m_szMark;
								if(ang > 0)
								{
									pRB->m_sDescription.Format("%s(%s)", pRC->m_sDescription, ang==1 ? "좌1" : "우1");
									if(ang > 2)
										pRB->m_sDescription.Format("%s(%s)", pRC->m_sDescription, ang==3 ? "좌2" : "우2");
									pRB->m_sMark.Format("%s-%d", pRC->m_szMark, ang);
								}

								pRB->m_dDia			= pRC->m_Dia;
								// 중간에 짤린거 는 일체형만 아니라면 직선철근이다.
								if((ang == 3 || ang == 4 || (pRC->m_nPosStt == pRC->m_nPosEnd && (Compare(dLenRoundApply, 0.0, "="))) && !IsMainRebarJointUpperSlabAndUpperSlab(pRC)))
								{
									pRB->m_dLengthMax_A	= dLenMax/dRad;
									pRB->m_dLengthMin_A	= dLenMin/dRad;
									pRB->m_nTypeRebar	= 1;
								}
								else
								{
									BOOL bSttRebar	= TRUE;
									// 상부슬래브와 외측벽체 연결된 형태
									// 편경사에 의해서 변화치수 나옴
									if(IsMainRebarJointLowerSlabAndOutWall(pRC, bSttRebar))
									{
										CTwinVectorArray tvArrMainWall, tvArrJoint;
										GetTvRebarMain_Side_OutWall(tvArrMainWall, bSttRebar, FALSE, cycle, dan, 0, tvArrJoint);
										double dLenMax	= tvArrMainWall.GetLengthMax();
										double dLenMin	= tvArrMainWall.GetLengthMin();

										if(bSttRebar)
										{
											pRB->m_dLengthMax_A	= ~(pRC->m_xyStt-pRC->m_xyMid1);
											pRB->m_dLengthMin_A	= 0;
											pRB->m_dLengthMax_B	= dLenMax - (fabs(pRC->m_xyMid1.y-pRC->m_xyMid2.y)) - (fabs(pRC->m_xyEnd.y - pRC->m_xyMidExt.y));
											pRB->m_dLengthMin_B	= dLenMin - (fabs(pRC->m_xyMid1.y-pRC->m_xyMid2.y)) - (fabs(pRC->m_xyEnd.y - pRC->m_xyMidExt.y));
											pRB->m_dLengthMax_C	= ~(pRC->m_xyMidExt-pRC->m_xyEndExt);
											pRB->m_dLengthMin_C	= ~(pRC->m_xyMidExt-pRC->m_xyEndExt);
											pRB->m_dLengthMax_C1	= pRC->GetLengthMid();
											pRB->m_dLengthMin_C1	= pRB->m_dLengthMax_C1;
											pRB->m_dLengthMax_C2	= pRC->GetLengthMidExt();
											pRB->m_dLengthMin_C2	= pRB->m_dLengthMax_C2;
											
											if(pRC->m_R_Mid > 0)
											{
												pRB->m_dLengthMax_R1	= pRC->m_R_Mid;
												pRB->m_dLengthMin_R1	= pRB->m_dLengthMax_R1;
											}

											if(pRC->m_R_MidExt > 0)
											{
												pRB->m_dLengthMax_R2	= pRC->m_R_MidExt;
												pRB->m_dLengthMin_R2	= pRB->m_dLengthMax_R2;
											}

										}
										else
										{
											pRB->m_dLengthMax_C	= pRC->GetLengthStt();
											pRB->m_dLengthMin_C	= pRC->GetLengthStt();
											pRB->m_dLengthMax_B	= dLenMax - (fabs(pRC->m_xyMid1.y-pRC->m_xyMid2.y)) - (fabs(pRC->m_xyEnd.y - pRC->m_xyMidExt.y));
											pRB->m_dLengthMin_B	= dLenMin - (fabs(pRC->m_xyMid1.y-pRC->m_xyMid2.y)) - (fabs(pRC->m_xyEnd.y - pRC->m_xyMidExt.y));
											pRB->m_dLengthMax_A	= ~(pRC->m_xyMidExt-pRC->m_xyEndExt);
											pRB->m_dLengthMin_A	= 0;
											pRB->m_dLengthMax_C1	= pRC->GetLengthMidExt();
											pRB->m_dLengthMin_C1	= pRB->m_dLengthMax_C1;
											pRB->m_dLengthMax_C2	= pRC->GetLengthMid();
											pRB->m_dLengthMin_C2	= pRB->m_dLengthMax_C2;
											pRB->m_dLengthMax_R1	= pRC->m_R_MidExt;
											pRB->m_dLengthMin_R1	= pRB->m_dLengthMax_R1;
											pRB->m_dLengthMax_R2	= pRC->m_R_Mid;
											pRB->m_dLengthMin_R2	= pRB->m_dLengthMax_R2;
										}

										// 타입 결정
										if(Compare(pRB->m_dLengthMax_R1, 0.0, ">") && Compare(pRB->m_dLengthMax_R2, 0.0, ">"))
											pRB->m_nTypeRebar	= 86;
										else if(Compare(pRB->m_dLengthMax_R1, 0.0, ">") && Compare(pRB->m_dLengthMax_R2, 0.0, "="))
											pRB->m_nTypeRebar	= 87;
										else if(Compare(pRB->m_dLengthMax_R1, 0.0, "=") && Compare(pRB->m_dLengthMax_R2, 0.0, ">"))
											pRB->m_nTypeRebar	= 88;
										else if(Compare(pRB->m_dLengthMax_R1, 0.0, "=") && Compare(pRB->m_dLengthMax_R2, 0.0, "="))
											pRB->m_nTypeRebar	= 89;
									}
									// 상부슬래브 주철근 일체형
									else if(IsMainRebarJointLowerSlabAndLowerSlab(pRC))
									{
										pRB->m_dLengthMax_A	= ~(pRC->m_xyStt - pRC->m_xyMid1);
										pRB->m_dLengthMin_A	= 0;
										pRB->m_dLengthMax_B	= dLenMax/dRad;
										pRB->m_dLengthMin_A	= dLenMin/dRad;
										pRB->m_dLengthMax_C	= ~(pRC->m_xyMidExt-pRC->m_xyEndExt);
										pRB->m_dLengthMin_C	= 0;
										pRB->m_dLengthMax_C1	= pRC->GetLengthMid();
										pRB->m_dLengthMin_C1	= pRB->m_dLengthMax_C1;
										pRB->m_dLengthMax_R1	= pRC->m_R_Mid;
										pRB->m_dLengthMin_R1	= pRB->m_dLengthMax_R1;
										pRB->m_dLengthMax_C2	= pRC->GetLengthMidExt();
										pRB->m_dLengthMin_C2	= pRB->m_dLengthMax_C2;
										pRB->m_dLengthMax_R2	= pRC->m_R_MidExt;
										pRB->m_dLengthMin_R2	= pRB->m_dLengthMax_R2;

										// 철근 타입 결정
										if(Compare(pRB->m_dLengthMax_R1, 0.0, ">") && Compare(pRB->m_dLengthMax_R2, 0.0, ">"))
											pRB->m_nTypeRebar	= 87;
										else
											pRB->m_nTypeRebar	= 91;
									}
									else	// 보통 형태!!
									{
										pRB->m_dLengthMax_A	= dLenMax/dRad;// - dLenRoundApply;
										pRB->m_dLengthMin_A	= dLenMin/dRad;// - dLenRoundApply;
											
										if(pRC->m_nPosStt == REBARINFO_POS_LOWERSLAB_LOWER)
										{
											pRB->m_dLengthMax_C	= fabs(pRC->m_xyMid2.y - pRC->m_xyEnd.y);
											pRB->m_dLengthMin_C	= pRB->m_dLengthMax_C;
										}
										else if(pRC->m_nPosEnd == REBARINFO_POS_LOWERSLAB_LOWER)
										{
											pRB->m_dLengthMax_C	= fabs(pRC->m_xyMid1.y - pRC->m_xyStt.y);
											pRB->m_dLengthMin_C	= pRB->m_dLengthMax_C;
										}
										
										if(pRC->m_R_Mid > 0)
										{
											pRB->m_nTypeRebar	= 5;
											pRB->m_R			= pRC->m_R_Mid;

											// dLengthMax_C값은 사보강일 경우 Round의 변화로 약간씩 차이가 생길 수 있음
											if(ang > 0)
											{
												double dDiff	= (ang == 1 ? dLenRoundL : dLenRoundR) - dLenRound;
												pRB->m_dLengthMax_C -= dDiff;
												pRB->m_dLengthMin_C	-= dDiff;
												pRB->m_R			+= dDiff;
											}
											pRB->m_dLengthMax_B	= pRC->GetLengthMid();// 2*ConstPi*pRB->m_R/4;
																						// 사보강의 사철근이 직철근과 겹쳐서 사철근의 상세가 라운드 ㄱ 형태에서 ㅡ 형태로 변경
											if(Compare(pRB->m_R, 0.0, "="))
											{
												pRB->m_R	= 0;
												pRB->m_dLengthMax_B	= 0;
												pRB->m_dLengthMax_C	= 0;
												pRB->m_dLengthMin_C	= 0;
											}
										}
										else if(Compare(pRC->m_R_Mid, 0.0, "=") && Compare(pRC->GetLengthMid(), 0.0, ">"))
										{
											pRB->m_nTypeRebar	= 78;
											pRB->m_dLengthMax_B	= pRC->GetLengthMid();
										}
										else if(Compare(pRC->GetLengthMid(), 0.0, "="))
										{
											pRB->m_dLengthMax_B	= pRB->m_dLengthMax_C;
											pRB->m_dLengthMin_B	= pRB->m_dLengthMin_C;
											pRB->m_dLengthMax_C	= 0;
											pRB->m_dLengthMin_C	= 0;
											pRB->m_nTypeRebar	= 2;
										}
									}
								}

								pRB->m_bMainRebar	= TRUE;
								pRB->m_nEa			= nSize;
								baseConc.OptimizationRebar(pRB);	// 철근 최적화
								SetRebarLsdOptionSlab(pRB->m_pOptionLsd, FALSE, bUpper, TRUE, cycle, dan);
								if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
								m_Util.SetLengthRebar(pRB, bUpper ? JOINT_TENS_UPPER_B : JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
								pRB->m_dRateAdd	= MAKE_RATE;
								AddOrDeleteRebarInList(&m_pArrRebarMain, pRB);

								// 단부 철근 개수 집계
								if(dan == 0 && bUpper && (nIdx == 0 || nIdx == nSizeRC-1))
								{
									long nCycleRebarDanbu	= cycle == 0 || cycle == 2 ? 0 : 1;
									long nStt	= nIdx == 0 ? iSTT : iEND;
									m_nCountRebarDanbu[iLOWER][nCycleRebarDanbu][nStt] += pRB->m_nEa;
								}
							}
						}
					}
				}
			}
		}
	} // end of 상부슬래브


	// 가각부 (헌치부도 함께 집계함)
	CTwinVectorArrayArray pTvArrCycle1[2];
	CTwinVectorArrayArray pTvArrCycle2[2];
	CTwinVectorArray tvArrCycleHunch1, tvArrCycleHunch2;

	CTwinVector tvUpper	= GetTvOffset_UpperSlab(0, TRUE, -1.0, -1.0, IsVertDir());
	CTwinVector tvHunch[2]	= {m_tvArrVertSection.GetTvByInfo("시점벽체헌치"), m_tvArrVertSection.GetTvByInfo("종점벽체헌치")};
	tvUpper.Sort(TRUE, FALSE);
	tvHunch[0].Sort(TRUE, FALSE);
	tvHunch[1].Sort(TRUE, FALSE);
	

	for(stt = 0; stt < 2; stt++)
	{
		bStt	= stt == iSTT;

		for(upper = 0; upper < 2; upper++)
		{
			bUpper	= upper == iUPPER;
			
			for(left = 0; left < 2; left++)
			{
				bLeft	= left == iLEFT;

				for(dan = 0; dan < MAX_REBAR_DAN; dan++)
				{
					GetTvRebarMain_Plane_Slab_Exp(FALSE, &pTvArrCycle1[0], &pTvArrCycle2[0], &pTvArrCycle1[1], &pTvArrCycle2[1], bStt, bLeft, dan, bUpper, tvArrCycleHunch1, tvArrCycleHunch2);

					CString sMark	= _T("");
					CString sDescription	= _T("");
					double dDia		= 0;

					CTwinVectorArrayArray *pTvArr	= NULL;
					
					for(cycle = 0; cycle < 2; cycle++)
					{
						long type = 0; for(type = 0; type < 2; type++)
						{
							pTvArr	= cycle == 0 ? &pTvArrCycle1[type] : &pTvArrCycle2[type];

							long nSize	= pTvArr->GetSize();
							if(nSize == 0) continue;


							// 가각 주철근은 두가지로 분류가능함.
							CTwinVectorArray tvArrMain1, tvArrMain2;
							GetInfoMainRebarExp_LowerSlab(bStt, bLeft, bUpper, cycle, dan, type, sMark, dDia, sDescription);

							long i = 0; for(i = 0; i < nSize; i++)
							{
								CTwinVectorArray *pTvArrTmp	= pTvArr->GetAt(i);
								if(pTvArrTmp->GetLength() == 0) continue;
								if(i == 0)
								{
									dLenMax		= pTvArrTmp->GetLength();
									dLenMin		= pTvArrTmp->GetLength();
								}
								else
								{
									dLenMax		= max(dLenMax, pTvArrTmp->GetLength());
									dLenMin		= min(dLenMin, pTvArrTmp->GetLength());
								}
							}
							dLenRound	= GetLenRebarAtEdge(dDia, FALSE);

							CRebar *pRB	= new CRebar;
							pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
							pRB->m_sDescription	= sDescription;
							pRB->m_sMark		= sMark;
							pRB->m_dDia			= dDia;

							// 하면철근이 벽체로 올라 가는 경우는
							// 가각철근을 선형방향으로 하면 1Cycle에는 보강철근이
							// 2Cycle에는 선형방향 철근이 들어온다.
							if((!bUpper && !m_bLineDirRebarOfExp[stt][left]) || (!bUpper && m_bLineDirRebarOfExp[stt][left] && cycle == 1))
							{
								pRB->m_dLengthMax_A	= (dLenMax-dLenRound)/dRad;
								pRB->m_dLengthMin_A	= dLenMin > dLenRound ? (dLenMin-dLenRound)/dRad : 0;
									
								// (ARCBRIDGE-2828) 철근제원을 1,2 Cycle을 같이 적용하고 있었다. 분리하낟.
								CRebarInfoCycle *pRCSlab	= GetRebarInfoCycleLowerSlab(cycle, 0, bUpper, bStt ? 0 : -1);
								// CRebarInfoCycle *pRCSlab2Cycle	= GetRebarInfoCycleLowerSlab(1, 0, bUpper, bStt ? 0 : -1);

								if(pRCSlab)
								{
									if(!bStt)
									{
										pRB->m_dLengthMax_C	= fabs(pRCSlab->m_xyMid2.y - pRCSlab->m_xyEnd.y);
									}
									else
									{
										pRB->m_dLengthMax_C	= fabs(pRCSlab->m_xyMid1.y - pRCSlab->m_xyStt.y);
									}

									if(pRB->m_dLengthMin_C > pRB->m_dLengthMax_C)
										GetSwap(pRB->m_dLengthMin_C, pRB->m_dLengthMax_C);

									if(pRCSlab->m_R_Mid > 0)
									{
										pRB->m_nTypeRebar	= 5;
										pRB->m_R			= pRCSlab->m_R_Mid;
										pRB->m_dLengthMax_B	= pRCSlab->GetLengthMid();
									}
									else if(Compare(pRCSlab->m_R_Mid, 0.0, "=") && Compare(pRCSlab->GetLengthMid(), 0.0, ">"))
									{
										pRB->m_nTypeRebar	= 78;
										pRB->m_dLengthMax_B	= pRCSlab->GetLengthMid();
									}
									else if(Compare(pRCSlab->GetLengthMid(), 0.0, "="))
									{
										pRB->m_dLengthMax_B	= pRB->m_dLengthMax_C;
										pRB->m_dLengthMin_B	= pRB->m_dLengthMin_C;
										pRB->m_dLengthMax_C	= 0;
										pRB->m_dLengthMin_C	= 0;
										pRB->m_nTypeRebar	= 2;
									}
								}
							}
							else
							{
								pRB->m_dLengthMax_A	= dLenMax/dRad;
								pRB->m_dLengthMin_A	= dLenMin/dRad;
								pRB->m_nTypeRebar	= 1;
							}

							pRB->m_bMainRebar	= TRUE;
							pRB->m_nEa			= nSize;
							baseConc.OptimizationRebar(pRB);	// 철근 최적화
							SetRebarLsdOptionSlab(pRB->m_pOptionLsd, FALSE, bUpper, TRUE, cycle, dan);
							if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
							m_Util.SetLengthRebar(pRB, bUpper ? JOINT_TENS_UPPER_B : JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
							pRB->m_dRateAdd	= MAKE_RATE;
							AddOrDeleteRebarInList(&m_pArrRebarMain, pRB);

							// 단부 철근 개수 집계
							if(bUpper)
							{
								long nCycleRebarDanbu	= 0;
								long nStt	= bStt ? iSTT : iEND;
								m_nCountRebarDanbu[iLOWER][nCycleRebarDanbu][nStt] += pRB->m_nEa;
							}
						}

						// 하면일 경우 헌치부도 구한다.
						CTwinVectorArray *pTvArrHunch	= NULL;
						pTvArrHunch	= cycle == 0 ? &tvArrCycleHunch1 : &tvArrCycleHunch2;


						if(bUpper && pTvArrHunch->GetSize() > 0)
						{
							// 헌치철근이 곡선일수도 있으므로 다시 분리 한다. //////////
							CTwinVectorArrayArray pTvArrHunchArr;
							CString sInfoLast	= _T("");
							CTwinVectorArray *pTvArr	= new CTwinVectorArray;
							long h = 0; for(h = 0; h < pTvArrHunch->GetSize(); h++)
							{
								tv	= pTvArrHunch->GetAt(h);

								if(h == 0)
								{
									sInfoLast	= tv.m_sInfo;
								}
								else if(tv.m_sInfo != sInfoLast)
								{
									pTvArrHunchArr.Add(pTvArr);
									sInfoLast	= tv.m_sInfo;
									
									pTvArr	= new CTwinVectorArray;
								}

								pTvArr->Add(tv);

								if(h == pTvArrHunch->GetSize()-1)
									pTvArrHunchArr.Add(pTvArr);
							}
							//////////////////////////////////////////////////////////

							GetInfoMainRebarExp_LowerSlabHunch(bStt, bLeft, cycle, sMark, dDia, sDescription);
							long nJ	= bStt ? 0 : m_nQtyJigan;
							CRebarInfoCycle *pRC	= NULL;
							for(long rc = 0; rc < m_pArrRCMainLowerSlabHunch[cycle].GetSize(); rc++)
							{
								CRebarInfoCycle *pTmp	= m_pArrRCMainLowerSlabHunch[cycle].GetAt(rc);
								if(nJ == pTmp->m_nPosHunch)
								{
									pRC	= pTmp;
									break;
								}
							}
							if(!pRC) continue;
							if(!pRC->m_bExist) continue;
							if(pRC->m_tvArrRebar.GetSize() < 3) continue;
							CTwinVector tvSlope	= pRC->m_tvArrRebar.GetAt(1);
							
							// 
							double dH	= tvSlope.GetVerLength();
							double dW	= 0;//pTvArrHunch->GetLengthMax();
							double dWMin	= 0;
							for(h = 0; h < pTvArrHunchArr.GetSize(); h++)
							{
								CTwinVectorArray *pTvArr	= pTvArrHunchArr.GetAt(h);
								if(h == 0)
								{
									dW	= pTvArr->GetLength();
									dWMin	= dW;
								}
								else
								{
									dW	= max(dW, pTvArr->GetLength());
									dWMin	= min(dWMin, pTvArr->GetLength());
								}
							}
							

							CRebar *pRB	= new CRebar;
							pRB->m_Fy				= m_pARcBridgeDataStd->m_Fy;
							pRB->m_sDescription 	= sDescription;
							pRB->m_sMark			= sMark;
							pRB->m_dDia				= dDia;

							pRB->m_nTypeRebar		= 9;
							pRB->m_dLengthMax_A		= sqrt(dH*dH + dW*dW);
							pRB->m_dLengthMin_A		= sqrt(dH*dH + dWMin*dWMin);
							pRB->m_dLengthMax_B		= pRC->m_tvArrRebar.GetAt(0).GetLength();

							// 헌치철근 각도와 비교해서 각도를 넣어줌
							if(bStt)
							{
								CDPoint vAngUpper	= tvUpper.GetXyDir();
								CDPoint vAngHunch	= tvHunch[stt].GetXyDir(TRUE);
								CDPoint vAngVer		= CDPoint(0, -1);
								pRB->m_dAngleX1	= vAngUpper.BetweenAngle(vAngHunch).GetAngleDegree();
								vAngHunch	= tvHunch[stt].GetXyDir(FALSE);
								pRB->m_dAngleX2	= vAngHunch.BetweenAngle(vAngVer).GetAngleDegree();
							}
							else
							{
								CDPoint vAngUpper	= tvUpper.GetXyDir(TRUE);
								CDPoint vAngHunch	= tvHunch[stt].GetXyDir(FALSE);
								CDPoint vAngVer		= CDPoint(0, -1);
								pRB->m_dAngleX1	= vAngHunch.BetweenAngle(vAngUpper).GetAngleDegree();
								vAngHunch	= tvHunch[stt].GetXyDir(TRUE);
								pRB->m_dAngleX2	= vAngVer.BetweenAngle(vAngHunch).GetAngleDegree();
							}
							if(pRB->m_dAngleX1 > 180)
								pRB->m_dAngleX1 = 360 - pRB->m_dAngleX1;
							if(pRB->m_dAngleX2 > 180)
								pRB->m_dAngleX2 = 360 - pRB->m_dAngleX2;

							double dWExp	= bStt ? m_dExpSttW[left] : m_dExpEndW[left];
							double dHExp	= bStt ? m_dExpSttH[left] : m_dExpEndH[left];

							double dRate	= sqrt(dWExp*dWExp + dHExp*dHExp) / dWExp;
							pRB->m_dAngleX1 *= dRate;
							pRB->m_dAngleX2 *= dRate;
							
							pRB->m_bMainRebar		= TRUE;
							pRB->m_nEa				= pTvArrHunchArr.GetSize();
							baseConc.OptimizationRebar(pRB);	// 철근 최적화
							SetRebarLsdOptionSlab(pRB->m_pOptionLsd, FALSE, bUpper, TRUE, cycle, dan);
							if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
							m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
							pRB->m_dRateAdd	= MAKE_RATE;
							AddOrDeleteRebarInList(&m_pArrRebarMain, pRB);

							AhTPADelete(&pTvArrHunchArr,   (CTwinVectorArray*)0);
						}
					}
				}
			}
		}
	}

	long type = 0; for(type = 0; type < 2; type++)
	{
		AhTPADelete(&pTvArrCycle1[type], (CTwinVectorArray*)0);
		AhTPADelete(&pTvArrCycle2[type], (CTwinVectorArray*)0);
	}
}

void CRcBridgeRebar::SetDataDefaultRebarJewonBFooting()
{
	if(!m_bExistProtectionRiseFooting) return;
	if(m_dPRF_W <= 0) return;
	
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();

	CHgBaseConcStd baseConc;

	//부상방지저판 주철근
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = &m_pArrRCMainBoxLowerPRF_Cycle1[0];
	if(pArrRC->GetSize() == 0) return;
	CRebarInfoCycle *pRC	= pArrRC->GetAt(0);

	CTwinVector tvTop, tvSide, tvBottom;
	pRC->m_tvArrRebar.GetTvByInfo(_T("시점부상방지저판상면"), tvTop);
	pRC->m_tvArrRebar.GetTvByInfo(_T("시점부상방지저판바깥측면"), tvSide);
	pRC->m_tvArrRebar.GetTvByInfo(_T("시점부상방지저판하단"), tvBottom);

	//## 주철근///////////////////////////////////////////
	CRebar *pRB = new CRebar;
	pRB->m_sMark = _T("BO1");
	pRB->m_dDia	 = m_dPRF_Dia_Main;
	pRB->m_nEa	 = GetCountRebarDanbu(TRUE, 0);
	pRB->m_nTypeRebar   = (m_dPRF_H2>0) ? 13 : 4;
	pRB->m_sDescription = _T("부상방지저판 주철근");
	pRB->m_dLengthMax_A = (m_dPRF_H2>0) ? ~(tvBottom.m_v2-tvBottom.m_v1) : ~(tvSide.m_v1-tvSide.m_v2);
	pRB->m_dLengthMax_B = (m_dPRF_H2>0) ? ~(tvSide.m_v1-tvSide.m_v2)  : ~(tvTop.m_v1-tvTop.m_v2);
	pRB->m_dLengthMax_C = (m_dPRF_H2>0) ? ~(tvTop.m_v1-tvTop.m_v2) : ~(tvBottom.m_v2-tvBottom.m_v1);
	pRB->m_dLengthMax_D = 0;
	pRB->m_dRateAdd	= MAKE_RATE;
	pRB->m_Fy = bLsd? GetValueFy( ePartLowerSlab) : m_pARcBridgeDataStd->m_Fy;
	pRB->m_bMainRebar = TRUE;
	baseConc.OptimizationRebar(pRB);
	//m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B);
	AddOrDeleteRebarInList(&m_pArrRebarMain, pRB);
}

void CRcBridgeRebar::SetDataDefaultRebarJewon_BFooting_Support()
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();

	CHgBaseConcStd baseConc;
	CDPointArray xyArrSupport;
	CRebar *pRB = new CRebar;

	GetXyRebarSupport_VertSection_BFooting(xyArrSupport, TRUE, 50.);
	////## 수평철근///////////////////////////////////////////
	double dWidth = GetLengthBFooting(TRUE);
	double dCover	= m_dCoverWallOut[0];
	double dSpace	= GetCtcRebarMain();

	pRB->m_Fy = bLsd? GetValueFy(ePartLowerSlab) : m_pARcBridgeDataStd->m_Fy;
	pRB->m_sMark = _T("BO2");
	pRB->m_sDescription = _T("부상방지저판 수평철근");	
	pRB->m_dDia	 = m_dPRF_Dia_Support;
	pRB->m_nTypeRebar = 1;
	pRB->m_dLengthMax_A = dWidth - m_dCoverSide_UpperSlab[0] * 2;
	pRB->m_nEa	 = xyArrSupport.GetSize()*2;
	baseConc.OptimizationRebar(pRB);
	m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_A, dCover, dSpace);
	pRB->m_dRateAdd	    = MAKE_RATE;
	
	AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
}

void CRcBridgeRebar::SetDataDefaultRebarJewon_BFooting_Shear()
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();

	//전단철근 가져오기
	CTwinVectorArray tvArrShear;
	GetTvRebarShear_VertSection_BFooting(tvArrShear, TRUE);

	long nQtyBindShear  = m_nPRF_Count_Shear;
	double dCtcShearUnit= GetCTCRebarPRF_Main()*nQtyBindShear;
	
	if(m_dPRF_Dia_Shear > 0 && tvArrShear.GetSize() > 0)
	{
		CRebar *pRB = new CRebar;
		pRB->m_sMark			= _T("BO3");
		pRB->m_dDia			= m_dPRF_Dia_Shear;
		pRB->m_nEa				= GetCountShearRebarBFooting();
		pRB->m_sDescription	= _T("부상방지저판 전단철근");
		pRB->m_dRateAdd	    = MAKE_RATE;
		pRB->m_Fy				= bLsd? GetValueFy(ePartLowerSlab, TRUE) : m_pARcBridgeDataStd->m_Fy;

		long nTypeShear = m_nPRF_Type_Shear;
		double dCover = m_dCoverLower_LowerSlab[0];
		SetShearRebarJewon(pRB,nTypeShear,dCtcShearUnit,dCtcShearUnit,tvArrShear.GetLengthMax(),tvArrShear.GetLengthMax(),m_dPRF_Dia_Shear,m_dPRF_Dia_Main,m_dPRF_Dia_Main,dCover);
		AddOrDeleteRebarInList(&m_pArrRebarShear, pRB);
	}
}

void CRcBridgeRebar::SetShearRebarJewon(CRebar *pRB, long nTypeShear, double dWidth1, double dWidth2, double dHeight1, double dHeight2, double dDiaShear, double dDiaUpper, double dDiaLower, double dCover)
{
	switch(nTypeShear)
	{
	case 0 : // 캡형
	case 4 : // 캡형(다리길이 정착장)
		pRB->m_nTypeRebar = 92;
		pRB->m_dLengthMax_A = dWidth1 + dDiaShear + max(dDiaUpper,dDiaLower);
		pRB->m_dLengthMax_B = max(dHeight1,dHeight2) + dDiaShear + (dDiaUpper+dDiaLower)/2;
		pRB->m_dLengthMin_B = min(dHeight1,dHeight2) + dDiaShear + (dDiaUpper+dDiaLower)/2;
		pRB->m_dLengthMax_C = (nTypeShear==0) ? 100 : m_pARcBridgeDataStd->GetValueSettle(dDiaShear, SETTLE_TENS_NORMAL, toCm(dCover));
		break;

	case 1 : // 겹침형
		pRB->m_nTypeRebar = 18;
		pRB->m_dLengthMax_A = max(dWidth1,dWidth2) + dDiaShear + max(dDiaUpper,dDiaLower);
		pRB->m_dLengthMin_A = min(dWidth1,dWidth2) + dDiaShear + min(dDiaUpper,dDiaLower);
		pRB->m_dLengthMax_B = max(dHeight1,dHeight2) + dDiaShear + (dDiaUpper+dDiaLower)/2;
		pRB->m_dLengthMin_B = min(dHeight1,dHeight2) + dDiaShear + (dDiaUpper+dDiaLower)/2;
		pRB->m_dLengthMax_C = pRB->m_dLengthMax_B;
		pRB->m_dLengthMin_C = pRB->m_dLengthMin_B;
		break;

	case 2 : // ㄷ형
	case 5 : // 간격재
		pRB->m_nTypeRebar = 3;
		pRB->m_dLengthMax_A = max(dHeight1,dHeight2) + dDiaShear + (dDiaUpper+dDiaLower)/2;
		pRB->m_dLengthMin_A = min(dHeight1,dHeight2) + dDiaShear + (dDiaUpper+dDiaLower)/2;

		pRB->m_dLengthMax_B = 100;
		break;
	case 3 : // 꺽인 ㄷ형
		pRB->m_nTypeRebar = 16;
		pRB->m_dLengthMax_A = dWidth1 + dDiaShear + max(dDiaUpper,dDiaLower);
		pRB->m_dLengthMax_B = max(dHeight1,dHeight2) + dDiaShear + (dDiaUpper+dDiaLower)/2;
		pRB->m_dLengthMin_B = min(dHeight1,dHeight2) + dDiaShear + (dDiaUpper+dDiaLower)/2;
		pRB->m_dLengthMax_C = 100;
		break;
	}

	pRB->RoundJewonMaxMin(0);

	if(pRB->m_dLengthMax_A==pRB->m_dLengthMin_A) pRB->m_dLengthMin_A = 0;
	if(pRB->m_dLengthMax_B==pRB->m_dLengthMin_B) pRB->m_dLengthMin_B = 0;
	if(pRB->m_dLengthMax_C==pRB->m_dLengthMin_C) pRB->m_dLengthMin_C = 0;
	if(pRB->m_dLengthMax_D==pRB->m_dLengthMin_D) pRB->m_dLengthMin_D = 0;
}
void CRcBridgeRebar::GetInfoMainRebarExp_LowerSlab( BOOL bStt, BOOL bLeft, BOOL bUpper, long nCycle, long nDan, long nType, CString &sMark, double &dDia, CString &sDescription )
{
	long stt	= bStt ? iSTT : iEND;
	long left	= bLeft ? iLEFT : iRIGHT;

	CString sStt	= bStt ? "시점" : "종점";
	CString sLeft	= bLeft ? "좌측" : "우측";
	CString sUpper	= bUpper ? "상면" : "하면";
	CString sCycle	= m_bLineDirRebarOfExp[stt][left] ? (nCycle==0 ? "1" : "2") : (nCycle==0 ? "①" : "②");
	CString sType	= nType==0 ? "1" : "2";

	if(nDan == 0)
		sDescription.Format("하부SLAB %s %s%s 가각부 %s_%s", sUpper, sStt, sLeft, sCycle, sType);
	else
		sDescription.Format("하부SLAB %s %s%s 가각부 %s_%s_%d", sUpper, sStt, sLeft, sCycle, sType, nDan+1);
	long nNum	= 1;
	long upper = 0; for(upper = 0; upper < 2; upper++)
	{
		long stt = 0; for(stt = 0; stt < 2; stt++)
		{
			long left = 0; for(left = 0; left < 2; left++)
			{
				long cycle = 0; for(cycle = 0; cycle < 2; cycle++)
				{
					// 가각이 있는지는 상부슬래브와 동일하므로 그냥 사용
					if(!IsExistMainRebarUpperSlabExp(stt == iSTT, left == iLEFT, upper == iUPPER, cycle)) continue;

					long type = 0; for(type = 0; type < 2; type++)
					{
						if((bStt == (stt==iSTT)) && (bUpper == (upper==iUPPER)) && 
							(bLeft == (left==iLEFT)) && (nCycle == cycle) && 
							(type == nType))
						{
							if(nDan == 0)
								sMark.Format("ELT%d", nNum);
							else
								sMark.Format("ELT%d_%d", nNum, nDan+1);
							break;
						}
						nNum++;
					}
				}
			}
		}
	}

	CRebarInfoCycle *pRC	= GetRebarInfoCycleLowerSlabCheckExist(nCycle, 0, bUpper, bStt ? 0 : -1);
	if(pRC)
		dDia	= pRC->m_Dia;
}

void CRcBridgeRebar::GetInfoMainRebarExp_LowerSlabHunch( BOOL bStt, BOOL bLeft, long nCycle, CString &sMark, double &dDia, CString &sDescription )
{
	CString sStt	= bStt ? "시점" : "종점";
	CString sLeft	= bLeft ? "좌측" : "우측";
	CString sCycle	= nCycle==0 ? "①" : "②";

	sDescription.Format("하부SLAB 헌치부 %s%s 가각부 %s", sStt, sLeft, sCycle);
	long nNum	= 1;
	long cycle = 0; for(cycle = 0; cycle < 2; cycle++)
	{
		long stt = 0; for(stt = 0; stt < 2; stt++)
		{
			long left = 0; for(left = 0; left < 2; left++)
			{
				if((bStt == (stt==iSTT)) && (bLeft == (left==iLEFT)) && (nCycle == cycle))
				{
					sMark.Format("EHL%d", nNum);
					break;
				}
				nNum++;
			}
		}
	}

	long nJ	= bStt ? 0 : m_nQtyJigan;
	CRebarInfoCycle *pRC	= NULL;
	for(long rc = 0; rc < m_pArrRCMainLowerSlabHunch[nCycle].GetSize(); rc++)
	{
		CRebarInfoCycle *pTmp	= m_pArrRCMainLowerSlabHunch[nCycle].GetAt(rc);
		if(pTmp->m_nPosHunch == nJ)
		{
			pRC	= pTmp;
			break;
		}
	}

	if(pRC)
		dDia	= pRC->m_Dia;
}

void CRcBridgeRebar::GetTvCuttingArea_Plane_LowerSlabPRF( CTwinVectorArray &tvArr )
{
	tvArr.RemoveAll();

	// BOX가 아니거나 부상방지 저판이 없으면 리턴
	if(!IsBoxType()) return;
	if(!m_bExistProtectionRiseFooting) return;

	// 트랙 제원
	double dWPRF		= m_dPRF_W;
	double dLenJigan	= GetLengthJigan(m_nQtyJigan-1);
	double dSta			= m_dStationBridgeStt+m_dLengthBridge-m_dWE;	// 트랙의 중심 sta
	double dDistMid		= GetDistMidOfSlab(dSta);
	double dWid			= GetWidthSlabAct(dSta, CDPoint(0, 1), 0);
	double dR			= dWid/16;										// 트랙의 원의 반지름
	double dB			= dLenJigan/4;									// 트랙의 수평선 길이
	double dDist		= dDistMid - dWid/6 + 0.0345;					// 중심선형에서 트랙중심까지 거리.(0.0345는 정확히 원의 끝과 철근이 겹치는걸 방지하기 위해 임의로 더해줌)
	if(GetAngleJijum(0).GetAngleDegree() > 90)
		dDist	= dDistMid + dWid/6 + 0.0345;

	// 구하자.
	dSta += dB/3 + dWPRF;

	// 종점 지점각도가 90이 아니면 사각적용  sta조정
	double dAng	= GetAngleJijum(m_nQtyJigan).GetAngleDegree();
	if(!Compare(dAng, 90.0, "="))
		dSta -= dDist / tan(ToRadian(dAng));


	GetTvTrack_Plane(tvArr, dSta, dDist, dR, dB);

	// 주철근배치가 사보강으로 배치되면 시점각도의 직각방향으로 회전
	if(m_nTypePlacingMainRebar_UpperSlab == 1 || m_nTypePlacingMainRebar_UpperSlab == 2)
	{
		CRebarPlacing rb;
		double dRot	= dAng - 90;
		CDPoint xyOrg	= GetLineBase()->GetXyLineByLengthAndAngle(dSta, dDist, CDPoint(0, 1));
		rb.RotateTvArr(tvArr, xyOrg, dRot);
	}


	tvArr.SetTvInfoByInfo("종점측아크1", "그릴때제거1");
	tvArr.SetTvInfoByInfo("종점측아크2", "그릴때제거2");
	tvArr.SetTvInfoByInfo("종점측아크3", "그릴때제거3");
	tvArr.SetTvInfoByInfo("종점측아크4", "그릴때제거4");
}

void CRcBridgeRebar::GetTvRebarMain_Plane_LowerSlab_TypeNormal_Std( CTwinVectorArray &tvArr, CTwinVectorArray &tvArrAngLeft, CTwinVectorArray &tvArrAngRight, BOOL bUpper, long nCycle, long nDan, long nDrawLeft, long nIdx/*=-1*/, BOOL bHunch/*=FALSE*/, BOOL bSttPRF/*=FALSE*/, BOOL bEndPRF/*=FALSE*/, CTwinVectorArray &tvArrJoint/*=staticTvArr*/, CTwinVectorArray &tvArrHidden/*=staticTvArr*/, CTwinVectorArray &tvArrHiddenLeft/*=staticTvArr*/, CTwinVectorArray &tvArrHiddenRight/*=staticTvArr*/, BOOL bForDrawing/*=TRUE*/, CTwinVectorArray &tvArrAngLeftHalf/*=staticTvArr*/, CTwinVectorArray &tvArrAngRightHalf/*=staticTvArr*/, BOOL bCalDistRebarMain/*=TRUE*/ )
{
	tvArr.RemoveAll();
	tvArrAngLeft.RemoveAll();
	tvArrAngRight.RemoveAll();
	tvArrJoint.RemoveAll();
	tvArrHidden.RemoveAll();
	tvArrHiddenLeft.RemoveAll();
	tvArrHiddenRight.RemoveAll();
	tvArrAngLeftHalf.RemoveAll();
	tvArrAngRightHalf.RemoveAll();

	CTwinVectorArray tvArrTmp;
	CTwinVectorArray tvArrAngLeftTmp;
	CTwinVectorArray tvArrAngRightTmp;
	CTwinVectorArray tvArrJointTmp;
	CTwinVectorArray tvArrHiddenTmp;
	CTwinVectorArray tvArrHiddenLeftTmp;
	CTwinVectorArray tvArrHiddenRightTmp;
	CTwinVectorArray tvArrAngLeftHalfTmp;
	CTwinVectorArray tvArrAngRightHalfTmp;

	if(!m_bCaledRebarMain_Plane)
	{
		SettingTvArrRebarMainPlane();
	}

	long upper	= bUpper ? iUPPER : iLOWER;
	long nIdxSttCycle	= nCycle == -1 ? 0 : nCycle;
	long nIdxEndCycle	= nCycle == -1 ? MAX_REBAR_CYCLE : nCycle+1;
	long cycle = 0; for(cycle = nIdxSttCycle; cycle < nIdxEndCycle; cycle++)
	{
		if(bHunch)
		{
			m_Util.AddFromTvArray(tvArrTmp, &m_tvArr_RebarMain_LowerPlaneHunch[cycle], nIdx);	
			m_Util.AddFromTvArray(tvArrAngLeftTmp, &m_tvArrAngLeft_RebarMain_LowerPlaneHunch[cycle], nIdx);
			m_Util.AddFromTvArray(tvArrAngRightTmp, &m_tvArrAngRight_RebarMain_LowerPlaneHunch[cycle], nIdx);
			m_Util.AddFromTvArray(tvArrHiddenTmp, &m_tvArrHidden_RebarMain_LowerPlaneHunch[cycle], nIdx);
			m_Util.AddFromTvArray(tvArrHiddenLeftTmp, &m_tvArrHiddenLeft_RebarMain_LowerPlaneHunch[cycle], nIdx);
			m_Util.AddFromTvArray(tvArrHiddenRightTmp, &m_tvArrHiddenRight_RebarMain_LowerPlaneHunch[cycle], nIdx);
			m_Util.AddFromTvArray(tvArrAngLeftHalfTmp, &m_tvArrAngLeftHalf_RebarMain_LowerPlaneHunch[cycle], nIdx);
			m_Util.AddFromTvArray(tvArrAngRightHalfTmp, &m_tvArrAngRightHalf_RebarMain_LowerPlaneHunch[cycle], nIdx);
		}
		else if(bSttPRF)
		{
			tvArrTmp.AddFromTvArray(m_tvArrSttPRF_RebarMain_LowerPlane);
		}
		else if(bEndPRF)
		{
			tvArrTmp.AddFromTvArray(m_tvArrEndPRF_RebarMain_LowerPlane);
		}
		else
		{
			m_Util.AddFromTvArray(tvArrTmp, &m_tvArr_RebarMain_LowerPlane[cycle][nDan][upper], nIdx);
			m_Util.AddFromTvArray(tvArrAngLeftTmp, &m_tvArrAngLeft_RebarMain_LowerPlane[cycle][nDan][upper], nIdx);
			m_Util.AddFromTvArray(tvArrAngRightTmp, &m_tvArrAngRight_RebarMain_LowerPlane[cycle][nDan][upper], nIdx);
			m_Util.AddFromTvArray(tvArrJointTmp, &m_tvArrJoint_RebarMain_LowerPlane[cycle][nDan][upper], nIdx);
			m_Util.AddFromTvArray(tvArrHiddenTmp, &m_tvArrHidden_RebarMain_LowerPlane[cycle][nDan][upper], nIdx);
			m_Util.AddFromTvArray(tvArrHiddenLeftTmp, &m_tvArrHiddenLeft_RebarMain_LowerPlane[cycle][nDan][upper], nIdx);
			m_Util.AddFromTvArray(tvArrHiddenRightTmp, &m_tvArrHiddenRight_RebarMain_LowerPlane[cycle][nDan][upper], nIdx);
			m_Util.AddFromTvArray(tvArrAngLeftHalfTmp, &m_tvArrAngLeftHalf_RebarMain_LowerPlane[cycle][nDan][upper], nIdx);
			m_Util.AddFromTvArray(tvArrAngRightHalfTmp, &m_tvArrAngRightHalf_RebarMain_LowerPlane[cycle][nDan][upper], nIdx);
		}
	}

	BOOL bVertDir	= IsVertDir();
	if(nDrawLeft != 0 || m_nTypePlacingMainRebar_UpperSlab == 2)
	{
		// 바로 rb에 넘기면 시간이 오래 걸리므로 일단 스테이션으로 판단하는 곳에 넘겨서 살짝 걸러냄.
		if(!bVertDir)
		{
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrTmp, nDrawLeft);
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrAngLeftTmp, nDrawLeft);
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrAngRightTmp, nDrawLeft);
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrJointTmp, nDrawLeft);
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrHiddenTmp, nDrawLeft);
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrHiddenLeftTmp, nDrawLeft);
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrHiddenRightTmp, nDrawLeft);
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrAngLeftHalfTmp, nDrawLeft);
			m_Util.GetTvArrUpperSlabByDrawLeft_MainRebar(tvArrAngRightHalfTmp, nDrawLeft);
		}
		else
		{
			// 계산해서 잘라내기
			CTwinVectorArray tvArrPlane;
			GetTvRebarOut_Plane_UpperSlabStd(tvArrPlane, 0, TRUE, nDrawLeft==-1?iLEFT:(nDrawLeft==1?iRIGHT:2), bVertDir);

			CTwinVectorArray tvArrPlane9Dan;
			GetTvRebarOut_Plane_UpperSlabStd(tvArrPlane9Dan, 9, TRUE, nDrawLeft==-1?iLEFT:(nDrawLeft==1?iRIGHT:2), bVertDir);

			CTwinVectorArray tvArrPlaneOut;
			GetTvRebarOut_Plane_UpperSlabStd(tvArrPlaneOut, -1, TRUE, nDrawLeft==-1?iLEFT:(nDrawLeft==1?iRIGHT:2), bVertDir);

			CRebarPlacing rb;
			CLineInfo *pLineL	= GetLineLeftRight(TRUE);
			CLineInfo *pLineR	= GetLineLeftRight(FALSE);
			rb.GetTvArrayByCrossTvArrayArea(tvArrTmp, tvArrPlane, TRUE);
			rb.GetTvArrayByCrossTvArrayArea(tvArrJointTmp, tvArrPlaneOut, TRUE);
			rb.GetTvArrayByCrossTvArrayArea(tvArrHiddenTmp, tvArrPlane9Dan, TRUE);
			
			rb.m_pLine	= pLineL;
			rb.GetTvArrayByCrossTvArrayArea(tvArrAngLeftTmp, tvArrPlaneOut, TRUE);
			rb.m_pLine	= pLineR;
			rb.GetTvArrayByCrossTvArrayArea(tvArrAngRightTmp, tvArrPlaneOut, TRUE);
			rb.m_pLine	= NULL;
			StretchTvOfTvArr(tvArrHiddenLeftTmp, -1, -1);
			rb.GetTvArrayByCrossTvArrayArea(tvArrHiddenLeftTmp, tvArrPlane9Dan, TRUE);
			StretchTvOfTvArr(tvArrHiddenRightTmp, -1, -1);
			rb.GetTvArrayByCrossTvArrayArea(tvArrHiddenRightTmp, tvArrPlane9Dan, TRUE);
			rb.GetTvArrayByCrossTvArrayArea(tvArrAngLeftHalfTmp, tvArrPlane, TRUE);
			rb.GetTvArrayByCrossTvArrayArea(tvArrAngRightHalfTmp, tvArrPlane, TRUE);
		}
	}

	ConvertPlaneLineToTv(tvArrTmp);
	ConvertPlaneLineToTv(tvArrAngLeftTmp);
	ConvertPlaneLineToTv(tvArrAngRightTmp);
	ConvertPlaneLineToTv(tvArrJointTmp);
	ConvertPlaneLineToTv(tvArrHiddenTmp);
	ConvertPlaneLineToTv(tvArrHiddenLeftTmp);
	ConvertPlaneLineToTv(tvArrHiddenRightTmp);
	ConvertPlaneLineToTv(tvArrAngLeftHalfTmp);
	ConvertPlaneLineToTv(tvArrAngRightHalfTmp);

	
	tvArr.AddFromTvArray(tvArrTmp);
	tvArrAngLeft.AddFromTvArray(tvArrAngLeftTmp);
	tvArrAngRight.AddFromTvArray(tvArrAngRightTmp);
	tvArrJoint.AddFromTvArray(tvArrJointTmp);
	tvArrHidden.AddFromTvArray(tvArrHiddenTmp);
	tvArrHiddenLeft.AddFromTvArray(tvArrHiddenLeftTmp);
	tvArrHiddenRight.AddFromTvArray(tvArrHiddenRightTmp);
	tvArrAngLeftHalf.AddFromTvArray(tvArrAngLeftHalfTmp);
	tvArrAngRightHalf.AddFromTvArray(tvArrAngRightHalfTmp);
}

void CRcBridgeRebar::GetTvRebarMain_Plane_LowerSlab_TypeNormal( CTwinVectorArray &tvArr, CTwinVectorArray &tvArrAngLeft, CTwinVectorArray &tvArrAngRight, BOOL bUpper, long nCycle, long nDan, long nDrawLeft, long nIdx/*=-1*/, BOOL bHunch/*=FALSE*/, BOOL bSttPRF/*=FALSE*/, BOOL bEndPRF/*=FALSE*/, CTwinVectorArray &tvArrJoint/*=staticTvArr*/, CTwinVectorArray &tvArrHidden/*=staticTvArr*/, CTwinVectorArray &tvArrHiddenLeft/*=staticTvArr*/, CTwinVectorArray &tvArrHiddenRight/*=staticTvArr*/, BOOL bForDrawing/*=TRUE*/, CTwinVectorArray &tvArrAngLeftHalf/*=staticTvArr*/, CTwinVectorArray &tvArrAngRightHalf/*=staticTvArr*/, BOOL bCalDistRebarMain/*=TRUE*/ )
{
	tvArr.RemoveAll();
	tvArrAngLeft.RemoveAll();
	tvArrAngRight.RemoveAll();
	tvArrJoint.RemoveAll();
	tvArrHidden.RemoveAll();
	tvArrHiddenLeft.RemoveAll();
	tvArrHiddenRight.RemoveAll();
	tvArrAngLeftHalf.RemoveAll();
	tvArrAngRightHalf.RemoveAll();

	CTwinVectorArray tvArrPlane, tvArrPlaneRebar;
	GetTvRebarOut_Plane_UpperSlabStd(tvArrPlane, 0, TRUE, nDrawLeft == -1 ? iUPPER : (nDrawLeft == 1 ? iLOWER : 2));
	GetTvRebarOut_Plane_UpperSlabStd(tvArrPlaneRebar, 0, TRUE, 2);
	tvArrPlane	= m_tvArrPlane1DanOrg;
	tvArrPlaneRebar	= m_tvArrPlane1DanOrg;
	
	// 2005.06.16 부로 주철근 사보강 배치(절반) 옵션 없어짐 /////////
	// 하부장님 정차장님과 상의 함.
	// 2006.1.2부로 다시 작업함.
	/*
	if(m_nTypePlacingMainRebar_UpperSlab == 2) 
		m_nTypePlacingMainRebar_UpperSlab	= 1;
		*/
	////////////////////////////////////////////////////////////////

	SetDataDefaultDistLeftDirPlacing(bHunch);


	CTwinVectorArray tvArrHiddenAngLeftTmp, tvArrHiddenAngRightTmp, tvArrHiddenOrgTmp;

	BOOL bVertDir	= IsVertDir();
	
	CLineInfoApp *pLineBase		= static_cast<CLineInfoApp*>(GetLineBase(bVertDir));
	CLineInfoApp *pLineLeft		= static_cast<CLineInfoApp*>(GetLineLeftRight(TRUE));
	double dDistMid				= GetDistMidOfSlab(m_dStationBridgeStt-m_dWS, FALSE, FALSE);

	// 배근에 필요한 rebarinfocycle 고름
	long upper	= bUpper ? iUPPER : iLOWER;
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC	= &m_pArrRCMainLowerSlab[nCycle==-1?0:nCycle][upper][nDan];

	// 
	long nTypePlacing	= m_nTypePlacingMainRebar_UpperSlab;
	if(bHunch)
	{
		pArrRC	= &m_pArrRCMainLowerSlabHunch[nCycle==-1?0:nCycle];
		upper	= iUPPER;
	}
	else if(bSttPRF)
	{
		pArrRC	= nCycle == -1 || nCycle == 0 ? &m_pArrRCMainBoxLowerPRF_Cycle1[iSTT] : &m_pArrRCMainBoxLowerPRF_Cycle2[iSTT];
		upper	= iLOWER;
		nTypePlacing	= 1;
	}
	else if(bEndPRF)
	{
		pArrRC	= nCycle == -1 || nCycle == 0 ? &m_pArrRCMainBoxLowerPRF_Cycle1[iEND] : &m_pArrRCMainBoxLowerPRF_Cycle2[iEND];
		upper	= iLOWER;
		nTypePlacing	= 1;
	}

	long nSize	= pArrRC->GetSize();
	if(nSize == 0) return;
	if(nIdx != -1 && nIdx >= nSize) return;
	long nIdxStt	= nIdx == -1 ? 0 : nIdx;
	long nIdxEnd	= nIdx == -1 ? nSize : nIdx+1;


	// 철근들어가는 평면 좌표들 ////////
	CTwinVectorArray tvArrStt[2];
	CTwinVectorArray tvArrSttRebar[2];
	CTwinVectorArray tvArrLeft[2];
	
	CTwinVector tv;
	long i = 0; for(i = 0; i < tvArrPlane.GetSize(); i++)
	{
		tv	= tvArrPlane.GetAt(i);
		if(tv.m_sInfo == "시점") tvArrStt[iSTT].Add(tv);
		else if(tv.m_sInfo == "종점") tvArrStt[iEND].Add(tv);
	}
	for(i = 0; i < tvArrPlane.GetSize(); i++)
	{
		tv	= tvArrPlane.GetAt(i);
		if(tv.m_sInfo == "좌측") tvArrLeft[iLEFT].Add(tv);
		else if(tv.m_sInfo == "우측") tvArrLeft[iRIGHT].Add(tv);
	}

	for(i = 0; i < tvArrPlaneRebar.GetSize(); i++)
	{
		tv	= tvArrPlaneRebar.GetAt(i);
		if(tv.m_sInfo == "시점") tvArrSttRebar[iSTT].Add(tv);
		else if(tv.m_sInfo == "종점") tvArrSttRebar[iEND].Add(tv);
	}

	// 사보강 배근시 시점과 종점의 각도가 다를 경우 종점철근의 끝을 늘려주기 위한 기준점 잡기.
	tvArrStt[iSTT].Sort();
	tvArrStt[iEND].Sort();
	tvArrSttRebar[iSTT].Sort();
	tvArrSttRebar[iEND].Sort();
	CTwinVector tvStt, tvEnd;
	CTwinVector tvSttRebar, tvEndRebar;
	tvStt.m_v1	= tvArrStt[iSTT].GetAt(0).m_v1;
	tvStt.m_v2	= tvArrStt[iSTT].GetAt(tvArrStt[iSTT].GetSize()-1).m_v2;
	tvEnd.m_v1	= tvArrStt[iEND].GetAt(0).m_v1;
	tvEnd.m_v2	= tvArrStt[iEND].GetAt(tvArrStt[iEND].GetSize()-1).m_v2;
	tvSttRebar.m_v1	= tvArrSttRebar[iSTT].GetAt(0).m_v1;
	tvSttRebar.m_v2	= tvArrSttRebar[iSTT].GetAt(tvArrSttRebar[iSTT].GetSize()-1).m_v2;
	tvEndRebar.m_v1	= tvArrSttRebar[iEND].GetAt(0).m_v1;
	tvEndRebar.m_v2	= tvArrSttRebar[iEND].GetAt(tvArrSttRebar[iEND].GetSize()-1).m_v2;
	

	CDPoint xyMatch1(0, 0), xyMatch2(0, 0);
	GetXyMatchLineAndLine(tvStt.m_v1, tvStt.GetXyDir(), tvEnd.m_v1, tvEnd.GetXyDir().Rotate90(), xyMatch1);
	GetXyMatchLineAndLine(tvStt.m_v1, tvStt.GetXyDir(), tvEnd.m_v2, tvEnd.GetXyDir().Rotate90(), xyMatch2);

	CDPoint xyEnd1	= tvEndRebar.m_v1;
	CDPoint xyEnd2	= tvEndRebar.m_v2;
	CDPoint xyEndLeft	= xyEnd1;
	//////////////////////////////////////



	// rebarinfocycle들의 끝 좌표를 offset함.
	// 1,3 사이클은 이음이 없는 부분은 그냥 직각방향으로 offset하고
	// 이음이 있는 부분은 이음위치를 offset하고 거기서 이음 길이만큼 더 증가시킴
	
	// 2,4 사이클은 시작과 끝은 좌우측 offset한 다음 철근 길이를 줘서 좌표를 구하고, 
	// 나머지는 각 지점위치에서 각 지점 각도방향으로 offset을 한다.
	CRebarPlacing rb;
	CRebarInfoCycle *pRC		= NULL;
	CRebarInfoCycle *pRCNext	= NULL;
	CRebarInfoCycle *pRCPrev	= NULL;
	CDPointArray xyArrStt, xyArrEnd, xyArrTmp;
	static CDoubleArray dArrSttOrg, dArrEndOrg, dArrTmp;
	static CDoubleArray dArrSttAng, dArrEndAng;
	double	dStaStt	= 0,
			dStaEnd	= 0,
			dAngStt	= 90,
			dAngEnd	= 90;
	double dStaSttParalOfHunch	= 0;	// 헌치일 경우 수평인 스테이션의 시작(수평구간은 최대 한곳밖에 없으므로 수평구간을 파악함)
	double dStaEndParalOfHunch	= 0;	// 헌치일 경우 수평인 스테이션의 끝(수평구간은 최대 한곳밖에 없으므로 수평구간을 파악함)
			
	double dStaSttNext	= 0;
	double dStaEndPrev	= 0;
	tv.m_v1.z	= 3;
	tv.m_v1.y	= 90;
	tv.m_v2.y	= 90;
	for(long rc = nIdxStt; rc < nIdxEnd; rc++)
	{
		pRC		= pArrRC->GetAt(rc);
		if(!pRC->m_bExist) continue;
		pRCNext	= rc < nSize-1 ? pArrRC->GetAt(rc+1) : NULL;
		if(pRCNext)
		{
			if(!pRCNext->m_bExist)
				pRCNext	= NULL;
		}
		pRCPrev	= rc > 0 ? pArrRC->GetAt(rc-1) : NULL;

		// 철근이 들어가는 sta //////////////////////////////////////
		if(pRC->m_bUseTvArrRebar) 	// 기둥식 벽체 위 헌치철근은 tvArr로 구성되어 있다.
		{
			dStaStt	= pRC->m_tvArrRebar.GetXyLeft().x;
			dStaEnd	= pRC->m_tvArrRebar.GetXyRight().x;

			//
			if(bHunch)
			{
				BOOL bHunchRebarV	= FALSE;
				long nType	= GetTypeMainRebarSlabUpperHunch(pRC->m_nPosHunch, TRUE);

				long nJ	= pRC->m_nPosHunch;
				CWallApp *pWall	= GetInWall(nJ-1);
				if(pWall) bHunchRebarV	= pWall->m_bTopIsColumn;
					
				// V형일때만 수평구간이 있다.
				if((bHunchRebarV || nType == 1) && pRC->m_tvArrRebar.GetSize() > 1)
				{
					CTwinVector tvParal	= pRC->m_tvArrRebar.GetAt(1);
					dStaSttParalOfHunch	= tvParal.m_v1.x;
					dStaEndParalOfHunch	= tvParal.m_v2.x;
					if(dStaSttParalOfHunch > dStaEndParalOfHunch)
						GetSwap(dStaSttParalOfHunch, dStaEndParalOfHunch);
				}
			}

			dStaSttNext	= pRCNext ? pRCNext->m_tvArrRebar.GetXyLeft().x : dStaEnd;
			dStaEndPrev	= pRCPrev ? pRCPrev->m_tvArrRebar.GetXyRight().x : dStaEnd;
		}
		else
		{
			if(pRC->m_nPosStt == pRC->m_nPosEnd)
			{
				dStaStt	= pRC->m_xyStt.x;
				dStaEnd	= pRC->m_xyMid1.x;

				dStaSttNext	= pRCNext ? pRCNext->m_xyStt.x : dStaEnd;
				dStaEndPrev	= pRCPrev ? pRCPrev->m_xyMid1.x : dStaEnd;
			}
			else
			{
				BOOL bSttRebar	= TRUE;
				if(IsMainRebarJointLowerSlabAndOutWall(pRC, bSttRebar))
				{
					dStaStt	= bSttRebar ? pRC->m_xyMid2.x : pRC->m_xyStt.x;
					dStaEnd	= bSttRebar ? pRC->m_xyEndExt.x : pRC->m_xyMid2.x;
				}
				else if(IsMainRebarJointLowerSlabAndLowerSlab(pRC))
				{
					dStaStt	= pRC->m_xyStt.x;
					dStaEnd	= pRC->m_xyEndExt.x;
				}
				else
				{
					dStaStt	= pRC->m_xyStt.x;
					dStaEnd	= pRC->m_xyEnd.x;
				}

				if(IsMainRebarJointLowerSlabAndOutWall(pRCNext, bSttRebar))
				{
					dStaSttNext	= pRCNext ? (bSttRebar ? pRCNext->m_xyMid2.x : pRCNext->m_xyStt.x) : dStaEnd;
				}
// 				else if(IsMainRebarJointLowerSlabAndLowerSlab(pRCNext))	// 사실 이 부분은 안 쓰임.
// 				{
// 					dStaSttNext	= pRCNext ? pRCNext->m_xyStt.x : dStaEnd;
// 				}
				else
				{
					dStaSttNext	= pRCNext ? pRCNext->m_xyStt.x : dStaEnd;
				}

				if(IsMainRebarJointLowerSlabAndOutWall(pRCPrev, bSttRebar))
				{
					dStaEndPrev	= pRCPrev ? (bSttRebar ? pRCPrev->m_xyEndExt.x : pRCPrev->m_xyMid2.x) : dStaEnd;
				}
				else if(IsMainRebarJointLowerSlabAndLowerSlab(pRCPrev))	// 사실 이 부분은 안 쓰임.
				{
					dStaEndPrev	= pRCPrev ? pRC->m_xyEndExt.x : dStaEnd;
				}
				else
				{
					dStaEndPrev	= pRCPrev ? pRCPrev->m_xyEnd.x : dStaEnd;
				}
			}
		}
		////////////////////////////////////////////////////////////////

				
		// 이음길이 : 다음 철근이 이번 철근과 겹치는 경우에만 있다.
		double dLenJoint	= dStaEnd - dStaSttNext;
		
		// 이전 철근과의 이음길이
		// 있을 수도 있고 없을 수도 있음
		// 사보강 절반 배치시 직방향 절단되는 철근이 이전 이음보다 짧아질경우 철근을 없애 버리기 위함.
		double dLenJointPrev	= rc > 0 && pRCPrev->m_bExist ? dStaEndPrev - dStaStt : 0;
	
		
		BOOL bJoint			= dLenJoint > 0 ? TRUE : FALSE;
		BOOL bJointPrev		= dLenJointPrev > 0 ? TRUE : FALSE;
		
		// 기준sta에서의 주철근 간격
		// 선형방향일땐 시점기준으로 하고, 사보강일댄 구체 시작sta을 기준으로 한다.
		CDPoint vAng(0, 1);

		// 직철근밎 선형방향 배치용 간격
		// 확폭 지원은 안되므로 처음 철근일 경우 한번만 구해 주면 된다.
		// 단, 사보강배치인 경우, 중심선형 좌우측 모두 구해야 된다.
		// 그런후 상하면에 따라 잘라내는 방식으로 함.
		if(rc == nIdxStt/* && bCalDistRebarMain*/)
		{
			if(bHunch && IsHunchRebarPlane((dStaStt+dStaEnd)/2, TRUE))
			{
				// 시,종점 지점에서는 헌치부만이 아닌 슬래브하면과 동일하게 배근되어 들어간다. 
				// 철근 마킹하는 부분에는 => 같이 변경되어 있어서 맞춰 준다. (39755) 시종점 현치도 헌치 거리 고려...
				//if(pRC->m_nPosHunch == 0 || pRC->m_nPosHunch == m_nQtyJigan)
				//	dArrSttOrg	= m_dArrDist_RebarMain_LowerPlane[nCycle][nDan][upper][0];
				//else
				dArrSttOrg	= m_dArrDist_RebarMain_LowerPlaneHunch[nCycle][0];
				
				// 사철근용 간격 (피복을 맞춰줌)
				if(bVertDir || IsExtLine())
				{
					//if(pRC->m_nPosHunch == 0 || pRC->m_nPosHunch == m_nQtyJigan)
					//	dArrSttAng	= m_dArrDist_RebarMain_LowerPlane[nCycle][nDan][upper][1];
					//else
					dArrSttAng	= m_dArrDist_RebarMain_LowerPlaneHunch[nCycle][1];
				}
			}
			else
			{
				dArrSttOrg	= m_dArrDist_RebarMain_LowerPlane[nCycle][nDan][upper][0];

				// 사철근용 간격 (피복을 맞춰줌)
				if(bVertDir || IsExtLine())
				{
					dArrSttAng	= m_dArrDist_RebarMain_LowerPlane[nCycle][nDan][upper][1];
				}
			}
		}

		// 사보강배치일 경우 시점0을 기준으로하는 직방향 선형을 사용하기 때문에 실제로 그려진 종단면상의 철근에서일부 수정이 있어야 함.
		// 철근배치를 하기 위해선 직방향용 선형의 sta으로 변경
		if(bVertDir)
		{
 			double dDiff	= m_dStationBridgeStt;
			dStaStt			-= dDiff;
			dStaEnd			-= dDiff;

			dStaSttParalOfHunch	-= dDiff;
			dStaEndParalOfHunch	-= dDiff;

			// 중심선형을 기준으로 그려지지 않는 철근들..(브라켓,헌치)은
			// 철근의 sta에서의 기준선형과 수직선형과의 차이를 dist정보에서 보완을 해 주어야 한다.
			if(bSttPRF || bEndPRF)
			{
				CDPoint xyMidVert	= pLineBase->GetXyLineByLengthAndAngle(dStaStt, 0, CDPoint(0, 1));
				CDPointArray xyArrMatch;
				CTwinVectorArray tvArrCenter;
				GetTvCenterPlane_UpperSlab(tvArrCenter, FALSE, TRUE, 0, FALSE);
				rb.GetXyMatchTvArrAndLine(tvArrCenter, xyMidVert, GetAngleJijum(0), xyArrMatch);
				if(xyArrMatch.GetSize() > 0)
				{
					CDPoint xyMatch	= xyArrMatch.GetAt(0);
					double dDist	= ~(xyMatch - xyMidVert);
					long i = 0; for(i = 0; i < dArrSttOrg.GetSize(); i++)
						dArrSttOrg.SetAt(i, dArrSttOrg[i]-dDist);
					
					for(i = 0; i < dArrEndOrg.GetSize(); i++)
						dArrEndOrg.SetAt(i, dArrEndOrg[i]-dDist);

					for(i = 0; i < dArrSttAng.GetSize(); i++)
						dArrSttAng.SetAt(i, dArrSttAng[i]-dDist);
					
					for(i = 0; i < dArrEndAng.GetSize(); i++)
						dArrEndAng.SetAt(i, dArrEndAng[i]-dDist);
				}
			}
		}
		
		// 배근되는 각도 설정 ////////////////////////////////////////////////
		if(bHunch || bSttPRF || bEndPRF)	// 헌치,브라켓철근의 경우 각 지점의 각도를 따라서 배근된다.
		{
			dAngStt	= 90;
			dAngEnd	= 90;

			// 현재 헌치철근의 지점 번호를 알아야 됨.
			long nJ	= pRC->m_nPosHunch;
			if(bHunch)
				nJ	= pRC->m_nPosHunch;
			else if(bSttPRF)
				nJ	= 0;
			else if(bEndPRF)
				nJ	= m_nQtyJigan;

			if(nJ > -1)
			{
				CDPoint xyDir	= GetAngleJijum(nJ, bVertDir);
				dAngStt	= xyDir.GetAngleDegree();
				dAngEnd	= xyDir.GetAngleDegree();
			}
		}
		else
		{
			// 시종점이 아닌 철근은 중심sta이가장 가까운 지점의 각도를 따라간다.
			long nNearestJijumStt	= GetJijumNumberByStation(dStaStt);
			long nNearestJijumEnd	= GetJijumNumberByStation(dStaEnd);
			dAngStt		= GetAngleJijum(nNearestJijumStt).GetAngleDegree();
			dAngEnd		= GetAngleJijum(nNearestJijumEnd).GetAngleDegree();
			if(dStaStt < m_dStationBridgeStt)
				dAngStt	= GetAngleByTarget(BRIDGE_OFF_STT_SLABCOVER, 0).GetAngleDegree();
			if(dStaEnd > m_dStationBridgeStt + m_dLengthBridge)
				dAngEnd	= GetAngleByTarget(BRIDGE_OFF_END_SLABCOVER, 0).GetAngleDegree();
		}

		if(bVertDir)
		{
			dAngStt	= 90;
			dAngEnd	= 90;
		}

		// 구해진 간격들을 tvArr에 보관
		// 주철근 배치 방법에 따라서 여러가지로 보관될 수가 있다.
		// m_nTypePlacingMainRebar_UpperSlab 
		// 0 : 일반 선형방향
		// 1 : 사보강배치(전체)
		// 2 : 사보강배치(절반)
		// 1, 2의 배치는 선형이 곡선일 경우 매우 이상하게 나올 수 있다.. 주의해서 사용바람 

		// 시점과 종점라인에 교차되는 철근은 옵션에 따라 사방향 철근으로 빼던지, 그냥 배근하던지 한다. ///
		// 그래서 시종점 라인을 구함. 
		
// 		double dStaMid		= GetStationBridgeStt(bVertDir)+GetLengthBridge(bVertDir)/2;
// 		double dStaOrg		= GetStationBridgeStt(bVertDir);
// 		// 사보강 배치일 경우 사방향 철근 구간을 정확히 판단하기 위해서 시점벽체를 기준으로 배근한다.
// 		if(bVertDir)
// 		{
// // 			dStaMid			= dStaOrg;
// 			if(IsOutWall(TRUE))
// 			{
// // 				dStaMid	-= m_dWS;
// 				dStaOrg	-= m_dWS;
// 			}
// 		}

		CDPoint xyDirLeft	= GetXyDirRebarMainPlaneForSabogang(-1);
		CDPoint xyDirRight	= GetXyDirRebarMainPlaneForSabogang(1);

		CDPointArray xyArrMatch[2];
		CTwinVector tv;
		///////////////////////////////////////////////////////////////////////////////////////////////////

		CTwinVector tvHidden;
		double dLenRound		= bUpper ? 0 : fabs(pRC->m_xyMid1.x-pRC->m_xyMid2.x);
		double dStaSttSolid		= dStaStt;
		double dStaEndSolid		= dStaEnd;
		double dStaSttHidden	= dStaStt;
		double dStaEndHidden	= dStaStt;
		double dStaSttHidden2	= dStaStt;	// 상부슬래브 일체형 철근일 경우만 생길 수 있다. 양쪽에 점선.
		double dStaEndHidden2	= dStaStt;	// 상부슬래브 일체형 철근일 경우만 생길 수 있다. 양쪽에 점선.
		// 원래 sta를 변경하지 않는건 일단 좌표를 구하면 외곽선과 교차점 체크를 해야 되기 때문에 
		// 일단 그냥 구하고, bForDrawing일때는 교차점까지 체크후 다시 구한다.
		if(bForDrawing)
		{
			if(rc == 0)
			{
				dStaSttSolid	= dStaSttSolid + dLenRound;
				dStaEndHidden	= dStaSttSolid;

				if(IsMainRebarJointLowerSlabAndLowerSlab(pRC))
				{
					dStaEndHidden2	= dStaEndSolid;
					dStaSttHidden2	= dStaEndSolid - dLenRound;
					dStaEndSolid	= dStaSttHidden2;
				}
			}
			else if(rc == nSize-1)
			{
				dStaEndSolid	= dStaEndSolid - dLenRound;
				dStaSttHidden	= dStaEndSolid;
				dStaEndHidden	= dStaEnd;
			}
			else
			{
				dStaEndHidden	= dStaSttHidden;
			}
		}

		double dStaSttTmp	= dStaStt;
		double dStaEndTmp	= dStaEnd;
		double dAngSttTmp	= dAngStt;
		double dAngEndTmp	= dAngEnd;
		double dStaSttSolidTmp	= dStaSttSolid;
		double dStaEndSolidTmp	= dStaEndSolid;
		double dStaSttHiddenTmp	= dStaSttHidden;
		double dStaEndHiddenTmp	= dStaEndHidden;
		double dStaSttHiddenTmp2	= dStaSttHidden2;
		double dStaEndHiddenTmp2	= dStaEndHidden2;
		double dStaSttParalOfHunchTmp	= dStaSttParalOfHunch;
		double dStaEndParalOfHunchTmp	= dStaEndParalOfHunch;

		dAngStt	= 90;
		dAngEnd	= 90;

		CDPoint vAngStt				= GetAngleJijum(0);
		double dStaTmp				= IsOutWall(TRUE) ? m_dStationBridgeStt - m_dWS/vAngStt.y : m_dStationBridgeStt;
		double dDistLeft			= -(dDistMid + GetWidthSlabAct(dStaTmp, vAngStt, -1));
		double dDistRight			= GetWidthSlabAct(dStaTmp, vAngStt, 1) - dDistMid;
		double dDistLeftAngleRebar	= m_dDistLeftDirPlacing;
		double dDistRightAngleRebar	= m_dDistRightDirPlacing;
		double dDistDiff			= GetDistDiffOfMidInVert();// 사보강일경우 기준sta에서의 직방향중심과 선형방향 중심의 차이를 알아야 된다.

		// 폭이 가장 큰 스테이션(사보강시 직방향 철근은 폭이 가장 큰 것을 기준으로 한다)
		double dStaTmpBigestL			= GetStationSmallestWidthOfUpperSlab(TRUE, -1);
		double dStaTmpBigestR			= IsExtLine() ? GetStationSmallestWidthOfUpperSlab(TRUE, 1) : dStaTmpBigestL;
		double dDistLeftBigest			= -(dDistMid + GetWidthSlabAct(dStaTmpBigestL, vAngStt, -1));
		double dDistRightBigest			= GetWidthSlabAct(dStaTmpBigestR, vAngStt, 1) - dDistMid;
		double dDistLeftMaxBigest		= dDistLeftBigest;	// 횡단면 최대 길이
		double dDistRightMaxBigest		= dDistRightBigest;	// 횡단면 최대길이

		if(bVertDir)	// 사보강인 경우 횡단면 최대길이 구해줌
		{
			long nOldTypePlacingMainRebar	= m_nTypePlacingMainRebar_UpperSlab;
			double dOldDistLeftDirPlacing	= m_dDistLeftDirPlacing;
			double dOldDistRightDirPlacing	= m_dDistRightDirPlacing;

			m_nTypePlacingMainRebar_UpperSlab	= 1;
			SetDataDefaultDistLeftDirPlacing();

			double dAng	= GetAngleJijum(0).GetAngleDegree();
			if(dAng < 90)
			{
				dDistLeftMaxBigest -= m_dDistLeftDirPlacing;
			}
			if(dAng > 90)
			{
				dDistRightMaxBigest += m_dDistRightDirPlacing;
			}

			m_nTypePlacingMainRebar_UpperSlab	= nOldTypePlacingMainRebar;
			m_dDistLeftDirPlacing				= dOldDistLeftDirPlacing;
			m_dDistRightDirPlacing				= dOldDistRightDirPlacing;
		}

		CTwinVector tvTmp;
		double dDiffRad	= 0;	// 사보강인데 시점과 종점이 각도가 다른 경우를 대비해서 미리 구해둠
		if(bVertDir)
		{
			double dAngSttJi	= GetAngleJijum(0, TRUE).GetAngleDegree();
			double dAngEndJi	= GetAngleJijum(m_nQtyJigan, TRUE).GetAngleDegree();
			dDiffRad	= ToRadian(90 - (dAngSttJi - dAngEndJi));
		}

		// 혹시나 사방향 철근이 겹체게 되는 경우를 판단 //////////////////
		double dWMax	= GetWidthSlabAct(m_dStationBridgeStt, GetAngleJijum(0), 0);
		if(dDistLeftAngleRebar + dDistRightAngleRebar > dWMax)
		{
			dDistLeftAngleRebar		= dWMax/2;
			dDistRightAngleRebar	= dWMax/2;
		}
		//////////////////////////////////////////////////////////////////////

		// 사보강 배치일 경우 직방향 철근이 들어가는 범위를 구한다.
		double dDistLeftRangeVertRebar	= 0;
		double dDistRightRangeVertRebar	= 0;
		if(bVertDir)
		{
			GetTvSttEndOfSlab(tvStt, tvEnd);

			if(m_nTypePlacingMainRebar_UpperSlab == 1)
			{
				dDistLeftRangeVertRebar		= max(pLineBase->GetDisMatchVerticalByXy(tvStt.m_v2), pLineBase->GetDisMatchVerticalByXy(tvEnd.m_v2));
				dDistRightRangeVertRebar	= min(pLineBase->GetDisMatchVerticalByXy(tvStt.m_v1), pLineBase->GetDisMatchVerticalByXy(tvEnd.m_v1));
			}
			else if(m_nTypePlacingMainRebar_UpperSlab == 2)
			{
				dDistLeftRangeVertRebar		= min(pLineBase->GetDisMatchVerticalByXy(tvStt.m_v2), pLineBase->GetDisMatchVerticalByXy(tvEnd.m_v2)) + m_dDistLeftDirPlacing;
				dDistRightRangeVertRebar	= max(pLineBase->GetDisMatchVerticalByXy(tvStt.m_v1), pLineBase->GetDisMatchVerticalByXy(tvEnd.m_v1)) - m_dDistRightDirPlacing;
			}
		}

		// 가각 있고 전체사보강이면 dDist를 최대로 넓힌다.
		// 단 직방향 철근을 뻗어서 가각의 어느 부분이라도 닿으면 배근하지 않음
		
		if(m_nTypePlacingMainRebar_UpperSlab == 1)
		{
			// 우측 거리 조정
			double dDiff	= GetDiffLeftRightDistForGagakSabogang(TRUE, FALSE);
			if(dDiff > 0)
			{
				dDistRightRangeVertRebar += dDiff;
				m_dDistRightDirPlacing	-= dDiff;
				dDistRightAngleRebar	-= dDiff;
			}
			// 좌측 거리 조정
			dDiff	= GetDiffLeftRightDistForGagakSabogang(FALSE, TRUE);
			if(dDiff > 0)
			{
				dDistLeftRangeVertRebar += dDiff;
				m_dDistLeftDirPlacing -= dDiff;
				dDistLeftAngleRebar	-= dDiff;
			}
			// 좌측 거리 조정
			dDiff	= GetDiffLeftRightDistForGagakSabogang(TRUE, TRUE);
			if(dDiff > 0)
			{
				dDistLeftRangeVertRebar += dDiff;
				m_dDistLeftDirPlacing -= dDiff;
				dDistLeftAngleRebar	-= dDiff;
			}
			// 우측 거리 조정
			dDiff	= GetDiffLeftRightDistForGagakSabogang(FALSE, FALSE);
			if(dDiff > 0)
			{
				dDistRightRangeVertRebar += dDiff;
				m_dDistRightDirPlacing -= dDiff;
				dDistRightAngleRebar -= dDiff;
			}
		}
		
		// 사보강 배치일때만 사용함.
		CTwinVectorArray tvArrCenterVert;
		GetTvCenterPlane_UpperSlab(tvArrCenterVert, FALSE, TRUE, 0, TRUE);
		CTwinVector tvCenVert;
		if(tvArrCenterVert.GetSize() > 0)
			tvCenVert	= tvArrCenterVert.GetAt(0);

		if(dArrSttOrg.GetSize() > 0)// == dArrEndOrg.GetSize())
		{
			static BOOL bLeftDeleteNextRebar	= TRUE;
			static BOOL bDeleteNextRebar		= FALSE;
			//		static long nIdxDeleteNextRebar		= 0;
			static long nIdxDeleteNextRebarRC	= 0;
			// 모든 철근이 필요한건 아니지만, 
			// 헌치 철근의 경우 경사진부분과 수평부분의 철근이 실제 1개이면서 2개나 3개로 나눠져서 보관된다.
			// 따라서 철근집계시 개수파악에 문제가 있기 때문에 
			// 같은 철근임을 알려주는 인덱스를 달아주자.
			// m_sInfoVer에 달아줌.
			long nIdx	= 0;	


			// 사보강배치(절반)인 경우 직철근의 범위에 드는지 검사하기 위함. /////
			// 1. 직철근을 뻣어서 시점에 교차되는 경우
			//   - 왼쪽에 포함되는지 오른쪽에 포함되는지 판단
			//   - 포함되는 좌우측에 교차점을 찾아서 교차점과 종점과의 거리가 dLenLeft/2보다 작은 경우 철근생성
			// 2. 직철근을 뻣어서 종점에 교차되는 경우
			//   - 위의 경우와 반대로 체크
			CDPoint xyMatch(0, 0);
			double dLenLefft	= ~(tvStt.m_v2 - tvEnd.m_v2);
			double dLenRight	= ~(tvStt.m_v1 - tvEnd.m_v1);
			//////////////////////////////////////////////////////////////////////
			

//			double dOffsetOrg	= 0;	// 직철근 및 선형방향 철근배치용 거리
			double dOffsetAng	= 0;	// 사철근 배치용 거리
			long nSizeArr		= dArrSttOrg.GetSize();
			double dDistCen		= bVertDir ? 0 : GetDistMidOfSlab(m_dStationBridgeStt-m_dWS, TRUE, FALSE);
			// 사보강 배치시 사방향 철근은 직방향 철근 간격보다 적을 수 잇다.
			BOOL bSttAngForVert	= TRUE;
			double dMid	= 0;
			static long nIdxDeleteNextRebar		= 0;
			dMid	= GetMidCrossSection(FALSE) + dDistDiff;
			long i = 0; for(i = 0; i < nSizeArr; i++)
			{
				double dOffsetOrg	= 0;	// 직철근 및 선형방향 철근배치용 거리
				dOffsetOrg		= dArrSttOrg.GetAt(i);
				if(dArrSttAng.GetSize() > i)
				{
					bSttAngForVert	= TRUE;
					dOffsetAng		= dArrSttAng.GetAt(i);
				}
				else
					bSttAngForVert	= FALSE;

				
				dOffsetOrg		+= dDistDiff;
				dOffsetAng		+= dDistDiff;

				dStaStt			= pLineBase->GetStationByScInLine(dStaSttTmp, dOffsetOrg, ToDPointFrDegree(dAngSttTmp));
				dStaEnd			= pLineBase->GetStationByScInLine(dStaEndTmp, dOffsetOrg, ToDPointFrDegree(dAngEndTmp));
				dStaSttSolid	= pLineBase->GetStationByScInLine(dStaSttSolidTmp, dOffsetOrg, ToDPointFrDegree(dAngSttTmp));
				dStaEndSolid	= pLineBase->GetStationByScInLine(dStaEndSolidTmp, dOffsetOrg, ToDPointFrDegree(dAngEndTmp));

				// Hidden은 주철근의 앞에 생기는지 뒤에 생기는지 판단해서 
				// dAngSttTmp나 dAngEndTmp을 통일해서 사용함
				if(!Compare(dStaSttHiddenTmp, dStaEndHiddenTmp, "="))
				{
					BOOL bStt	= (dStaSttHiddenTmp + dStaEndHiddenTmp)/2 < (dStaSttSolidTmp + dStaEndSolidTmp)/2;
					dStaSttHidden	= pLineBase->GetStationByScInLine(dStaSttHiddenTmp, dOffsetOrg, ToDPointFrDegree(bStt ? dAngSttTmp : dAngEndTmp));
					dStaEndHidden	= pLineBase->GetStationByScInLine(dStaEndHiddenTmp, dOffsetOrg, ToDPointFrDegree(bStt ? dAngSttTmp : dAngEndTmp));
				}
				// Hidden은 주철근의 앞에 생기는지 뒤에 생기는지 판단해서 
				// dAngSttTmp나 dAngEndTmp을 통일해서 사용함
				if(!Compare(dStaSttHiddenTmp2, dStaEndHiddenTmp2, "="))
				{
					BOOL bStt	= (dStaSttHiddenTmp2 + dStaEndHiddenTmp2)/2 < (dStaSttSolidTmp + dStaEndSolidTmp)/2;
					dStaSttHidden2	= pLineBase->GetStationByScInLine(dStaSttHiddenTmp2, dOffsetOrg, ToDPointFrDegree(bStt ? dAngSttTmp : dAngEndTmp));
					dStaEndHidden2	= pLineBase->GetStationByScInLine(dStaEndHiddenTmp2, dOffsetOrg, ToDPointFrDegree(bStt ? dAngSttTmp : dAngEndTmp));
				}
				if(!Compare(dStaSttParalOfHunchTmp, dStaEndParalOfHunchTmp, "="))
				{
					dStaSttParalOfHunch	= pLineBase->GetStationByScInLine(dStaSttParalOfHunchTmp, dOffsetOrg, ToDPointFrDegree(dAngSttTmp));
					dStaEndParalOfHunch	= pLineBase->GetStationByScInLine(dStaEndParalOfHunchTmp, dOffsetOrg, ToDPointFrDegree(dAngEndTmp));
				}

				// 1. 직방향 철근
				// 브라켓이면 무조건 직방향으로 인정
				// dDistMid	0에서 슬래브 중심까지의 거리
				double dDistRealOrg	= dArrSttOrg.GetAt(i);
				double dDistRealAng	= dArrSttAng.GetSize() > i ? dArrSttAng.GetAt(i) : 0;
				dDistRealOrg	-= dDistMid;
				dDistRealAng	-= dDistMid;

				// long nDrawLeft에 따라서 필요한 경우에만 진행
				BOOL bDebugging	= FALSE;
				long drawLeft	= dOffsetOrg < dDistCen ? -1 : 1;
				if(drawLeft == nDrawLeft || nDrawLeft == 0 || bVertDir)
				{
					tv.m_sInfoHor.Format("%f", dOffsetOrg);
					tv.m_v1.x	= dStaStt;
					tv.m_v2.x	= dStaEnd;
					tv.m_v2.z	= drawLeft;
					if(bDebugging)
					{
						tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaStt, dOffsetOrg, ToDPointFrDegree(dAngStt));
						tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEnd, dOffsetOrg, ToDPointFrDegree(dAngEnd));
					}

					if(nTypePlacing == 0)
					{
						tv.m_v1.z	= 6;
						tv.m_v1.y	= dOffsetOrg;
						if(bDebugging)
						{
							tv.m_v1.z	= 4;
							tv.m_v2.z	= dOffsetOrg;
						}

						// 그리기 위한 좌표라면 점선부와 실선부를 나눠야 됨
						if(bForDrawing && dLenRound > 0)
						{
							// 실선부 다시 구함
							tv.m_v1.x	= dStaSttSolid;
							tv.m_v2.x	= dStaEndSolid;
							tv.m_v1.z	= 6;
							tv.m_v1.y	= dOffsetOrg;
							if(bDebugging)
							{
								tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaSttSolid, dOffsetOrg, ToDPointFrDegree(dAngStt));
								tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEndSolid, dOffsetOrg, ToDPointFrDegree(dAngEnd));
								tv.m_v1.z	= 4;
								tv.m_v2.z	= dOffsetOrg;
							}
							tv.m_sInfo	= "SOLID";

							tvArr.Add(tv);

							// 점선부 구함
							if(!Compare(dStaSttHidden, dStaEndHidden, "="))
							{
								tv.m_v1.x	= dStaSttHidden;
								tv.m_v2.x	= dStaEndHidden;
								tv.m_v1.z	= 6;
								tv.m_v1.y	= dOffsetOrg;
								if(bDebugging)
								{
									tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaSttHidden, dOffsetOrg, ToDPointFrDegree(dAngStt));
									tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEndHidden, dOffsetOrg, ToDPointFrDegree(dAngEnd));
									tv.m_v1.z	= 4;
									tv.m_v2.z	= dOffsetOrg;
								}
								tv.m_sInfo	= "HIDDEN";
								tvArrHiddenOrgTmp.Add(tv);
							}

							// 점선부2 구함
							if(!Compare(dStaSttHidden2, dStaEndHidden2, "="))
							{
								tv.m_v1.x	= dStaSttHidden2;
								tv.m_v2.x	= dStaEndHidden2;
								tv.m_v1.z	= 6;
								tv.m_v1.y	= dOffsetOrg;
								if(bDebugging)
								{
									tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaSttHidden2, dOffsetOrg, ToDPointFrDegree(dAngStt));
									tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEndHidden2, dOffsetOrg, ToDPointFrDegree(dAngEnd));
									tv.m_v1.z	= 4;
									tv.m_v2.z	= dOffsetOrg;
								}
								tv.m_sInfo	= "HIDDEN";
								tvArrHiddenOrgTmp.Add(tv);
							}

							
						}
						// 그리기 위한 좌표이면서 헌치용이라면 점선부와 실선부를 나눠야 됨.
						else if(bForDrawing && bHunch)
						{
//							long nIdx	= 0;	
							tv.m_sInfoVer.Format("%d", nIdx++);
							if(Compare(dStaSttParalOfHunch, dStaEndParalOfHunch, "="))
							{
								// 점선부 전체
								tv.m_v1.x	= dStaStt;
								tv.m_v2.x	= dStaEnd;
								tv.m_v1.z	= 6;
								tv.m_v1.y	= dOffsetOrg;
								if(bDebugging)
								{
									tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaStt, dOffsetOrg, ToDPointFrDegree(dAngStt));
									tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEnd, dOffsetOrg, ToDPointFrDegree(dAngEnd));
									tv.m_v1.z	= 4;
									tv.m_v2.z	= dOffsetOrg;
								}
								tv.m_sInfo	= "HIDDEN";
								tvArr.Add(tv);
							}
							else
							{
								// 점선부 첫번째 
								tv.m_v1.x	= dStaStt;
								tv.m_v2.x	= dStaSttParalOfHunch;
								tv.m_v1.z	= 6;
								tv.m_v1.y	= dOffsetOrg;
								if(bDebugging)
								{
									tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaStt, dOffsetOrg, ToDPointFrDegree(dAngStt));
									tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaSttParalOfHunch, dOffsetOrg, ToDPointFrDegree(dAngEnd));
									tv.m_v1.z	= 4;
									tv.m_v2.z	= dOffsetOrg;
								}
								tv.m_sInfo	= "HIDDEN";
								tvArr.Add(tv);

								// 중앙 실선부
								tv.m_v1.x	= dStaSttParalOfHunch;
								tv.m_v2.x	= dStaEndParalOfHunch;
								tv.m_v1.z	= 6;
								tv.m_v1.y	= dOffsetOrg;
								if(bDebugging)
								{
									tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaSttParalOfHunch, dOffsetOrg, ToDPointFrDegree(dAngStt));
									tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEndParalOfHunch, dOffsetOrg, ToDPointFrDegree(dAngEnd));
									tv.m_v1.z	= 4;
									tv.m_v2.z	= dOffsetOrg;
								}
								tv.m_sInfo	= "SOLID";
								tvArr.Add(tv);

								// 점선부 첫번째 
								tv.m_v1.x	= dStaEndParalOfHunch;
								tv.m_v2.x	= dStaEnd;
								tv.m_v1.z	= 6;
								tv.m_v1.y	= dOffsetOrg;
								if(bDebugging)
								{
									tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaEndParalOfHunch, dOffsetOrg, ToDPointFrDegree(dAngStt));
									tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEnd, dOffsetOrg, ToDPointFrDegree(dAngEnd));
									tv.m_v1.z	= 4;
									tv.m_v2.z	= dOffsetOrg;
								}
								tv.m_sInfo	= "HIDDEN";
								tvArr.Add(tv);
							}
						}
						else
						{
							tv.m_sInfo	= "SOLID";
							tvArr.Add(tv);
						}

						// 이음 구함
						if(bJoint)
						{
							dStaStt	= pLineBase->GetStationByScInLine(dStaEndTmp-dLenJoint, dOffsetOrg+m_dGapJoint, ToDPointFrDegree(dAngSttTmp));
							dStaEnd	= pLineBase->GetStationByScInLine(dStaEndTmp, dOffsetOrg+m_dGapJoint, ToDPointFrDegree(dAngEndTmp));

							tv.m_v1.x	= dStaEnd-dLenJoint;
							tv.m_v2.x	= dStaEnd;
							tv.m_v1.z	= 6;
							tv.m_v1.y	= dOffsetOrg+m_dGapJoint;
							if(bDebugging)
							{
								tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaEnd-dLenJoint, (dOffsetOrg+m_dGapJoint), ToDPointFrDegree(dAngStt));
								tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEnd, (dOffsetOrg+m_dGapJoint), ToDPointFrDegree(dAngEnd));
								tv.m_v1.z	= 4;
								tv.m_v2.z	= (dOffsetOrg+m_dGapJoint);
							}
							tv.m_sInfo	= "SOLID";

							tvArrJoint.Add(tv);
						}
					}
					else if(nTypePlacing == 1 || nTypePlacing == 2)	// 사보강 배치
					{
						tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaStt, dOffsetOrg, ToDPointFrDegree(dAngStt));
						tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEnd, dOffsetOrg, ToDPointFrDegree(dAngEnd));
						tv.m_v1.z	= 0;
						tv.m_v2.z	= drawLeft;


						
						// 여기서 m_dDistLeftDirPlacing, m_dDistRightDirPlacing는 직방향 철근에 대해서만 적용
						// 단 사방향 철근은 최대 길이보다 무조건 작게 구한 dDistLeftAngleRebar, dDistRightAngleRebar로 체크함.(휴 복잡다.ㅠㅠ)
						BOOL bOKAll	= (dDistRealOrg > (dDistLeftMaxBigest+m_dDistLeftDirPlacing) && dDistRealOrg < (dDistRightMaxBigest-m_dDistRightDirPlacing)) || bSttPRF || bEndPRF;
						BOOL bOKHalf	= bSttPRF || bEndPRF;
						if(!bOKHalf)
						{
							// 시종점에 한쪽에만 걸리면 일차 통과
							// 모두 걸리면 무조건 통과
							CDPoint xyMatchStt(0, 0), xyMatchEnd(0, 0);
							BOOL bMatchStt	= GetXyMatchSegAndLine(tvStt.m_v1, tvStt.m_v2, tv.m_v1, tv.GetXyDir(), xyMatchStt);
							BOOL bMatchEnd	= GetXyMatchSegAndLine(tvEnd.m_v1, tvEnd.m_v2, tv.m_v1, tv.GetXyDir(), xyMatchEnd);
							if(bMatchStt != bMatchEnd)
							{
								// 좌우측 판단
								BOOL bLeft	= GetDirPointByLine(tv.m_v1, tvCenVert.m_v1, tvCenVert.m_v2);
								CDPoint xyMatchLeft(0, 0), xyMatchRight(0, 0);
								
								GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), tvStt.m_v2, (tvEnd.m_v2 - tvStt.m_v2).Unit(), xyMatchLeft);
								GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), tvStt.m_v1, (tvEnd.m_v1 - tvStt.m_v1).Unit(), xyMatchRight);

								// 
								if(bMatchStt)
								{
									if(bLeft && ~(tvEnd.m_v2 - xyMatchLeft) <= dLenLefft/2)
										bOKHalf	= TRUE;
									else if(!bLeft && ~(tvStt.m_v1 - xyMatchRight) >= dLenRight/2)
										bOKHalf	= TRUE;
								}
								else
								{
									if(bLeft && ~(tvStt.m_v2 - xyMatchLeft) <= dLenLefft/2)
										bOKHalf	= TRUE;
									else if(!bLeft && ~(tvEnd.m_v1 - xyMatchRight) >= dLenRight/2)
										bOKHalf	= TRUE;
								}
							}
							else if(bMatchStt && bMatchEnd)
								bOKHalf	= TRUE;
						}

						if(nTypePlacing == 1 && bOKAll || nTypePlacing == 2 && bOKHalf)
						{
							// 브라켓의 경우 좌우측라인에 교차되지 않을때만 추가
							// 교차된다면 그냥 제낌.
							if(bSttPRF || bEndPRF)
							{

								rb.GetXyMatchTvArrAndSeg(tvArrLeft[iLEFT], tv.m_v1, tv.m_v2, xyArrMatch[iLEFT], FALSE);
								rb.GetXyMatchTvArrAndSeg(tvArrLeft[iRIGHT], tv.m_v1, tv.m_v2, xyArrMatch[iRIGHT], FALSE);
								tv.m_v1.z	= 0;
								if(xyArrMatch[iLEFT].GetSize() == 0 && xyArrMatch[iRIGHT].GetSize() == 0)
									tvArr.Add(tv);
							}
							// 헌치부 그릴때는 점선부 실선부 나눠줌
							else if(bForDrawing && bHunch)
							{
								tv.m_sInfoVer.Format("%d", nIdx++);
								if(Compare(dStaSttParalOfHunch, dStaEndParalOfHunch, "="))
								{
									// 실선부 전체
									tv.m_v1		= pLineBase->GetXyLineByLengthAndAngle(dStaStt, dOffsetOrg, ToDPointFrDegree(dAngStt));
									tv.m_v2		= pLineBase->GetXyLineByLengthAndAngle(dStaEnd, dOffsetOrg, ToDPointFrDegree(dAngEnd));
									tv.m_v1.z	= 0;
									tv.m_sInfo	= "HIDDEN";
									tvArr.Add(tv);							
								}
								else
								{
									// 점선부 앞
									tv.m_v1		= pLineBase->GetXyLineByLengthAndAngle(dStaStt, dOffsetOrg, ToDPointFrDegree(dAngStt));
									tv.m_v2		= pLineBase->GetXyLineByLengthAndAngle(dStaSttParalOfHunch, dOffsetOrg, ToDPointFrDegree(dAngEnd));
									tv.m_v1.z	= 0;
									tv.m_sInfo	= "HIDDEN";
									tvArr.Add(tv);							

									// 실선부 중앙
									tv.m_v1		= pLineBase->GetXyLineByLengthAndAngle(dStaSttParalOfHunch, dOffsetOrg, ToDPointFrDegree(dAngStt));
									tv.m_v2		= pLineBase->GetXyLineByLengthAndAngle(dStaEndParalOfHunch, dOffsetOrg, ToDPointFrDegree(dAngEnd));
									tv.m_v1.z	= 0;
									tv.m_sInfo	= "SOLID";
									tvArr.Add(tv);							

									// 실선부 중앙
									tv.m_v1		= pLineBase->GetXyLineByLengthAndAngle(dStaEndParalOfHunch, dOffsetOrg, ToDPointFrDegree(dAngStt));
									tv.m_v2		= pLineBase->GetXyLineByLengthAndAngle(dStaEnd, dOffsetOrg, ToDPointFrDegree(dAngEnd));
									tv.m_v1.z	= 0;
									tv.m_sInfo	= "HIDDEN";
									tvArr.Add(tv);							
								}
							}
							else	// 사보강배치 슬래브 주철근 그리는 부분
							{
								// 사보강 배치에다가 마지막 철근일 경우
								// 종점 각도가 시점 각도와 달라서 남거나 모자라는 경우가 생길 수 있다.
								// 이 경우를 대비해서 마지막 철근일 때는 종점에 교차점을 찾아서 철근길이에 변화를 준다.(에이 번거로워ㅡㅡ;)
								if(rc == nSize-1)
								{
									double dDiffSta	= Compare(dDiffRad, 1.0, "=") ? 0 : dOffsetOrg / tan(dDiffRad);
									dStaEndSolid -= dDiffSta;
									dStaSttHidden -= dDiffSta;
									dStaEndHidden -= dDiffSta;
									dStaSttHidden2 -= dDiffSta;
									dStaEndHidden2 -= dDiffSta;
								}

								// 실선부 다시 구함
								if(dStaEndSolid > dStaSttSolid)
								{
									tv.m_v1		= pLineBase->GetXyLineByLengthAndAngle(dStaSttSolid, dOffsetOrg, ToDPointFrDegree(dAngStt));
									tv.m_v2		= pLineBase->GetXyLineByLengthAndAngle(dStaEndSolid, dOffsetOrg, ToDPointFrDegree(dAngEnd));
									tv.m_v1.z	= 0;
									tv.m_sInfo	= "SOLID";

									// 철근을 뻗어서 시종점 피복에 교차 되어야 존재(전체일때만)
									CDPoint xyMatch(0, 0);
									BOOL bVert	= TRUE;
									if(m_nTypePlacingMainRebar_UpperSlab == 1)
									{
										if(!GetXyMatchSegAndLine(tvSttRebar.m_v1, tvSttRebar.m_v2, tv.m_v1, tv.GetXyDir(), xyMatch))
											bVert	= FALSE;
										if(!GetXyMatchSegAndLine(tvEndRebar.m_v1, tvEndRebar.m_v2, tv.m_v1, tv.GetXyDir(), xyMatch))
											bVert	= FALSE;
									}
	
									if(bVert)
									{

										tvArr.Add(tv);
										tvTmp	= tv;

										if(!Compare(dStaSttHidden, dStaEndHidden, "="))
										{
											if(dStaSttSolid > dStaSttHidden) tvTmp.m_v2	= tv.m_v2;
											else tvTmp.m_v1	= tv.m_v1;
										}

										// 이음구함
										BOOL bCutJoint	= FALSE;
										if(bJoint)
										{
											double dStaEndJo	= pLineBase->GetStationByScInLine(dStaEndTmp, dOffsetOrg+m_dGapJoint, ToDPointFrDegree(dAngEndTmp));

											tv.m_v1		= pLineBase->GetXyLineByLengthAndAngle(dStaEndJo-dLenJoint, (dOffsetOrg+m_dGapJoint), ToDPointFrDegree(dAngStt));
											tv.m_v2		= pLineBase->GetXyLineByLengthAndAngle(dStaEndJo, (dOffsetOrg+m_dGapJoint), ToDPointFrDegree(dAngEnd));

											// 사보강 배치(절반)에서 이음이 좌우측에 걸리면 존재 여부를 판단함 //////////
											if(m_nTypePlacingMainRebar_UpperSlab == 2)
											{
												CDPointArray xyArrMatch;
												rb.GetXyMatchTvArrAndTv(tvArrPlaneRebar, tv, xyArrMatch, TRUE);
												if(xyArrMatch.GetSize() > 0)
													bCutJoint	= TRUE;
											}

											tv.m_v1.z	= 0;
											tv.m_sInfo	= "SOLID";
											if(!bCutJoint)
												tvArrJoint .Add(tv);
										}

										// 점선부 구함
										if(!Compare(dStaSttHidden, dStaEndHidden, "="))
										{
											tv.m_v1		= pLineBase->GetXyLineByLengthAndAngle(dStaSttHidden, dOffsetOrg, ToDPointFrDegree(dAngStt));
											tv.m_v2		= pLineBase->GetXyLineByLengthAndAngle(dStaEndHidden, dOffsetOrg, ToDPointFrDegree(dAngEnd));
											tv.m_v1.z	= 0;
											tv.m_sInfo	= "HIDDEN";
											tvArrHiddenOrgTmp.Add(tv);

											if(dStaSttSolid > dStaSttHidden) tvTmp.m_v1	= tv.m_v1;
											else tvTmp.m_v2	= tv.m_v2;
										}
										if(!Compare(dStaSttHidden2, dStaEndHidden2, "="))
										{
											tv.m_v1		= pLineBase->GetXyLineByLengthAndAngle(dStaSttHidden2, dOffsetOrg, ToDPointFrDegree(dAngStt));
											tv.m_v2		= pLineBase->GetXyLineByLengthAndAngle(dStaEndHidden2, dOffsetOrg, ToDPointFrDegree(dAngEnd));
											tv.m_v1.z	= 0;
											tv.m_sInfo	= "HIDDEN";
											tvArrHiddenOrgTmp.Add(tv);

											tvTmp.m_v2	= tv.m_v2;
										}

										// tvTmp가 좌우측에 교차되는 선이라면 직방향 철근 변화구간에 있는 넘이다.
										// 그럼 tvArr와 tvArrHiddenOrgTmp에서 제거하고 tvArrAngLeftHalf나 tvArrAngRightHalf에 추가해 주자.
										// 대신 나중에 tvArr와 tvArrHiddenOrgTmp, tvArrAngLeftHalf, tvArrAngRightHalf는 외곽을 기준으로 걸러낸 필요가 없다.
										if(m_nTypePlacingMainRebar_UpperSlab == 2)
										{
//											static long nIdxDeleteNextRebarRC	= 0;

											if(bDeleteNextRebar && rc > nIdxDeleteNextRebarRC)
												bDeleteNextRebar	= FALSE;

											CTwinVectorArray tvArrTmp;
											tvArrTmp.Add(tvTmp);
											rb.GetTvByCrossTvArrArea(tvArrTmp, tvArrPlane, TRUE, TRUE, FALSE);

											BOOL bCross	= tvArrTmp.GetSize() == 0;
											if(!bCross)
												bCross	= !Compare(tvArrTmp.GetAt(0).GetLength(), tvTmp.GetLength(), "=");
											
											if(bCross || bCutJoint)
											{
												if(tvArr.GetSize() > 0)
													tvArr.RemoveAt(tvArr.GetSize()-1);
												if(tvArrHiddenOrgTmp.GetSize() > 0)
													tvArrHiddenOrgTmp.RemoveAt(tvArrHiddenOrgTmp.GetSize()-1);
												if(tvArrTmp.GetSize() > 0)
												{
													BOOL bDelete	= FALSE;
													if(bDeleteNextRebar && rc == nIdxDeleteNextRebarRC)
													{
														if(bLeftDeleteNextRebar)
														{
															bDelete	= nIdxDeleteNextRebar >= i;
														}
														else
														{
															bDelete = nIdxDeleteNextRebar <= i;
														}
													}

													// 이음이 걸리는 철근 중 슬래브 밖에서 시작하는 철근은 완전히 제거
													// 단, 슬래브 안에서 시작하는 철근은 다음 철근이 제거 된다.
													if(bCutJoint)
													{
														if(rb.CheckXyByTvArrayArea(tvTmp.m_v1, tvArrPlaneRebar, FALSE))
														{
															bDeleteNextRebar	= FALSE;
															bDelete				= TRUE;
														}
														else
														{
															// 다음 철근이 이 시점에서 제거 되야 됨을 미리 알려줌.
															if(!bDeleteNextRebar)
															{
																bLeftDeleteNextRebar	= dOffsetOrg < dDistCen;	
																bDeleteNextRebar		= TRUE;
																nIdxDeleteNextRebar		= i;
																nIdxDeleteNextRebarRC	= rc+1;
															}
														}
													}

													if(!bDelete)
													{
														tvTmp	= tvArrTmp.GetAt(0);
														// 두개로 나눠진 경우 가각이 아닌 부분에 포함된 철근을 선택한다.
														BOOL bRemoveRebar	= FALSE;
														if(m_bIsExp)
														{
															double dSta1(0), dSta2(0);
															CLineInfo *pLineOrg	= GetLineBase();
															pLineOrg->GetStationMatchVerticalByXy(tvTmp.m_v1, dSta1);
															pLineOrg->GetStationMatchVerticalByXy(tvTmp.m_v2, dSta2);
															long nLeft	= dOffsetOrg < dDistCen ? -1 : 1;
															double dWid1	= GetWidthSlabAct(dSta1, CDPoint(0, 1), nLeft, FALSE, FALSE, FALSE);
															double dWid2	= GetWidthSlabAct(dSta2, CDPoint(0, 1), nLeft, FALSE, FALSE, FALSE);
															
															double dDist1	= fabs(pLineOrg->GetDisMatchVerticalByXy(tvTmp.m_v1));
															double dDist2	= fabs(pLineOrg->GetDisMatchVerticalByXy(tvTmp.m_v2));

															if(dDist1 > dWid1 || dDist2 > dWid2)
															{
																if(tvArrTmp.GetSize() == 2)
																	tvTmp	= tvArrTmp.GetAt(1);
																else
																	bRemoveRebar	= TRUE;
															}
														}
														else
														{
															// 이전에 이음이 있었는데, 이음보다 지금 철근 길이가 작으면
															// 이 철근은 사라져야 하는 철근임..
															if(bJointPrev && tvArrTmp.GetLength() <= dLenJointPrev)
															{
																bRemoveRebar	= TRUE;
															}
														}

														if(!bRemoveRebar)
														{
															if(dOffsetOrg < dDistCen)
															{
																tvArrAngLeftHalf.Add(tvTmp);
															}
															else
															{
																tvArrAngRightHalf.Add(tvTmp);
															}
														}
													}
												}
											}
										} // if(m_nTypePlacingMainRebar_UpperSlab == 2)
									}
								}
							}
						}					
					}

					// 2. 사방향 철근(하부슬래브)
					if(bSttAngForVert && (dDistRealAng <= (dDistLeft+dDistLeftAngleRebar) || dDistRealAng >= (dDistRight-dDistRightAngleRebar)) && !bSttPRF && !bEndPRF)
					{
						// 사방향 철근은 최대길이가 아니라 실제 길이 내에서만 배근한다.
						if((dDistRealAng > dDistLeft && dDistRealAng < dDistRight))
						{
							// 시종점 교차 둘중에 하나라도 안되는 경우 진행방향 철근
							// 실선부
							CDPoint xyDirOrg	= dOffsetAng < dMid ? xyDirLeft : xyDirRight;
							double dStaOrg		= GetStationByTarget(BRIDGE_OFF_STT_SLAB, 0, TRUE);		
							CDPoint vAngOrg		= GetAngleByTarget(BRIDGE_OFF_STT_SLAB, 0);
							CDPoint xyOrg		= GetLineBase()->GetXyLineByLengthAndAngle(dStaOrg, dOffsetAng - dDistDiff, vAngOrg);


							if(bVertDir == FALSE)
							{
								// (ARCBRIDGE-2661	) 선형방향 배치에 사보강이 들어갈때는 사보강 철근 Offset이 달라서 철근의 Station을 다시 구해줘야한다.
								dStaStt			= pLineBase->GetStationByScInLine(dStaSttTmp, dOffsetAng, ToDPointFrDegree(dAngSttTmp));
								dStaEnd			= pLineBase->GetStationByScInLine(dStaEndTmp, dOffsetAng, ToDPointFrDegree(dAngEndTmp));
								dStaSttSolid	= pLineBase->GetStationByScInLine(dStaSttSolidTmp, dOffsetAng, ToDPointFrDegree(dAngSttTmp));
								dStaEndSolid	= pLineBase->GetStationByScInLine(dStaEndSolidTmp, dOffsetAng, ToDPointFrDegree(dAngEndTmp));
								if(!Compare(dStaSttHiddenTmp, dStaEndHiddenTmp, "="))
								{
									BOOL bStt	= (dStaSttHiddenTmp + dStaEndHiddenTmp)/2 < (dStaSttSolidTmp + dStaEndSolidTmp)/2;
									dStaSttHidden	= pLineBase->GetStationByScInLine(dStaSttHiddenTmp, dOffsetAng, ToDPointFrDegree(bStt ? dAngSttTmp : dAngEndTmp));
									dStaEndHidden	= pLineBase->GetStationByScInLine(dStaEndHiddenTmp, dOffsetAng, ToDPointFrDegree(bStt ? dAngSttTmp : dAngEndTmp));
								}
								// Hidden은 주철근의 앞에 생기는지 뒤에 생기는지 판단해서 
								// dAngSttTmp나 dAngEndTmp을 통일해서 사용함
								if(!Compare(dStaSttHiddenTmp2, dStaEndHiddenTmp2, "="))
								{
									BOOL bStt	= (dStaSttHiddenTmp2 + dStaEndHiddenTmp2)/2 < (dStaSttSolidTmp + dStaEndSolidTmp)/2;
									dStaSttHidden2	= pLineBase->GetStationByScInLine(dStaSttHiddenTmp2, dOffsetAng, ToDPointFrDegree(bStt ? dAngSttTmp : dAngEndTmp));
									dStaEndHidden2	= pLineBase->GetStationByScInLine(dStaEndHiddenTmp2, dOffsetAng, ToDPointFrDegree(bStt ? dAngSttTmp : dAngEndTmp));
								}
							}


							if(bForDrawing && bHunch)
							{
								tv.m_sInfoVer.Format("%d", nIdx++);
								if(Compare(dStaSttParalOfHunch, dStaEndParalOfHunch, "="))
								{
									// 점선부 전체
									tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaStt, dOffsetAng, ToDPointFrDegree(dAngStt));
									tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEnd, dOffsetAng, ToDPointFrDegree(dAngEnd));
									GetXyMatchLineAndLine(tv.m_v1, GetAngleAzimuthJijum(0), xyOrg, xyDirOrg, tv.m_v1);
									GetXyMatchLineAndLine(tv.m_v2, GetAngleAzimuthJijum(m_nQtyJigan), xyOrg, xyDirOrg, tv.m_v2);

									double dSta1(0), dSta2(0);
									BOOL bLeft	= dOffsetAng <= dMid;

									// 선형에 꼭 맞도록 변경 ///////////////////////////////////////
									double dDist	= pLineLeft->GetDisMatchVerticalByXy(xyOrg);
									// 										if(bLeft)
									// 										{
									// 											pLineLeft->GetStationMatchVerticalByXy(tv.m_v1, dSta1);
									// 											pLineLeft->GetStationMatchVerticalByXy(tv.m_v2, dSta2);
									// 										}
									// 										else
									// 										{
									pLineLeft->GetStationMatchVerticalByXy(tv.m_v1, dSta1);
									pLineLeft->GetStationMatchVerticalByXy(tv.m_v2, dSta2);
									// 										}

									tv.m_v1	= pLineLeft->GetXyLineDis(dSta1, dDist);
									tv.m_v2	= pLineLeft->GetXyLineDis(dSta2, dDist);
									// 선형에 꼭 맞도록 변경 ///////////////////////////////////////
									tv.m_v1.z	= 0;
									tv.m_sInfo	= "HIDDEN";

									// 좌측 사방향 철근인지?
									if(bLeft)//dDistLeftAngleRebar) 
									{
										tvArrAngLeft.Add(tv);
									}
									// 우측 사방향 철근인지
									else
									{
										tvArrAngRight.Add(tv);
									}
								}
								else
								{
									// 점선부 앞
									tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaStt, dOffsetAng, ToDPointFrDegree(dAngStt));
									tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaSttParalOfHunch, dOffsetAng, ToDPointFrDegree(dAngEnd));
									GetXyMatchLineAndLine(tv.m_v1, GetAngleAzimuthJijum(0), xyOrg, xyDirOrg, tv.m_v1);
									GetXyMatchLineAndLine(tv.m_v2, GetAngleAzimuthJijum(m_nQtyJigan), xyOrg, xyDirOrg, tv.m_v2);
									tv.m_v1.z	= 0;
									tv.m_sInfo	= "HIDDEN";

									// 좌측 사방향 철근인지?
									if(dOffsetAng <= dMid)//dDistLeftAngleRebar) 
										tvArrAngLeft.Add(tv);
									// 우측 사방향 철근인지
									else
										tvArrAngRight.Add(tv);

									// 실선부 중앙
									tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaSttParalOfHunch, dOffsetAng, ToDPointFrDegree(dAngStt));
									tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEndParalOfHunch, dOffsetAng, ToDPointFrDegree(dAngEnd));
									GetXyMatchLineAndLine(tv.m_v1, GetAngleAzimuthJijum(0), xyOrg, xyDirOrg, tv.m_v1);
									GetXyMatchLineAndLine(tv.m_v2, GetAngleAzimuthJijum(m_nQtyJigan), xyOrg, xyDirOrg, tv.m_v2);
									tv.m_v1.z	= 0;
									tv.m_sInfo	= "SOLID";

									// 좌측 사방향 철근인지?
									if(dOffsetAng <= dMid)//dDistLeftAngleRebar) 
										tvArrAngLeft.Add(tv);
									// 우측 사방향 철근인지
									else
										tvArrAngRight.Add(tv);
									// 점선부 뒤
									tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaEndParalOfHunch, dOffsetAng, ToDPointFrDegree(dAngStt));
									tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEnd, dOffsetAng, ToDPointFrDegree(dAngEnd));
									GetXyMatchLineAndLine(tv.m_v1, GetAngleAzimuthJijum(0), xyOrg, xyDirOrg, tv.m_v1);
									GetXyMatchLineAndLine(tv.m_v2, GetAngleAzimuthJijum(m_nQtyJigan), xyOrg, xyDirOrg, tv.m_v2);
									tv.m_v1.z	= 0;
									tv.m_sInfo	= "HIDDEN";

									// 좌측 사방향 철근인지?
									if(dOffsetAng <= dMid)//dDistLeftAngleRebar) 
										tvArrAngLeft.Add(tv);
									// 우측 사방향 철근인지
									else
										tvArrAngRight.Add(tv);
								}								
							}
							else
							{
								// 직방향 철근에 포함되는 사방향 철근은 점선부가 없다.
								// 포함되는지 여부를 정확하게 체크하기 위해서는 사방향 철근의 시작과 끝의 직방향
								// 선형에 대한 dist를 구해야 됨.
								// 직철근도 CTC로 나누다 보면 정확히 dist에 안걸리므로, 체크시 CTC만큼 여유를 둠.
								CTwinVector tvTmp;
								tvTmp.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaStt, dOffsetAng, ToDPointFrDegree(dAngStt));
								tvTmp.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEnd, dOffsetAng, ToDPointFrDegree(dAngEnd));
								GetXyMatchLineAndLine(tvTmp.m_v1, GetAngleAzimuthJijum(0), xyOrg, xyDirOrg, tvTmp.m_v1);
								GetXyMatchLineAndLine(tvTmp.m_v2, GetAngleAzimuthJijum(m_nQtyJigan), xyOrg, xyDirOrg, tvTmp.m_v2);
								double dDistStt	= pLineBase->GetDisMatchVerticalByXy(tvTmp.m_v1);
								double dDistEnd	= pLineBase->GetDisMatchVerticalByXy(tvTmp.m_v2);
								double dCTC	= GetCtcRebarMain(TRUE);

								// 사보강 배치가 되어 있는 경우 직철근과 겹치면 선형방향 철근에서 첫번째와 마지막은 무조건 실선이어야 한다.
								BOOL bLeftTmp	= i == 0;
								BOOL bSttTmp	= rc == 0;

								BOOL bContiForce	= FALSE;
								if((i == 0 || i == nSizeArr) && (rc == 0 || rc == nSize-1))
								{
									bContiForce	= IsRebarMainOneLineUpperSlab(bLeftTmp, bSttTmp);
								}

								if(bContiForce
									|| (rc == 0 && dDistLeftRangeVertRebar+dCTC <= dDistStt && dDistRightRangeVertRebar+dCTC >= dDistStt)
									|| (rc == nSize-1 && dDistLeftRangeVertRebar+dCTC <= dDistEnd && dDistRightRangeVertRebar+dCTC >= dDistEnd))
								{
									dStaSttSolid	= dStaStt;
									dStaEndSolid	= dStaEnd;
									dStaSttHidden	= dStaStt;
									dStaEndHidden	= dStaStt;
									dStaSttHidden2	= dStaStt;
									dStaEndHidden2	= dStaStt;
								}

								tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaSttSolid, dOffsetAng, ToDPointFrDegree(dAngStt));
								tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEndSolid, dOffsetAng, ToDPointFrDegree(dAngEnd));
								GetXyMatchLineAndLine(tv.m_v1, GetAngleAzimuthJijum(0), xyOrg, xyDirOrg, tv.m_v1);
								GetXyMatchLineAndLine(tv.m_v2, GetAngleAzimuthJijum(rc == nSize-1 ? m_nQtyJigan : 0), xyOrg, xyDirOrg, tv.m_v2);

								// 사보강 배치에다가 마지막 철근일 경우
								// 종점 각도가 시점 각도와 달라서 남거나 모자라는 경우가 생길 수 있다.
								// 이 경우를 대비해서 마지막 철근일 때는 종점에 교차점을 찾아서 철근길이에 변화를 준다.(에이 번거로워ㅡㅡ;)
								CDPoint xyMatch(0,0);
								if(rc == nSize-1)
								{
									GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), xyEndLeft, tvEnd.GetXyDir(), xyMatch);

									double dDiffSta	= tv.GetLength() - ~(tv.m_v1 - xyMatch) + (dStaEndHidden-dStaSttHidden);
									dStaEndSolid -= dDiffSta;
									dStaSttHidden -= dDiffSta;
									dStaEndHidden -= dDiffSta;
									dStaSttHidden2 -= dDiffSta;
									dStaEndHidden2 -= dDiffSta;
									if(!Compare(dStaSttHidden, dStaEndHidden, "="))
										dStaEndSolid	= dStaSttHidden;

									tv.m_v2	= xyMatch + tv.GetXyDir(TRUE) * (dStaEndHidden-dStaSttHidden);
								}
								tv.m_v1.z	= 0;
								tv.m_sInfo	= "SOLID";

								// 좌측 사방향 철근인지?
								BOOL bLeft	= TRUE;
								if(dOffsetAng <= dMid)//dDistLeftAngleRebar) 
								{
									bLeft	= TRUE;
									tv	= ConvertFromVertialRebarToLineRebarAtSabogang(tv, ToDPointFrDegree(dAngStt), ToDPointFrDegree(dAngEnd), TRUE);
									tvArrAngLeft.Add(tv);
								}
								// 우측 사방향 철근인지
								else
								{
									bLeft	= FALSE;
									tv	= ConvertFromVertialRebarToLineRebarAtSabogang(tv, ToDPointFrDegree(dAngStt), ToDPointFrDegree(dAngEnd), FALSE);
									tvArrAngRight.Add(tv);
								}

								// 이음구함
								if(bJoint)
								{
									double dStaEndJo	= pLineBase->GetStationByScInLine(dStaEndTmp, dOffsetAng+m_dGapJoint, ToDPointFrDegree(dAngEndTmp));

									tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaEndJo-dLenJoint, (dOffsetAng+m_dGapJoint), ToDPointFrDegree(dAngStt));
									tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEndJo, (dOffsetAng+m_dGapJoint), ToDPointFrDegree(dAngEnd));
									GetXyMatchLineAndLine(tv.m_v1, GetAngleAzimuthJijum(0), (xyOrg+xyDirOrg.RotateInv90()*m_dGapJoint), xyDirOrg, tv.m_v1);
									GetXyMatchLineAndLine(tv.m_v2, GetAngleAzimuthJijum(0), (xyOrg+xyDirOrg.RotateInv90()*m_dGapJoint), xyDirOrg, tv.m_v2);
									tv.m_v1.z	= 0;
									tv.m_sInfo	= "SOLID";
									tv	= ConvertFromVertialRebarToLineRebarAtSabogang(tv, ToDPointFrDegree(dAngStt), ToDPointFrDegree(dAngEnd), bLeft);
									tv.m_sInfoHor	= bLeft ? "좌측이음" : "우측이음";

									//철근 사구간 이음 변경
									if(ComparePt(vAngStt, CDPoint(0,1), _T("="), 0.1) == FALSE)
									{
										double dLenOrg = tv.GetLength();
										double dLenExt  = dLenOrg * vAngStt.y;
										tv.m_v1 = tv.m_v1 + (tv.GetXyDir(TRUE) * (dLenExt - dLenOrg)/2);
										tv.m_v2 = tv.m_v2 + (tv.GetXyDir() * (dLenExt - dLenOrg)/2);										
									}

									tvArrJoint.Add(tv);
									tv.m_sInfoHor	= "";
								}

								// 점선부
								if(!Compare(dStaSttHidden, dStaEndHidden, "="))
								{
									if(rc == nSize - 1)	// 마지막일 경우 시종점 각도가 달라서 스테이션을 조정할 필요가 있다.
									{
										tv.m_v1	= xyMatch + xyDirOrg * (dStaSttHidden - dStaEndHidden);
										tv.m_v2	= xyMatch;
									}
									else
									{
										BOOL bSttAng	= dStaSttHidden < (dStaSttSolid+dStaEndSolid)/2;
										tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaSttHidden, dOffsetAng, ToDPointFrDegree(dAngStt));
										tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEndHidden, dOffsetAng, ToDPointFrDegree(dAngEnd));
										GetXyMatchLineAndLine(tv.m_v1, GetAngleAzimuthJijum(bSttAng ? 0 : m_nQtyJigan), xyOrg, xyDirOrg, tv.m_v1);
										GetXyMatchLineAndLine(tv.m_v2, GetAngleAzimuthJijum(bSttAng ? 0 : m_nQtyJigan), xyOrg, xyDirOrg, tv.m_v2);
									}
									tv.m_v1.z	= 0;
									tv.m_sInfo	= "HIDDEN";
									tv	= ConvertFromVertialRebarToLineRebarAtSabogang(tv, ToDPointFrDegree(dAngStt), ToDPointFrDegree(dAngEnd), bLeft);

									tv.m_sInfoHor	= bLeft ? "좌측점선" : "우측점선";
									if(dOffsetAng <= dMid)//dDistLeftAngleRebar) 
										tvArrHiddenAngLeftTmp.Add(tv);
									else
										tvArrHiddenAngRightTmp.Add(tv);
									tv.m_sInfoHor	= "";
								}

								if(!Compare(dStaSttHidden2, dStaEndHidden2, "="))
								{
									BOOL bSttAng	= dStaSttHidden2 < (dStaSttSolid+dStaEndSolid)/2;
									tv.m_v1	= pLineBase->GetXyLineByLengthAndAngle(dStaSttHidden2, dOffsetAng, ToDPointFrDegree(dAngStt));
									tv.m_v2	= pLineBase->GetXyLineByLengthAndAngle(dStaEndHidden2, dOffsetAng, ToDPointFrDegree(dAngEnd));
									GetXyMatchLineAndLine(tv.m_v1, GetAngleAzimuthJijum(bSttAng ? 0 : m_nQtyJigan), xyOrg, xyDirOrg, tv.m_v1);
									GetXyMatchLineAndLine(tv.m_v2, GetAngleAzimuthJijum(bSttAng ? 0 : m_nQtyJigan), xyOrg, xyDirOrg, tv.m_v2);
									tv.m_v1.z	= 0;
									tv.m_sInfo	= "HIDDEN";
									tv	= ConvertFromVertialRebarToLineRebarAtSabogang(tv, ToDPointFrDegree(dAngStt), ToDPointFrDegree(dAngEnd), bLeft);

									tv.m_sInfoHor	= bLeft ? "좌측점선" : "우측점선";
									if(dOffsetAng <= dMid)//dDistLeftAngleRebar) 
										tvArrHiddenAngLeftTmp.Add(tv);
									else
										tvArrHiddenAngRightTmp.Add(tv);
									tv.m_sInfoHor	= "";
								}
							}
						}
					}//사방향 철근
				}
			}
		}
	}

	tvArrHidden.AddFromTvArray(tvArrHiddenOrgTmp);
	tvArrHiddenLeft.AddFromTvArray(tvArrHiddenAngLeftTmp);
	tvArrHiddenRight.AddFromTvArray(tvArrHiddenAngRightTmp);


	if(nDrawLeft == 0 && nIdx != -1)
	{
		if(bHunch)
		{
			CTwinVectorArray *pTvArr	= new CTwinVectorArray;
			*pTvArr	= tvArr;
			m_tvArr_RebarMain_LowerPlaneHunch[nCycle].Add(pTvArr);	

			CTwinVectorArray *pTvArrAngLeft	= new CTwinVectorArray;
			*pTvArrAngLeft	= tvArrAngLeft;
			m_tvArrAngLeft_RebarMain_LowerPlaneHunch[nCycle].Add(pTvArrAngLeft);

			CTwinVectorArray *pTvArrAngRight	= new CTwinVectorArray;
			*pTvArrAngRight	= tvArrAngRight;
			m_tvArrAngRight_RebarMain_LowerPlaneHunch[nCycle].Add(pTvArrAngRight);

			CTwinVectorArray *pTvArrHidden	= new CTwinVectorArray;
			*pTvArrHidden	= tvArrHidden;
			m_tvArrHidden_RebarMain_LowerPlaneHunch[nCycle].Add(pTvArrHidden);

			CTwinVectorArray *pTvArrHiddenLeft	= new CTwinVectorArray;
			*pTvArrHiddenLeft	= tvArrHiddenLeft;
			m_tvArrHiddenLeft_RebarMain_LowerPlaneHunch[nCycle].Add(pTvArrHiddenLeft);

			CTwinVectorArray *pTvArrHiddenRight	= new CTwinVectorArray;
			*pTvArrHiddenRight	= tvArrHiddenRight;
			m_tvArrHiddenRight_RebarMain_LowerPlaneHunch[nCycle].Add(pTvArrHiddenRight);

			CTwinVectorArray *pTvArrAngLeftHalf	= new CTwinVectorArray;
			*pTvArrAngLeftHalf	= tvArrAngLeftHalf;
			m_tvArrAngLeftHalf_RebarMain_LowerPlaneHunch[nCycle].Add(pTvArrAngLeftHalf);

			CTwinVectorArray *pTvArrAngRightHalf	= new CTwinVectorArray;
			*pTvArrAngRightHalf	= tvArrAngRightHalf;
			m_tvArrAngRightHalf_RebarMain_LowerPlaneHunch[nCycle].Add(pTvArrAngRightHalf);
		}
		else if(bSttPRF)
		{
			m_tvArrSttPRF_RebarMain_LowerPlane.AddFromTvArray(tvArr);
		}
		else if(bEndPRF)
		{
			m_tvArrEndPRF_RebarMain_LowerPlane.AddFromTvArray(tvArr);
		}
		else
		{
			CTwinVectorArray *pTvArr	= new CTwinVectorArray;
			*pTvArr	= tvArr;
			m_tvArr_RebarMain_LowerPlane[nCycle][nDan][upper].Add(pTvArr);	

			CTwinVectorArray *pTvArrAngLeft	= new CTwinVectorArray;
			*pTvArrAngLeft	= tvArrAngLeft;
			m_tvArrAngLeft_RebarMain_LowerPlane[nCycle][nDan][upper].Add(pTvArrAngLeft);

			CTwinVectorArray *pTvArrAngRight	= new CTwinVectorArray;
			*pTvArrAngRight	= tvArrAngRight;
			m_tvArrAngRight_RebarMain_LowerPlane[nCycle][nDan][upper].Add(pTvArrAngRight);

			CTwinVectorArray *pTvArrJoint	= new CTwinVectorArray;
			*pTvArrJoint	= tvArrJoint;
			m_tvArrJoint_RebarMain_LowerPlane[nCycle][nDan][upper].Add(pTvArrJoint);

			CTwinVectorArray *pTvArrHidden	= new CTwinVectorArray;
			*pTvArrHidden	= tvArrHidden;
			m_tvArrHidden_RebarMain_LowerPlane[nCycle][nDan][upper].Add(pTvArrHidden);

			CTwinVectorArray *pTvArrHiddenLeft	= new CTwinVectorArray;
			*pTvArrHiddenLeft	= tvArrHiddenLeft;
			m_tvArrHiddenLeft_RebarMain_LowerPlane[nCycle][nDan][upper].Add(pTvArrHiddenLeft);

			CTwinVectorArray *pTvArrHiddenRight	= new CTwinVectorArray;
			*pTvArrHiddenRight	= tvArrHiddenRight;
			m_tvArrHiddenRight_RebarMain_LowerPlane[nCycle][nDan][upper].Add(pTvArrHiddenRight);

			CTwinVectorArray *pTvArrAngLeftHalf	= new CTwinVectorArray;
			*pTvArrAngLeftHalf	= tvArrAngLeftHalf;
			m_tvArrAngLeftHalf_RebarMain_LowerPlane[nCycle][nDan][upper].Add(pTvArrAngLeftHalf);

			CTwinVectorArray *pTvArrAngRightHalf	= new CTwinVectorArray;
			*pTvArrAngRightHalf	= tvArrAngRightHalf;
			m_tvArrAngRightHalf_RebarMain_LowerPlane[nCycle][nDan][upper].Add(pTvArrAngRightHalf);
		}
	}
}

void CRcBridgeRebar::GetTvRebarSupport_CrossSection_LowerSlab( CTwinVectorArray &tvArr, CTwinVectorArray &tvArrLowerLeft, CTwinVectorArray &tvArrLowerRight, double dSta, BOOL bUpper, long nDan, long nDrawLeft, BOOL bForDrawCrossSection/*=TRUE*/, BOOL bForRebarBM/*=FALSE*/, BOOL bExp/*=TRUE*/, long nApplyAngle/*=0*/, BOOL bMirror/*=FALSE*/ )
{
	if(!IsExp(dSta))
		bExp	= FALSE;

	tvArr.RemoveAll();
	tvArrLowerLeft.RemoveAll();
	tvArrLowerRight.RemoveAll();

	double dCoverUpper	= nDan > -1 ? m_dCoverUpper_LowerSlab[nDan] : 0;
	double dCoverLower	= nDan > -1 ? m_dCoverLower_LowerSlab[nDan] : 0;

	BOOL bVertDir	= IsVertDir();
	CDPoint vAng	= !bVertDir ? GetAngleJijum(0) : CDPoint(0, 1);
	if(bForDrawCrossSection)
		vAng	= CDPoint(0, 1);
	if(nApplyAngle == -1)
		vAng	= CDPoint(0, 1);
	else if(nApplyAngle == 1)
		vAng	= GetAngleJijum(GetJijumNumberByStation(dSta));

	double dCoverSideL	= nDan > -1 ? GetCoverSide_UpperSlab(nDan, dSta, vAng, TRUE, TRUE) : 0;
	double dCoverSideR	= nDan > -1 ? GetCoverSide_UpperSlab(nDan, dSta, vAng, TRUE, FALSE) : 0;

	double dStaSmallestWidth	= dSta;//GetStationSmallestWidthOfUpperSlab();
	GetTvCrossSectionLowerSlab(tvArr, dStaSmallestWidth, vAng, FALSE, FALSE, bExp);

	// 상,측,하면 좌표들 구함.
	long nSize	= tvArr.GetSize();
	CTwinVector tv;
	CTwinVectorArray tvArrUpper, tvArrLower, tvArrLeft, tvArrRight;
	CString sOldInfo	= "";
	long i = 0; for(i = 0; i < nSize; i++)
	{
		tv	= tvArr.GetAt(i);
		if(tv.m_sInfo == "")
			tv.m_sInfo	= sOldInfo;
		if(Compare(tv.GetLength(), 0.0, "=")) 
			continue;

		if(tv.m_sInfo.Find("상면", 0) != -1) 
			tvArrUpper.Add(tv);
		else if(tv.m_sInfo.Find("하면", 0) != -1) 
			tvArrLower.Add(tv);
		else if(tv.m_sInfo.Find("좌측면", 0) != -1) 
			tvArrLeft.Add(tv);
		else if(tv.m_sInfo.Find("우측면", 0) != -1) 
			tvArrRight.Add(tv);

		sOldInfo	= tv.m_sInfo;
	}
	CRebarPlacing rb;

	// 단에 맞게 offset
	rb.GetOffsetTvArray(tvArrUpper, dCoverUpper);
	rb.GetOffsetTvArray(tvArrLower, -dCoverLower, TRUE, 0.00001);	// 길이가 매우 짧은 철근이 sort되면서 뒤집힌 경우가 있었음
	rb.GetOffsetTvArray(tvArrLeft, -dCoverSideL);
	rb.GetOffsetTvArray(tvArrRight, dCoverSideR);

	if(tvArrUpper.GetSize() == 0 || tvArrLower.GetSize() == 0 || tvArrLeft.GetSize() == 0 || tvArrRight.GetSize() == 0)
		return;

	double dCoverMax	= max(dCoverUpper, dCoverLower);
	dCoverMax	= max(dCoverMax, dCoverSideL);
	dCoverMax	= max(dCoverMax, dCoverSideR);

	// offset 된 것들을 교차점 처리
	// 현재 방향 상 : 좌->우, 하 : 좌->우, 좌와우 : 상->하
	// 1. 상면과 양 측면 교차점 처리
	CTwinVector tv1, tv2;
	tv1	= tvArrUpper.GetAt(0);
	tv2	= tvArrLeft.GetAt(0);
	
	GetXyMatchLineAndLine(tv1.m_v2, tv1.GetXyDir(TRUE), tv2.m_v2, tv2.GetXyDir(TRUE), tv1.m_v1);
	tv2.m_v1	= tv1.m_v1;
	
	tvArrUpper.SetAt(0, tv1);
	tvArrLeft.SetAt(0, tv2);

	// 측면이 하나밖에 없을때는 하면과의 교차점도 찾아야 한다.
	if(tvArrLeft.GetSize() == 1)
	{
		CTwinVector *pTv	= tvArrLeft.GetPAt(0);
		CDPointArray xyArrMatch;
		rb.GetXyMatchTvArrAndTvArr(tvArrLower, tvArrLeft, xyArrMatch, FALSE);
		if(xyArrMatch.GetSize() > 0)
		{
			pTv->m_v2	= xyArrMatch.GetAt(0);
		}
	}

	tv1	= tvArrUpper.GetAt(tvArrUpper.GetSize()-1);
	tv2	= tvArrRight.GetAt(0);

	GetXyMatchLineAndLine(tv1.m_v1, tv1.GetXyDir(), tv2.m_v2, tv2.GetXyDir(TRUE), tv1.m_v2);
	tv2.m_v1	= tv1.m_v2;

	tvArrUpper.SetAt(tvArrUpper.GetSize()-1, tv1);
	tvArrRight.SetAt(0, tv2);

	// 측면이 하나밖에 없을때는 하면과의 교차점도 찾아야 한다.
	if(tvArrRight.GetSize() == 1)
	{
		CTwinVector *pTv	= tvArrRight.GetPAt(0);
		CDPointArray xyArrMatch;
		rb.GetXyMatchTvArrAndTvArr(tvArrLower, tvArrRight, xyArrMatch, FALSE);
		if(xyArrMatch.GetSize() > 0)
		{
			pTv->m_v2	= xyArrMatch.GetAt(0);
		}
	}

	// 3. 하면과 양 측면 교차점 처리(좌측이나 우측에 라운드가 있는쪽은 교차점 안 찾아도 됨)
	CDPointArray xyArrMatch;

	// 좌
	tv1	= tvArrLower.GetAt(0);
	if(tvArrLower.GetSize() > 0)
	{
		rb.GetXyMatchTvArrAndLine(tvArrLeft, tv1.m_v1, tv1.GetXyDir(), xyArrMatch);
		if(xyArrMatch.GetSize() > 0)
		{
			tv1.m_v1	= xyArrMatch.GetAt(0);
			if(tv1.GetLength() > 0)
				tvArrLower.SetAt(0, tv1);
		}
	}

	// 우
	if(tvArrLower.GetSize() > 0)
	{
		tv1	= tvArrLower.GetAt(tvArrLower.GetSize()-1);
		rb.GetXyMatchTvArrAndLine(tvArrRight, tv1.m_v1, tv1.GetXyDir(), xyArrMatch);
		if(xyArrMatch.GetSize() > 0)
		{
			tv1.m_v2	= xyArrMatch.GetAt(0);
			if(tv1.GetLength() > 0)
				tvArrLower.SetAt(tvArrLower.GetSize()-1, tv1);
		}
	}



	// 우측은 순서를 뒤집어 줌.
	rb.ReverseRebar(tvArrRight);


	if(!bUpper)
		tvArr	= tvArrLower;
	else
	{
		tvArr.RemoveAll();
		if(bForRebarBM)
		{
			CPlaceRebarByBlock *pPlace	= &m_placeByBlock_SupportRebar_LowerSlab[iUPPER][0];
			long nSize		= pPlace->m_xyArr.GetSize();
			double dCover	= m_dCoverUpper_LowerSlab[0];
			double dSpace	= nSize > 0 ? pPlace->m_xyArr.GetAt(nSize/2).y : 0;
			double dDia		= pPlace->m_dDia;
			double dSettle(0);
			if(m_pARcBridgeDataStd->IsLsdDesign())
			{
				SRebarEnvOption LsdRebarOpt;
				SetRebarLsdOptionSlab(&LsdRebarOpt, FALSE, TRUE, FALSE, 0, 0);
				dSettle = m_pARcBridgeDataStd->m_pBasicConcInfo->GetValueSettle(dDia, &LsdRebarOpt);
			}else
			{
				dSettle = m_pARcBridgeDataStd->GetValueSettle(dDia, SETTLE_TENS_NORMAL, toCm(dCover), toCm(dSpace));
			}

			CDPointArray xyArrMatch;
			if(tvArrLeft.GetSize() > 4)
			{
				tvArrLowerLeft.Add(tvArrLeft.GetAt(0));
				tvArrLowerLeft.Add(tvArrLeft.GetAt(1));
				tv	= tvArrLeft.GetAt(2);
				tv.m_v2	+= (tv.GetXyDir() * dSettle);
				tvArrLowerLeft.Add(tv);

				tv	= tvArrLeft.GetAt(3);
				tv.m_v1 += (CDPoint(0, 1) * dSettle);
				rb.GetXyMatchTvArrAndSeg(tvArrUpper, tv.m_v1, tv.m_v2, xyArrMatch, TRUE);
				if(xyArrMatch.GetSize() > 0)
					tv.m_v1 = xyArrMatch.GetAt(0);
				tvArr.Add(tv);
				tvArr.Add(tvArrLeft.GetAt(4));
			}
			else if(tvArrLeft.GetSize() == 4)
			{
				tvArrLowerLeft.Add(tvArrLeft.GetAt(0));
				tv	= tvArrLeft.GetAt(1);
				tv.m_v2 += (tv.GetXyDir() * dSettle);
				tvArrLowerLeft.Add(tv);

				tv	= tvArrLeft.GetAt(2);
				tv.m_v1 += (CDPoint(0, 1) * dSettle);
				rb.GetXyMatchTvArrAndSeg(tvArrUpper, tv.m_v1, tv.m_v2, xyArrMatch, TRUE);
				if(xyArrMatch.GetSize() > 0)
					tv.m_v1 = xyArrMatch.GetAt(0);
				tvArr.Add(tv);
				tvArr.Add(tvArrLeft.GetAt(3));

			}
			else if(tvArrLeft.GetSize() == 3)
			{
				tvArrLowerLeft.Add(tvArrLeft.GetAt(0));
				tv	= tvArrLeft.GetAt(1);
				tv.m_v2 += tv.GetXyDir() * dSettle;
				tvArrLowerLeft.Add(tv);

				tv	= tvArrLeft.GetAt(2);
				tv.m_v1 += CDPoint(0, 1) * dSettle;
				rb.GetXyMatchTvArrAndSeg(tvArrUpper, tv.m_v1, tv.m_v2, xyArrMatch, TRUE);
				if(xyArrMatch.GetSize() > 0)
					tv.m_v1	= xyArrMatch.GetAt(0);
				tvArr.Add(tv);
			}
			else
			{
				tvArr.AddFromTvArray(tvArrLeft);
			}

			tvArr.AddFromTvArray(tvArrUpper);

			if(tvArrRight.GetSize() > 4)
			{
				tv	= tvArrRight.GetAt(2);
				tv.m_v1 += (tv.GetXyDir(TRUE) * dSettle);
				tvArrLowerRight.Add(tv);
				tvArrLowerRight.Add(tvArrRight.GetAt(3));
				tvArrLowerRight.Add(tvArrRight.GetAt(4));

				tv	= tvArrRight.GetAt(1);
				tv.m_v2 += (CDPoint(0, 1) * dSettle);
				rb.GetXyMatchTvArrAndSeg(tvArrUpper, tv.m_v1, tv.m_v2, xyArrMatch, TRUE);
				if(xyArrMatch.GetSize() > 0)
					tv.m_v2 = xyArrMatch.GetAt(0);
				tvArr.Add(tvArrRight.GetAt(0));
				tvArr.Add(tv);
			}
			else if(tvArrRight.GetSize() == 4)
			{
				tv	= tvArrRight.GetAt(2);
				tv.m_v1 += (tv.GetXyDir(TRUE) * dSettle);
				tvArrLowerRight.Add(tv);
				tv	= tvArrRight.GetAt(3);
				tvArrLowerRight.Add(tv);

				tv	= tvArrRight.GetAt(1);
				tv.m_v2 += (CDPoint(0, 1) * dSettle);
				rb.GetXyMatchTvArrAndSeg(tvArrUpper, tv.m_v1, tv.m_v2, xyArrMatch, TRUE);
				if(xyArrMatch.GetSize() > 0)
					tv.m_v2 = xyArrMatch.GetAt(0);
				tvArr.Add(tvArrRight.GetAt(0));
				tvArr.Add(tv);
			}
			else if(tvArrRight.GetSize() == 3)
			{
				tv	= tvArrRight.GetAt(1);
				tv.m_v1 += tv.GetXyDir(TRUE) * dSettle;
				tvArrLowerRight.Add(tv);

				tv	= tvArrRight.GetAt(2);
				tvArrLowerRight.Add(tv);

				tv	= tvArrRight.GetAt(0);
				tv.m_v2 += CDPoint(0, 1) * dSettle;
				rb.GetXyMatchTvArrAndSeg(tvArrUpper, tv.m_v1, tv.m_v2, xyArrMatch, TRUE);
				if(xyArrMatch.GetSize() > 0)
					tv.m_v2	= xyArrMatch.GetAt(0);
				tvArr.Add(tv);
			}
			else
			{
				tvArr.AddFromTvArray(tvArrRight);
			}
		}
		else
		{
			tvArr.AddFromTvArray(tvArrLeft);
			tvArr.AddFromTvArray(tvArrUpper);
			tvArr.AddFromTvArray(tvArrRight);
		}
	}

	// mirror
	// 시점에서 본 모양데로 그리기 위해.
	long nJ	= GetJijumNumberByStation(dSta);
	if(nJ == 0 || bMirror)
	{
		CTwinVectorArray tvArrCross;
		GetTvCrossSection(tvArrCross, dStaSmallestWidth, vAng, FALSE, TRUE, FALSE, 0, FALSE, FALSE);
		CDRect rect	= tvArrCross.GetRect();
		rb.Mirror(tvArr, CDPoint(rect.left, 0), TRUE);
		rb.Mirror(tvArrLowerLeft, CDPoint(rect.left, 0), TRUE);
		rb.Mirror(tvArrLowerRight, CDPoint(rect.left, 0), TRUE);
		rb.MoveRebar(tvArr, CDPoint(rect.Width(), 0));
		rb.MoveRebar(tvArrLowerLeft, CDPoint(rect.Width(), 0));
		rb.MoveRebar(tvArrLowerRight, CDPoint(rect.Width(), 0));
	}


	// nDrawLeft에 따라서 잘라냄
	if(nDrawLeft != 0)
	{
		CDRect rect	= tvArr.GetRect();
		double dMid	= GetMidCrossSection();
		BOOL bLeft	= nDrawLeft == -1 ? FALSE : TRUE;
		CDPoint xy1	= CDPoint(dMid, rect.bottom-100);
		CDPoint xy2	= CDPoint(dMid, rect.top+100);
		rb.TrimTvArrayByLine(tvArr, xy1, xy2, bLeft, TRUE, FALSE);
		rb.TrimTvArrayByLine(tvArrLowerLeft, xy1, xy2, bLeft, TRUE, FALSE);
		rb.TrimTvArrayByLine(tvArrLowerRight, xy1, xy2, bLeft, TRUE, FALSE);
	}
}

void CRcBridgeRebar::GetTvRebarSupport_CrossSection_LowerSlabHunch( CTwinVectorArray &tvArr, double dSta, long nDan, long nDrawLeft, BOOL bForDrawCrossSection/*=TRUE*/, BOOL bExp/*=TRUE*/, BOOL bForRebarBM/*=FALSE*/, long nApplyAngle/*=0*/, BOOL bMirror/*=FALSE*/ )
{
	if(!IsExp(dSta))
		bExp	= FALSE;

	tvArr.RemoveAll();
	double dThickHunch	= GetHeightLowerSlab(GetJijumNumberByStation(dSta), 0, CDPoint(0,1)) - m_dTS_Lower;
	double dCover		= m_dCoverUpper_LowerSlab[nDan];
	BOOL bVertDir	= IsVertDir();
	if(dThickHunch <= 0) return;
	if(!m_bPlacingSupportAtHunchRebar)	return;
	



	// 헌치 철근이 존재 하는지 검사
	double dStaCheck	= GetStationModifyForRebarCheck(dSta);
	/*
	long nJ	= GetJijumNumberByStation(dSta);
	if(nJ == 0 || nJ == m_nQtyJigan)
	{
		CDPoint vAng	= GetAngleJijum(nJ, bVertDir);
		double dStaStt	= GetStationByTarget(BRIDGE_OFF_STT_SLAB, 0, FALSE);
		double dLenBri	= GetStationByTarget(BRIDGE_OFF_END_SLAB, 0, FALSE) - GetStationByTarget(BRIDGE_OFF_STT_SLAB, 0, FALSE);
		if(nJ == 0 && dSta <= dStaStt + m_dCoverWallOut[0]/vAng.y)
			dSta = dStaStt + m_dCoverWallOut[0]/vAng.y;
		else if(nJ == m_nQtyJigan && dSta >= dStaStt + dLenBri - m_dCoverWallOut[0]/vAng.y)
			dSta	= dStaStt + dLenBri - m_dCoverWallOut[0]/vAng.y;
	}
	*/

	BOOL bFind	= FALSE;
	long i = 0; for(i = 0; i < m_pArrRCMainLowerSlabHunch[0].GetSize(); i++)
	{
		CRebarInfoCycle *pRC	= m_pArrRCMainLowerSlabHunch[0].GetAt(i);
		double dLeft	= pRC->m_tvArrRebar.GetXyLeft().x;
		double dRight	= pRC->m_tvArrRebar.GetXyRight().x;
		if((fabs(dStaCheck-dLeft) <= 100 || Compare(dStaCheck, dLeft, ">=")) && (fabs(dStaCheck-dRight) <= 100 || Compare(dStaCheck, dRight, "<=")))
		//if(pRC->m_tvArrRebar.GetXyLeft().x <= dSta && pRC->m_tvArrRebar.GetXyRight().x >= dSta)
		{
			bFind	= TRUE;
			break;
		}
	}
	if(!bFind) return;

	
	CDPoint vAng	= bVertDir ? CDPoint(0, 1) : GetAngleJijum(0);
	if(bForDrawCrossSection)
		vAng	= CDPoint(0, 1);

	if(bForRebarBM)
		vAng	= GetAngleJijum(GetJijumNumberByStation(dSta), FALSE);

	if(nApplyAngle == -1)
		vAng	= CDPoint(0, 1);
	else if(nApplyAngle == 1)
		vAng	= GetAngleJijum(GetJijumNumberByStation(dSta));

	// 헌치 상단 좌표들
	double dStaSmallestWidth	= dSta;//GetStationSmallestWidthOfUpperSlab();
	CTwinVector tv;
	CTwinVectorArray tvArrCross;
	GetTvCrossSectionLowerSlab(tvArrCross, dStaSmallestWidth, vAng, 0, FALSE);
	tv = tvArrCross.GetTvByInfo(_T("하부슬래브횡단상면"));
	
	tv.m_v1.y += (dThickHunch-dCover);
	tv.m_v2.y += (dThickHunch-dCover);
	tv.m_sInfo	= "슬래브헌치상부";
	tvArr.Add(tv);

	// 좌우측을 피복 고려
	CRebarPlacing rb;
	if(tvArr.GetSize() > 0)
	{
		double dCoverSide	=  GetCoverSide_UpperSlab(nDan, dSta, vAng, TRUE, TRUE); // m_dCoverUpper_UpperSlab[0];
		CDRect rect	= tvArr.GetRect();
		
		tv	= tvArr.GetAt(0);
		rb.TrimTvArrayByLine(tvArr, CDPoint(tv.m_v1.x+dCoverSide, rect.bottom-100), CDPoint(tv.m_v1.x+dCoverSide, rect.top+100), TRUE, TRUE, FALSE);

		if(tvArr.GetSize() > 0)
		{
			tv	= tvArr.GetAt(tvArr.GetSize()-1);
			rb.TrimTvArrayByLine(tvArr, CDPoint(tv.m_v2.x-dCoverSide, rect.bottom-100), CDPoint(tv.m_v2.x-dCoverSide, rect.top+100), FALSE, TRUE, FALSE);

			// 좌측 선 넣어줌
			if(tvArr.GetSize() > 0)
			{
				tv	= tvArr.GetAt(0);
				tv.m_v2	= tv.m_v1;
				tv.m_v1	= tv.m_v2 - CDPoint(0, dThickHunch);
				tv.m_sInfo	= "슬래브헌치좌측";
				tvArr.InsertAt(0, tv);

				// 우측 선 넣어줌
				tv	= tvArr.GetAt(tvArr.GetSize()-1);
				tv.m_v1	= tv.m_v2;
				tv.m_v2	= tv.m_v2 - CDPoint(0, dThickHunch);
				tv.m_sInfo	= "슬래브헌치우측";
				tvArr.Add(tv);
			}
		}

		// mirror
		// 시점에서 본 모양데로 그리기 위해.
		long nJ	= GetJijumNumberByStation(dSta);
		if(nJ == 0 || bMirror)
		{
			CTwinVectorArray tvArrCross;
			GetTvCrossSection(tvArrCross, dStaSmallestWidth, vAng, FALSE, TRUE, FALSE, 0, FALSE, FALSE);
			rect	= tvArrCross.GetRect();
			rb.Mirror(tvArr, CDPoint(rect.left, 0), TRUE);
			rb.MoveRebar(tvArr, CDPoint(rect.Width(), 0));
		}

		// nDrawLeft에 따라서 잘라냄
		if(nDrawLeft != 0)
		{
			rect	= tvArr.GetRect();
			double dMid	= GetMidCrossSection(TRUE);
			BOOL bLeft	= nDrawLeft == -1 ? FALSE : TRUE;
			CDPoint xy1	= CDPoint(dMid, rect.bottom-100);
			CDPoint xy2	= CDPoint(dMid, rect.top+100);
			rb.TrimTvArrayByLine(tvArr, xy1, xy2, bLeft, TRUE, FALSE);
		}
	}
}

void CRcBridgeRebar::GetTvRebarShear_CrossSection_LowerSlab( CTwinVectorArray &tvArr, CTwinVectorArray &tvArr2, double dSta, long nDrawLeft, BOOL bForMarkRebar/*=FALSE*/, BOOL bNotHunch/*=FALSE*/, BOOL bGagak/*=TRUE*/, BOOL bMirror/*=FALSE*/ )
{
	tvArr.RemoveAll();
	tvArr2.RemoveAll();

	// 전단철근 간격
	double dCTC	= GetCTCRebarShear_LowerSlab();
	// 주철근이 사보강배치인 경우 시점각도가 적용된 거리를 구해야 됨.
	if(IsVertDir())
		dCTC	= dCTC / GetAngleJijum(0).y;
	else
	{
		// 만약 벽체 기준이라면 간격이 작아짐
		if(m_nTypeStandardCTCRebarMain == 1)
			dCTC	= dCTC * GetAngleJijum(0).y;
	}
	if(Compare(dCTC, 0.0, "=")) return;

	// 전단철근은 하면 철 근 좌측끝에서 우측 끝으로 배근함(하면철근에서 시작)
	CTwinVectorArray tvArrUpper, tvArrLower, tvArrSupLeft, tvArrSupRight;
	CTwinVector tvUpper, tvLower;
	GetTvRebarSupport_CrossSection_LowerSlab(tvArrUpper, tvArrSupLeft, tvArrSupRight, dSta, TRUE, 0, 0, TRUE, FALSE, FALSE, 0, bMirror);
	GetTvRebarSupport_CrossSection_LowerSlab(tvArrLower, tvArrSupLeft, tvArrSupRight, dSta, FALSE, 0, 0, TRUE, FALSE, FALSE, 0, bMirror);
	tvUpper.m_v1	= tvArrUpper.GetAt(0).m_v1;
	tvUpper.m_v2	= tvArrUpper.GetAt(tvArrUpper.GetSize()-1).m_v2;
	tvLower.m_v1	= tvArrLower.GetAt(0).m_v1;
	tvLower.m_v2	= tvArrLower.GetAt(tvArrLower.GetSize()-1).m_v2;

	// 배력근 위치를 참조해야 되므로 주철근 위치 구함.
	CVectorArray xyArrUpper, xyArrLower, xyArrHunch;
	// 세로로 세워진 형태
	GetXyRebarMain_CrossSection_LowerSlab(xyArrUpper, xyArrHunch, dSta, TRUE, 0, 0, bMirror, TRUE);
	GetXyRebarMain_CrossSection_LowerSlab(xyArrLower, xyArrHunch, dSta, FALSE, 0, 0, bMirror, TRUE);

	if(GetCountCycleMainRebar() == 4)
	{
		// 배력근 위치를 참조해야 되므로 주철근 위치 구함.
		CVectorArray xyArrUpper2, xyArrLower2, xyArrHunch2;
		// 세로로 세워진 형태
		GetXyRebarMain_CrossSection_LowerSlab(xyArrUpper2, xyArrHunch2, dSta, TRUE, 0, 2, bMirror, TRUE);
		GetXyRebarMain_CrossSection_LowerSlab(xyArrLower2, xyArrHunch2, dSta, FALSE, 0, 2, bMirror, TRUE);
		if(xyArrUpper2.GetSize() > 0)
			xyArrUpper.Add(xyArrUpper2.GetAt(xyArrUpper2.GetSize()-1));
		if(xyArrLower2.GetSize() > 0)
			xyArrLower.Add(xyArrLower2.GetAt(xyArrLower2.GetSize()-1));
	}

	CRebarPlacing rb;
	rb.ReverseRebar(xyArrUpper);
	rb.ReverseRebar(xyArrLower);
	rb.ReverseRebar(xyArrHunch);



	// 가로로 눞혀야 된다.
	// 배력근 위치는 전단철근 시작위치 찾는데만 참조한다.
	CDPoint xy(0, 0);
	long i	= 0;
	long nSize	= xyArrLower.GetSize();
	if(nSize < 2) return;

	// xyArrUpper 소트
	// 사보강시 순서대로 안 구해져잇음
	for(i = 0; i < xyArrLower.GetSize()-1; i++)
	{
		CDPoint xy1	= xyArrLower.GetAt(i);
		long j = 0; for(j = i + 1; j < xyArrLower.GetSize(); j++)
		{
			CDPoint xy2	= xyArrLower.GetAt(j);

			if(xy1.x > xy2.x)
			{
				GetSwap(xy1, xy2);
				xyArrLower.SetAt(i, xy1);
				xyArrLower.SetAt(j, xy2);
			}
		}
	}

	// 배근 시작위치 찾음
	// 상면 두번째 주철근부터를 기본으로 하고 만약 시작 위치에 하면배력근이 없는 위치라면 다음 위치를 찾음
	nSize	= xyArrLower.GetSize();
	CDPoint xyStt	= xyArrLower.GetAt(0);
	CDPoint xyEnd	= xyArrLower.GetAt(nSize-2);	// 마지막 두번째 철근까지로 범위를 조정한다 (11818 2010.05.11 홍석현)

	BOOL bFindStt	= FALSE;
	for(i = 1; i < nSize; i++)
	{
		xyStt	= xyArrLower.GetAt(i);
		if(tvLower.m_v1.x <= xyStt.x && tvLower.m_v2.x >= xyStt.x)
		{
			bFindStt	= TRUE;
			break;
		}
	}
	if(!bFindStt) return;	// 시작위치를 못 찾으면 리턴

	// 전단철근 위치 찾음 하단에서
	CDPointArray xyArrShear;
	CTwinVector tv;
	xyStt	= xyArrLower.GetAt(i);
	nSize	= tvArrLower.GetSize();
	while(1)
	{
		if(xyStt.x >= tvLower.m_v1.x && xyStt.x <= tvLower.m_v2.x)
		{
			long i = 0; for(i = 0; i < nSize; i++)
			{
				tv	= tvArrLower.GetAt(i);
				if(GetXyMatchSegAndLine(tv.m_v1, tv.m_v2, xyStt, CDPoint(0, 1), xyStt))
					break;
			}
			xyArrShear.Add(CDPoint(xyStt.x, xyStt.y));
		}

		xyStt.x += dCTC;
		if((xyStt.x > tvLower.m_v2.x) || (xyStt.x > xyEnd.x))break;
	}

	// 다 구한뒤에 nDrawLeft에 따라서 걸러낸다.
	if(nDrawLeft == -1 || nDrawLeft == 1)
	{
		double dDistMid	= GetDistMidOfSlab(dSta);
		if(nDrawLeft == -1)
		{
			long i = 0; for(i = 0; i < xyArrShear.GetSize(); i++)
			{
				if(xyArrShear.GetAt(i).x > dDistMid)
				{
					xyArrShear.RemoveAt(i);
					i--;
				}
			}
		}
		else
		{
			long i = 0; for(i = 0; i < xyArrShear.GetSize(); i++)
			{
				if(xyArrShear.GetAt(i).x < dDistMid)
				{
					xyArrShear.RemoveAt(i);
					i--;
				}
			}
		}
	}



	// 저장 한거 하부 배력근 기준으로 잘라냄.
	CTwinVectorArray tvArrMid, tvArrLeft, tvArrRight;
	CTwinVectorArray tvArrHunch;
	// 슬래브상부 기준으로 자른뒤, 헌치하부에 포함되는건 헌치하부까지 뻗음
	GetTvRebarSupport_CrossSection_LowerSlab(tvArrMid, tvArrLeft, tvArrRight, dSta, TRUE, 0, 0, TRUE, FALSE, bGagak, 0, bMirror);
	GetTvRebarSupport_CrossSection_LowerSlabHunch(tvArrHunch, dSta, 0, 0, TRUE, bGagak, FALSE, 0, bMirror);
	CDRect rectHunch	= tvArrHunch.GetRect();
	CDPointArray xyArrMatch;
	for(i = 0; i < xyArrShear.GetSize(); i++)
	{
		xy	= xyArrShear.GetAt(i);
		CTwinVector tvMatch;
		if(!bNotHunch && (rectHunch.left <= xy.x && rectHunch.right >= xy.x))
		{
			rb.GetXyMatchTvArrAndLine(tvArrHunch, xy, CDPoint(0, 1), xyArrMatch);
		}
		else
		{
			long nIdx	= rb.GetXyMatchTvArrAndLine(tvArrMid, xy, CDPoint(0, 1), xyArrMatch);
			if(nIdx > -1)
				tvMatch	= tvArrMid.GetAt(nIdx);
		}

		if(xyArrMatch.GetSize() > 0)
		{
			if(bForMarkRebar)
			{
				tv.m_v1	= xy;
				tv.m_v2	= xy + CDPoint(0, m_dTS_Lower);
			}
			else
			{
				tv.m_v1	= xy;
				tv.m_v2	= xyArrMatch.GetAt(0);
			}
			if(tvMatch.m_sInfo.Find("좌측", 0) == -1 && tvMatch.m_sInfo.Find("우측", 0) == -1)
				tvArr.Add(tv);
			else
			{
				if(!m_bRemoveShearRebarAtSlabYundan)
					tvArr2.Add(tv);
			}
		}
	}
}

void CRcBridgeRebar::GetXyRebarMain_CrossSection_LowerSlab( CVectorArray &xyArr, CVectorArray &xyArrHunch, double dSta, BOOL bUpper, long nDan, long nCycle, BOOL bMirror/*=FALSE*/, BOOL bUseMatchSta/*=FALSE*/ )
{
	xyArr.RemoveAll();
	xyArrHunch.RemoveAll();
	if(GetCountCycleMainRebar() <= nCycle) return;

	long i = 0;
	BOOL bVertDir	= IsVertDir();
	double dStaOld	= dSta;

	double dStaCheck	= GetStationModifyForRebarCheck(dSta);

	// 철근이 없다면 그냥 리턴
	long nIdxFind	= -1;
	BOOL bFind	= IsRebarMainBySta(FALSE, dStaCheck, nCycle, bUpper, nDan, nIdxFind);
	if(!bFind) return;
	////////////////////////////////////////////////////////////////


	CLineInfo *pLine	= bUseMatchSta ? GetLineBase() : GetLineBase(bVertDir, FALSE);
	CRebarPlacing rb;

	// 1. 평면상의 주철근 위치를 구한다.
	CTwinVectorArray tvArrMain, tvArrHunch;
	CTwinVectorArray tvArrMainLeftAng, tvArrMainRightAng;
	CTwinVectorArray tvArrHunchLeftAng, tvArrHunchRightAng;
	CTwinVectorArray tvArrMainTmp, tvArrHunchTmp;
	CTwinVectorArray tvArrJoint, tvArrHidden;	// 이 두 변수는 사용하지 않음
	GetTvRebarMain_Plane_LowerSlab_TypeNormal_Std(tvArrMainTmp, tvArrMainLeftAng, tvArrMainRightAng, bUpper, nCycle, nDan, 0, bUseMatchSta ? nIdxFind : 0, FALSE, FALSE, FALSE, tvArrJoint, tvArrHidden, tvArrHidden, tvArrHidden, TRUE);
	if(bUpper)
		GetTvRebarMain_Plane_SlabHunch(tvArrHunchTmp, tvArrHunchLeftAng, tvArrHunchRightAng, nCycle, dSta, -1, 0, FALSE);
	CTwinVectorArray tvArrCen, tvArrCenTmp;
	GetTvCenterPlane_UpperSlab(tvArrCenTmp, TRUE, FALSE, 0, bVertDir);

	CTwinVectorArray tvArrStt;
	GetTvPlaneSttEndLine(tvArrStt, TRUE, TRUE, 0, FALSE);
	CDPoint xyStt	= bUseMatchSta ? pLine->GetXyLineDis(dStaOld, 0)
		: pLine->GetXyLineDis(bVertDir ? (IsOutWall(TRUE) ? -m_dWS : 0) : m_dStationBridgeStt, 0);

	if(0)//bVertDir)
	{
		CDPointArray xyArrMatch;
		rb.GetXyMatchTvArrAndLine(tvArrCenTmp, xyStt, tvArrCenTmp.GetAt(0).GetXyDir().Rotate90(), xyArrMatch);
		if(xyArrMatch.GetSize() > 0)
			xyStt	= xyArrMatch.GetAt(0);
	}	

	long nJ	= bUseMatchSta ? GetJijumNumberByStation(dStaOld) : 0;
	// 주철근들을 tv정보로 변경 ////////////////////////
	// 교차점을 찾아야 되므로 끊어진 철근없이 무조건 시점부터 종점까지 그어버린다.
	CLineInfoApp *pLineOrg	= static_cast<CLineInfoApp*>(GetLineBase(FALSE));
	double dStaStt	= bUseMatchSta ? dStaOld : GetStationByTarget(BRIDGE_OFF_STT_SLAB, 0, FALSE);//m_dStationBridgeStt-dExtStt;

	CTwinVector tv;
//	CTwinVector *pTv	= NULL;
	if(bVertDir || IsExtLine())
	{
		CDPoint vAng	= bUseMatchSta ? pLine->GetAngleAzimuth(dStaOld).Rotate90() : GetAngleAzimuthJijum(nJ);
		CDPoint xyMatch(0, 0);
		for(i = 0; i < tvArrMainTmp.GetSize(); i++)
		{
			tv	= tvArrMainTmp.GetAt(i);
			if(GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), xyStt, vAng, tv.m_v1))
				tvArrMain.Add(tv);
		}

		// 확폭이면 좌우측 사방향 철근도 교차점 찾아야됨.
		// 속도때문에 교차점 찾지 않으려 했으나,
		// 확폭이 아니고 직선사보강일때도 1,2사이클의 직경이 다르면
		// 곡선구간때문에 교차점을 찾기 시작하는 위치가 달라서 Y값만으로는 정확한 위치를 찾을 수 없어서
		// 무조건 교차점 찾도록 함.
		if(1)//IsExtLine() || m_nTypeSideRebarMain_UpperSlabSabogang == 1)
		{
			if(m_nTypeSideRebarMain_UpperSlabSabogang == 0 && !IsExtLine())
			{
				for(i = 0; i < tvArrMainLeftAng.GetSize(); i++)
				{
					tv	= tvArrMainLeftAng.GetAt(i);
					if(GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), xyStt, vAng, tv.m_v1))
						tvArrMainLeftAng.SetAt(i, tv);
				}

				for(i = 0; i < tvArrMainRightAng.GetSize(); i++)
				{
					tv	= tvArrMainRightAng.GetAt(i);
					if(GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), xyStt, vAng, tv.m_v1))
						tvArrMainRightAng.SetAt(i, tv);
				}
			}
			else if(m_nTypeSideRebarMain_UpperSlabSabogang == 1 || IsExtLine())
			{
				CTwinVector *pTv	= NULL;
				CLineInfo *pLineL	= GetLineLeftRight(TRUE);
				for(i = 0; i < tvArrMainLeftAng.GetSize(); i++)
				{
					pTv	= &tvArrMainLeftAng.GetAt(i);
					double dDist	= pLineL->GetDisMatchVerticalByXy(pTv->m_v1);
					double sta		= 0;
					pLineL->GetStationMatchByXyAndAngle(xyStt, vAng, sta, dDist);
					pTv->m_v1	= pLineL->GetXyLineDis(sta, dDist);
				}

				CLineInfo *pLineR	= GetLineLeftRight(FALSE);
				for(i = 0; i < tvArrMainRightAng.GetSize(); i++)
				{
					pTv	= &tvArrMainRightAng.GetAt(i);
					double dDist	= pLineR->GetDisMatchVerticalByXy(pTv->m_v1);
					double sta		= 0;
					pLineR->GetStationMatchByXyAndAngle(xyStt, vAng, sta, dDist);
					pTv->m_v1	= pLineR->GetXyLineDis(sta, dDist);
				}
			}
		}

		for(i = 0; i < tvArrHunchTmp.GetSize(); i++)
		{
			tv	= tvArrHunchTmp.GetAt(i);
			if(GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), xyStt, vAng, tv.m_v1))
				tvArrHunch.Add(tv);
		}

		// 확폭이면 좌우측 사방향 철근도 교차점 찾아야됨.
		if(IsExtLine())
		{
			for(i = 0; i < tvArrHunchLeftAng.GetSize(); i++)
			{
				tv	= tvArrHunchLeftAng.GetAt(i);
				if(GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), xyStt, vAng, tv.m_v1))
					tvArrHunchLeftAng.SetAt(i, tv);
			}

			for(i = 0; i < tvArrHunchRightAng.GetSize(); i++)
			{
				tv	= tvArrHunchRightAng.GetAt(i);
				if(GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), xyStt, vAng, tv.m_v1))
					tvArrHunchRightAng.SetAt(i, tv);
			}
		}

	}
	else
	{
		for(i = 0; i < tvArrMainTmp.GetSize(); i++)
		{
			tv	= tvArrMainTmp.GetAt(i);
			double dDist	= pLine->GetDisMatchVerticalByXy(tv.m_v1);
			tv.m_v1 = tv.m_v2 = pLineOrg->GetXyLineDis(dStaStt, dDist);
			tvArrMain.Add(tv);
		}
		for(i = 0; i < tvArrHunchTmp.GetSize(); i++)
		{
			tv	= tvArrHunchTmp.GetAt(i);
			double dDist	= pLine->GetDisMatchVerticalByXy(tv.m_v1);
			tv.m_v1 = tv.m_v2 = pLineOrg->GetXyLineDis(dStaStt, dDist);
			tvArrHunch.Add(tv);
		}
		for(i = 0; i < tvArrCenTmp.GetSize(); i++)
		{
			tv	= tvArrCenTmp.GetAt(i);
			double dDist	= pLine->GetDisMatchVerticalByXy(tv.m_v1);
			tv.m_v1 = tv.m_v2 = pLineOrg->GetXyLineDis(dStaStt, dDist);
			tvArrCen.Add(tv);
		}
	}
	// 주철근들을 tv정보로 변경 ////////////////////////



	// 2. bUseMatchSta일때는 해당 sta이 90도가 되도록 하고, 아닐땐 주철근을 시점이 90도가 되도록 회전한다.
	double dAngJijum	= GetAngleJijum(nJ).GetAngleDegree();
	double dAngAzJijum	= GetAngleAzimuthJijum(nJ).GetAngleDegree();
	double dAng		= (180+dAngJijum)-dAngAzJijum;
	CDPoint xyOrg	= CDPoint(0, 0);
	rb.RotateTvArr(tvArrMain, xyOrg, dAng);
	rb.RotateTvArr(tvArrHunch, xyOrg, dAng);
	rb.RotateTvArr(tvArrMainLeftAng, xyOrg, dAng);
	rb.RotateTvArr(tvArrMainRightAng, xyOrg, dAng);
	rb.RotateTvArr(tvArrHunchLeftAng, xyOrg, dAng);
	rb.RotateTvArr(tvArrHunchRightAng, xyOrg, dAng);
	rb.RotateTvArr(tvArrCen, xyOrg, dAng);
	rb.RotateTvArr(tvArrStt, xyOrg, dAng);
	rb.RotateXy(xyStt, xyOrg, dAng);

	// 3. 주철근 시작점의 y좌표를 모두 보관한다.
	CDoubleArray dArrMainY[3], dArrHunchY[3];
	CDPoint xyMatch(0, 0);
	CDPoint vAng	= GetAngleJijum(0);
	// 중심선에서 시점과 교차되는 부분을 찾는다.(어쨋든 시점을 기준으로 회전했으므로 
	// 시점을 기준으로 배근을 하자!!)
	// 사보강일 때만 찾으면 됨. 아닐땐 그냥 실제 y좌표 사용하자.!!!!
	for(i = 0; i < tvArrMain.GetSize(); i++)
		dArrMainY[0].Add(tvArrMain.GetAt(i).m_v1.y);

	for(i = 0; i < tvArrMainLeftAng.GetSize(); i++)
		dArrMainY[1].Add(tvArrMainLeftAng.GetAt(i).m_v1.y);

	for(i = 0; i < tvArrMainRightAng.GetSize(); i++)
		dArrMainY[2].Add(tvArrMainRightAng.GetAt(i).m_v1.y);

	for(i = 0; i < tvArrHunch.GetSize(); i++)
		dArrHunchY[0].Add(tvArrHunch.GetAt(i).m_v1.y);

	for(i = 0; i < tvArrHunchLeftAng.GetSize(); i++)
		dArrHunchY[1].Add(tvArrHunchLeftAng.GetAt(i).m_v1.y);

	for(i = 0; i < tvArrHunchRightAng.GetSize(); i++)
		dArrHunchY[2].Add(tvArrHunchRightAng.GetAt(i).m_v1.y);


	// 소트후 중복되는건 제거
	long s = 0; for(s = 0; s < 3; s++)
	{
		dArrMainY[s].Sort(TRUE);
		dArrHunchY[s].Sort(TRUE);

		for(i = 0; i < dArrMainY[s].GetSize()-1; i++)
		{
			if(Compare(dArrMainY[s].GetAt(i), dArrMainY[s].GetAt(i+1), "="))
				dArrMainY[s].RemoveAt(i+1);
		}
		for(i = 0; i < dArrHunchY[s].GetSize()-1; i++)
		{
			if(Compare(dArrHunchY[s].GetAt(i), dArrHunchY[s].GetAt(i+1), "="))
				dArrHunchY[s].RemoveAt(i+1);
		}
	}



	// 시점에서의 좌우측 점도 추가해줌
	// 폭이 가장 작은 부분을 기준으로 삼아야 됨. ///////
	CTwinVector tvStt;
	tvStt.m_v2	= tvArrStt.GetAt(0).m_v1;
	tvStt.m_v1	= tvArrStt.GetAt(tvArrStt.GetSize()-1).m_v2;
	double dStaSmallest	= dStaOld;
	double dW	= GetWidthSlabAct(dStaSmallest, CDPoint(0, 1), 0);
	if(bUseMatchSta)
	{
		tvStt.m_v1	= GetXySlabEdgeAct(dStaOld, CDPoint(0, 1), FALSE);
		tvStt.m_v2	= GetXySlabEdgeAct(dStaOld, CDPoint(0, 1), TRUE);
		rb.RotateXy(tvStt.m_v1, xyOrg, dAng);
		rb.RotateXy(tvStt.m_v2, xyOrg, dAng);
	}

	GetXyMatchLineAndLine(tvStt.m_v1, tvStt.GetXyDir(), CDPoint(0, tvStt.GetXyMid().y+dW/2), CDPoint(1, 0), xyMatch);
	tvStt.m_v2	= xyMatch;
	GetXyMatchLineAndLine(tvStt.m_v1, tvStt.GetXyDir(), CDPoint(0, tvStt.GetXyMid().y-dW/2), CDPoint(1, 0), xyMatch);
	tvStt.m_v1	= xyMatch;
	////////////////////////////////////////////////////

	for(s = 0; s < 3; s++)
	{
		dArrMainY[s].Add(tvStt.m_v1.y);
		dArrMainY[s].Add(tvStt.m_v2.y);
		if(!bUpper)
		{
			dArrHunchY[s].Add(tvStt.m_v1.y);
			dArrHunchY[s].Add(tvStt.m_v2.y);
		}
	}


	// y좌표 정렬 위에서 아래로
	for(s = 0; s < 3; s++)
	{
		dArrMainY[s].Sort(FALSE);
		dArrHunchY[s].Sort(FALSE);

		// 중복좌표 제거
		for(i = 0; i < dArrMainY[s].GetSize()-1; i++)
		{
			if(Compare(dArrMainY[s].GetAt(i), dArrMainY[s].GetAt(i+1), "="))
			{
				dArrMainY[s].RemoveAt(i+1);
				i--;
			}
		}
		for(i = 0; i < dArrHunchY[s].GetSize()-1; i++)
		{
			if(Compare(dArrHunchY[s].GetAt(i), dArrHunchY[s].GetAt(i+1), "="))
			{
				dArrHunchY[s].RemoveAt(i+1);
				i--;
			}
		}
	}

	// 4. 보관된 y좌표로 횡단면에 그려질 간격을 구한다.
	// 중심선시작점에서의 떨어진 거리임.
	CDoubleArray dArrMainDist[3], dArrHunchDist[3];

	for(s = 0; s < 3; s++)
	{
		for(i = 0; i < dArrMainY[s].GetSize(); i++)
		{
			double dY	= dArrMainY[s].GetAt(i);
			dArrMainDist[s].Add(tvStt.m_v1.y-dY);
		}
		for(i = 0; i < dArrHunchY[s].GetSize(); i++)
			dArrHunchDist[s].Add(tvStt.m_v1.y-dArrHunchY[s].GetAt(i));
	}

	// 떨어진 거리를 이용해 실제 위치로 옮김
	CTwinVectorArray tvArrCross;
	GetTvCrossSectionLowerSlab(tvArrCross, dStaOld, CDPoint(0, 1), 0, TRUE, FALSE);
	CDRect rect	= tvArrCross.GetRect();
	for(s = 0; s < 3; s++)
	{
		for(i = 0; i < dArrMainDist[s].GetSize(); i++)
			dArrMainDist[s].SetAt(i, rect.left-dArrMainDist[s].GetAt(i));
		for(i = 0; i < dArrHunchDist[s].GetSize(); i++)
			dArrHunchDist[s].SetAt(i, rect.left-dArrHunchDist[s].GetAt(i));
	}

	// 5. 횡단면에 그려지는 좌표를 구하자.
	// 실제 횡단면 배력근에 수직으로 뻗어서 붙이면 끝.
	CTwinVectorArray tvArrSup, tvArrSupLeft, tvArrSupRight, tvArrSupHunch;
	GetTvRebarSupport_CrossSection_LowerSlab(tvArrSup, tvArrSupLeft, tvArrSupRight, dStaOld, bUpper, nDan, 0, TRUE, FALSE, FALSE, 0, bMirror);
	GetTvRebarSupport_CrossSection_LowerSlabHunch(tvArrSupHunch, dStaOld, nDan, 0, TRUE, FALSE, FALSE, 0, bMirror);

	// 곡선일 경우 교차점 안 찾아 지는 경우 있다.
	// 피복 보다 작을 정도로 늘려주자.
	CDRect rectSup	= tvArrSup.GetRect();
	CDRect rectStrecth	= rectSup;
	rectStrecth.top += 10;
	rectStrecth.bottom -= 10;

	rectStrecth.left	= rectSup.right - 10;
	rectStrecth.right	= rectSup.right + 10;
	rb.StretchTvArr(tvArrSup, rectStrecth, CDPoint(20, 0));		// 32493 : Stretch 값 조정

	rectStrecth.left	= rectSup.left - 10;
	rectStrecth.right	= rectSup.left + 10;
	rb.StretchTvArr(tvArrSup, rectStrecth, CDPoint(-25, 0));	// 32493 : Stretch 값 조정

	for(s = 0; s < 3; s++)
	{
		long nType	= 0;
		switch(s)
		{
		case 0: nType = 0; break;
		case 1: nType = -1; break;
		case 2: nType = 1; break;
		}
		if(tvArrSup.GetSize() > 0)
		{
			CDPointArray xyArrMatch;
			long i = 0; for(i = 0; i < dArrMainDist[s].GetSize(); i++)
			{
				rb.GetXyMatchTvArrAndLine(tvArrSup, CDPoint(dArrMainDist[s].GetAt(i), 0), CDPoint(0, 1), xyArrMatch);
				if(xyArrMatch.GetSize() > 0)
				{
					CVector xy	= xyArrMatch.GetAt(0);
					xy.z	= nType;

					xyArr.Add(xy);
				}
			}
		}

		if(tvArrSupHunch.GetSize() > 0)
		{
			CDPointArray xyArrMatch;
			long i = 0; for(i = 0; i < dArrHunchDist[s].GetSize(); i++)
			{
				rb.GetXyMatchTvArrAndLine(tvArrSupHunch, CDPoint(dArrHunchDist[s].GetAt(i), 0), CDPoint(0, 1), xyArrMatch);
				if(xyArrMatch.GetSize() > 0)
				{
					CVector xy	= xyArrMatch.GetAt(0);
					xy.z	= nType;
					xyArrHunch.Add(xy);
				}

			}
		}
	}


	// 철근반지름만큼 상하로 이동
	if(bUpper)
	{
		rb.MoveRebar(xyArr, CDPoint(0, 1)*REBAR_RADIUS);
		rb.MoveRebar(xyArrHunch, CDPoint(0, 1)*REBAR_RADIUS);
	}
	else
	{
		rb.MoveRebar(xyArr, CDPoint(0, -1)*REBAR_RADIUS);
	}
}

long CRcBridgeRebar::GetMaxWingWallDan(BOOL bStt, BOOL bLeft, long nOut)
{
	CWingWall* pWing = GetWingWall(bStt, bLeft);

	long nMaxAB = max(pWing->m_nCountLayerA[nOut], pWing->m_nCountLayerB[nOut]);
	long nMaxCD = max(pWing->m_nCountLayerC[nOut], pWing->m_nCountLayerD[nOut]);
	long nMaxDan = max(nMaxAB, nMaxCD);

	return nMaxDan;
}

void CRcBridgeRebar::SetDataDefaultRebarJewon_LowerSlab_Support()
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();
	const double dMulti = bLsd? 10 : 1;

	CHgBaseConcStd baseConc;
	CRebarPlacing rb;
	CTwinVectorArray tvArr, tvArrAngStt, tvArrAngEnd, tvArrRAngStt, tvArrRAngEnd;
	CTwinVectorArray tvArrCross, tvArrMid, tvArrLeft, tvArrRight;
	CTwinVectorArray tvArrExpSttLAndR, tvArrExpSttLOrR;
	CTwinVectorArray tvArrExpEndLAndR, tvArrExpEndLOrR;

	double dLenMax(0), dLenMin(0), dLenDiff(0);
	double dCover(0);
	double dRebarSpace	= 0;
// 	double dRateLenPyungSlopAndPlane	= 1.0;	// 편구배 고려된 길이와 평면상의 길이와의 비..

	// 편구배 고려된 길이와 평면상 길이와의 비율을 계산해서 평면상의 길이에 적용하자!!! ///
	GetTvCrossSection(tvArrCross, m_dStationBridgeStt, CDPoint(0, 1), FALSE, FALSE, FALSE, 0, FALSE, FALSE, FALSE, TRUE);
	double dRateLenPyungSlopAndPlane	= tvArrCross.GetLength() / tvArrCross.GetHorLength();
	//////////////////////////////////////////////////////////////////////////////////////////

	// 횡단면 상에서 배력근의 좌우측 높이 //////////////////////////
	// 이것이 곳 상부슬래브 배력근 B값이나 C값이 된다.
	double dHeightRebarLeft		= 0;
	double dHeightRebarRight	= 0;
	double dSta	= GetStationSmallestWidthOfUpperSlab();
	GetTvRebarSupport_CrossSection_LowerSlab(tvArrMid, tvArrLeft, tvArrRight, dSta, TRUE, 0, 0, TRUE, TRUE);
	if(tvArrLeft.GetSize() > 0)
	{
		dHeightRebarLeft	= tvArrLeft.GetAt(0).GetLength();
	}
	else if(tvArrMid.GetSize() > 0)
	{
		dHeightRebarLeft	= tvArrMid.GetAt(0).GetLength();
	}

	if(tvArrRight.GetSize() > 0)
	{
		dHeightRebarRight	= tvArrRight.GetAt(tvArrRight.GetSize()-1).GetLength();
	}
	else if(tvArrMid.GetSize() > 0)
	{
		dHeightRebarRight	= tvArrMid.GetAt(tvArrMid.GetSize()-1).GetLength();
	}
	BOOL bSameHeight	= Compare(dHeightRebarLeft, dHeightRebarRight, "=");
	//////////////////////////////////////////////////////////////////

	long upper = 0; for(upper = 0; upper < 2; upper++)
	{
		BOOL bUpper		= upper == iUPPER;
		CString sUpdn	= bUpper ? "상면" : "하면";
		long nTypeRebar	= bUpper ? LS_REBAR_S_U1 : LS_REBAR_S_L1;

		long dan = 0; for(dan = 0; dan < MAX_REBAR_DAN; dan++)
		{
			dCover		= bUpper ? m_dCoverUpper_LowerSlab[dan] : m_dCoverLower_LowerSlab[dan];
			dRebarSpace	= GetCTCRebarSupport_Slab(FALSE, TRUE, 0, TRUE);

			GetTvRebarSupport_Plane_Slab_Std(FALSE, tvArr, tvArrAngStt, tvArrAngEnd, tvArrRAngStt, tvArrRAngEnd, bUpper, dan, 0);
			if(m_bIsExp)
				DivideRebarSupport_Plane_UpperSlabExpSection(tvArr, tvArrExpSttLAndR, tvArrExpSttLOrR, tvArrExpEndLAndR, tvArrExpEndLOrR);

			CPlaceRebarByBlock *pPlace	= &m_placeByBlock_SupportRebar_LowerSlab[upper][dan];

			if(!bUpper)
			{
				double dCover		= m_dCoverLower_LowerSlab[0];
				double dRebarSpace	=  GetCTCRebarSupport_Slab(FALSE, bUpper, dan, TRUE);

				// ang == 0 : 기본철근
				// ang == 1 : 시점좌측우측 모두 교차되는 철근
				// ang == 2 : 시점좌측이나 우측 한 곳만 교차되는 철근
				// ang == 3 : 종점좌측우측 모두 교차되는 철근
				// ang == 4 : 시점좌측이나 우측 한 곳만 교차되는 철근
				CTwinVectorArray *pTvArr	= NULL;
				for(long ang = 0; ang < 5; ang++)
				{
					if(!m_bIsExp && ang > 0) break;
					switch(ang)
					{
					case 0: pTvArr	= &tvArr; break;
					case 1: pTvArr	= &tvArrExpSttLAndR; break;
					case 2: pTvArr	= &tvArrExpSttLOrR; break;
					case 3: pTvArr	= &tvArrExpEndLAndR; break;
					case 4: pTvArr	= &tvArrExpEndLOrR; break;
					default: break;
					}
					if(!pTvArr) continue;
					if(pTvArr->GetSize() == 0) continue;

					dLenMax		= pTvArr->GetLengthMax();
					dLenMin		= pTvArr->GetLengthMin();

					// 하부슬래브 하면 배력근 기본철근(사보강시 직방향 철근이나, 선형방향시 나오는 철근)
					CRebar *pRB	= new CRebar;
					pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
					if(ang == 0)
						pRB->m_sDescription.Format("하부슬래브 %s %d단 배력철근", sUpdn, dan+1);
					else
						pRB->m_sDescription.Format("하부슬래브 %s %d단 배력철근%d", sUpdn, dan+1, 5+ang);
					pRB->m_sMark		= GetMarkRebarSupport(nTypeRebar+dan, FALSE, TRUE, FALSE);
					pRB->m_dDia			= pPlace->m_dDia;
					pRB->m_dLengthMax_A	= dLenMax * dRateLenPyungSlopAndPlane;
					pRB->m_dLengthMin_A	= dLenMin * dRateLenPyungSlopAndPlane;
					if(bSameHeight)
					{
						pRB->m_dLengthMax_B	= dHeightRebarLeft;
						pRB->m_nTypeRebar	= 3;
					}
					else
					{
						pRB->m_dLengthMax_B	= dHeightRebarLeft;
						pRB->m_dLengthMax_C	= dHeightRebarRight;
						pRB->m_nTypeRebar	= 4;
					}
					pRB->m_bMainRebar	= FALSE;
					pRB->m_nEa			= pTvArr->GetSize();
					baseConc.OptimizationRebar(pRB);	// 철근 최적화
					SetRebarLsdOptionSlab(pRB->m_pOptionLsd, FALSE, bUpper, FALSE, 0, dan);
					if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
					m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
					pRB->m_dRateAdd	= MAKE_RATE;
					AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
				}


				// 상부슬래브 상면 배력근 시점측 철근1(사보강시 시점측 사방향 철근)
				if(tvArrAngStt.GetSize() > 0)
				{
					dLenMax	= tvArrAngStt.GetLengthMax();
					dLenMin	= tvArrAngStt.GetLengthMin();

					CRebar *pRB	= new CRebar;
					pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
					pRB->m_sDescription.Format("하부슬래브 %s %d단 배력철근2", sUpdn, dan+1);
					pRB->m_sMark		= GetMarkRebarSupport(nTypeRebar+dan, FALSE, TRUE, FALSE);
					pRB->m_dDia			= pPlace->m_dDia;
					pRB->m_dLengthMax_A	= dLenMax * dRateLenPyungSlopAndPlane;
					pRB->m_dLengthMin_A	= dLenMin * dRateLenPyungSlopAndPlane;
					if(bSameHeight)
					{
						pRB->m_dLengthMax_B	= dHeightRebarLeft;
						pRB->m_nTypeRebar	= 3;
					}
					else
					{
						pRB->m_dLengthMax_B	= dHeightRebarLeft;
						pRB->m_dLengthMax_C	= dHeightRebarRight;
						pRB->m_nTypeRebar	= 4;
					}
					pRB->m_bMainRebar	= FALSE;
					pRB->m_nEa			= tvArrAngStt.GetSize();
					baseConc.OptimizationRebar(pRB);	// 철근 최적화
					SetRebarLsdOptionSlab(pRB->m_pOptionLsd, FALSE, bUpper, FALSE, 0, dan);
					if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
					m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
					pRB->m_dRateAdd	= MAKE_RATE;
					AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
				}


				// 상부슬래브 상면 배력근 종점측 철근1(사보강시 종점측 사방향 철근)
				if(tvArrAngEnd.GetSize() > 0)
				{
					dLenMax	= tvArrAngEnd.GetLengthMax();
					dLenMin	= tvArrAngEnd.GetLengthMin();

					CRebar *pRB	= new CRebar;
					pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
					pRB->m_sDescription.Format("하부슬래브 %s %d단 배력철근3", sUpdn, dan+1);
					pRB->m_sMark		= GetMarkRebarSupport(nTypeRebar+dan, FALSE, TRUE, FALSE);
					pRB->m_dDia			= pPlace->m_dDia;
					pRB->m_dLengthMax_A	= dLenMax * dRateLenPyungSlopAndPlane;
					pRB->m_dLengthMin_A	= dLenMin * dRateLenPyungSlopAndPlane;
					if(bSameHeight)
					{
						pRB->m_dLengthMax_B	= dHeightRebarLeft;
						pRB->m_nTypeRebar	= 3;
					}
					else
					{
						pRB->m_dLengthMax_B	= dHeightRebarLeft;
						pRB->m_dLengthMax_C	= dHeightRebarRight;
						pRB->m_nTypeRebar	= 4;
					}
					pRB->m_nEa			= tvArrAngEnd.GetSize();
					baseConc.OptimizationRebar(pRB);	// 철근 최적화
					SetRebarLsdOptionSlab(pRB->m_pOptionLsd, FALSE, bUpper, FALSE, 0, dan);
					if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
					m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
					pRB->m_dRateAdd	= MAKE_RATE;
					AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
				}

				// 상부슬래브 상면 배력근 시점측 철근2(사보강시 시점측 직방향 철근)
				if(tvArrRAngStt.GetSize() > 0)
				{
					dLenMax	= tvArrRAngStt.GetLengthMax();
					dLenMin	= tvArrRAngStt.GetLengthMin();

					CRebar *pRB	= new CRebar;
					pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
					pRB->m_sDescription.Format("하부슬래브 %s %d단 배력철근4", sUpdn, dan+1);
					pRB->m_sMark		= GetMarkRebarSupport(nTypeRebar+dan, FALSE, TRUE, FALSE);
					pRB->m_dDia			= pPlace->m_dDia;
					pRB->m_dLengthMax_A	= dLenMax * dRateLenPyungSlopAndPlane;
					pRB->m_dLengthMin_A	= dLenMin * dRateLenPyungSlopAndPlane;
					if(bSameHeight)
					{
						pRB->m_dLengthMax_B	= dHeightRebarLeft;
						pRB->m_nTypeRebar	= 3;
					}
					else
					{
						pRB->m_dLengthMax_B	= dHeightRebarLeft;
						pRB->m_dLengthMax_C	= dHeightRebarRight;
						pRB->m_nTypeRebar	= 4;
					}
					pRB->m_nEa			= tvArrRAngStt.GetSize();
					baseConc.OptimizationRebar(pRB);	// 철근 최적화
					SetRebarLsdOptionSlab(pRB->m_pOptionLsd, FALSE, bUpper, FALSE, 0, dan);
					if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
					m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
					pRB->m_dRateAdd	= MAKE_RATE;
					AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
				}

				// 상부슬래브 상면 배력근 종점측 철근2(사보강시 종점측 직방향 철근)
				if(tvArrRAngStt.GetSize() > 0)
				{
					dLenMax	= tvArrRAngEnd.GetLengthMax();
					dLenMin	= tvArrRAngEnd.GetLengthMin();

					CRebar *pRB	= new CRebar;
					pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
					pRB->m_sDescription.Format("하부슬래브 %s %d단 배력철근5", sUpdn, dan+1);
					pRB->m_sMark		= GetMarkRebarSupport(nTypeRebar+dan, FALSE, TRUE, FALSE);
					pRB->m_dDia			= pPlace->m_dDia;
					pRB->m_dLengthMax_A	= dLenMax * dRateLenPyungSlopAndPlane;
					pRB->m_dLengthMin_A	= dLenMin * dRateLenPyungSlopAndPlane;
					if(bSameHeight)
					{
						pRB->m_dLengthMax_B	= dHeightRebarLeft;
						pRB->m_nTypeRebar	= 3;
					}
					else
					{
						pRB->m_dLengthMax_B	= dHeightRebarLeft;
						pRB->m_dLengthMax_C	= dHeightRebarRight;
						pRB->m_nTypeRebar	= 4;
					}
					pRB->m_bMainRebar	= FALSE;
					pRB->m_nEa			= tvArrRAngEnd.GetSize();
					baseConc.OptimizationRebar(pRB);	// 철근 최적화
					SetRebarLsdOptionSlab(pRB->m_pOptionLsd, FALSE, bUpper, FALSE, 0, dan);
					if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
					m_Util.SetLengthRebar(pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
					pRB->m_dRateAdd	= MAKE_RATE;
					AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
				}
			}
			else
			{
				// 하면 desc에 붙은 배력철근뒤의 숫자는 1,2,3으로 하면철근 좌측캔티레버좌 : 1, 중간 : 2, 우 : 3으로 나누기 위해 구분함.
				double dSta	= GetStationSmallestWidthOfUpperSlab();
				GetTvRebarSupport_CrossSection_LowerSlab(tvArrMid, tvArrLeft, tvArrRight, dSta, bUpper, dan, 0,TRUE, TRUE, TRUE, 1, FALSE);

				// i == 0 : tvArrLeft, 1 : tvArrMid, 2 : tvArrRight
				// tvArrMid는 철근타입 파악의 정확성을 위해서 철근의 하부쪽에 있는 것들을 수평선으로 변경해준다.
				double dLen	= 0;
				long nIdx	= -1;
				CTwinVector tvLower, tv;
				long i = 0; for(i = 0; i < tvArrMid.GetSize(); i++)
				{
					tv	= tvArrMid.GetAt(i);
					if(tv.m_sInfo.Find("슬래브하부", 0) != -1)
					{
						if(nIdx == -1)
						{
							nIdx = i;
							tvLower	 = tv;
						}
						dLen += tvArrMid.GetAt(i).GetLength();
						tvArrMid.RemoveAt(i);
						i--;
					}
				}

				if(nIdx > -1)
				{
					tvLower.m_v2 = tvLower.m_v1 + CDPoint(dLen, 0);
					tvArrMid.InsertAt(nIdx, tvLower);

					//#0029964 - tvArrMid 철근이 끊겨져 있어 철근제원이 정상적으로 표현되어 있지 않았다. 슬래브 하부가 경사가 되어 있는데 이것을 강제적으로 직선으로 표현하다보니 슬래브우측면 횡단의 CTwinVector가 떨어져있게 됨
					tv	= tvArrMid.GetAt(tvArrMid.GetSize() - 1);

					if(tv.m_sInfo.Find("슬래브우측면 횡단", 0) != -1)
					{
						if(ComparePt(tvLower.m_v2, tv.m_v1, "=", 0.001) == FALSE)
						{
							//슬래브우측면 횡단이 90도가 되지않아 상세를 찾지 못함... (90.02도정도...)
							CDPoint xyMove = (CDPoint)tvLower.m_v2 - (CDPoint)tv.m_v1;

							CRebarPlacing rp;

							tv.m_v1 += xyMove;
							tv.m_v2 += xyMove;

							//90도로 강제 조정
							double dAng = tv.GetXyDir().GetAngleDegree();

							if(dAng != 90 && dAng != 270)
							{
								tv.m_v2.x = tv.m_v1.x;
							}

							tvArrMid.SetAt(tvArrMid.GetSize() - 1, tv);
						}
					}
				}

				// ang == 0 : 기본철근
				// ang == 1 : 시점좌측우측 모두 교차되는 철근
				// ang == 2 : 시점좌측이나 우측 한 곳만 교차되는 철근
				// ang == 3 : 종점좌측우측 모두 교차되는 철근
				// ang == 4 : 시점좌측이나 우측 한 곳만 교차되는 철근
				CTwinVectorArray *pTvArr	= NULL;

				for(long ang = 0; ang < 5; ang++)
				{
					if(!m_bIsExp && ang > 0) break;
					switch(ang)
					{
					case 0: pTvArr	= &tvArr; break;
					case 1: pTvArr	= &tvArrExpSttLAndR; break;
					case 2: pTvArr	= &tvArrExpSttLOrR; break;
					case 3: pTvArr	= &tvArrExpEndLAndR; break;
					case 4: pTvArr	= &tvArrExpEndLOrR; break;
					default: break;
					}
					if(!pTvArr) continue;
					if(pTvArr->GetSize() == 0) continue;

					double dLenDiffExpAndNormal	= pTvArr->GetLengthMax() - tvArr.GetLengthMax();	// 일반과 가각과의 길이차이
					dLenDiff	= pTvArr->GetLengthMax() - pTvArr->GetLengthMin();	// 평면상에서 최대와 최소의 차이

					// o == 0, 2 : 캔티레버일때 좌우에 하나씩 뻗는 철근.
					for(i = 0; i < 3; i++)
					{
						// 캔티레버부의 철근은 한번에 집계한다.(어짜피 길이가 모두 같을 테니까)
						if(ang > 0 && (i == 0 || i == 2)) continue;

						CTwinVectorArray tvArrTmp;
						switch(i)
						{
						case 0 : tvArrTmp = tvArrLeft; break;
						case 1 : tvArrTmp = tvArrMid; break;
						case 2 : tvArrTmp = tvArrRight; break;
						default : break;
						}
						if(tvArrTmp.GetSize() == 0) continue;

						CRebar *pRB	= new CRebar;
						pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
						CRebarType rt;

						rt.SetRebar(tvArrTmp, FALSE);
						rt.SetRB(pRB);
						baseConc.OptimizationRebar(pRB);

						//m_Util.GetRebarType(pRB, tvArrTmp);
						// mid일때 가장 긴 값은 최소 최대 값이 생길 수 있다.
						if(i == 1)
						{
							double dMax	= max(pRB->m_dLengthMax_A, max(pRB->m_dLengthMax_B, max(pRB->m_dLengthMax_C, pRB->m_dLengthMax_D)));
							if(Compare(dMax, pRB->m_dLengthMax_A, "=")) 
							{
								pRB->m_dLengthMax_A	+= dLenDiffExpAndNormal;
								pRB->m_dLengthMin_A = pRB->m_dLengthMax_A - dLenDiff;
							}
							else if(Compare(dMax, pRB->m_dLengthMax_B, "=")) 
							{
								pRB->m_dLengthMax_B += dLenDiffExpAndNormal;
								pRB->m_dLengthMin_B = pRB->m_dLengthMax_B - dLenDiff;
							}
							else if(Compare(dMax, pRB->m_dLengthMax_C, "=")) 
							{
								pRB->m_dLengthMax_C += dLenDiffExpAndNormal;
								pRB->m_dLengthMin_C = pRB->m_dLengthMax_C - dLenDiff;
							}
							else if(Compare(dMax, pRB->m_dLengthMax_D, "=")) 
							{
								pRB->m_dLengthMax_D += dLenDiffExpAndNormal;
								pRB->m_dLengthMin_D = pRB->m_dLengthMax_D - dLenDiff;
							}
						}
						if(ang == 0)
							pRB->m_sDescription.Format("하부슬래브 %s %d단 배력철근%d", sUpdn, dan+1, i+1);
						else
							pRB->m_sDescription.Format("하부슬래브 %s %d단 배력철근2_%d", sUpdn, dan+1, 5+ang);
						pRB->m_dDia			= pPlace->m_dDia;
						pRB->m_sMark.Format("%s", GetMarkRebarSupport(nTypeRebar+dan, FALSE, TRUE, FALSE));
						pRB->m_bMainRebar	= FALSE;
						pRB->m_nEa			= (i == 1) ? pTvArr->GetSize() : 
							tvArr.GetSize() + tvArrAngStt.GetSize() + 
							tvArrAngEnd.GetSize() + tvArrExpSttLAndR.GetSize() +
							tvArrExpSttLOrR.GetSize() + tvArrExpEndLAndR.GetSize() + 
							tvArrExpEndLOrR.GetSize();
						baseConc.OptimizationRebar(pRB);	// 철근 최적화
						SetRebarLsdOptionSlab(pRB->m_pOptionLsd, FALSE, bUpper, FALSE, 0, dan);
						if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
						m_Util.SetLengthRebar(pRB, (m_nSelectJointUpperRange == 0)? JOINT_TENS_UPPER_B:JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
						pRB->m_dRateAdd	= MAKE_RATE;

						AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
					}
				}


				dLenDiff	= tvArr.GetLengthMax() - tvArr.GetLengthMin();

				dLenMax	= pTvArr->GetLengthMax();
				dLenMin	= pTvArr->GetLengthMin();
				// 상부슬래브 하면 배력근 시점측 철근1(사보강시 시점측 사방향 철근)
				if(tvArrAngStt.GetSize() > 0)
				{
					double dMaxTmp	= tvArrAngStt.GetLengthMax();
					double dMinTmp	= tvArrAngStt.GetLengthMin();

					// (ARCBRIDGE-3570) 하부슬래브는 슬래브 좌우의 캔틸래버부 형상 때문에 평면에서 뽑은 길이를 직접 쓸수 없다.
					// 그래서 횡단에서 길이를 뽑고 횡단 길이와 평면 길이의 차이를 더이해주는 방식인데 
					// 횡단 적용좌표인 tvArrMid의 위치와 조정을 위한 평면 좌표인tvArr의 위치가 일치하지 않는다.
					// dLenMax를 횡단의 수평길이를 쓰고 dLenMin은 사용하지 않으며 dMinTmp를 쓴다.

					dLenMax = tvArrMid.GetHorLength();
					dLenDiff	= dMaxTmp - dMinTmp;
					dLenMin = dLenMax - dLenDiff;

					CRebar *pRB	= new CRebar;
					pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
					CRebarType rt;
					rt.SetRebar(tvArrMid, FALSE);
					rt.SetRB(pRB);
					baseConc.OptimizationRebar(pRB);
					//m_Util.GetRebarType(pRB, tvArrMid);

					double dMax	= max(pRB->m_dLengthMax_A, max(pRB->m_dLengthMax_B, max(pRB->m_dLengthMax_C, pRB->m_dLengthMax_D)));
					if(Compare(dMax, pRB->m_dLengthMax_A, "=")) pRB->m_dLengthMin_A = pRB->m_dLengthMax_A - dLenDiff;
					else if(Compare(dMax, pRB->m_dLengthMax_B, "=")) pRB->m_dLengthMin_B = pRB->m_dLengthMax_B - dLenDiff;
					else if(Compare(dMax, pRB->m_dLengthMax_C, "=")) pRB->m_dLengthMin_C = pRB->m_dLengthMax_C - dLenDiff;
					else if(Compare(dMax, pRB->m_dLengthMax_D, "=")) pRB->m_dLengthMin_D = pRB->m_dLengthMax_D - dLenDiff;

					if(pRB->m_nTypeRebar == 87)
					{
						pRB->m_dLengthMax_B	= pRB->m_dLengthMax_B + (dMaxTmp - dLenMax);

						if(!Compare(pRB->m_dLengthMin_B, 0.0, "="))
							pRB->m_dLengthMin_B = pRB->m_dLengthMin_B + (dMinTmp - dLenMin);
					}
					else
					{
						pRB->m_dLengthMax_A	= pRB->m_dLengthMax_A + (dMaxTmp - dLenMax);

						if(!Compare(pRB->m_dLengthMin_A, 0.0, "="))
							pRB->m_dLengthMin_A = pRB->m_dLengthMin_A + (dMinTmp - dLenMin);
					}

					// 사방향 철근임(R에도 사거리 적용함)
					if(pRB->m_nTypeRebar == 7)
					{
						CDPoint vAng	= GetAngleJijum(0);
						pRB->m_dLengthMax_B	= pRB->m_dLengthMax_B/vAng.y;
						pRB->m_dLengthMin_B	= pRB->m_dLengthMin_B/vAng.y;

						double dR	= m_dRE1[0]-m_dCoverLower_UpperSlab[0];
						pRB->m_dLengthMax_A -= ((dR / vAng.y) - dR) * 2;
						if(!Compare(pRB->m_dLengthMin_A, 0.0, "="))
							pRB->m_dLengthMin_A	-= ((dR / vAng.y) - dR) * 2;
					}

					pRB->m_sDescription.Format("하부슬래브 %s %d단 배력철근2_2", sUpdn, dan+1);
					pRB->m_dDia			= pPlace->m_dDia;
					pRB->m_sMark.Format("%s", GetMarkRebarSupport(nTypeRebar+dan, FALSE, TRUE, FALSE));
					pRB->m_bMainRebar	= FALSE;
					pRB->m_nEa			= tvArrAngStt.GetSize();
					baseConc.OptimizationRebar(pRB);	// 철근 최적화
					SetRebarLsdOptionSlab(pRB->m_pOptionLsd, FALSE, bUpper, FALSE, 0, dan);
					if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
					m_Util.SetLengthRebar(pRB, (m_nSelectJointUpperRange == 0)? JOINT_TENS_UPPER_B:JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
					pRB->m_dRateAdd	= MAKE_RATE;
					AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
				}

				// 상부슬래브 하면 배력근 종점측 철근1(사보강시 종점측 사방향 철근)
				if(tvArrAngEnd.GetSize() > 0)
				{
					double dMaxTmp	= tvArrAngEnd.GetLengthMax();
					double dMinTmp	= tvArrAngEnd.GetLengthMin();

					// (ARCBRIDGE-3570) 
					dLenMax = tvArrMid.GetHorLength();
					dLenDiff	= dMaxTmp - dMinTmp;
					dLenMin = dLenMax - dLenDiff;

					CRebar *pRB	= new CRebar;
					pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
					CRebarType rt;
					rt.SetRebar(tvArrMid, FALSE);
					rt.SetRB(pRB);
					baseConc.OptimizationRebar(pRB);
					//m_Util.GetRebarType(pRB, tvArrMid);

					double dMax	= max(pRB->m_dLengthMax_A, max(pRB->m_dLengthMax_B, max(pRB->m_dLengthMax_C, pRB->m_dLengthMax_D)));
					if(Compare(dMax, pRB->m_dLengthMax_A, "=")) pRB->m_dLengthMin_A = pRB->m_dLengthMax_A - dLenDiff;
					else if(Compare(dMax, pRB->m_dLengthMax_B, "=")) pRB->m_dLengthMin_B = pRB->m_dLengthMax_B - dLenDiff;
					else if(Compare(dMax, pRB->m_dLengthMax_C, "=")) pRB->m_dLengthMin_C = pRB->m_dLengthMax_C - dLenDiff;
					else if(Compare(dMax, pRB->m_dLengthMax_D, "=")) pRB->m_dLengthMin_D = pRB->m_dLengthMax_D - dLenDiff;

					if(pRB->m_nTypeRebar == 87)
					{
						pRB->m_dLengthMax_B	= pRB->m_dLengthMax_B + (dMaxTmp - dLenMax);

						if(!Compare(pRB->m_dLengthMin_B, 0.0, "="))
							pRB->m_dLengthMin_B = pRB->m_dLengthMin_B + (dMinTmp - dLenMin);
					}
					else
					{
						pRB->m_dLengthMax_A	= pRB->m_dLengthMax_A + (dMaxTmp - dLenMax);

						if(!Compare(pRB->m_dLengthMin_A, 0.0, "="))
							pRB->m_dLengthMin_A = pRB->m_dLengthMin_A + (dMinTmp - dLenMin);
					}

					// 사방향 철근임(R에도 사거리 적용함)
					if(pRB->m_nTypeRebar == 7)
					{
						CDPoint vAng	= GetAngleJijum(m_nQtyJigan);
						pRB->m_dLengthMax_B	= pRB->m_dLengthMax_B/vAng.y;
						pRB->m_dLengthMin_B	= pRB->m_dLengthMin_B/vAng.y;

						double dR	= m_dRE1[0]-m_dCoverLower_UpperSlab[0];
						pRB->m_dLengthMax_A -= ((dR / vAng.y) - dR) * 2;
						if(!Compare(pRB->m_dLengthMin_A, 0.0, "="))
							pRB->m_dLengthMin_A	-= ((dR / vAng.y) - dR) * 2;
					}

					pRB->m_sDescription.Format("하부슬래브 %s %d단 배력철근2_3", sUpdn, dan+1);
					pRB->m_dDia			= pPlace->m_dDia;
					pRB->m_sMark.Format("%s", GetMarkRebarSupport(nTypeRebar+dan, FALSE, TRUE, FALSE));
					pRB->m_bMainRebar	= FALSE;
					pRB->m_nEa			= tvArrAngEnd.GetSize();
					baseConc.OptimizationRebar(pRB);	// 철근 최적화
					SetRebarLsdOptionSlab(pRB->m_pOptionLsd, FALSE, bUpper, FALSE, 0, dan);
					if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
					m_Util.SetLengthRebar(pRB, (m_nSelectJointUpperRange == 0)? JOINT_TENS_UPPER_B:JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
					pRB->m_dRateAdd	= MAKE_RATE;
					AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
				}

				// 상부슬래브 하면 배력근 시점측 철근2(사보강시 시점측 직방향 철근)
				if(tvArrRAngStt.GetSize() > 0)
				{
					double dMaxTmp	= tvArrRAngStt.GetLengthMax();
					double dMinTmp	= tvArrRAngStt.GetLengthMin();

					// (ARCBRIDGE-3570) 
					dLenMax = tvArrMid.GetHorLength();
					dLenDiff	= dMaxTmp - dMinTmp;
					dLenMin = dLenMax - dLenDiff;

					CRebar *pRB	= new CRebar;
					pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
					CRebarType rt;
					rt.SetRebar(tvArrMid, FALSE);
					rt.SetRB(pRB);
					baseConc.OptimizationRebar(pRB);
					//m_Util.GetRebarType(pRB, tvArrMid);

					double dMax	= max(pRB->m_dLengthMax_A, max(pRB->m_dLengthMax_B, max(pRB->m_dLengthMax_C, pRB->m_dLengthMax_D)));
					if(Compare(dMax, pRB->m_dLengthMax_A, "=")) pRB->m_dLengthMin_A = pRB->m_dLengthMax_A - dLenDiff;
					else if(Compare(dMax, pRB->m_dLengthMax_B, "=")) pRB->m_dLengthMin_B = pRB->m_dLengthMax_B - dLenDiff;
					else if(Compare(dMax, pRB->m_dLengthMax_C, "=")) pRB->m_dLengthMin_C = pRB->m_dLengthMax_C - dLenDiff;
					else if(Compare(dMax, pRB->m_dLengthMax_D, "=")) pRB->m_dLengthMin_D = pRB->m_dLengthMax_D - dLenDiff;

					if(pRB->m_nTypeRebar == 87)
					{
						pRB->m_dLengthMax_B	= pRB->m_dLengthMax_B + (dMaxTmp - dLenMax);

						if(!Compare(pRB->m_dLengthMin_B, 0.0, "="))
							pRB->m_dLengthMin_B = pRB->m_dLengthMin_B + (dMinTmp - dLenMin);
					}
					else
					{
						pRB->m_dLengthMax_A	= pRB->m_dLengthMax_A + (dMaxTmp - dLenMax);

						if(!Compare(pRB->m_dLengthMin_A, 0.0, "="))
							pRB->m_dLengthMin_A = pRB->m_dLengthMin_A + (dMinTmp - dLenMin);
					}

					pRB->m_sDescription.Format("하부슬래브 %s %d단 배력철근2_4", sUpdn, dan+1);
					pRB->m_dDia			= pPlace->m_dDia;
					pRB->m_sMark.Format("%s", GetMarkRebarSupport(nTypeRebar+dan, FALSE, TRUE, FALSE));
					pRB->m_bMainRebar	= FALSE;
					pRB->m_nEa			= tvArrRAngStt.GetSize();
					baseConc.OptimizationRebar(pRB);	// 철근 최적화
					SetRebarLsdOptionSlab(pRB->m_pOptionLsd, FALSE, bUpper, FALSE, 0, dan);
					if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
					m_Util.SetLengthRebar(pRB, (m_nSelectJointUpperRange == 0)? JOINT_TENS_UPPER_B:JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
					pRB->m_dRateAdd	= MAKE_RATE;
					AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
				}

				// 상부슬래브 하면 배력근 종점측 철근2(사보강시 종점측 직방향 철근)
				if(tvArrRAngEnd.GetSize() > 0)
				{
					double dMaxTmp	= tvArrRAngEnd.GetLengthMax();
					double dMinTmp	= tvArrRAngEnd.GetLengthMin();

					// (ARCBRIDGE-3570) 
					dLenMax = tvArrMid.GetHorLength();
					dLenDiff	= dMaxTmp - dMinTmp;
					dLenMin = dLenMax - dLenDiff;

					CRebar *pRB	= new CRebar;
					pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
					CRebarType rt;
					rt.SetRebar(tvArrMid, FALSE);
					rt.SetRB(pRB);
					baseConc.OptimizationRebar(pRB);
					//m_Util.GetRebarType(pRB, tvArrMid);

					double dMax	= max(pRB->m_dLengthMax_A, max(pRB->m_dLengthMax_B, max(pRB->m_dLengthMax_C, pRB->m_dLengthMax_D)));
					if(Compare(dMax, pRB->m_dLengthMax_A, "=")) pRB->m_dLengthMin_A = pRB->m_dLengthMax_A - dLenDiff;
					else if(Compare(dMax, pRB->m_dLengthMax_B, "=")) pRB->m_dLengthMin_B = pRB->m_dLengthMax_B - dLenDiff;
					else if(Compare(dMax, pRB->m_dLengthMax_C, "=")) pRB->m_dLengthMin_C = pRB->m_dLengthMax_C - dLenDiff;
					else if(Compare(dMax, pRB->m_dLengthMax_D, "=")) pRB->m_dLengthMin_D = pRB->m_dLengthMax_D - dLenDiff;
					if(pRB->m_nTypeRebar == 87)
					{
						pRB->m_dLengthMax_B	= pRB->m_dLengthMax_B + (dMaxTmp - dLenMax);

						if(!Compare(pRB->m_dLengthMin_B, 0.0, "="))
							pRB->m_dLengthMin_B = pRB->m_dLengthMin_B + (dMinTmp - dLenMin);
					}
					else
					{
						pRB->m_dLengthMax_A	= pRB->m_dLengthMax_A + (dMaxTmp - dLenMax);

						if(!Compare(pRB->m_dLengthMin_A, 0.0, "="))
							pRB->m_dLengthMin_A = pRB->m_dLengthMin_A + (dMinTmp - dLenMin);
					}

					pRB->m_sDescription.Format("하부슬래브 %s %d단 배력철근2_5", sUpdn, dan+1);
					pRB->m_dDia			= pPlace->m_dDia;
					pRB->m_sMark.Format("%s", GetMarkRebarSupport(nTypeRebar+dan, FALSE, TRUE, FALSE));
					pRB->m_bMainRebar	= FALSE;
					pRB->m_nEa			= tvArrRAngEnd.GetSize();
					baseConc.OptimizationRebar(pRB);	// 철근 최적화
					SetRebarLsdOptionSlab(pRB->m_pOptionLsd, FALSE, bUpper, FALSE, 0, dan);
					if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
					m_Util.SetLengthRebar(pRB, (m_nSelectJointUpperRange == 0)? JOINT_TENS_UPPER_B:JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
					pRB->m_dRateAdd	= MAKE_RATE;
					AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
				}

				// 상부인 경우 헌치부도 포함된다.
				if(dan == 0)
				{
					BOOL bIsHunch	= FALSE;
					// 헌치가 있는 sta 구함.
					double dSta	= m_dStationBridgeStt;
					long j = 0; for(j = 0; j <= m_nQtyJigan; j++)
					{
						if(IsHunch(j, TRUE))
						{
							bIsHunch	= TRUE;
							dSta	= GetStationOnJijum(j);
						}

					}
					if(!bIsHunch) continue;


					GetTvRebarSupport_CrossSection_LowerSlabHunch(tvArrMid, dSta, dan, 0, TRUE, TRUE, TRUE);
					GetTvRebarSupport_Plane_SlabHunch(tvArr, FALSE, 0, -1);

					if(tvArr.GetSize() > 0)
					{
						double dMax	= tvArr.GetLengthMax();
						double dMin	= tvArr.GetLengthMin();

						// 각 지점별로 헌치의 최대 높이와 최소 높이를 구함.
						dLenMax	= 0;
						dLenMin	= 0;
						for(long nJ = 0; nJ < GetCountJijum(); nJ++)
						{
							if(IsHunch(nJ, FALSE))
							{
								if(dLenMax==0)
								{
									dLenMax	= GetHeightHunchByJijum(nJ, FALSE);
									dLenMin	= GetHeightHunchByJijum(nJ, FALSE);
								}
								else
								{
									dLenMax	= max(GetHeightHunchByJijum(nJ, FALSE), dLenMax);
									dLenMin	= min(GetHeightHunchByJijum(nJ, FALSE), dLenMin);
								}
							}
						}

						CRebar *pRB	= new CRebar;
						pRB->m_Fy			= m_pARcBridgeDataStd->m_Fy;
						pRB->m_nTypeRebar	= 3;
						pRB->m_dLengthMax_A	= dMax * dRateLenPyungSlopAndPlane;
						pRB->m_dLengthMin_A	= dMin * dRateLenPyungSlopAndPlane;
						pRB->m_dLengthMax_B	= dLenMax;
						pRB->m_dLengthMin_B	= dLenMin;
						pRB->m_sDescription.Format("하부슬래브 헌치부 배력철근");
						pRB->m_dDia			= pPlace->m_dDia;
						pRB->m_sMark.Format("%s", GetMarkRebarSupport(nTypeRebar+dan, FALSE, TRUE, FALSE));
						pRB->m_bMainRebar	= FALSE;
						pRB->m_nEa			= tvArr.GetSize();
						baseConc.OptimizationRebar(pRB);	// 철근 최적화
						SetRebarLsdOptionSlab(pRB->m_pOptionLsd, FALSE, bUpper, FALSE, 0, dan);
						if(pRB->m_pOptionLsd->dFy > 0)		pRB->m_Fy = pRB->m_pOptionLsd->dFy * dMulti;
						m_Util.SetLengthRebar(pRB, (m_nSelectJointUpperRange == 0)? JOINT_TENS_UPPER_B:JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
						pRB->m_dRateAdd	= MAKE_RATE;
						AddOrDeleteRebarInList(&m_pArrRebarSupport, pRB);
					}
				}
			}
		}
	}

	SetDataDefaultRebarJewon_Slab_ObtuseSupportRebar(FALSE);
}

void CRcBridgeRebar::SetDataDefaultRebarJewon_LowerSlab_Shear()
{
	CARcBridgeDataStd *pStd	= m_pARcBridgeDataStd;
	const HGBOOL bLsd = pStd->IsLsdDesign();

	if(IsBoxType() == FALSE) return;

	CHgBaseConcStd baseConc;
	CBasicConcInfo concInfo;
	double dLenMaxA(0), dLenMinA(0);
	double dLenMaxB(0), dLenMinB(0);
//	double dLenMaxADanbuSt(0);

	double dCover(0);
	double dRebarSpace	= 0;

	dCover		= m_dCoverLower_LowerSlab[0];
	dRebarSpace	= GetCTCRebarShear_LowerSlab();


	// 전단철근이 들어가는 전체 스테이션을 구함.(벽체는 제외함(무조건 안들어간다 치고.))
	BOOL bVertDir	= IsVertDir();
	double dStaStt	= min(GetStationByTarget(BRIDGE_OFF_STT_STT, -1, TRUE), GetStationByTarget(BRIDGE_OFF_STT_STT, 1, TRUE));
	double dStaEnd	= max(GetStationByTarget(BRIDGE_OFF_END_END, -1, TRUE), GetStationByTarget(BRIDGE_OFF_END_END, 1, TRUE));
	if(bVertDir)
	{
		dStaStt	= GetStationOnJijum(0, 0, bVertDir);
		dStaEnd	= GetStationOnJijum(m_nQtyJigan, 0, bVertDir);
	}
	double dStaSttCen	= GetStationOnJijum(0, 0, bVertDir);
	double dStaEndCen	= GetStationOnJijum(m_nQtyJigan, 0, bVertDir);

	// 입력된 전단철근과 빈공간에 자동으로 넣을 전단철근의 sta들을 구함.
	// 전단철근 높이
	CTwinVectorArray tvArr, tvArrHunch;
	CTwinVectorArray tvArrTot;
	GetTvRebarShear_VertSection_LowerSlab(tvArr, tvArrHunch);
	tvArrTot.AddFromTvArray(tvArr);
	tvArrTot.AddFromTvArray(tvArrHunch);
	CDoubleArray dArrStaShear;
	
	double dCTC	= m_dCTC_ShearRebar[iLOWER];
	double dStaCur	= dStaSttCen - dCTC;
	while(dStaCur > dStaStt)
	{
		dArrStaShear.InsertAt(0, dStaCur);
		dStaCur -= dCTC;
	}
	long i = 0; for(i = 0; i < tvArr.GetSize(); i++)
		dArrStaShear.Add(tvArr.GetAt(i).m_v1.x);
	for(i = 0; i < tvArrHunch.GetSize(); i++)
		dArrStaShear.Add(tvArrHunch.GetAt(i).m_v1.x);
	dStaCur	= dStaEndCen + dCTC;
	while(dStaCur < dStaEnd)
	{
		dArrStaShear.Add(dStaCur);
		dStaCur += dCTC;
	}


	// 스테이션 별 슬래브 폭으로 전단철근 개수 구함
	long nCountTot	= 0;
	CTwinVectorArray tvArrPlane, tvArrPlaneOrg;
	GetTvRebarOut_Plane_UpperSlabStd(tvArrPlane, 0, TRUE);
	GetTvRebarOut_Plane_UpperSlabStd(tvArrPlaneOrg, 0, FALSE);

	CLineInfo *pLine	= GetLineBase(bVertDir);
	CDPoint vAngShear	= pLine->GetAngleAzimuth(dStaStt).Rotate90();
	CDPoint vAngLineOfShear	= CDPoint(0, 1);
	if(m_nTypePlacingSupportRebar_UpperSlab == 0)
	{
		vAngShear	= GetAngleAzimuthJijum(0);
		vAngLineOfShear	= GetAngleJijum(0, bVertDir);
	}
	else if(m_nTypePlacingSupportRebar_UpperSlab == 1)
	{
		vAngShear	= GetAngleAzimuthJijum(m_nQtyJigan);
		vAngLineOfShear	= GetAngleJijum(m_nQtyJigan, bVertDir);
	}



	CRebarPlacing rb;


	double dCTCMainRebar	= GetCtcRebarMain(FALSE)/vAngLineOfShear.y;

	// 원곡선인 경우 해당 sta의 폭중 최대 최소를 이용해서 전단철근의 최대최소 길이를 구해야 된다.
	// 10000을 기준으로 한 폭으로 계산함.
	double dStdWidth	= 10000;
	double dMaxWidth	= 0;
	double dMinWidth	= 0;
	BOOL bFirst	= TRUE;
	////////////////////////////////////////////////////////////////////////////////////////////////////
	BOOL bIncludeArc	= !IsIncludeOnlyLineInBridge();
	for(i = 0; i < dArrStaShear.GetSize(); i++)
	{
		double dSta	= dArrStaShear.GetAt(i);
		CDPoint xy	= pLine->GetXyLine(bVertDir ? dSta-m_dStationBridgeStt : dSta);
		CDPoint xyDir	= vAngShear;
		if(m_nTypePlacingSupportRebar_UpperSlab > 1 && bIncludeArc)
		{
			xyDir	= pLine->GetAngleAzimuth(bVertDir ? dSta-m_dStationBridgeStt : dSta).Rotate90();
		}

		CDPointArray xyArrMatch;
		rb.GetXyMatchTvArrAndLine(tvArrPlane, xy, xyDir, xyArrMatch);
		double dDist	= 0;
		if(xyArrMatch.GetSize() > 1)
		{

			long j = 0; for(j = 0; j < xyArrMatch.GetSize()-1; j++)
			{
				for(long k = j + 1; k < xyArrMatch.GetSize(); k++)
				{
					dDist = max(~(xyArrMatch.GetAt(j)-xyArrMatch.GetAt(k)), dDist);
				}
			}
		}

		if(dDist > 0)
		{
			long nCount	= (long)(dDist / (dCTCMainRebar * m_nCountWrapMainRebarLowerSlab));
			if(dDist - (dCTCMainRebar * m_nCountWrapMainRebarLowerSlab) > (dCTCMainRebar * m_nCountWrapMainRebarLowerSlab)/2)
				nCount ++;
			nCountTot += nCount;

			// 철근이 들어간 곳의 폭 구함.
			// 원곡선이고 배근방법이 시점이나 종점방향으로 배근 되었을 경우에만 구하면 된다
			// 그리고 사보강 배치가 아닐경우
			if(bIncludeArc && (m_nTypePlacingSupportRebar_UpperSlab == 0 || m_nTypePlacingSupportRebar_UpperSlab == 1) && !bVertDir)
			{
				CDPoint xy		= pLine->GetXyLine(dSta);
				double staL(0), staR(0);
				pLine->GetStationMatchByXyAndAngle(xy, vAngShear, staL, -dStdWidth/2);
				pLine->GetStationMatchByXyAndAngle(xy, vAngShear, staR, dStdWidth/2);
				CDPoint xyLeft	= pLine->GetXyLineDis(staL, -dStdWidth/2);
				CDPoint xyRight	= pLine->GetXyLineDis(staR, dStdWidth/2);
				if(bFirst)
				{
					dMaxWidth	= ~(xyLeft - xyRight);
					dMinWidth	= ~(xyLeft - xyRight);
					bFirst	= FALSE;
				}
				else
				{
					dMaxWidth	= max(~(xyLeft - xyRight), dMaxWidth);
					dMinWidth	= min(~(xyLeft - xyRight), dMinWidth);
				}
			}
		}
	}


	// 전체 개수를 구했으면 헌치부와 슬래브부의 철근 비율을 이용해서 평면상의 개수도 나눈다.
	double dRateNormal	= (double)tvArrTot.GetSize() / (double)tvArr.GetSize();
	long nCountNormal	= (long)((double)nCountTot / dRateNormal);
	long nCountHunch	= nCountTot - nCountNormal;

	// 정착장
	CPlaceRebarByBlock *pPlace	= &m_placeByBlock_ShearRebar_LowerSlab;
	double dSettle	= m_pARcBridgeDataStd->GetValueJoint((long)pPlace->m_dDia, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
	double dFck	= GetValueFck(ePartLowerSlab);
	double dFy	= GetValueFy(ePartLowerSlab, FALSE);

	double dDiaMainLower	= GetDiaMainRebarLowerSlab(0, 0, FALSE, 0, 0);
	double dDiaMainUpper	= GetDiaMainRebarLowerSlab(0, 0, TRUE, 0, 0);

	// 철근 길이 구해주자(현재 원곡선부분 빼고는 모두 같음)
	dLenMaxA	= dCTCMainRebar/2 * m_nCountWrapMainRebarLowerSlab;
	dLenMinA	= dLenMaxA;

	if(bIncludeArc && !bVertDir && (m_nTypePlacingSupportRebar_UpperSlab == 0 || m_nTypePlacingSupportRebar_UpperSlab == 1))
	{
		double dRateMin	= dStdWidth / dMinWidth;
		double dRateMax	= dStdWidth / dMaxWidth;

		dLenMaxA	= (GetCtcRebarMain(FALSE)/2 * m_nCountWrapMainRebarLowerSlab) / dRateMax;
		dLenMinA	= (GetCtcRebarMain(FALSE)/2 * m_nCountWrapMainRebarLowerSlab) / dRateMin;
	}

	// 전단철근 동일 길이인거
	if(tvArr.GetSize() > 0)
	{
		// 변화치수인것과 정상치수인것을 구분한다.
		CTwinVectorArray tvArrRebarCross, tvArrRebarCross2;

		// (37296) 슬래브교에서는 교량시점에서는 주철근을 찾을수 없기 때문에 아래 함수를 사용한겨우 철근을 만들지 못한다.
		// 왜 교량 중심Station을 쓰다가 시점 Station으로 변경했을까....
		// 일단 슬래브 교일때만 교량 중심을 사용하는걸로...
		GetTvRebarShear_CrossSection_LowerSlab(tvArrRebarCross, tvArrRebarCross2, dStaSttCen, 0, FALSE, FALSE, FALSE, TRUE);
		long nCountCrossTot	= tvArrRebarCross.GetSize() + tvArrRebarCross2.GetSize();

		dLenMaxB	= tvArr.GetLengthMax();
		dLenMinB	= tvArr.GetLengthMin();

		CRebar *pRB	= new CRebar;
		pRB->m_Fy			= bLsd? GetValueFy(ePartLowerSlab, TRUE) : m_pARcBridgeDataStd->m_Fy;
		pRB->m_sDescription.Format("하부슬래브 전단철근1");
		pRB->m_sMark		= GetMarkRebarShear(LS_REBAR_V, FALSE, TRUE, FALSE);
		m_RebarShearDetail_LowerSlab.SetRB(pRB, dDiaMainUpper, dDiaMainLower, dLenMaxA, dLenMaxB, dSettle);
		m_RebarShearDetail_LowerSlab.SetMin(dLenMinA, dLenMinB);
		m_RebarShearDetail_LowerSlab.SetDataDefaultRebarJewon();
		pRB->m_bMainRebar	= FALSE;
		pRB->m_nEa	= (long)((double)nCountNormal * ((double)tvArrRebarCross.GetSize()/(double)nCountCrossTot));
		long nCount	= pRB->m_nEa;
		baseConc.OptimizationRebar(pRB);	// 철근 최적화
		concInfo.SetLengthRebar(dFck, dFy, pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
		pRB->m_dRateAdd	= MAKE_RATE;
		AddOrDeleteRebarInList(&m_pArrRebarShear, pRB);

		// 전단철근 동일인거 중에 모서리 부분에 변화 치수인거
		if(tvArrRebarCross2.GetSize() > 0)
		{
			double dHeightMax	= tvArrRebarCross2.GetLengthMax();
			double dHeightMin	= tvArrRebarCross2.GetLengthMin();

			pRB	= new CRebar;
			pRB->m_Fy			= bLsd? GetValueFy(ePartLowerSlab, TRUE)  : m_pARcBridgeDataStd->m_Fy;
			pRB->m_sDescription.Format("하부슬래브 전단철근1_1");
			pRB->m_sMark		= GetMarkRebarShear(LS_REBAR_V, FALSE, TRUE, FALSE);
			m_RebarShearDetail_LowerSlab.SetRB(pRB, dDiaMainUpper, dDiaMainLower, dLenMaxA, dHeightMax, dSettle);
			m_RebarShearDetail_LowerSlab.SetMin(dLenMinA, dHeightMin);
			m_RebarShearDetail_LowerSlab.SetDataDefaultRebarJewon();
			pRB->m_bMainRebar	= FALSE;
			pRB->m_nEa			= nCountNormal - nCount;
			baseConc.OptimizationRebar(pRB);	// 철근 최적화
			concInfo.SetLengthRebar(dFck, dFy, pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
			pRB->m_dRateAdd	= MAKE_RATE;
			AddOrDeleteRebarInList(&m_pArrRebarShear, pRB);
		}
	}


	// 전단철근 헌치부까지 확장되어 변화길이인거
	if(tvArrHunch.GetSize() > 0)
	{
		dLenMaxB	= tvArrHunch.GetLengthMax();
		dLenMinB	= tvArrHunch.GetLengthMin();

		CRebar *pRB	= new CRebar;
		pRB->m_Fy			= bLsd? GetValueFy(ePartLowerSlab, TRUE)  : m_pARcBridgeDataStd->m_Fy;
		pRB->m_sDescription.Format("하부슬래브 전단철근2");
		pRB->m_sMark		= GetMarkRebarShear(LS_REBAR_V, FALSE, TRUE, FALSE);
		m_RebarShearDetail_LowerSlab.SetRB(pRB, dDiaMainUpper, dDiaMainLower, dLenMaxA, dLenMaxB, dSettle);
		m_RebarShearDetail_LowerSlab.SetMin(dLenMinA, dLenMinB);
		m_RebarShearDetail_LowerSlab.SetDataDefaultRebarJewon();
		pRB->m_bMainRebar	= FALSE;
		pRB->m_nEa			= nCountHunch;
		baseConc.OptimizationRebar(pRB);	// 철근 최적화
		concInfo.SetLengthRebar(dFck, dFy, pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
		pRB->m_dRateAdd	= MAKE_RATE;
		AddOrDeleteRebarInList(&m_pArrRebarShear, pRB);
	}

	// 단부 스터럽 철근////////////
	
//	double dW	= m_bIsExp ? GetWidthSlabActByGagak(m_dStationBridgeStt, GetAngleJijum(0)) : GetWidthSlabAct(m_dStationBridgeStt, GetAngleJijum(0));
	double dW	= m_bIsExp ? GetWidthSlabActByGagak(m_dStationBridgeStt+m_dLengthBridge, GetAngleJijum(m_nQtyJigan)) : GetWidthSlabAct(m_dStationBridgeStt+m_dLengthBridge, GetAngleJijum(m_nQtyJigan));

	long stt = 0; for(stt = 0; stt < 2; stt++)
	{
		BOOL bStt	= stt == iSTT;

		dRebarSpace	= GetCTCRebarShear_DanbuStirrup(FALSE, bStt);
		// 단부 스터럽 철근은 시종점 사각 적용
		CDPoint vAngLineOfShearForStirrup	= bStt ? GetAngleJijum(0) : GetAngleJijum(m_nQtyJigan);
		dCTCMainRebar	= m_nTypePlacingMainRebar_Footing == 0? GetCtcRebarMain(TRUE) / vAngLineOfShearForStirrup.y : GetCtcRebarMain(TRUE);
		double dLenMaxADanbuSt(0);
		dLenMaxADanbuSt	= dCTCMainRebar/2 * m_nCountStirrupCtcMainRebar[iLOWER][bStt? 0:1];

		long  nCountDanb(0);
		nCountDanb	= (long)(dW / (dCTCMainRebar * m_nCountStirrupCtcMainRebar[iLOWER][bStt? 0:1]));
		
		CTwinVectorArray tvArrDanbu;
		GetTvRebarShear_VertSection_LowerSlabDanbu(tvArrDanbu, bStt, 0);
		dDiaMainLower	= GetDiaMainRebarLowerSlabHunch(0, bStt ? 0 : m_nQtyJigan);
		dDiaMainUpper	= GetDiaMainRebarLowerSlab(0, 0, TRUE, bStt ? 0 : m_nQtyJigan-1, bStt ? 0 : -1);
		if(dDiaMainLower == 0)
			dDiaMainLower	= GetDiaMainRebarLowerSlab(0, 0, FALSE, bStt ? 0 : m_nQtyJigan-1, bStt ? 0 : -1);

		long i = 0; for(i = 0; i < tvArrDanbu.GetSize(); i++)
		{
			long nTypeRebar		= bStt ? SD_REBAR_V1 : ED_REBAR_V1;
			CTwinVector tv		= tvArrDanbu.GetAt(i);

			CRebar *pRB	= new CRebar;
			pRB->m_Fy			= bLsd? GetValueFy(bStt? ePartOutWallStt : ePartOutWallEnd, TRUE) : m_pARcBridgeDataStd->m_Fy;
			pRB->m_sDescription.Format("하부슬래브 %s 우각부 보강 조립철근%d", bStt ? "시점" : "종점", i+1);
			pRB->m_sMark		= GetMarkRebarShear(nTypeRebar, FALSE, TRUE, FALSE);
			pRB->m_dDia			= GetDiaRebarStirrupDanbu(bStt, i, FALSE);
			pRB->m_dLengthMax_A	= dLenMaxADanbuSt + max(dDiaMainUpper, dDiaMainLower) + pRB->m_dDia;
			pRB->m_dLengthMin_A	= 0;
			//pRB->m_dLengthMax_B	= tv.GetLength() + (2 * ConstPi * (dDiaMainUpper/2 + dDiaMainLower/2 + pRB->m_dDia) / 4);
			pRB->m_dLengthMax_B	= tv.GetLength() + dDiaMainUpper/2 + dDiaMainLower/2 + pRB->m_dDia;
			pRB->m_dLengthMin_B	= 0;
			pRB->m_dLengthMax_C	= 100;
			pRB->m_dLengthMin_C	= 0;
			pRB->m_nTypeRebar	= 16;
			pRB->m_bMainRebar	= FALSE;
			pRB->m_nEa			= nCountDanb;
			baseConc.OptimizationRebar(pRB);	// 철근 최적화
			concInfo.SetLengthRebar(dFck, dFy, pRB, JOINT_TENS_NORMAL_B, dCover, dRebarSpace);
			pRB->m_dRateAdd	= MAKE_RATE;
			AddOrDeleteRebarInList(&m_pArrRebarShear, pRB);
		}
	}
}

void CRcBridgeRebar::GetTvRebarMain_Plane_LowerSlabPRF( CTwinVectorArray &tvArr, BOOL bStt, long nCycle )
{
	tvArr.RemoveAll();

	// 주철근 간격이 지간마다 다를 수 있으므로 해당 지간 가져옴
	CRebarPlacing rb;
// 	double dCoverSide	= GetCoverSide_UpperSlab(0);
	CTwinVector tvPath;


	// 1. 주철근이 배치되는 기준이 되는 sta들 구함
	double dStaSttRebar	= 0;
	double dStaEndRebar	= 0;
// 	double dCTC			= GetCtcRebarMain(TRUE);
	CDPoint xyDirRebar	= CDPoint(0, 1);

	double dCoverSide	= GetCoverSide_UpperSlab(0);
	double dCTC		= GetCtcRebarMain() / 2;
	long stt	= bStt ? iSTT : iEND;
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = nCycle == 0 ? &m_pArrRCMainBoxLowerPRF_Cycle1[stt] : &m_pArrRCMainBoxLowerPRF_Cycle2[stt];

	if(pArrRC->GetSize() > 0)
	{
		CRebarInfoCycle *pRC	= pArrRC->GetAt(0);
		dStaSttRebar	= m_Util.GetStationRebarInfoCycle(pRC, TRUE);
// 		dStaEndRebar	= m_Util.GetStationRebarInfoCycle(pRC, FALSE);

		// 직방향 배치 전용 철근은 m_tvArrVertSection의 영향을 받아서는 안된다.
		dStaEndRebar	= dStaSttRebar + (bStt ? (m_dPRF_W + m_dWS) - m_dCoverWallOut[0] * 2 
			: (m_dPRF_W + m_dWE) - m_dCoverWallOut[0] * 2);
	}

	CTwinVectorArray tvArrPlane;
	GetTvPlaneOutWall(tvArrPlane, bStt, FALSE, FALSE, TRUE);
	tvPath	= tvArrPlane.GetTvByInfo("부상방지저판");
	GetSwap(tvPath.m_v1, tvPath.m_v2);
	Offset(tvPath.m_v1, tvPath.m_v2, m_dCoverWallOut[0]);

	xyDirRebar	= tvPath.GetXyDir().RotateInv90();

	tvPath.m_v1	+= tvPath.GetXyDir() * dCoverSide;
	tvPath.m_v2 += tvPath.GetXyDir(TRUE) * dCoverSide;

	if(Compare(dStaSttRebar, dStaEndRebar, "=")) return;
	double dLenRebar	= dStaEndRebar  - dStaSttRebar;


	// 주철근 간격 구함
	CDPointArray xyArr;
	rb.GetXyDivideLine(xyArr, tvPath.m_v1, tvPath.m_v2, dCTC, FALSE, (int)(dCTC), TRUE, TRUE);

	CDPointArray xyArrTmp;
	xyArrTmp	 = xyArr;
	xyArr.RemoveAll();

	long nSize	= xyArrTmp.GetSize();
	long nStt	= nCycle == 0 ? 0 : 1;
	long i = 0; for(i = nStt; i < nSize-1; i+=2)
		xyArr.Add(xyArrTmp.GetAt(i));

	rb.MakePointArrayToLineArray(xyArr, tvArr, xyDirRebar, dLenRebar, FALSE);
}

void CRcBridgeRebar::GetTvRebarSupport_Plane_LowerSlabPRF( CTwinVectorArray &tvArr, BOOL bStt, long nVertDir/*=0*/ )
{
	tvArr.RemoveAll();

	//#0031858 
	if(nVertDir == 1) MakeRebarInfoCycle_BFooting(nVertDir);

	long stt		= bStt ? iSTT : iEND;
	CSafetyTypedPtrArray <CObArray, CRebarInfoCycle*> *pArrRC = &m_pArrRCMainBoxLowerPRF_Cycle1[stt];
	if(pArrRC->GetSize() == 0) pArrRC = &m_pArrRCMainBoxLowerPRF_Cycle2[stt];
	if(pArrRC->GetSize() == 0) return;

	//#0031858 
	if(nVertDir == 1) MakeRebarInfoCycle_BFooting(0);


	// 브라켓과 외측벽체 배력근을 하나씩만 가져옴.(평면상에서 배력근을 그릴때는 주철근 중심을 기준으로 그린다.)
	CDPointArray xyArr;
	CTwinVector tv;

	GetXyRebarSupport_VertSection_BFooting(xyArr, bStt, 0, TRUE);

	// 스테이션 이 작은 순대로 정렬
	xyArr.Sort(TRUE);

	// 지점별 배력철근 구함
	long nJ	= bStt ? 0 : m_nQtyJigan;

	GetTvRebarSupport_Plane_UpperSlab_JijumAngle(tvArr, xyArr, nJ, 0);
}

void CRcBridgeRebar::AddOrDeleteRebarInList(CSafetyTypedPtrArray <CObArray, CRebar*> *pArrRebar, CRebar *pRB)
{
	CHgBaseConcStd baseConc;

	if(baseConc.SetRebarJewon(pArrRebar, pRB->m_sDescription, pRB->m_sMark))
	{
		delete pRB;
	}
	else
	{
		pArrRebar->Add(pRB);
	}
}

void CRcBridgeRebar::MakeRebarInfoCycle_FootingAll( BOOL bInput, long nVertDir/*=0*/ )
{
	long nCountFooting	= GetCountFooting();
	long cycle(0), dan(0), upper(0),  front(0);

	for(long footing = 0; footing < nCountFooting; footing ++)
	{
		CFootingApp *pFooting	= GetFooting(footing);
		if(pFooting)
		{
			if(pFooting->m_nType == FOOTING_TYPE_BOX) continue;

			for(upper = 0; upper < 2; upper++)
			{
				BOOL bUpper	= (upper==iUPPER);

				for(dan = 0; dan < MAX_REBAR_DAN; dan++)
				{
					for(cycle = 0; cycle < MAX_REBAR_CYCLE; cycle ++)
					{
						pFooting->MakeRebarInfoCycle(cycle, bUpper, dan, bInput, footing==0&&cycle==0&&dan==0&&bUpper, nVertDir);


						// 기초가 여러개인데 각각 철근 이름을 구분하기 위해. ////////////
						CRebarInfoCycle *pRC	= NULL;
						switch(cycle)
						{
						case 0: pRC	= &pFooting->m_rebarInfoCycle_Cycle1[upper][dan]; break;
						case 1: pRC	= &pFooting->m_rebarInfoCycle_Cycle2[upper][dan]; break;
						case 2: pRC	= &pFooting->m_rebarInfoCycle_Cycle3[upper][dan]; break;
						case 3: pRC	= &pFooting->m_rebarInfoCycle_Cycle4[upper][dan]; break;
						default: break;
						}
						if(!pRC) continue;
						if(!pRC->m_bExist) continue;

						CString sFooting	= _T("");
						sFooting.Format("기초%d", footing+1);
						pRC->m_sDescription.Replace("기초", sFooting);

						if(bUpper)
						{
							// 기초가 여러개인데 각각 철근 이름을 구분하기 위해. ////////////
							CRebarInfoCycle *pRC	= NULL;
							switch(cycle)
							{
							case 0: pRC	= &pFooting->m_rebarInfoCycle_Cycle1_Ext[dan]; break;
							case 1: pRC	= &pFooting->m_rebarInfoCycle_Cycle2_Ext[dan]; break;
							case 2: pRC	= &pFooting->m_rebarInfoCycle_Cycle3_Ext[dan]; break;
							case 3: pRC	= &pFooting->m_rebarInfoCycle_Cycle4_Ext[dan]; break;
							default: break;
							}
							if(!pRC) continue;
							if(!pRC->m_bExist) continue;

							CString sFooting	= _T("");
							sFooting.Format("기초%d", footing+1);
							pRC->m_sDescription.Replace("기초", sFooting);
						}



						/////////////////////////////////////////////////////////////////
					}

					// 스프링깅부 보강 주철근
					if(m_nTypeBridge == BRIDGE_TYPE_ARCH)
					{
						CString sFooting	= _T("");
						sFooting.Format("기초%d", footing+1);
						pFooting->m_rebarInfoCycle_Slope[dan].m_sDescription.Replace("기초", sFooting);
					}
				}
			}

			// 기초 둔각부
			pFooting->MakeRebarInfoCycle_Obtuse(bInput, nVertDir);
			for(front = 0; front < 2; front++)
			{
				CRebarInfoCycle *pRC	= &pFooting->m_rebarInfoCycle_Obtuse[front];

				CString sFooting	= _T("");
				CString sFront		= footing == 0 ? _T("좌측") : _T("우측");
				CString sBack		= footing == 0 ? _T("우측") : _T("좌측");
				sFooting.Format("기초%d", footing+1);
				pRC->m_sDescription.Replace("기초", sFooting);
				pRC->m_sDescription.Replace("전면", sFront);
				pRC->m_sDescription.Replace("후면", sBack);
			}
		}
	}
}

CTwinVector CRcBridgeRebar::GetTvCornerBaseLine( HGBOOL bStt, HGBOOL bUpper )
{
	CTwinVector tv, tvLine;

	if(bUpper)
	{
		if(bStt)
		{
			// 좌측단부 구함.
			if(IsOutWall(TRUE) && m_tvArrVertSection.GetTvByInfo("시점브라켓상부측면", tv))
			{
				tvLine.m_v1	= tv.m_v2;
				m_tvArrVertSection.GetTvByInfo("시점벽체우측면", tv);
				GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), tvLine.m_v1, CDPoint(1, -1), tvLine.m_v2);
			}
		}
		else
		{
			// 우측단부 구함.
			if(IsOutWall(FALSE) && m_tvArrVertSection.GetTvByInfo("종점브라켓상부측면", tv))
			{
				tvLine.m_v1	= tv.m_v1;
				m_tvArrVertSection.GetTvByInfo("종점벽체좌측면", tv);
				GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), tvLine.m_v1, CDPoint(-1, -1), tvLine.m_v2);
			}
		}
	}
	else
	{
		CDPoint xyStart =  bStt? tv.m_v1 : tv.m_v2;
		if(IsBoxType())
		{
			CTwinVectorArray tvArrLowSlabLower;
			m_tvArrVertSection.GetTvArrByInfo(_T("하부슬래브하면"), tvArrLowSlabLower,FALSE, FALSE);
			if(tvArrLowSlabLower.GetSize() > 0)
				xyStart = bStt? tvArrLowSlabLower.GetXyLeft() : tvArrLowSlabLower.GetXyRight();
		}
	
		if(bStt)
		{
			// 좌측단부 구함.
			if(IsOutWall(TRUE) && m_tvArrVertSection.GetTvByInfo("시점벽체좌측면", tv))
			{
				tvLine.m_v1	= xyStart;
				m_tvArrVertSection.GetTvByInfo("시점벽체우측면", tv);
				GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), tvLine.m_v1, CDPoint(1, 1), tvLine.m_v2);
			}
		}
		else
		{
			// 우측단부 구함.
			if(IsOutWall(FALSE) && m_tvArrVertSection.GetTvByInfo("종점벽체우측면", tv))
			{
				tvLine.m_v1	= xyStart;
				m_tvArrVertSection.GetTvByInfo("종점벽체좌측면", tv);
				GetXyMatchLineAndLine(tv.m_v1, tv.GetXyDir(), tvLine.m_v1, CDPoint(-1, 1), tvLine.m_v2);
			}
		}			
	}

	return tvLine;
}

void CRcBridgeRebar::SetRebarLsdOptionSlab( SRebarEnvOption *pSLsdOption, BOOL bUpperSlab, BOOL bUper, BOOL bMain, long nCycle, long nDan )
{
	if(m_pARcBridgeDataStd->IsLsdDesign() == FALSE)
		return;

	*pSLsdOption = m_plsdRebar->GetOption();

	double Fck = GetValueFck(bUpperSlab? ePartUpperSlab : ePartLowerSlab);
	double Fy  = GetValueFy(bUpperSlab? ePartUpperSlab : ePartLowerSlab);

	// 주철근 간격은 표준간격/2, 배력철근 간격은 표준 간격으로..
	double dCtcMain = GetCtcRebarMain(TRUE) / 2;
	double dCtcSupp = GetCTCRebarSupport_Slab(bUpperSlab, bUper, nDan, TRUE);
	double dDia(0);
	if(bMain)
	{
		CPlaceRebarByBlock *pPlace	= NULL;
		if(bUpperSlab)
			pPlace	= &m_placeByBlock_SupportRebar_UpperSlab[bUper? iUPPER : iLOWER][nDan];
		else
			pPlace	= &m_placeByBlock_SupportRebar_LowerSlab[bUper? iUPPER : iLOWER][nDan];

		dDia = pPlace->m_dDia;
	}
	else
	{
		// 전체 배근 중에서 가장 큰 직경으로 적용하자.
		long nSize = bUpperSlab? m_pArrDiaUpperSlab[nCycle][bUper? iUPPER : iLOWER][nDan].GetSize() : m_pArrDiaLowerSlab[nCycle][bUper? iUPPER : iLOWER][nDan].GetSize();
		for(long ix=0; ix<nSize; ++ix)
		{
			CDoubleArray *pDarrDia = bUpperSlab? m_pArrDiaUpperSlab[nCycle][bUper? iUPPER : iLOWER][nDan].GetAt(ix) : m_pArrDiaLowerSlab[nCycle][bUper? iUPPER : iLOWER][nDan].GetAt(ix);
			long nSizeArray = pDarrDia->GetSize();
			for(long jx=0; jx<nSizeArray; ++jx)
			{
				double dDiaCur = pDarrDia->GetAt(jx);

				if(dDiaCur > dDia)
					dDia = dDiaCur;
			}
		}
	}
	double dCover(0);
	if(bUpperSlab)
	{
		dCover = bUper? m_dCoverUpper_UpperSlab[nDan] : m_dCoverLower_UpperSlab[nDan];
	}
	else
	{
		dCover = bUper? m_dCoverUpper_LowerSlab[nDan] : m_dCoverLower_LowerSlab[nDan];
	}
	
	if(bUper)
		pSLsdOption->bUpperRebar = TRUE;
	else
		pSLsdOption->bUpperRebar = FALSE;

	pSLsdOption->dFy = GetValueUnitNmm(Fy, _T("kgf/cm²"));
	pSLsdOption->dFck = GetValueUnitNmm(Fck, _T("kgf/cm²"));
	pSLsdOption->nRebarType = eStraitRebar;
	pSLsdOption->dCover = dCover;
	pSLsdOption->nHorDia	= (ERebarDia)m_pARcBridgeDataStd->m_pBasicConcInfo->GetIndexDia(dDia);

	pSLsdOption->ePosType = eRebarPosTension;
	pSLsdOption->dCheckCTC	= bMain? dCtcMain : dCtcSupp;
	pSLsdOption->dHorCTC	= bMain? dCtcSupp : dCtcMain;
	pSLsdOption->dK = m_pARcBridgeDataStd->m_pBasicConcInfo->GetLsdRebarOpt()->dK_RebarPos[bMain ? iOUTTER : iINNER];
}

void CRcBridgeRebar::SetRebarLsdOptionOutWall( SRebarEnvOption *pSLsdOption, BOOL bStt, BOOL bFront, BOOL bMain, long nCycle, long nDan )
{
	if(m_pARcBridgeDataStd->IsLsdDesign() == FALSE)
		return;

	*pSLsdOption = m_plsdRebar->GetOption();

	double Fck = GetValueFck(bStt? ePartOutWallStt : ePartOutWallEnd);
	double Fy  = GetValueFy(bStt? ePartOutWallStt : ePartOutWallEnd);

	double dCtcMain = GetCtcRebarMain(FALSE) / 2;
	double dCtcSupp = GetCTCRebarSupport_OutWall(bStt, bFront, nDan, TRUE);

	long nOut = bFront? iINNER : iOUTTER;
	
	double dDia(0);
	if(bMain)
	{
		CPlaceRebarByBlock *pPlace	= &m_placeByBlock_SupportRebar_OutWall[bStt? iSTT:iEND][nOut][nDan];
		
		dDia = pPlace->m_dDia;
	}
	else
	{
		// 전체 배근 중에서 가장 큰 직경으로 적용하자.
		long nSize = m_pArrDiaOutWall[nCycle][bStt? iSTT:iEND][nOut][nDan].GetSize();
		for(long ix=0; ix<nSize; ++ix)
		{
			double dDiaCur = m_pArrDiaOutWall[nCycle][bStt? iSTT:iEND][nOut][nDan].GetAt(ix);

			if(dDiaCur > dDia)
				dDia = dDiaCur;
		}
	}
	double dCover = bFront? m_dCoverWallIn[nDan] : m_dCoverWallOut[nDan];
	
	pSLsdOption->dFy = GetValueUnitNmm(Fy, _T("kgf/cm²"));
	pSLsdOption->dFck = GetValueUnitNmm(Fck, _T("kgf/cm²"));
	pSLsdOption->nRebarType = eStraitRebar;
	pSLsdOption->dCover = dCover;
	pSLsdOption->nHorDia	= (ERebarDia)m_pARcBridgeDataStd->m_pBasicConcInfo->GetIndexDia(dDia);

	pSLsdOption->ePosType = eRebarPosTension;
	pSLsdOption->dCheckCTC	= bMain? dCtcMain : dCtcSupp;
	pSLsdOption->dHorCTC	= bMain? dCtcSupp : dCtcMain;
	pSLsdOption->bUpperRebar = FALSE;
	pSLsdOption->dK = m_pARcBridgeDataStd->m_pBasicConcInfo->GetLsdRebarOpt()->dK_RebarPos[bMain ? iOUTTER : iINNER];
}

void CRcBridgeRebar::SetRebarLsdOptionOutWallHunchSupport( SRebarEnvOption *pSLsdOption, BOOL bStt )
{
	if(m_pARcBridgeDataStd->IsLsdDesign() == FALSE)
		return;

	*pSLsdOption = m_plsdRebar->GetOption();

	double Fck = GetValueFck(ePartUpperSlab);
	double Fy  = GetValueFy(ePartUpperSlab);

	double dCtcMain = GetCtcRebarMain(TRUE) / 2;
	double dCtcSupp = GetCTCRebarSupport_UpperSlabHunch();
	double dDia = GetDiaMainRebarUpperSlabHunch(0, bStt? 0 : m_nQtyJigan);
	
	double dCover = m_dCoverLower_UpperSlab[0];
	
	pSLsdOption->dFy = GetValueUnitNmm(Fy, _T("kgf/cm²"));
	pSLsdOption->dFck = GetValueUnitNmm(Fck, _T("kgf/cm²"));
	pSLsdOption->nRebarType = eStraitRebar;
	pSLsdOption->dCover = dCover;
	pSLsdOption->nHorDia	= (ERebarDia)m_pARcBridgeDataStd->m_pBasicConcInfo->GetIndexDia(dDia);

	pSLsdOption->ePosType = eRebarPosTension;
	pSLsdOption->dCheckCTC	= dCtcSupp;
	pSLsdOption->dHorCTC	= dCtcMain;
	pSLsdOption->bUpperRebar = FALSE;
	pSLsdOption->dK = m_pARcBridgeDataStd->m_pBasicConcInfo->GetLsdRebarOpt()->dK_RebarPos[iINNER];
}

void CRcBridgeRebar::SetRebarLsdOptionWingWall( SRebarEnvOption *pSLsdOption, BOOL bStt, BOOL bLeft, BOOL bFront, long nPos, BOOL bMain )
{
	if(m_pARcBridgeDataStd->IsLsdDesign() == FALSE)
		return;
	
	CWingWall* pWing = GetWingWall(bStt, bLeft);
	if(pWing == NULL) return;

	*pSLsdOption = m_plsdRebar->GetOption();

	double Fck = GetValueFck(bStt? ePartWingWallStt : ePartWingWallEnd);
	double Fy  = GetValueFy(bStt? ePartWingWallStt : ePartWingWallEnd);

	double dCtcMain = GetRebarCtcWingwall(bStt, bLeft, nPos, bFront, TRUE);
	double dCtcSupp = GetRebarCtcWingwall(bStt, bLeft, nPos, bFront, FALSE);

	long nOut = bFront? iINNER : iOUTTER;
	double dDia(0);
	switch (nPos)
	{
	case WINGWALL_SECTA:
		dDia = bMain? pWing->m_dDiaSupportA[nOut][0] : pWing->m_dDiaMainA[nOut][0];
		break;
	case WINGWALL_SECTB:
		dDia = bMain? pWing->m_dDiaSupportB[nOut][0] : pWing->m_dDiaMainB[nOut][0];
		break;
	case WINGWALL_SECTC:
		dDia = bMain? pWing->m_dDiaSupportC[nOut][0] : pWing->m_dDiaMainC[nOut][0];
		break;
	case WINGWALL_SECTD:
		dDia = bMain? pWing->m_dDiaSupportD[nOut][0] : pWing->m_dDiaMainD[nOut][0];
		break;
	}
	
	pSLsdOption->dFy = GetValueUnitNmm(Fy, _T("kgf/cm²"));
	pSLsdOption->dFck = GetValueUnitNmm(Fck, _T("kgf/cm²"));
	pSLsdOption->nRebarType = eStraitRebar;
	pSLsdOption->dCover = bFront ? m_dCoverWingOut[0] : m_dCoverWingIn[0];
	pSLsdOption->nHorDia	= (ERebarDia)m_pARcBridgeDataStd->m_pBasicConcInfo->GetIndexDia(dDia);

	pSLsdOption->ePosType = eRebarPosTension;
	pSLsdOption->dCheckCTC	= bMain? dCtcMain : dCtcSupp;
	pSLsdOption->dHorCTC	= bMain? dCtcSupp : dCtcMain;
	pSLsdOption->bUpperRebar = FALSE;
	// (ARCBRIDGE-2614) 날개벽 C구간은 수직이 주철근이지만 내측에 배치됨
	if(nPos == WINGWALL_SECTC)
	{
		pSLsdOption->dK = m_pARcBridgeDataStd->m_pBasicConcInfo->GetLsdRebarOpt()->dK_RebarPos[bMain ? iINNER : iOUTTER];
	}
	else
	{
		pSLsdOption->dK = m_pARcBridgeDataStd->m_pBasicConcInfo->GetLsdRebarOpt()->dK_RebarPos[bMain ? iOUTTER : iINNER];
	}
}

void CRcBridgeRebar::SetRebarLsdOptionOutWallBracketSupport( SRebarEnvOption *pSLsdOption, BOOL bStt )
{
	if(m_pARcBridgeDataStd->IsLsdDesign() == FALSE)
		return;

	*pSLsdOption = m_plsdRebar->GetOption();

	double Fck = GetValueFck(bStt? ePartOutWallStt : ePartOutWallEnd);
	double Fy  = GetValueFy(bStt? ePartOutWallStt : ePartOutWallEnd);

	double dCtcMain = GetCtcRebarMain(TRUE) / 2;
	double dCtcSupp = GetCTCRebarSupport_OutWall(bStt, FALSE, 0, TRUE);
	double dDia = m_dDiaRebarMain_Bracket_Cycle1[bStt? iSTT:iEND];

	double dCover = m_dCoverLower_UpperSlab[0];

	pSLsdOption->dFy = GetValueUnitNmm(Fy, _T("kgf/cm²"));
	pSLsdOption->dFck = GetValueUnitNmm(Fck, _T("kgf/cm²"));
	pSLsdOption->nRebarType = eStraitRebar;
	pSLsdOption->dCover = dCover;
	pSLsdOption->nHorDia	= (ERebarDia)m_pARcBridgeDataStd->m_pBasicConcInfo->GetIndexDia(dDia);

	pSLsdOption->ePosType = eRebarPosTension;
	pSLsdOption->dCheckCTC	= dCtcSupp;
	pSLsdOption->dHorCTC	= dCtcMain;
	pSLsdOption->bUpperRebar = FALSE;
	pSLsdOption->dK = m_pARcBridgeDataStd->m_pBasicConcInfo->GetLsdRebarOpt()->dK_RebarPos[iINNER];
}

void CRcBridgeRebar::SetRebarLsdOptionGirderMain( SRebarEnvOption *pSLsdOption, long nJ, BOOL bStt, BOOL bLeft, BOOL bGagak, BOOL bJongGirder, BOOL bApplyVert, BOOL bUpperSlabGirder, BOOL bUpper, long nDan )
{
	if(m_pARcBridgeDataStd->IsLsdDesign() == FALSE)
		return;

	CGirderSectionRebar *pGirder	= bJongGirder ? GetGirderRebarJong(bStt, bLeft, bGagak) : &m_SlabGirderRebar[bUpperSlabGirder ? iUPPER : iLOWER][nJ];
	if(pGirder == NULL) return;

	*pSLsdOption = m_plsdRebar->GetOption();

	double Fck = GetValueFck(bUpperSlabGirder? ePartUpperSlab : ePartLowerSlab);
	double Fy  = GetValueFy(bUpperSlabGirder? ePartUpperSlab : ePartLowerSlab);

	double dCtcStirrup = pGirder->m_dF;
	if(Compare(dCtcStirrup, 0.0, "=")) 
		dCtcStirrup	= pGirder->m_dF1;

	double dCtcMain = pGirder->m_dCTC;
	double dDia = pGirder->m_dDiaStirrup;

	double dCover = m_dCoverLower_UpperSlab[0];

	pSLsdOption->dFy = GetValueUnitNmm(Fy, _T("kgf/cm²"));
	pSLsdOption->dFck = GetValueUnitNmm(Fck, _T("kgf/cm²"));
	pSLsdOption->nRebarType = eStraitRebar;
	pSLsdOption->dCover = dCover;
	pSLsdOption->nHorDia	= (ERebarDia)m_pARcBridgeDataStd->m_pBasicConcInfo->GetIndexDia(dDia);

	pSLsdOption->ePosType = eRebarPosTension;
	pSLsdOption->dCheckCTC	= dCtcMain;
	pSLsdOption->dHorCTC	= dCtcStirrup;
	pSLsdOption->bUpperRebar = FALSE;
	pSLsdOption->dK = m_pARcBridgeDataStd->m_pBasicConcInfo->GetLsdRebarOpt()->dK_RebarPos[iOUTTER];
}

HGINT32 CRcBridgeRebar::GetCountConcFooting(HGBOOL bReverse, HGBOOL bCheckAdd) const
{
	HGINT32 icConc = 0;
	for (HGINT32 ix = 0; ix < eEnvService; ++ix)
	{
		icConc += m_pArrConcFoot[ix].GetSize();
	}

	if (bReverse)
	{
		for (HGINT32 ix = 0; ix < eEnvService; ++ix)
		{
			icConc += m_pArrConcFootRev[ix].GetSize();
		}
	}

	if (bCheckAdd)
	{
		for (HGINT32 ix = 0; ix < eEnvService; ++ix)
		{
			icConc += m_pArrConcFootCheckAdd[ix].GetSize();
		}
	}

	return icConc;
}

HGINT32 CRcBridgeRebar::GetCountConcSlab() const
{
	HGINT32 icConc = 0;
	for (HGINT32 ix = 0; ix < eEnvService; ++ix)
	{
		icConc += m_pArrConcSlab[ix].GetSize();
	}

	return icConc;
}

HGINT32 CRcBridgeRebar::GetCountConcUpperAndLowerSlab(BOOL bUpperSlab) const
{
	HGINT32 icConc = 0;

	CString sSlab = bUpperSlab? _T("상부슬래브") : _T("하부슬래브");
	if(m_nTypeBridge == BRIDGE_TYPE_BOX)
	{
		for (HGINT32 ix = 0; ix < eEnvService; ++ix)
		{
			long nSize = m_pArrConcSlab[ix].GetSize();
			for (long jx =0; jx < nSize; jx++)
			{
				CConcBasic *pConc = m_pArrConcSlab[ix].GetAt(jx);
				if(pConc == NULL) continue;

				if(pConc->m_sTitle.Find(sSlab) > -1)
					icConc++;
			}	
		}
	}
	else
	{
		icConc = bUpperSlab? GetCountConcSlab() : 0;
	}	

	return icConc;
}


HGINT32 CRcBridgeRebar::GetCountConcOutWall() const
{
	HGINT32 icConc = 0;
	for (HGINT32 ix = 0; ix < eEnvService; ++ix)
	{
		icConc += m_pArrConcWall[ix].GetSize();
	}

	return icConc;
}

HGINT32 CRcBridgeRebar::GetCountConcInWall() const
{
	HGINT32 icConc = 0;
	for (HGINT32 ix = 0; ix < eEnvService; ++ix)
	{
		icConc += m_pArrConcInWall[ix].GetSize();
	}

	return icConc;
}

HGINT32 CRcBridgeRebar::GetCountConcPRF() const
{
	HGINT32 icConc = 0;
	for (HGINT32 ix = 0; ix < eEnvService; ++ix)
	{
		icConc += m_pArrConcPRF[ix].GetSize();
	}

	return icConc;
}

HGINT32 CRcBridgeRebar::GetCountValidComboEnvType()
{
	if (m_pARcBridgeDataStd->IsLsdDesign() == FALSE)
		return 1;

	HGINT32 icValidEnvType = 0;
	for (HGINT32 ix = 0; ix < eEnvService; ++ix)
	{
		if (IsValidComboEnvType(static_cast<ETypeEnvComboLsd>(ix)))
		{
			++icValidEnvType;
		}
	}

	return icValidEnvType;
}

void CRcBridgeRebar::SetExposureParameter(SExposureOutputParams &stOutputParams)
{
	CARcBridgeDataStd *pData = m_pARcBridgeDataStd;

	// CRcBridgeApp::SetDataDefaultExposureRatingLsd() 에서의 순서와 맞춰야 한다.

	//////////////////////////////////////////////////////////////////////////
	///1. 콘크리트 적용강도 
	double dVal = GetValueUnitChange(m_Fck[ePartUpperSlab], UNIT_CGS_KGF_CM2, pData->m_szKgf_CM2);		
	stOutputParams.m_vecConcApplyStrength.push_back(dVal);											// 상부슬래브 상면
	stOutputParams.m_vecConcApplyStrength.push_back(dVal);											// 상부슬래브 하면

	if(IsBoxType())
	{
		dVal = GetValueUnitChange(m_Fck[ePartLowerSlab], UNIT_CGS_KGF_CM2, pData->m_szKgf_CM2);		
		stOutputParams.m_vecConcApplyStrength.push_back(dVal);											// 하부슬래브 상면
		stOutputParams.m_vecConcApplyStrength.push_back(dVal);											// 하부슬래브 하면
	}

	if(IsOutWall(TRUE))
	{
		dVal = GetValueUnitChange(m_Fck[ePartOutWallStt], UNIT_CGS_KGF_CM2, pData->m_szKgf_CM2);		
		stOutputParams.m_vecConcApplyStrength.push_back(dVal);											// 시점부 벽체 전면
		stOutputParams.m_vecConcApplyStrength.push_back(dVal);											// 시점부 벽체 배면

		if(!IsBoxType())
		{
			dVal = GetValueUnitChange(m_Fck[ePartFootStt], UNIT_CGS_KGF_CM2, pData->m_szKgf_CM2);		
			stOutputParams.m_vecConcApplyStrength.push_back(dVal);											// 시점부 기초 상면
			stOutputParams.m_vecConcApplyStrength.push_back(dVal);											// 시점부 기초 하면
		}

		dVal = GetValueUnitChange(m_Fck[ePartWingWallStt], UNIT_CGS_KGF_CM2, pData->m_szKgf_CM2);		
		stOutputParams.m_vecConcApplyStrength.push_back(dVal);											// 시점부 날개벽 전면
		stOutputParams.m_vecConcApplyStrength.push_back(dVal);											// 시점부 날개벽 배면
	}

	dVal = GetValueUnitChange(m_apsStt->m_dFck, UNIT_CGS_KGF_CM2, pData->m_szKgf_CM2);			
	stOutputParams.m_vecConcApplyStrength.push_back(dVal);											// 시점부 접속슬래브 상면
	stOutputParams.m_vecConcApplyStrength.push_back(dVal);											// 시점부 접속슬래브 하면

	if(IsOutWall(FALSE))
	{
		dVal = GetValueUnitChange(m_Fck[ePartOutWallEnd], UNIT_CGS_KGF_CM2, pData->m_szKgf_CM2);		
		stOutputParams.m_vecConcApplyStrength.push_back(dVal);											// 종점부 벽체 전면
		stOutputParams.m_vecConcApplyStrength.push_back(dVal);											// 종점부 벽체 배면

		if(!IsBoxType())
		{
			dVal = GetValueUnitChange(m_Fck[ePartFootEnd], UNIT_CGS_KGF_CM2, pData->m_szKgf_CM2);		
			stOutputParams.m_vecConcApplyStrength.push_back(dVal);											// 종점부 기초 상면
			stOutputParams.m_vecConcApplyStrength.push_back(dVal);											// 종점부 기초 하면
		}

		dVal = GetValueUnitChange(m_Fck[ePartWingWallEnd], UNIT_CGS_KGF_CM2, pData->m_szKgf_CM2);		
		stOutputParams.m_vecConcApplyStrength.push_back(dVal);											// 종점부 날개벽 전면
		stOutputParams.m_vecConcApplyStrength.push_back(dVal);											// 종점부 날개벽 배면
	}

	dVal = GetValueUnitChange(m_apsEnd->m_dFck, UNIT_CGS_KGF_CM2, pData->m_szKgf_CM2);			
	stOutputParams.m_vecConcApplyStrength.push_back(dVal);											// 종점부 접속슬래브 상면
	stOutputParams.m_vecConcApplyStrength.push_back(dVal);											// 종점부 접속슬래브 하면

	
	if(m_nTypeBridge != BRIDGE_TYPE_SLAB && m_nQtyJigan > 1)
	{
		dVal = GetValueUnitChange(m_Fck[ePartInWall], UNIT_CGS_KGF_CM2, pData->m_szKgf_CM2);		
		stOutputParams.m_vecConcApplyStrength.push_back(dVal);											// 중간벽체

		if(!IsBoxType())
		{
			dVal = GetValueUnitChange(m_Fck[ePartInFoot], UNIT_CGS_KGF_CM2, pData->m_szKgf_CM2);		
			stOutputParams.m_vecConcApplyStrength.push_back(dVal);											// 중간기초 상면
			stOutputParams.m_vecConcApplyStrength.push_back(dVal);											// 중간기초 하면
		}
	}

	//////////////////////////////////////////////////////////////////////////
	//2.부착 피복 직경(교대용 직경값을 가져 와야함)
	dVal = GetDiaLsdExposure_Main(ePartUpperSlab, TRUE);		
	stOutputParams.m_vecAttachCoverThick.push_back(dVal);											// 상부슬래브 상면
	dVal = GetDiaLsdExposure_Main(ePartUpperSlab, FALSE);		
	stOutputParams.m_vecAttachCoverThick.push_back(dVal);											// 상부슬래브 하면

	if(IsBoxType())
	{
		dVal = GetDiaLsdExposure_Main(ePartLowerSlab, TRUE);		
		stOutputParams.m_vecAttachCoverThick.push_back(dVal);											// 하부슬래브 상면
		dVal = GetDiaLsdExposure_Main(ePartLowerSlab, FALSE);		
		stOutputParams.m_vecAttachCoverThick.push_back(dVal);											// 하부슬래브 하면
	}

	if(IsOutWall(TRUE))
	{
		dVal = GetDiaLsdExposure_Main(ePartOutWallStt, TRUE);		
		stOutputParams.m_vecAttachCoverThick.push_back(dVal);											// 시점부 벽체 전면
		dVal = GetDiaLsdExposure_Main(ePartOutWallStt, FALSE);		
		stOutputParams.m_vecAttachCoverThick.push_back(dVal);											// 시점부 벽체 배면

		if(!IsBoxType())
		{
			dVal = GetDiaLsdExposure_Main(ePartFootStt, TRUE);		
			stOutputParams.m_vecAttachCoverThick.push_back(dVal);											// 시점부 기초 상면
			dVal = GetDiaLsdExposure_Main(ePartFootStt, FALSE);		
			stOutputParams.m_vecAttachCoverThick.push_back(dVal);											// 시점부 기초 하면
		}

		dVal = GetDiaLsdExposure_Main(ePartWingWallStt, TRUE);		
		stOutputParams.m_vecAttachCoverThick.push_back(dVal);											// 시점부 날개벽 전면
		dVal = GetDiaLsdExposure_Main(ePartWingWallStt, FALSE);		
		stOutputParams.m_vecAttachCoverThick.push_back(dVal);											// 시점부 날개벽 배면
	}
	

	dVal = GetDiaLsdExposure_Main(ePartApsStt, TRUE);		
	stOutputParams.m_vecAttachCoverThick.push_back(dVal);											// 시점부 접속슬래브 상면
	dVal = GetDiaLsdExposure_Main(ePartApsStt, FALSE);		
	stOutputParams.m_vecAttachCoverThick.push_back(dVal);											// 시점부 접속슬래브 하면

	if(IsOutWall(FALSE))
	{
		dVal = GetDiaLsdExposure_Main(ePartOutWallEnd, TRUE);		
		stOutputParams.m_vecAttachCoverThick.push_back(dVal);											// 종점부 벽체 전면
		dVal = GetDiaLsdExposure_Main(ePartOutWallEnd, FALSE);		
		stOutputParams.m_vecAttachCoverThick.push_back(dVal);											// 종점부 벽체 배면

		if(!IsBoxType())
		{
			dVal = GetDiaLsdExposure_Main(ePartFootEnd, TRUE);		
			stOutputParams.m_vecAttachCoverThick.push_back(dVal);											// 종점부 기초 상면
			dVal = GetDiaLsdExposure_Main(ePartFootEnd, FALSE);		
			stOutputParams.m_vecAttachCoverThick.push_back(dVal);											// 종점부 기초 하면
		}

		dVal = GetDiaLsdExposure_Main(ePartWingWallEnd, TRUE);		
		stOutputParams.m_vecAttachCoverThick.push_back(dVal);											// 종점부 날개벽 전면
		dVal = GetDiaLsdExposure_Main(ePartWingWallEnd, FALSE);		
		stOutputParams.m_vecAttachCoverThick.push_back(dVal);											// 종점부 날개벽 배면
	}

	dVal = GetDiaLsdExposure_Main(ePartApsEnd, TRUE);		
	stOutputParams.m_vecAttachCoverThick.push_back(dVal);											// 종점부 접속슬래브 상면
	dVal = GetDiaLsdExposure_Main(ePartApsEnd, FALSE);		
	stOutputParams.m_vecAttachCoverThick.push_back(dVal);											// 종점부 접속슬래브 하면

	if(m_nTypeBridge != BRIDGE_TYPE_SLAB  && m_nQtyJigan > 1)
	{
		dVal = GetDiaLsdExposure_Main(ePartInWall, FALSE);		
		stOutputParams.m_vecAttachCoverThick.push_back(dVal);											// 중간벽체

		if(!IsBoxType())
		{
			dVal = GetDiaLsdExposure_Main(ePartInFoot, TRUE);		
			stOutputParams.m_vecAttachCoverThick.push_back(dVal);											// 중간기초 상면
			dVal = GetDiaLsdExposure_Main(ePartInFoot, FALSE);		
			stOutputParams.m_vecAttachCoverThick.push_back(dVal);											// 중간기초 하면
		}
	}

	//////////////////////////////////////////////////////////////////////////
	// 3.설계 피복 두께
	long dan = 0;
	stOutputParams.m_vecDesignCoverThick.push_back(m_dCoverUpper_UpperSlab[dan]);			// 상부슬래브 상면
	stOutputParams.m_vecDesignCoverThick.push_back(m_dCoverLower_UpperSlab[dan]);			// 상부슬래브 하면
	if(IsBoxType())
	{
		stOutputParams.m_vecDesignCoverThick.push_back(m_dCoverUpper_LowerSlab[dan]);			// 하부슬래브 상면
		stOutputParams.m_vecDesignCoverThick.push_back(m_dCoverLower_LowerSlab[dan]);			// 하부슬래브 하면
	}

	if(IsOutWall(TRUE))
	{
		stOutputParams.m_vecDesignCoverThick.push_back(m_dCoverWallIn[dan]);					// 시점부 벽체 전면
		stOutputParams.m_vecDesignCoverThick.push_back(m_dCoverWallOut[dan]);					// 시점부 벽체 배면
		if(!IsBoxType())
		{
			stOutputParams.m_vecDesignCoverThick.push_back(m_dCoverUpper_Footing[dan]);				// 시점부 기초 상면
			stOutputParams.m_vecDesignCoverThick.push_back(IsPileBase(0)?m_dCoverLower_Footing_Pile[dan] : m_dCoverLower_Footing_Lean[dan]);			// 시점부 기초 하면 - 직접기초
		}
		stOutputParams.m_vecDesignCoverThick.push_back(m_dCoverWingOut[dan]);					// 시점부 날개벽 전면
		stOutputParams.m_vecDesignCoverThick.push_back(m_dCoverWingIn[dan]);					// 시점부 날개벽 배면

	}
	stOutputParams.m_vecDesignCoverThick.push_back(m_apsStt->m_dCoverUpper);				// 시점부 접속슬래브 상면
	stOutputParams.m_vecDesignCoverThick.push_back(m_apsStt->m_dCoverLower);				// 시점부 접속슬래브 하면

	if(IsOutWall(FALSE))
	{
		stOutputParams.m_vecDesignCoverThick.push_back(m_dCoverWallIn[dan]);					// 종점부 벽체 전면
		stOutputParams.m_vecDesignCoverThick.push_back(m_dCoverWallOut[dan]);					// 종점부 벽체 배면
		if(!IsBoxType())
		{
			stOutputParams.m_vecDesignCoverThick.push_back(m_dCoverUpper_Footing[dan]);				// 종점부 기초 상면
			stOutputParams.m_vecDesignCoverThick.push_back(IsPileBase(m_nQtyJigan-1)?m_dCoverLower_Footing_Pile[dan] : m_dCoverLower_Footing_Lean[dan]);			// 종점부 기초 하면 - 직접기초
		}
		stOutputParams.m_vecDesignCoverThick.push_back(m_dCoverWingOut[dan]);					// 종점부 날개벽 전면
		stOutputParams.m_vecDesignCoverThick.push_back(m_dCoverWingIn[dan]);					// 종점부 날개벽 배면
	}
	
	stOutputParams.m_vecDesignCoverThick.push_back(m_apsEnd->m_dCoverUpper);				// 종점부 접속슬래브 상면
	stOutputParams.m_vecDesignCoverThick.push_back(m_apsEnd->m_dCoverLower);				// 종점부 접속슬래브 하면

	if(m_nTypeBridge != BRIDGE_TYPE_SLAB  && m_nQtyJigan > 1)
	{
		stOutputParams.m_vecDesignCoverThick.push_back(m_dCoverWallMid[dan]);					// 중간벽체
		if(!IsBoxType())
		{
			stOutputParams.m_vecDesignCoverThick.push_back(m_dCoverUpper_Footing[dan]);				// 중간기초 상면
			stOutputParams.m_vecDesignCoverThick.push_back(m_dCoverLower_Footing_Lean[dan]);			// 중간기초 하면
		}
	}

	//////////////////////////////////////////////////////////////////////////
	// 4.전단철근 직경
	double dDia = 0;
	
	dDia = GetDiaLsdExposure_Shear(ePartUpperSlab);
	stOutputParams.m_vecDiaShearRebar.push_back(dDia);			// 상부슬래브 상면
	stOutputParams.m_vecDiaShearRebar.push_back(dDia);			// 상부슬래브 하면
	if(IsBoxType())
	{
		dDia = GetDiaLsdExposure_Shear(ePartLowerSlab);
		stOutputParams.m_vecDiaShearRebar.push_back(dDia);			// 하부슬래브 상면
		stOutputParams.m_vecDiaShearRebar.push_back(dDia);			// 하부슬래브 하면
	}

	if(IsOutWall(TRUE))
	{
		dDia = GetDiaLsdExposure_Shear(ePartOutWallStt);
		stOutputParams.m_vecDiaShearRebar.push_back(dDia);					// 시점부 벽체 전면
		stOutputParams.m_vecDiaShearRebar.push_back(dDia);					// 시점부 벽체 배면
		if(!IsBoxType())
		{
			dDia = GetDiaLsdExposure_Shear(ePartFootStt);
			stOutputParams.m_vecDiaShearRebar.push_back(dDia);			// 시점부 기초 상면
			stOutputParams.m_vecDiaShearRebar.push_back(dDia);	
		}

		dDia = GetDiaLsdExposure_Shear(ePartWingWallStt);
		stOutputParams.m_vecDiaShearRebar.push_back(dDia);					// 시점부 날개벽 전면
		stOutputParams.m_vecDiaShearRebar.push_back(dDia);					// 시점부 날개벽 배면
	}

	dDia = GetDiaLsdExposure_Shear(ePartApsStt);
	stOutputParams.m_vecDiaShearRebar.push_back(dDia);				// 시점부 접속슬래브 상면
	stOutputParams.m_vecDiaShearRebar.push_back(dDia);				// 시점부 접속슬래브 하면

	if(IsOutWall(FALSE))
	{
		dDia = GetDiaLsdExposure_Shear(ePartOutWallEnd);
		stOutputParams.m_vecDiaShearRebar.push_back(dDia);					// 종점부 벽체 전면
		stOutputParams.m_vecDiaShearRebar.push_back(dDia);					// 종점부 벽체 배면
		if(!IsBoxType())
		{
			dDia = GetDiaLsdExposure_Shear(ePartFootEnd);
			stOutputParams.m_vecDiaShearRebar.push_back(dDia);				// 종점부 기초 상면
			stOutputParams.m_vecDiaShearRebar.push_back(dDia);			// 종점부 기초 하면 - 직접기초
		}

		dDia = GetDiaLsdExposure_Shear(ePartWingWallEnd);
		stOutputParams.m_vecDiaShearRebar.push_back(dDia); // 종점부 날개벽 전면
		stOutputParams.m_vecDiaShearRebar.push_back(dDia); // 종점부 날개벽 배면
	}

	dDia = GetDiaLsdExposure_Shear(ePartApsEnd);
	stOutputParams.m_vecDiaShearRebar.push_back(dDia);				// 종점부 접속슬래브 상면
	stOutputParams.m_vecDiaShearRebar.push_back(dDia);				// 종점부 접속슬래브 하면

	if(m_nTypeBridge != BRIDGE_TYPE_SLAB && m_nQtyJigan > 1)
	{
		dDia = GetDiaLsdExposure_Shear(ePartInWall);
		stOutputParams.m_vecDiaShearRebar.push_back(dDia); // 중간벽체
		
		if(!IsBoxType())
		{
			dDia = GetDiaLsdExposure_Shear(ePartInFoot);
			stOutputParams.m_vecDiaShearRebar.push_back(dDia);	// 중간기초 상면
			stOutputParams.m_vecDiaShearRebar.push_back(dDia);	// 중간기초 하면
		}
	}
}

CRebar* CRcBridgeRebar::GetRebarShearByDescription( CString sDescription )
{
	for(long ix = 0; ix < m_pArrRebarShear.GetSize(); ++ix)
	{
		CRebar *pRB	= m_pArrRebarShear.GetAt(ix);
		if(pRB->m_sDescription == sDescription)
		{
			return pRB;
		}
	}

	return NULL;
}

CRebar* CRcBridgeRebar::GetRebarSupportByDescription( CString sDescription )
{
	for(long ix = 0; ix < m_pArrRebarSupport.GetSize(); ++ix)
	{
		CRebar *pRB	= m_pArrRebarSupport.GetAt(ix);
		if(pRB->m_sDescription == sDescription)
		{
			return pRB;
		}
	}

	return NULL;
}

CRebar* CRcBridgeRebar::GetRebarEtcByDescription( CString sDescription, BOOL bGirder )
{
	CTypedPtrArray <CObArray, CRebar*> *pArrRebar	= bGirder ? &m_pArrRebarGirder : &m_pArrRebarEtc;
	
	for(long ix = 0; ix < pArrRebar->GetSize(); ++ix)
	{
		CRebar *pRB	= pArrRebar->GetAt(ix);
		if(pRB->m_sDescription == sDescription)
		{
			return pRB;
		}
	}

	return NULL;
}

CRebar* CRcBridgeRebar::GetRebarMainByDescription( CString sDescription )
{
	for(long ix = 0; ix < m_pArrRebarMain.GetSize(); ++ix)
	{
		CRebar *pRB	= m_pArrRebarMain.GetAt(ix);
		if(pRB->m_sDescription == sDescription)
		{
			return pRB;
		}
	}

	return NULL;
}

double CRcBridgeRebar::GetDistCheckShearSlab( long nSpan, long nPos, BOOL bUpperSlab, CConcBasic *pConc )
{
	if(m_nApplyCalcShearDistSlab ==0 || nPos == CHECK_POS_CENTER)
		return 0;

	double dDist = 0;
	CConcBasic *pConcSection;
	if(pConc == NULL)
	{
		if(m_pARcBridgeDataStd->IsLsdDesign())
		{
			CString strEnv;
			long nIdx = 3 * nSpan + nPos;
			if(bUpperSlab == FALSE)
				nIdx += (m_nQtyJigan*2 + 1);

			if(nIdx < m_pArrConcSlab[eEnvLimit].GetSize())
				pConcSection = m_pArrConcSlab[eEnvLimit].GetAt(nIdx);
			else 
				pConcSection = NULL;
		}
		else
		{
			pConcSection = GetConcDataSlab(nSpan, nPos, bUpperSlab);
		}
	}
	else
		pConcSection = pConc;

	double dHeightD = 0;
	if(pConcSection)
	{
		dHeightD = pConcSection->GetHo() - pConcSection->GetRebarDistTension();
	}

	if(m_nApplyCalcShearDistSlab == 1)
		dDist = dHeightD;
	else if(m_nApplyCalcShearDistSlab == 2)
		dDist = dHeightD / 2;

	return dDist;
}

double CRcBridgeRebar::GetDistCheckShearPRF( BOOL bStt, CConcBasic *pConc/*=NULL*/ )
{
	double dDist = 0;
	CConcBasic *pConcSection;
	if(pConc == NULL)
	{
		if(m_pARcBridgeDataStd->IsLsdDesign())
		{
			CString strEnv;
			long nIdx = bStt ? 0 : 1;

			if(nIdx < m_pArrConcSlab[eEnvLimit].GetSize())
				pConcSection = m_pArrConcPRF[eEnvLimit].GetAt(nIdx);
			else 
				pConcSection = NULL;
		}
		else
		{
			pConcSection = GetConcDataPRF(bStt);
		}
	}
	else
		pConcSection = pConc;

	double dHeightD = 0;
	if(pConcSection)
	{
		dHeightD = pConcSection->GetHo() - pConcSection->GetRebarDistTension();
	}

	if(m_nApplyCalcShearDistSlab == 1)
		dDist = dHeightD;
	else if(m_nApplyCalcShearDistSlab == 2)
		dDist = dHeightD / 2;

	return dDist;
}

double CRcBridgeRebar::GetDistCheckShearWall( long nJijum, long nPos, CConcBasic *pConc/*=NULL*/ )
{
	if(m_nApplyCalcShearDistWall ==0 || nPos == CHECK_POS_CENTER)
		return 0;

	double dDist = 0;
	CConcBasic *pConcSection;
	if(pConc == NULL)
	{
		if(m_pARcBridgeDataStd->IsLsdDesign())
		{
			CString strEnv;
			
			long nIdx = GetIndexConcDataWall(nJijum, nPos, TRUE);
			// (ARCBRIDGE-3448) 이 인덱스는 조합case 갯수는 고려되지 않은 강도설계법에 사용하는 인덱스다
			// 어짜피 eEnvLimit 조합 데이터를 쓸꺼기 때문에 강도설계법용 함수인 GetConcDataWall()를 쓰자.
			// pConcSection = GetConcDataWall_Lsd(nIdx, &strEnv);
			pConcSection = GetConcDataWall(nIdx, TRUE);
		}
		else
		{
			pConcSection = GetConcDataWall(nJijum, nPos, TRUE);
		}
	}
	else
		pConcSection = pConc;

	double dHeightD = 0;
	if(pConcSection)
	{
		dHeightD = pConcSection->GetHo() - pConcSection->GetRebarDistTension();
	}

	if(m_nApplyCalcShearDistWall == 1)
		dDist = dHeightD;
	else if(m_nApplyCalcShearDistWall == 2)
		dDist = dHeightD / 2;

	return dDist;
}

long CRcBridgeRebar::GetIndexConcDataWall( long nJijum, long nPos, BOOL bAllSection )
{
	long nIndex = 0;
	BOOL bIsOutWall = (IsOutsideWall());
	BOOL bOutWall = (bIsOutWall && (nJijum==0 || nJijum==GetCountJijum()-1))? TRUE:FALSE;

	if(!bIsOutWall) nIndex = nJijum-1;
	else if(nJijum == 0) nIndex = 0;
	else if(nJijum == GetCountJijum()-1) nIndex = 5;
	else nIndex = nJijum+9;

	if(bOutWall && nPos == CHECK_POS_TOP) nIndex += 0;
	else if(bOutWall && nPos == CHECK_POS_CENTER) nIndex += 1;
	else if(bOutWall && nPos == CHECK_POS_BOTTOM) nIndex += 3;

	if(bOutWall && nPos != CHECK_POS_TOP && !bAllSection) nIndex += 1;

	return nIndex;
}

double CRcBridgeRebar::GetDiffStationSupportForVert()
{
	long nType	= m_nTypePlacingSupportRebar_UpperSlab;
	BOOL bVertDir	= IsVertDir();
	// 기준이 되는 철근 방향 ////////////////
	// 기준은 수직방향이고, all 사방향 배치일 경우 시점 각도를 기준으로 함.
	// 참고로 all 사방향 배치는 시점 각도를 기준으로 하기 때문에 시점과 종점의 각도가 다를 경우 정상적으로 배치 되지않을 수 있음
	CDPoint xyDirDefaultRebar	= CDPoint(0, 1);	
	if(nType == 0)
		xyDirDefaultRebar	= GetAngleJijum(0, bVertDir);
	else if(nType == 1)
		xyDirDefaultRebar	= GetAngleJijum(m_nQtyJigan, bVertDir);
	else if(nType == 2 || nType == 3)
		xyDirDefaultRebar	= CDPoint(0, 1);
	///////////////////////////////////////////

	// 주철근 선형방향 배치고 배력근 사보강 배치일때
	double dDiffStaForVert	= 0;
	if(!bVertDir && (m_nTypePlacingSupportRebar_UpperSlab==2||m_nTypePlacingSupportRebar_UpperSlab==3)) 
	{
		double dWidthLeft	= GetWidthSlabAct(m_dStationBridgeStt, xyDirDefaultRebar, -1, FALSE, FALSE);
		double dWidthRight	= GetWidthSlabAct(m_dStationBridgeStt, xyDirDefaultRebar, 1, FALSE, FALSE);

		// 중심선형이 도로중심이 아닐 경우 지점 각도에 따라서 tan값을 적용해야 된다.
		// 2007.04.04 막음 by jaeho
		// 왜 이 부분을 했는지 이해가 안가고 철근이 비는 경우가 발생해서 막아버림

		// 막았었는데, 사보강배치시 직철근에만 적용을 해야 된다는 사실을 알아 버렸음
		// 그래서 다시 풀었음. 2007.08.13ss
		// 다시 풀고 직철근에만 적용하도록 수정함.
		if(dWidthLeft-dWidthRight != 0)
		{
			double dRad		= GetAngleJijum(0).GetAngleRadian();
			dDiffStaForVert	= (-dWidthLeft+dWidthRight)/2/tan(dRad);
		}
	}

	return dDiffStaForVert;
}

//가각부 사보강 철근의 최대 길이(구조물 선을 벗어나지 않게함)
double CRcBridgeRebar::GetExtMainRebarLimitGagak(BOOL bStt, BOOL bLeft)
{
	double dLenMaxLimit = 1500;

	long nStt	 = bStt? iSTT : iEND;
	long nLeft = bLeft? iLEFT : iRIGHT;
	
	//1. 미설치시 길이 0
	if(bStt)
	{
		if(m_dExpSttW[nLeft] == 0 || m_dExpSttH[nLeft] == 0)
			return 0 ;
	}
	else
	{
		if(m_dExpEndW[nLeft] == 0 || m_dExpEndH[nLeft] == 0)
			return 0 ;
	}

	//2. 지간의 1/2 보다 가각의 길이가 짧으면 최초 기본값 1500으로 설정 (지간이 1500보다 짧다면 지간 /2로 한다)
	double dTotJiGan = m_dLengthBridge /2;
	if(bStt)
	{
		if(m_dExpSttW[nLeft] <= dTotJiGan)
		{
			if(dTotJiGan >= dLenMaxLimit)
				return dLenMaxLimit;
			else
				return dTotJiGan/2;	
		}
	}
	else
	{
		if(m_dExpEndW[nLeft] <= dTotJiGan)
		{
			if(dTotJiGan >= dLenMaxLimit)
				return dLenMaxLimit;
			else
				return dTotJiGan/2;	
		}		
	}
	

	CRebarPlacing rp;

	CTwinVectorArray tvArr, tvArrSide, tvArrSttEnd, tvArrGagak, tvArrSum, tvArrStt, tvArrEnd, tvArrTmp;
	GetTvRebarOut_Plane_UpperSlabStd(tvArr, 0, TRUE);
		
	CString sSttEnd	= bStt? _T("시점") : _T("종점");
	CString sSide		= bLeft? _T("좌측") : _T("우측");
	CString sGagak	= _T("가각");

	tvArr.GetTvArrByInfo(_T("시점"), tvArrStt,FALSE, FALSE);
	tvArr.GetTvArrByInfo(_T("종점"), tvArrEnd,FALSE, FALSE);
	tvArr.GetTvArrByInfo(sSide, tvArrSum,FALSE, FALSE);	
	tvArrSum.GetTvArrByInfo(sGagak, tvArrGagak, FALSE, FALSE);
	tvArrSum.GetTvArrByInfo(sSide, tvArrSide, FALSE, TRUE);

	BOOL bFind = FALSE;
	for (long lx =0; lx < tvArrGagak.GetSize(); lx++)
	{
		CTwinVector tvGagak = tvArrGagak.GetAt(lx);
		if(tvGagak.m_sInfo.Find(sSttEnd) > -1)
			bFind = TRUE;
	}
	if(bFind == FALSE)
		return dLenMaxLimit;

	rp.StretchTvArr(tvArrGagak, 6000, 6000);

	tvArrSttEnd.AddFromTvArray(tvArrStt);
	tvArrSttEnd.AddFromTvArray(tvArrEnd);
	for (long nJx =0; nJx < tvArrSide.GetSize(); nJx++)
	{
		CTwinVector tvSide = tvArrSide.GetAt(nJx);
		for (long nIdx =0; nIdx< tvArrSttEnd.GetSize(); nIdx++)
		{
			CTwinVector tvPoint = tvArrSttEnd.GetAt(nIdx);
			if(tvPoint.m_sInfo.Find(_T("가각")) > -1)
				continue;

			if(ComparePt(tvSide.m_v1 , tvPoint.m_v1, _T("="), 0.1) || ComparePt(tvSide.m_v1 , tvPoint.m_v2, _T("="), 0.1) ||
				ComparePt(tvSide.m_v2 , tvPoint.m_v1, _T("="), 0.1) || ComparePt(tvSide.m_v2 , tvPoint.m_v2, _T("="), 0.1))
			{

				tvArrTmp.Add(tvPoint);
			}
		}
	}
	if(tvArrTmp.GetSize() > 0)
	{
		tvArrSttEnd.RemoveAll();
		tvArrSttEnd.AddFromTvArray(tvArrTmp);
	}


	CDPointArray xyArrMat1, xyArrMat2;
	rp.GetXyMatchTvArrAndTvArr(tvArrSttEnd, tvArrGagak, xyArrMat1,FALSE);
	rp.GetXyMatchTvArrAndTvArr(tvArrSide, tvArrGagak, xyArrMat2,FALSE);
	
	if(xyArrMat1.GetSize() > 0 && xyArrMat2.GetSize() > 0)
	{
		double dMax =0, dCurr = 0;
		for (long ix =0; ix < xyArrMat2.GetSize(); ix++)
		{
			CDPoint xy2 = xyArrMat2.GetAt(ix);
			for (long jx =0; jx < xyArrMat1.GetSize(); jx++)
			{
				CDPoint xy1 = xyArrMat1.GetAt(jx);

				dCurr = ~(xy2 - xy1);
				dMax = max(dCurr , dMax);
			}
		}

		if(dMax > 0)
			dLenMaxLimit = dMax;
	}


	return dLenMaxLimit;
}

BOOL CRcBridgeRebar::SetDesignForcePRF_Usd( CConcBasic *pConc, BOOL bStt, long nPosCheck )
{
	CARcBridgeDataStd *pStd = m_pARcBridgeDataStd;

	BOOL bLeft(TRUE);
	double Moment=0,MomentUse=0, MomentEq=0, Shear=0, ShearEq = 0, MomentEq_2=0, ShearEq_2 = 0;
	BOOL bCalc3DUlt = IsCalc3D(COMBO_ULTIMATE);
	BOOL bCalc3DUse = IsCalc3D(COMBO_SERVICE);

	long nSpan = 0;
	Moment	  = fabs(GetOutValuePRF(bStt, COMBO_ULTIMATE, ELE_MOMENT2));
	MomentEq  = fabs(GetOutValuePRF(bStt, COMBO_EARTHQUAKE, ELE_MOMENT2));
	MomentUse = fabs(GetOutValuePRF(bStt, COMBO_SERVICE, ELE_MOMENT2));
	Shear	  = fabs(GetOutValuePRF(bStt, COMBO_ULTIMATE, ELE_SHEAR_2));
	ShearEq	  = fabs(GetOutValuePRF(bStt, COMBO_EARTHQUAKE, ELE_SHEAR_2));
	if(m_nSelectModelingCountEQ==2)
	{
		MomentEq_2	= fabs(GetOutValuePRF(bStt, COMBO_EARTHQUAKE2, ELE_MOMENT2));
		ShearEq_2	= fabs(GetOutValuePRF(bStt, COMBO_EARTHQUAKE2, ELE_SHEAR_2));
		MomentEq	= (fabs(MomentEq) > fabs(MomentEq_2))? MomentEq : MomentEq_2;
		ShearEq		= (fabs(ShearEq) > fabs(ShearEq_2))? ShearEq : ShearEq_2;
	}
	
	Moment	  = max(Moment, MomentEq);
	Shear	  = max(Shear, ShearEq);
	if(bCalc3DUlt)
	{		
		Moment	= max(Moment, fabs(GetOutValuePRFShell(bStt,COMBO_ULTIMATE,ELE_MOMENT2)));
		Shear	= max(Shear, fabs(GetOutValuePRFShell(bStt,COMBO_ULTIMATE,ELE_SHEAR_2)));
		
	}
	if(bCalc3DUse)
	{
		MomentUse = max(MomentUse, fabs(GetOutValuePRFShell(bStt,COMBO_SERVICE ,ELE_MOMENT2)));
	}

	pConc->m_Moment		= GetValueUnitChange(Moment,pStd->m_szTonfM,UNIT_CGS_TONFM);
	pConc->m_Shear		= GetValueUnitChange(Shear,pStd->m_szTonf,UNIT_CGS_TONF);
	pConc->m_MomentUse	= GetValueUnitChange(MomentUse,pStd->m_szTonfM,UNIT_CGS_TONFM);
	pConc->m_MomentCrack	= pConc->m_MomentUse;

	return bLeft;
}

BOOL CRcBridgeRebar::SetDesignForcePRF_Lsd( CConcBasic *pConc, BOOL bStt, long nPosCheck, const ETypeEnvComboLsd eTypeEnv )
{
	CARcBridgeDataStd *pStd = m_pARcBridgeDataStd;

	BOOL bLeft(TRUE);
	BOOL bCalc3DUlt = IsCalc3D(COMBO_ULTIMATE);
	double Moment=0, Shear=0;

	//double dDistShear = GetDistCheckShearSlab(nSpan, nPosCheck, bUpperSlab, pConc);;
	long nSpan = 0;
	if(eTypeEnv == eEnvExtremeI || eTypeEnv == eEnvExtremeII)
	{
		Moment	  = fabs(GetOutValuePRFEQ(bStt, ELE_MOMENT2, eTypeEnv));
		Shear	  = fabs(GetOutValuePRFEQ(bStt, ELE_SHEAR_2, eTypeEnv));
	}
	else
	{
		Moment	= fabs(GetOutValuePRF(bStt, COMBO_ULTIMATE, ELE_MOMENT2, eTypeEnv));
		Shear   = fabs(GetOutValuePRF(bStt, COMBO_ULTIMATE, ELE_SHEAR_2, eTypeEnv));
	}
	
	if(bCalc3DUlt)
	{		
		Moment	= max(Moment, fabs(GetOutValuePRFShell(bStt,COMBO_ULTIMATE,ELE_MOMENT2, eTypeEnv)));
		Shear	= max(Shear, fabs(GetOutValuePRFShell(bStt,COMBO_ULTIMATE,ELE_SHEAR_2, eTypeEnv)));
		
	}

	// mm당 부재력 이므로 검토단면 폭을 곱해준다.
	double dWidth = frM(UNIT_METER);
	pConc->m_Moment		= GetValueUnitChange(Moment,pStd->m_szTonfM,UNIT_CGS_TONFM) * dWidth;
	pConc->m_Shear		= GetValueUnitChange(Shear,pStd->m_szTonf,UNIT_CGS_TONF) * dWidth;
	pConc->m_MomentUse	= GetValueUnitChange(Moment,pStd->m_szTonfM,UNIT_CGS_TONFM) * dWidth;
	if(eTypeEnv == eEnvService)
	{
		Moment	= fabs(GetOutValuePRF(bStt, COMBO_ULTIMATE, ELE_MOMENT2, eEnvService_Crack));
		
		if(bCalc3DUlt)
		{			
			Moment	= max(Moment, fabs(GetOutValuePRFShell(bStt,COMBO_ULTIMATE,ELE_MOMENT2, eEnvService_Crack)));			
		}
		pConc->m_MomentCrack	= GetValueUnitChange(Moment,pStd->m_szTonfM,UNIT_CGS_TONFM) * dWidth;
	}
	else
	{
		pConc->m_MomentCrack	= pConc->m_MomentUse;
	}

	return bLeft;
}

double CRcBridgeRebar::GetCTCRebarPRF_Main()
{
	return m_bPRF_SameCTC_Main ? m_dCTC_MainRebar : m_dCTC_MainRebar/2;
}
